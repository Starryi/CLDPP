<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>USB Flash Memory HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="This document describes procedures for installing USB Flash Memory devices and the way of formatting them for various file systems such as vfat (the way they usually come) and ext2 (the way they fit in better with Linux). It is also described how to partition the device in two sections with different file types."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="Flash-Memory-HOWTO"></a>USB Flash Memory HOWTO</h2></div><div><div class="author"><h3 class="author"><span class="firstname"> Niko</span> <span class="surname"> Sauer</span></h3><div class="affiliation"><span class="orgname"> Unit of Advanced Study<br></span> <span class="orgdiv"> University of Pretoria, South Africa<br></span><div class="address"><p><br>
           <code class="email">&lt;<a class="email" href="mailto:%20nikos@friedrichs.up.ac.za"> nikos@friedrichs.up.ac.za</a>&gt;</code><br>
       </p></div></div></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.06</td><td align="left">2004-03-10</td><td align="left">ns</td></tr><tr><td align="left" colspan="3">Added section on Linux-2.6.</td></tr><tr><td align="left">Revision 0.05</td><td align="left">2003-12-26</td><td align="left">ejh</td></tr><tr><td align="left" colspan="3">Technical review.</td></tr><tr><td align="left">Revision  0.04</td><td align="left"> 2003-12-11</td><td align="left">ns</td></tr><tr><td align="left">Revision  0.03</td><td align="left"> 2003-12-02</td><td align="left"> ejh</td></tr><tr><td align="left" colspan="3">
            Technical review.
          </td></tr><tr><td align="left">Revision  0.02</td><td align="left"> 2003-10-30</td><td align="left"> ns</td></tr><tr><td align="left" colspan="3">
            Changed 2003-11-20
          </td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
     This document describes procedures for installing USB Flash
     Memory devices and the way of formatting them for various file
     systems such as vfat (the way they usually come) and ext2 (the
     way they fit in better with Linux). It is also described how to
     partition the device in two sections with different file types.
    </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#purpose">1.  Purpose</a></span></dt><dt><span class="sect1"><a href="#physical">2. Physical devices</a></span></dt><dt><span class="sect1"><a href="#buying">3.  Buying a memory stick</a></span></dt><dt><span class="sect1"><a href="#reading">4.  Reading</a></span></dt><dt><span class="sect1"><a href="#hardware">5.  Hardware and kernel</a></span></dt><dd><dl><dt><span class="sect2"><a href="#setup">5.1.  Setup</a></span></dt><dt><span class="sect2"><a href="#kernel">5.2.  Kernel options</a></span></dt><dt><span class="sect2"><a href="#notes">5.3. Notes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#basics">6.  Some basic concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#proc">6.1. The /proc filesystem</a></span></dt><dt><span class="sect2"><a href="#scsidev">6.2.  SCSI devices</a></span></dt><dt><span class="sect2"><a href="#usbfs">6.3.  The USB device filesystem</a></span></dt><dt><span class="sect2"><a href="#ext2fs">6.4. The ext2 filesystem</a></span></dt><dt><span class="sect2"><a href="#vfatfs">6.5. The vfat filesystem</a></span></dt><dt><span class="sect2"><a href="#options">6.6. Explanation of command options</a></span></dt></dl></dd><dt><span class="sect1"><a href="#verifications">7. Basic verifications</a></span></dt><dd><dl><dt><span class="sect2"><a href="#quick">7.1. A quick check</a></span></dt><dt><span class="sect2"><a href="#proc-probe">7.2.  Probing the /proc filesystem</a></span></dt><dt><span class="sect2"><a href="#mounting">7.3.  Mounting the USB filesystem</a></span></dt><dt><span class="sect2"><a href="#tests">7.4.  Tests -- vfat</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ext2">8.  Setting up an Ext2 filesystem</a></span></dt><dd><dl><dt><span class="sect2"><a href="#partition">8.1.  Partitioning</a></span></dt><dt><span class="sect2"><a href="#making-ext2">8.2.  Making an ext2 device</a></span></dt><dt><span class="sect2"><a href="#tests4">8.3.  Tests -- ext2</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mixed">9.  Setting up a dual partition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#double-partition">9.1.  Partitioning</a></span></dt><dt><span class="sect2"><a href="#both">9.2. Making a dual ext2/vfat system</a></span></dt><dt><span class="sect2"><a href="#mixed-tests">9.3.  Tests -- ext2 and vfat</a></span></dt><dt><span class="sect2"><a href="#config-linux">9.4. Configuring Linux for the dual partition</a></span></dt></dl></dd><dt><span class="sect1"><a href="#users">10.  Making the memory stick accessible to users</a></span></dt><dt><span class="sect1"><a href="#maintain">11.  Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fs-inspect">11.1.  Filesystem inspection</a></span></dt><dt><span class="sect2"><a href="#and-then">11.2.  And then?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#linux-2.6">12.  The Linux-2.6 kernel</a></span></dt><dd><dl><dt><span class="sect2"><a href="#What-is-new">12.1.  What is new?</a></span></dt><dt><span class="sect2"><a href="#kernel-options">12.2.  Kernel options </a></span></dt><dt><span class="sect2"><a href="#notes-2.6">12.3. Notes</a></span></dt><dt><span class="sect2"><a href="#hotplug">12.4.  Hotplugging and Naming </a></span></dt></dl></dd><dt><span class="sect1"><a href="#formal">13.  Formalities</a></span></dt><dd><dl><dt><span class="sect2"><a href="#copyright">13.1.  Copyright Information</a></span></dt><dt><span class="sect2"><a href="#disclaimer">13.2.  Disclaimer</a></span></dt><dt><span class="sect2"><a href="#credits">13.3.  Credits</a></span></dt><dt><span class="sect2"><a href="#feedback">13.4.  Feedback</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="purpose"></a>1.  Purpose</h2></div></div></div><p>
    The purpose of this document is to describe procedures for
    implementing USB flash memory devices (memory sticks) on
    Linux. This entails the following:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         making over-the-counter devices, pre-formatted for the MS
         Windows system, work on Linux;
         </p></li><li class="listitem"><p>
         formatting the device in the ext2 filesystem on a single
         partition and making it work. This is intended for situations
         where the device will be used exclusively on Linux machines;
         </p></li><li class="listitem"><p>
         formatting the device on a dual partition in the ext2 and
         vfat filesystems and making it work. The purpose of this
         is for situations where Linux + Linux and Linux + Windows are
         possible;
         </p></li><li class="listitem"><p>
         making the device more user friendly;
         </p></li><li class="listitem"><p>
         maintaining the filesystem of the device;
         </p></li><li class="listitem"><p>
         using additional features of Linux-2.6.x.
         </p></li></ul></div><p>
    The procedures described in this document should work on
    any USB memory stick device which can be operated as a read-write
    device. Read-only devices do not fall in this category. The
    procedures will not work if the write facility of the device is
    disabled (i.e. if the write protect switch is on).
   </p><p>
    The procedures described for formatting and maintenance in
    particular filesystems may (in principle) be adapted for other
    filesystems such as ext3 and reiserfs. These have not been tried
    and tested. Neither has any attention been paid to adaptation of
    the procedures to other related operating systems.
   </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
    It may be dangerous to re-format the flash memory
    intended for a digital camera. The camera may then be unable to
    understand it. Use the camera's built-in menu system to do this
	 reformatting for you.
	 
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="physical"></a>2. Physical devices</h2></div></div></div><p>
    Flash memory devices come mainly in the form of small, portable
    devices often referred to as <span class="emphasis"><em>memory sticks</em></span> or
    <span class="emphasis"><em>keychains</em></span>, and as part of digital
    cameras. They are <span class="emphasis"><em>non-volatile devices</em></span> which
    operate on the principle that electric charges are used to
    represent data in binary format. These charges can remain
    unchanged almost indefinitely, but changes (such as writing to the
    device) limit the life span of the device (100000 writes of 8MB
    each).
   </p><p> 
    Memory sticks plug directly into a USB-port at the back of your
    computer. The power it needs is supplied by the USB-port. It is
    sometimes convenient to use a USB-extension cable to bring the
    device within easy reach. 
   </p><p>
    Memory sticks usually have <span class="emphasis"><em>write protect
    switches</em></span> which should be turned off if you want to use
    it as read-write device. If the switch is in the <span class="quote">&#8220;<span class="quote">on</span>&#8221;</span> position,
    the device is <span class="emphasis"><em>read-only</em></span>. The devices are
    usually equipped with a led (light emitting diode), which
    indicates that the device is operational. The led also flickers
    while data is being transferred to or from the device.
   </p><p>
    Digital cameras use flash memory for image storage. These are 
    powered by the camera and connected to the computer's USB-port via
    an electronic interface. To be able to connect to the computer,
    the camera's power must be turned on for the duration of the
    interfacing, and should only be turned off after the device had
    been unmounted from the computer. It is important to remember that
    the device takes power from the camera's battery. The operation
    should therefore be terminated as soon as possible.
   </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buying"></a>3.  Buying a memory stick</h2></div></div></div><p>
    Important considerations when buying a memory stick are the
    following:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="strong"><strong>The size of the memory</strong></span></span></dt><dd><p>
		This will depend on whatever use you have in mind. 128MB seems to be
		a popular choice.
	</p></dd><dt><span class="term"><span class="strong"><strong>Is it known to work on Linux?</strong></span></span></dt><dd><p>
    The established brands have web sites in which this may be stated
    explicitly. Alternatively, ask the supplier. But beware: the sales
    person may not know what you are talking about. The instruction
    leaflet may also mention something like: Works on Linux-2.4, or
    may have a picture of the Linux penguin. If these inquiries fail, it
    may be wise not to buy.  
	</p></dd><dt><span class="term"><span class="strong"><strong>Extension cable and keychain</strong></span></span></dt><dd><p>
    Memory sticks usually are packaged with an extension cable 
    (<a class="xref" href="#physical" title="2. Physical devices">Section 2, &#8220;Physical devices&#8221;</a>) and a keychain. The latter provides
    a safe and with-it way of transporting the device. Make sure that
    these are included. You may need an additional extension cable,
    depending on circumstances. Laptop and notebook computers usually
    don't need them.
	</p></dd><dt><span class="term"><span class="strong"><strong>File system</strong></span></span></dt><dd><p>
    Over-the-counter memory sticks are usually formatted in vfat
    (msdos), and this will work in Linux, but you will not have the
    strength and versatility of the standard ext2 (or other) file
    system. This is not a problem. It can be endowed with other file
    systems as will be described later in this document.
	</p></dd><dt><span class="term"><span class="strong"><strong>Cost</strong></span></span></dt><dd><p>
    Prices of memory sticks of a given size may vary considerably. It
    is a good idea to find out what that range is. The internet is
    excellent for the purpose.
	</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reading"></a>4.  Reading</h2></div></div></div><p> 
    Users of this document might want to acquaint themselves with
    the following:
     <a href="#ftn.ftn-heavy-dependencies" class="footnote" name="ftn-heavy-dependencies"><sup class="footnote">[1]</sup></a>
   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none">
          Manual pages of the following tools:
          <span class="application">mount</span>,
			 <span class="application">umount</span>, <span class="application">fdisk</span>, <span class="application">mke2fs</span>, <span class="application">mkdosfs</span>,
          <span class="application">dumpe2fs</span>&gt; and <span class="application">fsck.ext2</span>.
        </li><li class="listitem" style="list-style-type: none">
          <a class="ulink" href="http://www.tldp.org" target="_top">
            Linux documentation project
          </a>
        </li><li class="listitem" style="list-style-type: none">
          <a class="ulink" href="http://www.tldp.org/HOWTO/USB-Digital-Camera-HOWTO" target="_top">
            USB-Digital Camera HOWTO
          </a>*
        </li><li class="listitem" style="list-style-type: none">
          <a class="ulink" href="http://www.tldp.org/HOWTO/Partition" target="_top"> The Linux 
            Partition HOWTO
          </a>*
        </li><li class="listitem" style="list-style-type: none">
         <a class="ulink" href="http://www.tldp.org/HOWTO/The%20Linux%20SCSI-2.4-HOWTO" target="_top">
           The Linux 2.4 SCSI subsystem HOWTO
         </a>
        </li><li class="listitem" style="list-style-type: none">
         <a class="ulink" href="http://www.tldp.org/HOWTO/Kernel-HOWTO" target="_top">
           The Linux Kernel HOWTO
         </a>
        </li><li class="listitem" style="list-style-type: none">
         <a class="ulink" href="http://www.linux-usb.org/USB-guide/book1.html" target="_top">
           The Linux USB subsystem
         </a>*
        </li><li class="listitem" style="list-style-type: none">
         <a class="ulink" href="http://www.tldp.org/guides.html" target="_top">
           Linux filesystem hierarchy
         </a>
        </li><li class="listitem" style="list-style-type: none">
         <a class="ulink" href="http://www.tldp.org/guides.html" target="_top">
           The Linux Kernel
         </a>
        </li><li class="listitem" style="list-style-type: none">
           Linux Kernel 2.4.xx/Documentation (should be in
           <code class="filename"> /usr/src/linux/Documentation</code> )
        </li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hardware"></a>5.  Hardware and kernel</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="setup"></a>5.1.  Setup</h3></div></div></div><p>
    This is a description of the salient features of the setup used to
    develop the procedures described below. All the procedures have
    been tried and tested, also for Linux-2.6. The screen-like
    displays are precise copies of what appeared on my screen.
   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none">
       Hardware: Intel (R) Celeron (TM) 1100 MHz
      </li><li class="listitem" style="list-style-type: none">
       Distribution: RedHat Linux 7.0 (extensively modified)
      </li><li class="listitem" style="list-style-type: none">
       Kernel: Linux-2.4.20 (from www.kernel.org). See also
       <a class="xref" href="#linux-2.6" title="12.  The Linux-2.6 kernel">Section 12, &#8220; The Linux-2.6 kernel&#8221;</a> for Linux-2.6.x.
      </li><li class="listitem" style="list-style-type: none">
       Tools: util-linux-2.11z (<span class="application">mount</span>, <span class="application">umount</span>, <span class="application">fdisk</span>); 
          e2fsprogs-1.32 (<span class="application">mke2fs</span>, <span class="application">dumpe2fs</span>, <span class="application">fsck.ext2</span>);
          mkdosfs-2.2
      </li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="kernel"></a>5.2.  Kernel options</h3></div></div></div><p>
    It is uncertain if USB-support is sufficient in kernels earlier
    than 2.4.xx. The following support, relevant to this document, was
    compiled into the kernel. A modular approach may also be followed.
   </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="scsi"></a>5.2.1.  SCSI support</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"> SCSI support (CONFIG_SCSI  scsi_mod.o)</li><li class="listitem" style="list-style-type: none"> SCSI disk support (CONFIG_BLK_DEV_SD  sd_mod.o)</li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="fss"></a>5.2.2.  File systems</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"> DOS FAT fs support (CONFIG_FAT_FS  fat.o)</li><li class="listitem" style="list-style-type: none"> MSDOS fs support (CONFIG_MSDOS_FS  msdos.o)</li><li class="listitem" style="list-style-type: none"> 
        VFAT (Windows 95) fs support (CONFIG_VFAT_FS  vfat.o)
	</li><li class="listitem" style="list-style-type: none"> /proc filesystem (CONFIG_PROC_FS)</li><li class="listitem" style="list-style-type: none"> 
        Second extended fs support (ext2fs) (CONFIG_EXT2_FS  ext2.o)
      </li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="usb"></a>5.2.3.  USB support</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"> Support for USB (CONFIG_USB  usbcore.o)</li><li class="listitem" style="list-style-type: none"> 
        Preliminary USB device filesystem (CONFIG_USB_DEVICEFS)
      </li><li class="listitem" style="list-style-type: none"> 
        USB Mass Storage support (CONFIG_USB_STORAGE  usb-storage.o)
      </li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="notes"></a>5.3. Notes</h3></div></div></div><p>
     In the lists above the entities in uppercase refer to the
     variable names to be found in the <code class="filename">.config</code>
     file in the upper level directory of the kernel source (<code class="filename">/usr/src/linux/</code>). The entities
     <code class="filename">xxx.o</code> refer to the modules created when a
     modular approach is followed. When there is no reference to a
     module, the option can only be hard-compiled into the kernel.
    </p><p>
     Different kernel versions may have different indications of
     options when, for example, <span class="emphasis"><em>make menuconfig</em></span>
     or <span class="emphasis"><em> make xconfig</em></span> are run. Variables such
     as CONFIG_USB, which can be gleaned from the various <span class="emphasis"><em>
     help</em></span> options, may be a more reliable indication.
    </p><p>
     Very recent Linux distributions such as
     <span class="emphasis"><em>RedHat</em></span> and <span class="emphasis"><em>SuSE</em></span>
     probably have the appropriate kernel options compiled in.
    </p><p>
     Under USB-support, options for a number of digital cameras are 
     available.
    </p><p>
     Please consult the relevant texts as set out in 
     <a class="xref" href="#reading" title="4.  Reading">Section 4, &#8220; Reading&#8221;</a> if you consider (re)compiling your 
     kernel.
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basics"></a>6.  Some basic concepts</h2></div></div></div><p>
    In this section we discuss in a very brief manner, some basic
    Linux concepts which should contribute to an understanding of the
    procedures described below.
   </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="proc"></a>6.1. The /proc filesystem</h3></div></div></div><p>
      The /proc filesystem serves as a window through which we can see
      the workings of a Linux setup. The objects of most interest for
      this document are the directories<code class="filename">/proc/bus/usb/</code> and <code class="filename">/proc/scsi/</code>. These will be used to
      verify that the kernel had been set up properly for our purpose
      (<a class="xref" href="#proc-probe" title="7.2.  Probing the /proc filesystem">Section 7.2, &#8220; Probing the /proc filesystem&#8221;</a>). 

    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="scsidev"></a>6.2.  SCSI devices</h3></div></div></div><p>
    Your memory stick will be considered as a USB mass storage device
    posing as a removable SCSI disk (sd).  SCSI disk devices are
    mapped to the <code class="filename"> /dev</code>
    (devices) directory under <code class="filename">
    /dev/sda</code> , <code class="filename">
    /dev/sdb</code> , ... When different disk devices are present,
    they will be mapped to <code class="filename">/dev/sda</code>,
    <code class="filename">/dev/sdb</code>, etc.  If, for example, a memory
    stick and a digital camera are plugged in, the one would be mapped
    to <code class="filename">/dev/sda</code> and the other to
    <code class="filename">/dev/sdb</code>. Tests have indicated that the first
    device to be detected is mapped to <code class="filename">sda</code> and
    represented in the directory <code class="filename">/proc/scsi/usb-storage-0</code>. The second
    will be mapped to <code class="filename">sdb</code> and represented in
    <code class="filename">/proc/scsi/usb-storage-0</code>.
    What will happen when both devices are present at boot-up, is not
    known. An overview of the partitions relevant to this document,
    the file <code class="filename">/proc/partitions</code> may be consulted.
    Look for entries like <code class="filename">sda, sda1, sdb</code>. Under
    the Linux-2.6 series of kernels this problem may be very neatly
    resolved (<a class="xref" href="#linux-2.6" title="12.  The Linux-2.6 kernel">Section 12, &#8220; The Linux-2.6 kernel&#8221;</a>).


    </p><p>
    In the descriptions further on, it will be assumed that only one
    memory stick is present, and therefore mapped to 
    <code class="filename">/dev/sda</code>.
   </p><p>
    In most distributions these points exist in abundance. You should
    check that this is the case in your setup
	 (<strong class="userinput"><code><span class="command"><strong>ls</strong></span> /dev/sda*</code></strong>. If there are none you can create them by
    doing (as root, indicated by the hash).
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mknod</strong></span> /dev/sda  b 8 0</code></strong>
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mknod</strong></span> /dev/sda1 b 8 1</code></strong>
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mknod</strong></span> /dev/sda2 b 8 2</code></strong>
   </pre><p>
    etc, up to <code class="filename">/dev/sda15</code> if necessary. The
    device as a whole is mapped to <code class="filename">/dev/sda</code>,
    while <code class="filename">/dev/sdax (x = 1 ... 15)</code> represent
    the various partitions of the device. We shall describe, later on,
    how to create different partitions for different file systems (see
    <a class="xref" href="#ext2" title="8.  Setting up an Ext2 filesystem">Section 8, &#8220; Setting up an Ext2 filesystem&#8221;</a> and <a class="xref" href="#mixed" title="9.  Setting up a dual partition">Section 9, &#8220; Setting up a dual partition&#8221;</a> ). If you
    intend to use your memory stick with a single partition
    (filesystem), <code class="filename">/dev/sda1</code> is sufficient. 
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="usbfs"></a>6.3.  The USB device filesystem</h3></div></div></div><p>
     This dynamically generated filesystem should be mounted at
     <code class="filename">/proc/bus/usb/</code>. It is
     therefore essential that this mount point exists. Once it is
     mounted, there should be more to be seen in <code class="filename">/proc/bus/usb/</code> and in <code class="filename">/proc/scsi/</code> (<a class="xref" href="#mounting" title="7.3.  Mounting the USB filesystem">Section 7.3, &#8220; Mounting the USB filesystem&#8221;</a>). To find out which USB devices are
     present, read the file <code class="filename">/proc/bus/usb/devices</code>
     (<span class="command"><strong> less /proc/bus/usb/devices</strong></span>). It takes a
     small effort to interpret the writing on the screen, but it is
     not difficult. A memory stick is indicated by <span class="emphasis"><em>Mass
     Storage Device</em></span>.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ext2fs"></a>6.4. The ext2 filesystem</h3></div></div></div><p>
     The ext2 (second extended) filesystem still is the most prevalent
     in Linux setups. It is most versatile and sophisticated, carrying
     with it permissions (read-write-execute, who is permitted to do
     what), ownership (user, group, others), a timestamp (when last
     modified), etc. Moreover, tools for the proper maintenance of a
     device endowed with ext2, exist (<a class="xref" href="#maintain" title="11.  Maintenance">Section 11, &#8220; Maintenance&#8221;</a>).  If
     a flash memory device is to be used exclusively within Linux
     setups, it is therefore desirable to format it in ext2 (see <a class="xref" href="#ext2" title="8.  Setting up an Ext2 filesystem">Section 8, &#8220; Setting up an Ext2 filesystem&#8221;</a>).
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="vfatfs"></a>6.5. The vfat filesystem</h3></div></div></div><p>
     Enabling vfat in the kernel makes it possible to mount
     filesystems created under Dos/Windows to be mounted in a Linux
     system. Most memory sticks are formatted for direct use on
     Windows and should therefore be considered as vfat-formatted. The
     vfat filesystem is less sophisticated than ext2 and will
     therefore be more economic as far as memory space is
     concerned. It does not carry permissions in the same way as ext2
     with the result that an ext2-file saved in vfat will re-appear
     with its permissions changed. Nonetheless, if a memory stick is
     to be used for the purpose of carrying data between Linux and
     Windows machines, it is best to keep it in the vfat format. A
     compromise is to partition the memory stick in two parts: one in
     vfat and the other in ext2. At least the Linux machine should be
     able to handle both. This is described in <a class="xref" href="#mixed" title="9.  Setting up a dual partition">Section 9, &#8220; Setting up a dual partition&#8221;</a>
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="options"></a>6.6. Explanation of command options</h3></div></div></div><p>
    Here is a short list of command options that occur in this
    document:
   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t ext2 /dev/sda1 /mnt/memstick</code></strong> 
       Mount in filetype ext2, device sda1 at mountpoint /mnt/memstick
      </li><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>ls</strong></span> -l</code></strong>
       Make a complete list (modes, ownerships, etc.)
      </li><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>mkdosfs</strong></span> -F 32 /dev/sda1</code></strong>
       Create an ms-dos filesystem, FAT-size 32, on the
            partition /dev/sda1
      </li><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>ln</strong></span> -s /dev/sda1 /dev/flash</code></strong>
      	link, symbolically, the existing /dev/sda1 to 
         the symbolic /dev/flash
      </li><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>mkdir</strong></span> -m 777
		 /mnt/memstick/superdir</code></strong>
        create a new directory with mode rwx for user, group and others
      </li><li class="listitem" style="list-style-type: none"> 
       <strong class="userinput"><code><span class="command"><strong>dumpe2fs</strong></span> -h /dev/sda1</code></strong>
       Show the header of the ext2 partition /dev/sda1
      </li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="verifications"></a>7. Basic verifications</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
   In order to make sure that the device you look at and write on is
   the one intended, it is best to remove similar devices from
   the USB-bus before starting these procedures.
  </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="quick"></a>7.1. A quick check</h3></div></div></div><p>
    It is possible that your system is already set up for handling a
    USB-flash memory device. To check this, simply issue the command 
    <code class="prompt">$ </code><strong class="userinput"><code><span class="command"><strong>mount</strong></span></code></strong> from an X-terminal. If something like
   </p><pre class="screen">
           none on /proc/bus/usb type usbfs (rw)
      </pre><p>
    appears among the output, you are ready to go to 
    <a class="xref" href="#tests" title="7.4.  Tests -- vfat">Section 7.4, &#8220; Tests -- vfat&#8221;</a> and proceed from there. It may be
    virtuous, however, to glance through the intervening sections.
    If the test is unsuccessful, all is not lost. Please read on.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="proc-probe"></a>7.2.  Probing the /proc filesystem</h3></div></div></div><p>
    A few things in the <code class="filename"> /proc</code>
    directory can be checked so see if the kernel options have been
    properly included or the appropriate modules properly inserted. As
    a first check, see if the directory <code class="filename">/proc/bus/usb</code> exists. If it does,
    your kernel supports the USB-subsystem correctly. If this is not
    the case the kernel has to be re-compiled with appropriate USB
    support (see <a class="xref" href="#usb" title="5.2.3.  USB support">Section 5.2.3, &#8220; USB support&#8221;</a>) or the kernel has to be
    updated. Next, check if the directory <code class="filename">/proc/scsi</code> exists. If it does, you're
    well-away. If it doesn't, SCSI support has not been compiled into
    your kernel (see <a class="xref" href="#scsi" title="5.2.1.  SCSI support">Section 5.2.1, &#8220; SCSI support&#8221;</a>).
   </p><p>
    In <code class="filename"> /proc</code> there should be
    provision for a mount point for the USB filesystem. That point is
    <code class="filename"> /proc/bus/usb</code>. If it
    exists, the kernel is correctly set up.  
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mounting"></a>7.3.  Mounting the USB filesystem</h3></div></div></div><p>
    If the verifications of the previous sections were positive, the
    next step is to mount the USB filesystem. This is issued from root
    as follows:
   </p><pre class="screen">
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t usbfs none /proc/bus/usb </code></strong>
   </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    In older kernel versions the mount command above may have to
    be changed by replacing <em class="parameter"><code>usbfs</code></em> with
    <em class="parameter"><code>usbdevfs</code></em>. In Linux-2.4.20 both forms work.
   </p></div><p>
    If there are no complaints, do some more tests. The first is the
    quick test (<a class="xref" href="#quick" title="7.1. A quick check">Section 7.1, &#8220;A quick check&#8221;</a>).  A deeper probe would be to
    issue the command <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>ls</strong></span> -l /proc/bus/usb</code></strong> . This
    should give something similar to
   </p><pre class="screen">
             dr-xr-xr-x 1 root root 0  Sep 19  14:21  001
             dr-xr-xr-x 1 root root 0  Sep 19  14:21  002
             -r--r--r-- 1 root root 0  Sep 19  22:30  devices 
             -r--r--r-- 1 root root 0  Sep 19  22:30  drivers
   </pre><p>
    The path <code class="filename">
    /proc/scsi/usb-storage-0/</code> should now exist and one of
    the files at the end will show this. In my setup the command
    <code class="prompt">$ </code><strong class="userinput"><code><span class="command"><strong>less</strong></span> /proc/scsi/usb-storage-0/1</code></strong> gives
   </p><pre class="screen">
                Host scsi1: usb-storage  
                    Vendor: Generic  
                   Product: Mass Storage Device  
             Serial Number: None  
                  Protocol: Transparent SCSI  
                 Transport: Bulk  
                      GUID: 0ed166800000000000000000  
                  Attached: Yes/No  
   </pre><p>
    If the flashdrive is present, the last line will have the entry
    "Yes". If it is not plugged in, the entry will be "No".
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tests"></a>7.4.  Tests -- vfat</h3></div></div></div><p> You are now ready to find out if the memory stick is
   working. Let us suppose that you bought it over the counter. Its
   instruction leaflet will most likely tell you how to set it up for
   Windows. That is an indication that it is formatted in vfat. Before
   you try to mount it, create a mount point for it. Do something like
   <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mkdir</strong></span> -m 777
   /mnt/memstick</code></strong>. The mounting command would most likely
   be
   </p><pre class="screen">
    <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t vfat /dev/sda1 /mnt/memstick</code></strong>
   </pre><p> 
    If everything went smoothly, you should be able to see the device:
    <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>ls</strong></span>
    /mnt/memstick</code></strong>.
   </p><p> 
    Now try some standard things like making a directory on the device
    and copying a favourite text file to it:
   </p><pre class="screen">
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mkdir</strong></span> /mnt/memstick/apollo </code></strong>
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>cp</strong></span> /home/myname/myfavourite_file /mnt/memstick/apollo/.</code></strong>
   </pre><p> 
    List again (<code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>ls</strong></span> -l /mnt/memstick</code></strong> ) and
    pay attention to the permissions.
    </p><p> 
     Unmount the device (<code class="prompt">#
     </code><strong class="userinput"><code><span class="command"><strong>umount</strong></span>
     /dev/sda1</code></strong> ) and mount it again as above. List again
     and check the permissions. Most likely your favourite text file
     will now have an x-permission. It became executable. That is
     normal in the vfat filesystem. If you are happy with that,
     unmount the device and skip to <a class="xref" href="#users" title="10.  Making the memory stick accessible to users">Section 10, &#8220; Making the memory stick accessible to users&#8221;</a> .
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ext2"></a>8.  Setting up an Ext2 filesystem</h2></div></div></div><p>
  The procedures described here will give the entire flash memory
  device a single partition endowed with the ext2 filesystem. This
  will make the device more suitable for use between Linux machines.
  Don't do this if the device is supposed to operate between
  Linux and Windows machines.
</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
    The device associated with <code class="filename">/dev/sda</code> will be
    re-formatted. Any data present on it will be destroyed. To make
    sure that the device you work with is the one intended, remove
    similar devices from the USB-bus before starting these procedures.
  </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="partition"></a>8.1.  Partitioning</h3></div></div></div><p>
    It is assumed that the flash memory is mapped to <code class="filename">
    /dev/sda</code>. In this section we treat the situation where
    the whole flash memory device will become devoted to a single ext2
    partition. In the example procedure shown below, a 128MB flash
    memory was formatted for ext2. That is why figures like 131MB and
    888 cylinders appear. The fdisk tool, which is used, simply reads
    that from the device.
   </p><p> 
    All operations are done by root. The single partition will be
    created on <code class="filename"> /dev/sda</code>
    (please note: not <code class="filename">
    /dev/sda1</code> ) The procedure is described in a series of
    steps with comments. The standard prompt of
    <span class="application">fdisk</span> is <code class="prompt"> Command (m for
    help):</code> and you can, at any stage enter
    <strong class="userinput"><code>m</code></strong> to see the available commands. If you do
    that the result would be
   </p><pre class="screen">
             Command   action 
                a      toggle a bootable flag 
                b      edit bsd disklabel 
                c      toggle the dos compatibility flag 
                d      delete a partition 
                l      list known partition types 
                m      print this menu 
                n      add a new partition 
                o      create a new empty DOS partition table 
                p      print the partition table 
                q      quit without saving changes 
                s      create a new empty Sun disklabel 
                t      change a partition's system id 
                u      change display/entry units 
                v      verify the partition table 
                w      write table to disk and exit 
                x      extra functionality (experts only) 
   </pre><p>
    Your memory stick must be plugged in, but not mounted. Take care
    that write protect is off.
   </p><p> Here goes:</p><pre class="screen">
             <code class="prompt">#</code><strong class="userinput"><code><span class="command"><strong> fdisk</strong></span> /dev/sda</code></strong> 
             Command (m for help):<strong class="userinput"><code>d</code></strong> {enter }
             Selected partition 1  
             Command (m for help):<strong class="userinput"><code>n</code></strong> {enter} 
             Command action  
                e  extended  
                p  primary partition (1-4)  
             <strong class="userinput"><code>p</code></strong> {enter}  
             Partition number (1-4):<strong class="userinput"><code>1</code></strong> {enter} 
             First cylinder (1-888, default 1): {press enter} 
             Using default value 1  
             Last cylinder ... (1-888, default 888): {press enter} 
             Using default value 888  
   </pre><p> 
    Now is a good time to verify that all went well by printing out
    the partition details and table.
   </p><pre class="screen">
             Command (m for help): <strong class="userinput"><code>p</code></strong> 
             Disk /dev/sda: 131 MB, 131072000 bytes  
             9 heads, 32 sectors/track, 888 cylinders  
             Units = cylinders of 288 * 512 = 147456 bytes 

             Device     Boot Start End Blocks Id System 
	  
             /dev/sda1         1   888 127856 83 Linux 
   </pre><p>
    Make sure that the partition is not set up as bootable. There
    should not be an asterisk under the heading "Boot" in the
    partition table. Furthermore, the headings "Id" and "System"
    should be as they are in the printout shown above. That indicates
    that you can format the device in ext2 (next section). These are
    the defaults. If they are not, they can be changed by
   </p><pre class="screen">
             Command (m for help): <strong class="userinput"><code>a</code></strong> [toggle a bootable flag] 
             Command (m for help): <strong class="userinput"><code>t</code></strong> [change a partition's system id] 
   </pre><p> 
     If (or when) the partition table is correct, you can conclude the
     procedure with
    </p><pre class="screen">
             Command (m for help): <strong class="userinput"><code>w</code></strong> [write table to disk and exit] 
    </pre><p> That's it!</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="making-ext2"></a>8.2.  Making an ext2 device</h3></div></div></div><p> 
    Having completed the partition part, we go straight on to
    "formatting" the device in ext2. For this we use the tool
    mke2fs. This is straightforward.
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mke2fs</strong></span> /dev/sda1</code></strong> 
   </pre><p>
    You might like to watch the led on your memory stick flicker
    while this is happening. When it stops, the job is done.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tests4"></a>8.3.  Tests -- ext2</h3></div></div></div><p> 
    To see if you were successful, essentially repeat the procedures
    described in <a class="xref" href="#mounting" title="7.3.  Mounting the USB filesystem">Section 7.3, &#8220; Mounting the USB filesystem&#8221;</a> and <a class="xref" href="#tests" title="7.4.  Tests -- vfat">Section 7.4, &#8220; Tests -- vfat&#8221;</a>
    with two exceptions of detail. In the first place the mount
    command should be
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t ext2 /dev/sda1 /mnt/memstick</code></strong> 
   </pre><p> 
    The second exception is that the permissions on your favourite
    text file should not change anymore.
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mixed"></a>9.  Setting up a dual partition</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="double-partition"></a>9.1.  Partitioning</h3></div></div></div><p>
  The procedures described here will partition the flash memory device
  in two pieces -- one of the partitions will be formatted in ext2 and
  the other in vfat. This may be handy when the device is to be used
  to transport data between two (or more) Linux machines (ext2) and between Linux
  and Windows machines (vfat)
</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
    The device mapped to <code class="filename">/dev/sda</code> will be
    re-formatted. Any data present on it will be destroyed.  To make
    sure that the device you work with is the one intended, remove
    similar devices from the USB-bus before starting these procedures.
  </p></div><p> 
    In this section we describe how to set up a dual partition for
    the memory stick: One half of the device will be
    devoted to the vfat filesystem, and the other will be ext2. In
    this way your device will be more versatile, but also a little
    shattered. The procedure will be given in somewhat less detailed
    than in <a class="xref" href="#partition" title="8.1.  Partitioning">Section 8.1, &#8220; Partitioning&#8221;</a> . Note that the procedure
    of the previous section is repeated and that the hex code for 
    each file type is explicitly entered (lines following the entry 
    "t": Win95 = b; Linux = 83). When the partition will only be for
    Linux, this is unnecessary -- Linux is the default. Also note that
    the vfat partition goes on first -- that is the way Windows would 
    have it.
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>fdisk</strong></span> /dev/sda</code></strong>
	    
             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>d</code></strong>
             <code class="computeroutput">Selected partition 1</code>

             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>n</code></strong>
             <code class="computeroutput">Command action
                e   extended
                p   primary partition (1-4)</code>
             <strong class="userinput"><code>p</code></strong>
             <code class="prompt">Partition number (1-4):</code> <strong class="userinput"><code>1</code></strong>
             <code class="prompt">First cylinder (1-888, default 1): </code>
             <code class="computeroutput">Using default value 1</code>
             <code class="prompt">Last cylinder or +size or +sizeM or +sizeK (1-888,
                   default 888):</code><strong class="userinput"><code>444</code></strong>
             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>t</code></strong>
             <code class="computeroutput">Selected partition 1</code>
             <code class="prompt">Hex code (type L to list codes):</code> <strong class="userinput"><code>b</code></strong>
             <code class="computeroutput">
              Changed system type of partition 1 to b (Win95 FAT32)
             </code>
             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>n</code></strong>
             <code class="computeroutput">Command action
                e   extended
                p   primary partition (1-4)</code>
             <strong class="userinput"><code>p</code></strong>
             <code class="prompt">Partition number (1-4):</code> <strong class="userinput"><code>2</code></strong>
             <code class="prompt">First cylinder (445-888, default 445): </code>
             <code class="computeroutput">Using default value 445</code>
             <code class="prompt">
              Last cylinder or +size or +sizeM or +sizeK (445-888,
              default 888): 
             </code>
             <code class="computeroutput">Using default value 888</code>

             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>t</code></strong>
             <code class="prompt">Partition number (1-4):</code> <strong class="userinput"><code>2</code></strong>
             <code class="prompt">Hex code (type L to list codes):</code> <strong class="userinput"><code>83</code></strong>

             <code class="prompt">Command (m for help):</code> <strong class="userinput"><code>p</code></strong>

             <code class="computeroutput">
				 Disk /dev/sda: 131 MB, 131072000 bytes
             9 heads, 32 sectors/track, 888 cylinders
             Units = cylinders of 288 * 512 = 147456 bytes

                Device Boot    Start       End    Blocks   Id  System
             /dev/sda1             1       444     63920    b  Win95 FAT32
             /dev/sda2           445       888     63936   83  Linux
				 </code>

             <code class="prompt">Command (m for help):</code><strong class="userinput"><code>w</code></strong>

   </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    Note that we went on with the second partition before writing.
   </p></div><p>
    The choice of splitting the device right in the middle (1--444;
    445--888 for a 128 MB memory stick) is arbitrary. Any other
    well-conceived splitting would be fine.
   </p><p>
    If you had more than one partition to begin with, the "delete"
    part of the procedure would have to be repeated.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="both"></a>9.2. Making a dual ext2/vfat system</h3></div></div></div><p> 
    This step is a repetition of <a class="xref" href="#making-ext2" title="8.2.  Making an ext2 device">Section 8.2, &#8220; Making an ext2 device&#8221;</a>. The first step
	 makes the dos partition, the second makes the Linux ext2 partition.
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mkdosfs</strong></span> -F 32 /dev/sda1</code></strong>
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mke2fs</strong></span> /dev/sda2</code></strong>
   </pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mixed-tests"></a>9.3.  Tests -- ext2 and vfat</h3></div></div></div><p> 
    Simply carry out the tests of <a class="xref" href="#tests" title="7.4.  Tests -- vfat">Section 7.4, &#8220; Tests -- vfat&#8221;</a> and <a class="xref" href="#tests4" title="8.3.  Tests -- ext2">Section 8.3, &#8220; Tests -- ext2&#8221;</a> on the two devices separately. The mount commands
    would be
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t vfat /dev/sda1 /mnt/fatstick </code></strong>
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mount</strong></span> -t ext2 /dev/sda2 /mnt/memstick</code></strong>
   </pre><p>
	 to mount both partitions on your device.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="config-linux"></a>9.4. Configuring Linux for the dual partition</h3></div></div></div><p>
   The Linux machine you did the partitioning on, will be
   configured for the dual partition. Evidently you need to carry the
   keychain to another Linux machine. There you will find that it only
   sees <code class="filename">/dev/sda1</code>. This is, perhaps, a shortcoming
   of the kernel. The workaround is as follows: On the new host
   machine do (keychain plugged in but not mounted)
  </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>fdisk</strong></span> /dev/sda</code></strong>
                   <code class="computeroutput">Choose p; check partition table
                   If satisfied, choose w</code>
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>less</strong></span> /proc/partitions</code></strong>
  </pre><p>
   Your device with its partitions should be there. Data on your
   keychain should be untouched. For a single partition this is not 
   necessary.
  </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="users"></a>10.  Making the memory stick accessible to users</h2></div></div></div><p> 
    What we have described so far, are simply the procedures of setting
    up the system and formatting memory sticks. We have to make the
    mounting of the USB filesystem more permanent, and we have to make
    mounting of such a device easier for non-root users. There are
    only a few things to be done.
   </p><p>
    The procedure described below is for the more complex situation of
    a memory stick with a dual partition (<a class="xref" href="#mixed" title="9.  Setting up a dual partition">Section 9, &#8220; Setting up a dual partition&#8221;</a>). If 
    the partition is a single ext2, the procedure should be simplified
    by leaving out the line referring to the vfat part and changing 
    <code class="filename">sda2</code> to <code class="filename">sda1</code>.
   </p><p> 
    Suppose that the mount points <code class="filename"> /mnt/memstick</code>
    and <code class="filename"> /mnt/fatstick</code> have been created. You do
    not have to use those words and they don't even have to be
    sub-directories of <code class="filename"> /mnt</code>
   </p><p> 
    To make remembering easier, create the following symbolic links:
   </p><pre class="screen">
 
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>ln</strong></span> -s /dev/sda1 /dev/fatflash</code></strong>
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>ln</strong></span> -s /dev/sda2 /dev/flash</code></strong> 
   </pre><p> 
    For smoother and easier mounting add the following lines to
   <code class="filename"> /etc/fstab</code> : (<span class="emphasis"><em> See NOTE at the end of
   </em></span> <a class="xref" href="#mounting" title="7.3.  Mounting the USB filesystem">Section 7.3, &#8220; Mounting the USB filesystem&#8221;</a> )</p><pre class="screen">
             none          /proc/bus/usb usbfs       defaults       0 0 
             /dev/flash    /mnt/memstick ext2,vfat   rw,user,noauto 0 0 
             /dev/fatflash /mnt/fatstick vfat        rw,user,noauto 0 0 
   </pre><p> 
    The middle line enables mounting either in ext2 or vfat.
    The last two lines make it possible for any user to mount the
    device by the command
   </p><pre class="screen">
             <code class="prompt">$</code><strong class="userinput"><code><span class="command"><strong> mount</strong></span> /dev/flash</code></strong>  [for ext2 or vfat] 
             <code class="prompt">$</code><strong class="userinput"><code><span class="command"><strong> mount</strong></span> /dev/fatflash</code></strong>  [for vfat] 
   </pre><p> 
     It is possible to mount both partitions simultaneously. See <a class="xref" href="#mixed" title="9.  Setting up a dual partition">Section 9, &#8220; Setting up a dual partition&#8221;</a>.
   </p><p> 
    In the case of an ext2-formatted device it does not seem possible
    for a user (other than root) to mount in read-write mode. The
    solution is to create a directory on the memory stick owned by the
    particular user with complete permissions. Root should do that:
   </p><pre class="screen">
             <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>mount </strong></span>/dev/flash </code></strong>
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mkdir</strong></span> -m 777 /mnt/memstick/superdir </code></strong>
             <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>chown</strong></span> charles:charles /mnt/memstick/superdir </code></strong>
   </pre><p>
    If the device is in the vfat format, this step is unnecessary.
   </p><p> 
    In conclusion, here is a small script I use to mount and unmount
    my (ext2) flash drive:
   </p><pre class="programlisting">
             #!/bin/bash 
             EXCODE="keepit" 
             green='\033[0;32m' 
             yellow='\033[0;33m' 
             ## ___________________________ 
             ## Function to echo in colours 
             echo_in_color () 
             { 
                  message=$2 
                  message1=$4 
                  color=$1 
                  color1=$3 
                  echo -e -n $color 
		      echo -n $message 
                  echo -e -n $color1 " " 
                  echo  -n $message1 " " 
                  tput sgr0 
                  return 
             } 
             ## ___________________________ 
             clear 
             mount /dev/flash 
             echo_in_color $green "Flash drive mounted" 
             sleep 2 
             while [ $EXCODE != "flexit" ] 
                  do 
                     clear 
                     echo_in_color $yellow "Enter [flexit] to unmount and exit:" 
                     read EXCODE 
                  done 
             umount /dev/flash 
             exit 
   </pre><p> 
    I call this from an FVWM menu by <strong class="userinput"><code> Exec exec xterm
    -geometry 43x2+1250+0 -e /home/nikos/bin/flashdrive</code></strong>
    which places it on a tiny x-term in one corner of the screen. The
    horizontal displacement of 1250 may have to be modified according
    to the horizontal resolution of your screen.
   </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="maintain"></a>11.  Maintenance</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fs-inspect"></a>11.1.  Filesystem inspection</h3></div></div></div><p>
    It is a virtuous habit to inspect your ext2 filesystem on the
    flash memory regularly. To do this, the tool
    <span class="application">dumpe2fs</span> may be used in the following way:
    <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>dumpe2fs</strong></span> -h /dev/sda1</code></strong> (you must be root and
    the device should not be mounted). The result should be similar to
    the following:
   </p><pre class="screen">
             Filesystem volume name:   &lt;none&gt;
             Last mounted on:          &lt;not available&gt;
             Filesystem UUID:          c42a6963-5e6a-4cd2-b7d7-c8f09dca6c52
             Filesystem magic number:  0xEF53
             Filesystem revision #:    1 (dynamic)
             Filesystem features:      dir_index filetype sparse_super
             Default mount options:    (none)
             Filesystem state:         clean
             Errors behavior:          Continue
             Filesystem OS type:       Linux
             Inode count:              32000
             Block count:              127856
             Reserved block count:     6392
             Free blocks:              116456
             Free inodes:              31922
             First block:              1
             Block size:               1024
             Fragment size:            1024
             Blocks per group:         8192
             Fragments per group:      8192
             Inodes per group:         2000
             Inode blocks per group:   250
             Filesystem created:       Sat Sep 20 12:43:00 2003
             Last mount time:          Tue Oct 28 14:13:03 2003
             Last write time:          Tue Oct 28 14:28:27 2003
             Mount count:              13
             Maximum mount count:      35
             Last checked:             Sat Oct 18 11:28:26 2003
             Check interval:           15552000 (6 months)
             Next check after:         Thu Apr 15 11:28:26 2004
             Reserved blocks uid:      0 (user root)
             Reserved blocks gid:      0 (group root)
             First inode:              11
             Inode size:               128
             Default directory hash:   tea
             Directory Hash Seed:      118bee0a-efa5-4771-967e-41a0badd0355
   </pre><p>
    A few important aspects need to be pointed out.
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
           When the ext2 filesystem is created, it is by default
           given maximal usage before it has to be checked. These can
           be seen <span class="emphasis"><em> Maximum mount count </em></span> (35) and
           <span class="emphasis"><em> Check interval</em></span> (expiry date).
         </li><li class="listitem">
           The usage so far: <span class="emphasis"><em> Mount count</em></span> and
           <span class="emphasis"><em> Last checked</em></span> .
         </li><li class="listitem">
           The existence of corrupted files (bad blocks):
           <span class="emphasis"><em> Filesystem state</em></span> .
         </li></ul></div><p>
    You might get warnings about these things when you mount the
    device or when you try the read files from the device.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="and-then"></a>11.2.  And then?</h3></div></div></div><p>
    When the usage allocation has been spent, or there is evidence of
    file corruption, the thing to do is to run <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>fsck.ext2</strong></span> /dev/sda1</code></strong> with the device unmounted. After that, usage
    parameters will be freshly allocated and bad blocks will be gone.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> 
       When dealing with the vfat system, the <span class="application">
       dump</span> does not seem to exist. The command
       <code class="prompt">#</code> <strong class="userinput"><code><span class="command"><strong>dumpe2fs</strong></span> -f /dev/sda1</code></strong> for filesystems
       other than ext2 does not work for vfat. The tool <span class="application">
       dosfsck</span> exists (it is still Alpha), and may be
       risky to use on a device you have not formatted yourself.
      </p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="linux-2.6"></a>12.  The Linux-2.6 kernel</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="What-is-new"></a>12.1.  What is new?</h3></div></div></div><p> 
      Setting up your system as described above for the Linux-2.4.x
      kernels will be perfectly good, but with the Linux-2.6.x kernels
      (x = 0, 1, 2, 3 at the time of this writing) much more is possible:
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          USB Hotplugging of devices has been improved immensely. This
          means that it has become possible to attach and remove a
          device from the USB port with full cognisance of the
          system. If a device is attached, it will show in the /proc
          filesystem. Once it is removed, it will not show anymore.
         </p></li><li class="listitem"><p>
          The <span class="emphasis"><em>sysfs</em></span> system has been
          introduced. By using this facility, a very tight grip on
          attached devices, their attributes and nodes of attachment
          is possible.
         </p></li><li class="listitem"><p>
          Utilities for handling hotplugging have been improved or
          became available. With the aid of these it is possible to
          easily distinguish between attached devices irrespective of
          the order in which they were attached.
         </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="kernel-options"></a>12.2.  Kernel options </h3></div></div></div><p>
      Kernel configuration options are very much the same as described
      in <a class="xref" href="#kernel" title="5.2.  Kernel options">Section 5.2, &#8220; Kernel options&#8221;</a>. The configuration menu
      (<code class="prompt">#</code><strong class="userinput"><code><span class="command"><strong> make </strong></span>  
      menuconfig</code></strong>) has been organized differently
      and more systematically. Here are the relevant choices:
     </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="bus-options"></a>12.2.1.  Bus options</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none">
           Support for hot-pluggable devices (CONFIG_HOTPLUG)
          </li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="device-drivers"></a>12.2.2.  Device drivers</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: disc">
           <span class="strong"><strong> SCSI device support</strong></span>
          </li><li class="listitem" style="list-style-type: none">
            SCSI device support (CONFIG_SCSI scsi_mod)
          </li><li class="listitem" style="list-style-type: none"> 
           legacy /proc/scsi support (CONFIG_SCSI_PROC_FS)
          </li><li class="listitem" style="list-style-type: none"> 
           SCSI disk support (CONFIG_BLK_DEV_SD sd_mod)
          </li><li class="listitem" style="list-style-type: none"><p> </p></li><li class="listitem" style="list-style-type: disc">
           <span class="strong"><strong> USB support</strong></span>
          </li><li class="listitem" style="list-style-type: none">
           Support for USB (CONFIG_USB usbcore)
          </li><li class="listitem" style="list-style-type: none">
           USB device filesystem (CONFIG_USB_DEVICEFS)
          </li><li class="listitem" style="list-style-type: none">
           UHCI HCD support (CONFIG_USB_UHCI_HCD uhci_hcd) 
          </li><li class="listitem" style="list-style-type: none">
           USB Mass Storage support (CONFIG_USB_STORAGE usb_storage)
          </li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="fss-2.6"></a>12.2.3.  File systems</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: none; "><li class="listitem" style="list-style-type: none"> 
           Second extended (CONFIG_EXT2_FS ext2)
          </li><li class="listitem" style="list-style-type: none"><p> </p></li><li class="listitem" style="list-style-type: disc"> 
           <span class="strong"><strong> DOS/FAT/NT filesystems</strong></span>
          </li><li class="listitem" style="list-style-type: none"> 
           DOS FAT fs support (CONFIG_FAT_FS fat)
          </li><li class="listitem" style="list-style-type: none"> 
           MSDOS fs support (CONFIG_MSDOS_FS msdos)
          </li><li class="listitem" style="list-style-type: none"> 
           VFAT (Windows 95) fs support (CONFIG_VFAT_FS vfat)
          </li><li class="listitem" style="list-style-type: none"><p> </p></li><li class="listitem" style="list-style-type: disc">
           <span class="strong"><strong> Pseudo filesystems</strong></span>
          </li><li class="listitem" style="list-style-type: none"> 
           /proc file system support (CONFIG_PROC_FS)
          </li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="notes-2.6"></a>12.3. Notes</h3></div></div></div><p>
     It may be in your interest to consult 
        <a class="ulink" href="http://thomer.com/linux/migrate-to-2.6.html" target="_top">
          Migrating to Linux Kernel 2.6</a>,
     but it is not necessary to follow steps that cannot be followed.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="hotplug"></a>12.4.  Hotplugging and Naming </h3></div></div></div><p>
         In <a class="xref" href="#scsidev" title="6.2.  SCSI devices">Section 6.2, &#8220; SCSI devices&#8221;</a> the situation of two USB
         devices plugged in at the same time was discussed. The
         difficulty is that it becomes hard for the user to
         distinguish the two devices. Progress recently made in the
         <a class="ulink" href="http://sourceforge.net/search/" target="_top">Linux Hotplug
         Project </a> (search for hotplug) and implemented in the
         2.6-series of kernels, has made it possible to address this
         problem efficiently. For implementation some utilities are
         needed:
       </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"> sysfs -- compiled by default into Linux-2.6.x
          </li><li class="listitem">
           <a class="ulink" href="http://linux-diag.sourceforge.net/Sysfsutils.html" target="_top">
            sysfsutils-0.4.0 or later</a>
          </li><li class="listitem"> 
           <a class="ulink" href="http://sourceforge.net/projects/linux-hotplug" target="_top">
           hotplug-2004_01_05 or later</a>
          </li><li class="listitem">
            <a class="ulink" href="http://www.kernel.org/pub/linux/utils/kernel/hotplug" target="_top">
             udev-016 or later</a>
          </li></ul></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="installation"></a>12.4.1.  Installation</h4></div></div></div><p><b>The sysfs filesystem. </b></p><p>
             The <span class="emphasis"><em>sysfs</em></span> filesystem is intrinsic to
             the Linux-2.6 kernel series. It is used by
             <span class="emphasis"><em>udev</em></span> and
             <span class="emphasis"><em>sysfstools</em></span> to obtain information
             about kernel objects (devices, etc.), their attributes
             and mutual linkages. Activation is according to the
             following procedure:
            </p><pre class="screen">
              <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>cd</strong></span></code></strong> /
              <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mkdir</strong></span></code></strong> sys
              <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong>mount</strong></span></code></strong> -t sysfs none /sys
            </pre><p> 

             If you do <strong class="userinput"><code><span class="command"><strong> ls </strong></span>  -F
             /sys</code></strong>, a whole directory structure
             with entries like <span class="emphasis"><em>block/</em></span>,
             <span class="emphasis"><em>bus/</em></span>, ... will be shown. You were
             successful. The mounting should now be made permanent by
             adding the following line to
             <code class="filename">/etc/fstab</code>:
            </p><pre class="screen">
              none  /sys   sysfs  defaults  0  0
            </pre><p><b>Sysfsutils. </b></p><p>
             This is installed in one of the usual ways without having
             to make special configuration options. Instructions in
             the README file are very clear. You should, however,
             first make sure that the entry
             <code class="filename">/usr/local/lib</code> is entered in
             <code class="filename">/etc/ld.so.conf</code> so that the
             <code class="filename">libsysfs.so</code> libraries will be
             recognisable by the system. After installation, check
             that the utilities <code class="filename">/usr/local/bin/lsbus</code>
             and <code class="filename">/usr/local/bin/systool</code> have been
             installed. Also check that the libraries mentioned above
             have been properly linked in
             (<strong class="userinput"><code><span class="command"><strong>ldconfig </strong></span>-p | grep
             libsysfs</code></strong>).
           </p><p><b>Hotplug. </b></p><p>
             Next install the <code class="filename">hotplug</code>
             scripts. The first thing to do is to check that
             hotplugging will work on your system. Do:
             <strong class="userinput"><code><span class="command"><strong> less </strong></span>
             /proc/sys/kernel/hotplug</code></strong>. The
             result should be
             <code class="computeroutput">/sbin/hotplug</code>. If it is
             not so, you should add the line <code class="filename"> echo
             "/sbin/hotplug" &gt; /proc/sys/kernel/hotplug</code> to
             an appropriate initialization script,
             e.g. <code class="filename">/etc/rc.d/rc.local</code>. This
             command could also be given (as root) before checking
             that everything works. Installation is extremely
             simple. Do: <code class="prompt"># </code><strong class="userinput"><code><span class="command"><strong> make
             </strong></span> install</code></strong>. Check afterwards that the
             script <code class="filename">/sbin/hotplug</code> exists.
            </p><p><b>Udev. </b></p><p>
             This is the last installation. Study the README file and
             follow the instructions necessary to be able to run
             <strong class="userinput"><code><span class="command"><strong>make </strong></span>
             USE_KLIBC=true</code></strong>. If you have
             compiled the Linux-2.6.x kernel, this should not be too
             difficult. A quick check would be to find out if
             <code class="filename">/sbin/udev</code> and
             <code class="filename">/sbin/udevinfo</code> exist. There are
             other occurences as well, a very important one being
             <code class="filename">/etc/udev/udev.rules</code>. If you have a
             working setup for memory sticks (as described above) and
             a memory stick plugged in you could try
             <strong class="userinput"><code><span class="command"><strong>ls </strong></span>/udev</code></strong>, you
             should see the device (sda, sda1, ...). If it is there,
             unplug the device and list again. It should be gone!
           </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="names"></a>12.4.2. Naming memory sticks</h4></div></div></div><p>
             With the <span class="emphasis"><em>udev</em></span> utility in place, it
             is possible to identify a memory stick on the basis of
             some built-in attribute. One that works, is the
             <span class="emphasis"><em>vendor</em></span> identity. To find this for an
             attached device, do <strong class="userinput"><code><span class="command"><strong>systool
             </strong></span> -vb scsi | grep vendor</code></strong>. This
             should give a list of attached SCSI devices (remember
             that your memory stick poses as a SCSI device <a class="xref" href="#scsidev" title="6.2.  SCSI devices">Section 6.2, &#8220; SCSI devices&#8221;</a>). Let us suppose that you have two
             memory sticks plugged in at the same time and found (as I
             did) two vendor Id's, namely "UFD" and "STORAGE". Then
             add to the file <code class="filename">/etc/udev/udev.rules</code>
             the following lines (at the top if you like):
           </p><pre class="screen">
              ## Flash Memory 1
              BUS="scsi", SYSFS_vendor="UFD*", NAME="namib%n"

              ## Flash Memory 2
              BUS="scsi", SYSFS_vendor="STORAGE*", NAME="kalahari%n"
           </pre><p>
             The vendor-identities may have trailing blank spaces, and
             therefore the wildcard asterisks have a purpose. Do not
             ignore them.  Remove and replace the memory sticks, then
             do <strong class="userinput"><code><span class="command"><strong>ls </strong></span>
             /udev</code></strong>. Instead of the impersonal
             <code class="filename">sda</code>, <code class="filename">sda1</code>,
             etc. there should now be <code class="filename">kalahari</code>,
             <code class="filename">kalahari1</code>,
             <code class="filename">namib</code> and
             <code class="filename">namib1</code>. The devices have been named
             according to the "vendor" information in them. Thus we
             can identify the device, no matter where it was
             mapped. All that remains to be done is to creat
             appropriate mount points like
             <code class="filename">/mnt/namib</code> and
             <code class="filename">kalahari</code> and make entries like
           </p><pre class="screen">
             /udev/namib1     /mnt/namib     vfat,ext2  user,noauto,rw  0 0 
             /udev/kalahari1  /mnt/kalahari  vfat,ext2  user,noauto,rw  0 0         
            </pre><p>
             in <code class="filename">/etc/fstab</code> to enable mounting
             from other places.
           </p><p>
             This is great fun ... and remember, there are other
             deserts on the planet.
           </p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="formal"></a>13.  Formalities</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="copyright"></a>13.1.  Copyright Information</h3></div></div></div><p>
    This document is copyrighted (c) 2003 Niko Sauer and is
    distributed under the terms of the Linux Documentation Project
    (LDP) license, stated below.
   </p><p>
    Unless otherwise stated, Linux HOWTO documents are
    copyrighted by their respective authors. Linux HOWTO documents may
    be reproduced and distributed in whole or in part, in any medium
    physical or electronic, as long as this copyright notice is
    retained on all copies. Commercial redistribution is allowed and
    encouraged; however, the author would like to be notified of any
    such distributions.
   </p><p>
    All translations, derivative works, or aggregate works
    incorporating any Linux HOWTO documents must be covered under this
    copyright notice. That is, you may not produce a derivative work
    from a HOWTO and impose additional restrictions on its
    distribution. Exceptions to these rules may be granted under
    certain conditions; please contact the Linux HOWTO coordinator at
    the address given below.
   </p><p>
    In short, we wish to promote dissemination of this
    information through as many channels as possible. However, we do
    wish to retain copyright on the HOWTO documents, and would like to
    be notified of any plans to redistribute the HOWTOs.
   </p><p>
    If you have any questions, please contact 
    <code class="email">&lt;<a class="email" href="mailto:nikos@friedrichs.up.ac.za%20">nikos@friedrichs.up.ac.za </a>&gt;</code>
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="disclaimer"></a>13.2.  Disclaimer</h3></div></div></div><p>
    No liability for the contents of this documents can be accepted.
    Use the concepts, examples and other content at your own risk.
    As this is a new document, there may be errors
    and inaccuracies, that may of course be damaging to your system.
    Proceed with caution, and although this is highly unlikely,
    the author do not take any responsibility for that.
   </p><p>
    All copyrights are held by their by their respective owners, unless
    specifically noted otherwise.  Use of a term in this document
    should not be regarded as affecting the validity of any trademark
    or service mark.
   </p><p>
    Naming of particular products or brands should not be seen 
    as endorsements.
   </p><p>
    You are strongly recommended to take a backup of your system 
    before major installation and backups at regular intervals.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="credits"></a>13.3.  Credits</h3></div></div></div><p>
    I wish to express my deep gratitude towards my sons Paul and
    Philip who in 1995 persuaded me to move to Linux. Philip gave me
    profound advice and insights which made this project a pleasant
    learning experience.
   </p><p>
     Emma Jane Hogbin, in her review, raised a number of important
     questions which served to improve this document immensely. My
     sincerest thanks to her.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="feedback"></a>13.4.  Feedback</h3></div></div></div><p>
    Users of this document are most welcome to email me with
    suggestions on the improvement of the presentation and possible
    additions to the scope of it.
   </p></div></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.ftn-heavy-dependencies" class="footnote"><p><a href="#ftn-heavy-dependencies" class="para"><sup class="para">[1] </sup></a>
         This document leans heavily on the texts marked with an asterisk
        </p></div></div></div></body></html>
