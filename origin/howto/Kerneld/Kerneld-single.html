<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux kerneld mini-HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux kerneld mini-HOWTO</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Henrik Storner</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:kerneld-howto@linuxdoc.org"
>kerneld-howto@linuxdoc.org</A
>&#62;</CODE
></P
></DIV
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2000 Linux Documentation
      Project</P
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v2.0</TD
><TD
ALIGN="LEFT"
>22 May 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>conversion from HTML to DocBook SGML.</TD
></TR
></TABLE
></DIV
><DIV
CLASS="LEGALNOTICE"
><A
NAME="AEN19"
></A
><P
><B
>Copyright</B
></P
><P
>This document is Copyright by Henrik Storner, 1996, 1997.</P
><P
>Unless otherwise stated, Linux HOWTO documents are
      copyrighted by their respective authors. Linux HOWTO documents
      may be reproduced and distributed in whole or in part, in any
      medium physical or electronic, as long as this copyright notice
      is retained on all copies. Commercial redistribution is allowed
      and encouraged; however, the author would like to be notified of
      any such distributions. </P
><P
>All translations, derivative works, or aggregate works
      incorporating any Linux HOWTO documents must be covered under
      this copyright notice.  That is, you may not produce a
      derivative work from a HOWTO and impose additional restrictions
      on its distribution. Exceptions to these rules may be granted
      under certain conditions; please contact the Linux HOWTO
      coordinator at the address given below. </P
><P
>In short, we wish to promote dissemination of this
      information through as many channels as possible. However, we do
      wish to retain copyright on the HOWTO documents, and would like
      to be notified of any plans to redistribute the HOWTOs. </P
><P
>If you have questions, please contact the Linux HOWTO
      coordinator, at linux-howto@sunsite.unc.edu via email.</P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN26"
>About the kerneld mini-HOWTO</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#CREDITS"
>Credits</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#INTRODUCTION"
>What is kerneld?</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#WHY"
>Why do I want to use it ?</A
></DT
><DT
>2.2. <A
HREF="#WHERE"
>Where can I pick up the necessary pieces
    ?</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#SETUP"
>How do I set it up?</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#TESTING"
>Trying out kerneld</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#CONFIGURATION"
>How does kerneld know what module
     to load?</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#BLOCKDEV"
>Block devices</A
></DT
><DT
>4.2. <A
HREF="#CHARDEV"
>Character devices</A
></DT
><DT
>4.3. <A
HREF="#ETH0"
>Network devices</A
></DT
><DT
>4.4. <A
HREF="#BINFMT"
>Binary formats</A
></DT
><DT
>4.5. <A
HREF="#LDISC"
>Line disciplines (slip, cslip and ppp)</A
></DT
><DT
>4.6. <A
HREF="#NET-PF"
>Network protocol families (IPX,
      AppleTalk, AX.25)</A
></DT
><DT
>4.7. <A
HREF="#FS"
>File systems</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#SPECIAL-DEVS"
>Devices requiring special
     configuration</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#MISCDEVS"
>char-major-10 : Mice, watchdogs and randomness</A
></DT
><DT
>5.2. <A
HREF="#SCSIDEVS"
>Loading SCSI drivers: The
      <TT
CLASS="LITERAL"
>scsi_hostadapter</TT
> entry</A
></DT
><DT
>5.3. <A
HREF="#PRE-POST"
>When loading a module isn't enough: The
        <TT
CLASS="LITERAL"
>post-install</TT
> entry</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#SPYING"
>Spying on kerneld</A
></DT
><DT
>7. <A
HREF="#GOODIES"
>Special kerneld uses</A
></DT
><DT
>8. <A
HREF="#COMMONPROBLEMS"
>Common problems and things that make you wonder</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN26"
>1. About the kerneld mini-HOWTO</A
></H2
><P
>This document explains how to install and use the automatic
      kernel module loader <SPAN
CLASS="QUOTE"
>"kerneld"</SPAN
>. The latest released
      version of this document can be found at <A
HREF="http://www.linuxdoc.org"
TARGET="_top"
>the Linux Documentation
      Project</A
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CREDITS"
>1.1. Credits</A
></H3
><P
>This document is based on an original HTML version 1.7
      dated July 19, 1997 by Henrik Storner
      <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:storner@osiris.ping.dk"
>storner@osiris.ping.dk</A
>&#62;</CODE
> and was revised and
      translated to DocBook DTD by Gary Lawrence Murphy
      <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:garym@teledyn.com"
>garym@teledyn.com</A
>&#62;</CODE
> May 20, 2000.</P
><P
>The following people have contributed to this
      mini-HOWTO at some point:</P
><P
></P
><UL
><LI
><P
>Bjorn Ekwall bj0rn@blox.se</P
></LI
><LI
><P
>Ben Galliart bgallia@luc.edu</P
></LI
><LI
><P
>Cedric Tefft cedric@earthling.net</P
></LI
><LI
><P
>Brian Miller bmiller@netspace.net.au</P
></LI
><LI
><P
>James C. Tsiao
        jtsiao@madoka.jpl.nasa.gov</P
></LI
></UL
><P
>If you find errors in this document, please send email to
      <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:kerneld-howto@linuxdoc.org"
>kerneld-howto@linuxdoc.org</A
>&#62;</CODE
>. Your comments,
      encouragement and suggestions are welcome and appreciated, and
      help ensure this guide remains current and accurate.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INTRODUCTION"
>2. What is kerneld?</A
></H2
><P
>The kerneld feature was introduced during the 1.3
      development kernels by Bjorn Ekwall. It allows kernel modules
      such as device drivers, network drivers and filesystems to be
      loaded automatically when they are needed, rather than having to
      do it manually with <B
CLASS="COMMAND"
>modprobe</B
> or
      <B
CLASS="COMMAND"
>insmod</B
>. </P
><P
>And for the more amusing aspects, although these are not
      (yet ?) integrated with the standard kernel: </P
><P
></P
><UL
><LI
><P
>It can be setup to run a user-program instead
        of the default screen blanker, thus letting you use any
        program as a screen-saver. </P
></LI
><LI
><P
>Similar to the screen-blanker support, you can
        also change the standard console beep into something
        completely different. </P
></LI
></UL
><P
>kerneld consists of two components: </P
><P
></P
><UL
><LI
><P
>Support in the Linux kernel for sending
        requests to a daemon requesting a module for a certain
        task. </P
></LI
><LI
><P
>A user-space daemon that can figure out what
         modules must be loaded to fulfill the request from the
         kernel. </P
></LI
></UL
><P
>Both components must be working for the kerneld support to
       function; it is not enough that only one or the other has been
       setup. </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WHY"
>2.1. Why do I want to use it ?</A
></H3
><P
>There are some good reasons for using kerneld. The ones I
      will mention are mine, others have other reasons. </P
><P
></P
><UL
><LI
><P
>If you have to build kernels for several
        systems that only differ slightly - different kind of network
        card, for instance - then you can build a single kernel and
        some modules, instead of having to build individual kernels
        for each system. </P
></LI
><LI
><P
>Modules are easier for developers to test.
        You don't need to reboot the system to load and unload the
        driver; this applies to all modules, not just kerneld-loaded
        ones. </P
></LI
><LI
><P
>It cuts down on the kernel memory usage
        leaving more memory available for applications. Memory used by
        the kernel is <EM
>never</EM
> swapped out, so if
        you have 100Kb worth of unused drivers compiled into your
        kernel, they are simply wasting RAM. </P
></LI
><LI
><P
>Some of the things I use, the ftape
        floppy-tape driver, for instance, or iBCS, are only available
        as modules, but I don't want to bother with loading and
        unloading them whenever I need them. </P
></LI
><LI
><P
>People making Linux distributions don't have
        to build 284 different boot images: Each user loads the
        drivers he needs for just his hardware.  Most modern Linux
        distributions will detect your hardware and will only load
        those modules actually required.</P
></LI
></UL
><P
>Of course, there are also reasons why you may not want to
       use it. If you prefer to have just one kernel image file with
       all of your drivers built in, you are reading the wrong
       document.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WHERE"
>2.2. Where can I pick up the necessary pieces
    ?</A
></H3
><P
>The support in the Linux kernel was introduced with Linux
      1.3.57. If you have an earlier kernel version, you will need to
      upgrade if you want the kerneld support. The current Linux
      kernel sources can be found at most Linux FTP archive sites
      including:</P
><P
></P
><UL
><LI
><P
><A
HREF="ftp://ftp.kernel.org/pub/linux/kernel/"
TARGET="_top"
>Kernel.Org
          Archive</A
></P
></LI
><LI
><P
><A
HREF="ftp://metalab.unc.edu/pub/Linux/kernel/"
TARGET="_top"
>Metalab Linux
          Archive</A
></P
></LI
><LI
><P
><A
HREF="ftp://tsx-11.mit.edu/pub/linux/sources/system/"
TARGET="_top"
>TSX-11
          at MIT</A
></P
></LI
></UL
><P
>The user-space daemon is included with the
      <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
> package. These are normally
      available from the same place as the kernel sources
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you want to try module-loading with the latest
      <EM
>development</EM
> kernels, you should use the
      newer <SPAN
CLASS="PRODUCTNAME"
>modutils</SPAN
> package and not the
      <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
>.  Always check the
      <TT
CLASS="FILENAME"
>Documentation/Changes</TT
> file in the kernel
      sources for the minimum required version number for your kernel
      image. Also see  about the problems with modules
      and 2.1 kernels.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SETUP"
>3. How do I set it up?</A
></H2
><P
>First get the necessary parts: A suitable kernel and the
      latest <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
> package.  Then you
      should install the module utilities as per the instructions
      included in the package. Pretty simple: Just unpack the sources
      and run <B
CLASS="COMMAND"
>make install</B
>. This compiles and
      installs the following programs in <TT
CLASS="FILENAME"
>/sbin</TT
>:
      <B
CLASS="COMMAND"
>genksysm</B
>, <B
CLASS="COMMAND"
>insmod</B
>,
      <B
CLASS="COMMAND"
>lsmod</B
>, <B
CLASS="COMMAND"
>modprobe</B
>,
      <B
CLASS="COMMAND"
>depmod</B
> and <B
CLASS="COMMAND"
>kerneld</B
>. I
      recommend you add some lines to your startup-scripts to do some
      necessary setup whenever you boot Linux. Add the following lines
      to your <TT
CLASS="FILENAME"
>/etc/rc.d/rc.S</TT
> file (if you are
      running Slackware), or to
      <TT
CLASS="FILENAME"
>/etc/rc.d/rc.sysinit</TT
> if you are running
      SysVinit, i.e. Debian, Corel, RedHat, Mandrake or Caldera:
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        # Start kerneld - this should happen very early in the
        # boot process, certainly BEFORE you run fsck on filesystems
        # that might need to have disk drivers autoloaded
        if [ -x /sbin/kerneld ]
        then
                /sbin/kerneld
        fi

        # Your standard fsck commands go here
        # And you mount command to mount the root fs read-write

        # Update kernel-module dependencies file
        # Your root-fs MUST be mounted read-write by now
        if [ -x /sbin/depmod ]
        then
                /sbin/depmod -a
        fi</PRE
></FONT
></TD
></TR
></TABLE
><P
>These commands may already be installed in your SysV init
      scripts. The first part starts kerneld itself. The second calls
      <B
CLASS="COMMAND"
>depmod -a</B
> at startup to build a list of all
      available modules and analyzes their inter-dependencies. The
      depmod map then tells kerneld if one module needs to have
      another loaded before it will itself load. </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Recent versions of kerneld have an option to link with the
      GNU gdbm library, <SPAN
CLASS="PRODUCTNAME"
>libgdbm</SPAN
>. If you
      enable this when building the module utilities,
      <EM
>kerneld will not start if libgdbm is not
      available</EM
> which may well be the case if you have
      <TT
CLASS="FILENAME"
>/usr</TT
> on a separate partition and start
      kerneld before <TT
CLASS="FILENAME"
>/usr</TT
> is mounted. The
      recommended solution is to move
      <TT
CLASS="FILENAME"
>/usr/lib/libgdbm</TT
> to
      <TT
CLASS="FILENAME"
>/lib</TT
>, or to link kerneld
      statically.</P
></TD
></TR
></TABLE
></DIV
><P
>Next, unpack the kernel sources, configure and build a
      kernel to your liking. If you have never done this before, you
      should definitely read the README file at the top level of the
      Linux sources. When you run <EM
>make xconfig</EM
>
      to configure the kernel, you should pay attention to some
      questions that appear early on: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  Enable loadable module support (CONFIG_MODULES) [Y/n/?] Y</PRE
></FONT
></TD
></TR
></TABLE
><P
>You need to select the loadable module support, or there
      will be no modules for kerneld to load! Just say Yes. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  Kernel daemon support (CONFIG_KERNELD) [Y/n/?] Y</PRE
></FONT
></TD
></TR
></TABLE
><P
>This, of course, is also necessary. Then, a lot of the
      things in the kernel can be built as modules - you will see
      questions like </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  Normal floppy disk support (CONFIG_BLK_DEV_FD) [M/n/y/?] </PRE
></FONT
></TD
></TR
></TABLE
><P
>where you can answer with an <SPAN
CLASS="KEYSYM"
>M</SPAN
> for
      <SPAN
CLASS="QUOTE"
>"Module"</SPAN
>. Generally, only the drivers necessary for
      you to boot up your system should be built into the kernel; the rest
      can be built as modules. </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Essential drivers</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Essential drivers
        required to boot your system must be compiled into the core
        kernel and cannot be loaded as modules. Typically this will
        include the hard-disk driver and the driver for the root
        filesystem.  If you have a dual-boot machine and rely on files
        found in the foreign partition, you must also compile support
        for that filesystem into the core kernel.</P
></TD
></TR
></TABLE
></DIV
><P
>When you have gone through the <B
CLASS="COMMAND"
>make
      config</B
>, compile and install the new
      kernel and the modules with <B
CLASS="COMMAND"
>make dep clean bzlilo
      modules modules_install</B
>.</P
><P
>Phew. </P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Compiling a Kernel Image</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The
        <B
CLASS="COMMAND"
>make zImage</B
> command will stop short of
        installing a kernel and will leave the new kernel image in the
        file <TT
CLASS="FILENAME"
>arch/i386/boot/zImage</TT
>.  To use this
        image, you will
        need to copy it to where you keep your boot-image and install it
        manually with LILO. </P
><P
>For more information about configuring, building and
        installing your own kernel, check out the Kernel-HOWTO posted
        regularly to <TT
CLASS="FILENAME"
>comp.os.linux.answers</TT
>, and
        available from <A
HREF="http://www.linuxdoc.org"
TARGET="_top"
>the Linux
        Documentation Project</A
> and its mirrors.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TESTING"
>3.1. Trying out kerneld</A
></H3
><P
>Now reboot with the new kernel. When the system comes back
      up, you can run <B
CLASS="COMMAND"
>ps ax</B
>, and you should see a
      line for kerneld: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>    PID TTY STAT  TIME COMMAND
     59  ?  S     0:01 /sbin/kerneld</PRE
></FONT
></TD
></TR
></TABLE
><P
>One of the nice things with kerneld is that once you have
      the kernel and the daemon installed, very little setup is
      needed. For a start, try using one of the drivers that you built
      as a module; it is more likely than not that it will work
      without further configuration. If I build the floppy driver as a
      module, I could put a DOS floppy in the drive and type</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  osiris:~ $ mdir a:
   Volume in drive A has no label
   Volume Serial Number is 2E2B-1102
   Directory for A:/

  binuti~1 gz       1942 02-14-1996  11:35a binutils-2.6.0.6-2.6.0.7.diff.gz
  libc-5~1 gz      24747 02-14-1996  11:35a libc-5.3.4-5.3.5.diff.gz
          2 file(s)        26689 bytes</PRE
></FONT
></TD
></TR
></TABLE
><P
>The floppy driver works! It gets loaded automatically
      by kerneld when I try to use the floppy disk. </P
><P
>To see that the floppy module is indeed loaded, you can
      run <B
CLASS="COMMAND"
>/sbin/lsmod</B
> to list all currently
      loaded modules: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  osiris:~ $ /sbin/lsmod 
  Module:        #pages:  Used by:
  floppy            11    0 (autoclean)</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <SPAN
CLASS="QUOTE"
>"(autoclean)"</SPAN
> means that the module will
      automatically be removed by kerneld when it has not been used
      for more than one minute.  So the 11 pages of memory (= 44kB,
      one page is 4 kB) will only be used while I access the floppy
      drive - if I don't use the floppy for more than a minute, they
      are freed. Quite nice, if you are short of memory for your
      applications! </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONFIGURATION"
>4. How does kerneld know what module
     to load?</A
></H2
><P
>Although kerneld comes with builtin knowledge about the
      most common types of modules, there are situations where kerneld
      will not know how to handle a request from the kernel. This is
      the case with things like CD-ROM drivers or network drivers,
      where there are more than one possible module that can be
      loaded. </P
><P
>The requests that the kerneld daemon gets from the kernel
      is for one of the following items: </P
><P
></P
><UL
><LI
><P
>a block-device driver </P
></LI
><LI
><P
>a character-device driver </P
></LI
><LI
><P
>a binary format </P
></LI
><LI
><P
>a tty line discipline </P
></LI
><LI
><P
>a filesystem </P
></LI
><LI
><P
>a network device </P
></LI
><LI
><P
>a network service (e.g. rarp) </P
></LI
><LI
><P
>a network protocol (e.g. IPX)
        </P
></LI
></UL
><P
>The kerneld determines what module should be loaded by
      scanning the configuration file
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
><A
NAME="AEN192"
HREF="#FTN.AEN192"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>. There are
      two kinds of entries in this file: Paths where the module-files
      are located, and aliases assigning the module to be loaded for a
      given service. If you don't have this file already, you could
      create it by running
      </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  /sbin/modprobe -c | grep -v '^path' /etc/conf.modules</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to add yet another path directive to the
      default paths, you <EM
>must include all the default paths
      as well</EM
>, since a path directive in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> will
      <EM
>replace</EM
>all the ones that modprobe knows by
      default!  </P
><P
>Normally you don't want to add any paths by your own,
      since the built-in set should take care of all normal setups
      (and then some...), I promise! </P
><P
>On the other hand, if you just want to add an alias or an
      option directive, your new entries in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> will be
      <EM
>added</EM
> to the ones that modprobe already
      knows. If you should <EM
>redefine</EM
> an alias or
      an option, your new entries in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> will override the
      built-in ones.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BLOCKDEV"
>4.1. Block devices</A
></H3
><P
>If you run <B
CLASS="COMMAND"
>/sbin/modprobe -c</B
>, you
      will get a listing of the modules that kerneld knows about, and
      what requests they correspond to. For instance, the request that
      ends up loading the floppy driver is for the block-device that
      has major number 2: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  osiris:~ $ /sbin/modprobe -c | grep floppy
  alias block-major-2 floppy</PRE
></FONT
></TD
></TR
></TABLE
><P
>Why <TT
CLASS="FILENAME"
>block-major-2</TT
> ? Because the
     floppy devices <TT
CLASS="FILENAME"
>/dev/fd*</TT
> use major device 2
     and are block devices:
     </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  osiris:~ $ ls -l /dev/fd0 /dev/fd1
  brw-rw-rw-   1 root     root       2,   0 Mar  3  1995 /dev/fd0
  brw-r--r--   1 root     root       2,   1 Mar  3  1995 /dev/fd1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHARDEV"
>4.2. Character devices</A
></H3
><P
>Character devices are dealt with in a similar
        way. E.g. the ftape floppy tape driver sits on major-device
        27: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  osiris:~ $ ls -lL /dev/ftape 
  crw-rw----   1 root     disk      27,   0 Jul 18  1994 /dev/ftape</PRE
></FONT
></TD
></TR
></TABLE
><P
>However, kerneld does not by default know about the
        ftape driver - it is not listed in the output from
        <B
CLASS="COMMAND"
>/sbin/modprobe -c</B
>. So to setup kerneld to
        load the ftape driver, I must add a line to the kerneld
        configuration file, <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>:
        </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias char-major-27 ftape</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ETH0"
>4.3. Network devices</A
></H3
><P
>You can also use the device name instead of the
        <TT
CLASS="LITERAL"
>char-major-xxx</TT
> or
        <TT
CLASS="LITERAL"
>block-major-yyy</TT
> setup. This is especially
        useful for network drivers. For example, a driver for an
        ne2000 netcard acting as <TT
CLASS="FILENAME"
>eth0</TT
> would be
        loaded with </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias eth0 ne</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you need to pass some options to the driver, for
        example to tell the module about what IRQ the netcard is
        using, you must add an <SPAN
CLASS="QUOTE"
>"options"</SPAN
> line: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  options ne irq=5</PRE
></FONT
></TD
></TR
></TABLE
><P
>This will cause kerneld to load the NE2000 driver with
        the command </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  /sbin/modprobe ne irq=5</PRE
></FONT
></TD
></TR
></TABLE
><P
>Of course, the actual options available are specific to
        the module you are loading. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BINFMT"
>4.4. Binary formats</A
></H3
><P
>Binary formats are handled in a similar way. Whenever
        you try to run a program that the kernel does not know how to
        load, kerneld gets a request for
        <TT
CLASS="LITERAL"
>binfmt-</TT
><CODE
CLASS="VARNAME"
>xxx</CODE
>, where
        <CODE
CLASS="VARNAME"
>xxx</CODE
> is a number determined from the first
        few bytes of the executable. So, the kerneld configuration to
        support loading the binfmt_aout module for ZMAGIC (a.out)
        executables is
        </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias binfmt-267 binfmt_aout</PRE
></FONT
></TD
></TR
></TABLE
><P
>Since the magic number for ZMAGIC files is 267, if you
        check <TT
CLASS="FILENAME"
>/etc/magic</TT
>, you will see the number
        0413; keep in mind that <TT
CLASS="FILENAME"
>/etc/magic</TT
> uses
        octal numbers where kerneld uses decimal, and octal 413 =
        decimal 267.  There are actually three slightly different
        variants of a.out executables (NMAGIC, QMAGIC and ZMAGIC), so
        for full support of the binfmt_aout module we need
        </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias binfmt-264 binfmt_aout  # pure executable (NMAGIC)
  alias binfmt-267 binfmt_aout  # demand-paged executable (ZMAGIC)
  alias binfmt-204 binfmt_aout  # demand-paged executable (QMAGIC)</PRE
></FONT
></TD
></TR
></TABLE
><P
>a.out, Java and iBCS binary formats are recognized
        automatically by kerneld, without any configuration. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LDISC"
>4.5. Line disciplines (slip, cslip and ppp)</A
></H3
><P
>Line disciplines are requested with
        <TT
CLASS="LITERAL"
>tty-ldisc-</TT
><CODE
CLASS="VARNAME"
>x</CODE
>, with
        <CODE
CLASS="VARNAME"
>x</CODE
> 
        being usually 1 (for SLIP) or 3 (for PPP). Both of these are
        known by kerneld automatically. </P
><P
>Speaking of ppp, if you want kerneld to load the
        bsd_comp data compression module for ppp, then you must add
        the following two lines to your
        <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias tty-ldisc-3 bsd_comp
  alias ppp0 bsd_comp</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NET-PF"
>4.6. Network protocol families (IPX,
      AppleTalk, AX.25)</A
></H3
><P
>Some network protocols can be loaded as modules as
        well. The kernel asks kerneld for a protocol family (e.g. IPX)
        with a request for
        <TT
CLASS="LITERAL"
>net-pf-</TT
><CODE
CLASS="VARNAME"
>X</CODE
> where
        <CODE
CLASS="VARNAME"
>X</CODE
> is a number indicating what family is
        wanted. E.g. <TT
CLASS="LITERAL"
>net-pf-3</TT
> is AX.25,
        <TT
CLASS="LITERAL"
>net-pf-4</TT
> is IPX and
        <TT
CLASS="LITERAL"
>net-pf-5</TT
> is AppleTalk; These numbers are
        determined by the AF_AX25, AF_IPX etc. definitions in the
        linux source file <TT
CLASS="FILENAME"
>include/linux/socket.h</TT
>.
        So to autoload the IPX module, you would need an entry like
        this in <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias net-pf-4 ipx</PRE
></FONT
></TD
></TR
></TABLE
><P
>See <A
HREF="#COMMONPROBLEMS"
>Common Problems</A
> for information
        about how you can avoid some annoying boot-time messages
        related to undefined protocol families. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FS"
>4.7. File systems</A
></H3
><P
>kerneld requests for filesystems are simply the name of
        the filesystem type. A common use of this would be to load the
        isofs module for CD-ROM filesystems, i.e. filesystems of type
        iso9660: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  alias iso9660 isofs</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIAL-DEVS"
>5. Devices requiring special
     configuration</A
></H2
><P
>Some devices require a bit of extra configuration beyond the
     normal aliasing of a device to a module. </P
><P
></P
><UL
><LI
><P
>Character devices on major number 10: <A
HREF="#MISCDEVS"
>The miscellaneous
        devices</A
></P
></LI
><LI
><P
><A
HREF="#SCSIDEVS"
>SCSI devices</A
>
        </P
></LI
><LI
><P
><A
HREF="#PRE-POST"
>Devices that require
        special initialization</A
></P
></LI
></UL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MISCDEVS"
>5.1. char-major-10 : Mice, watchdogs and randomness</A
></H3
><P
>Hardware devices are usually identified through their
        major device numbers, e.g. ftape is
        <TT
CLASS="LITERAL"
>char-major-27</TT
>. However, if you look through
        the entries in <TT
CLASS="FILENAME"
>/dev</TT
> for char major 10,
        you will see that this is a bunch of very different devices,
        including </P
><P
></P
><UL
><LI
><P
>Mice of various sorts (bus mice, PS/2
          mice)</P
></LI
><LI
><P
>Watchdog devices </P
></LI
><LI
><P
>The kernel <TT
CLASS="FILENAME"
>random</TT
>
          device </P
></LI
><LI
><P
>APM (Advanced Power Management) interface
          </P
></LI
></UL
><P
>These devices are controlled by several different
        modules, not a single one, and therefore the kerneld
        configuration for these <EM
>misc. devices</EM
>
        use the major number <EM
>and</EM
> the minor
        number: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>        alias char-major-10-1 psaux     # For PS/2 mouse
        alias char-major-10-130 wdt     # For WDT watchdog</PRE
></FONT
></TD
></TR
></TABLE
><P
>You need a kernel version 1.3.82 or later to use this;
        earlier versions do not pass the minor number to kerneld,
        making it impossible for kerneld to figure out which of the
        misc. device modules to load. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SCSIDEVS"
>5.2. Loading SCSI drivers: The
      <TT
CLASS="LITERAL"
>scsi_hostadapter</TT
> entry</A
></H3
><P
>Drivers for SCSI devices consist of a driver for the
        SCSI host adapter (e.g. an Adaptec 1542), and a driver for the
        type of SCSI device you use, e.g. a hard disk, a CD-ROM or a
        tape-drive. All of these can be loaded as modules. However,
        when you want to access e.g. the CD-ROM drive that is
        connected to the Adaptec card, the kernel and kerneld only
        knows that it needs to load the <TT
CLASS="FILENAME"
>sr_mod</TT
>
        module in order to support SCSI CD-ROM's; it does not know
        what SCSI controller the CD-ROM is connected to, and hence
        does not know what module to load to support the SCSI
        controller. </P
><P
>To resolve this, you can add an entry for the SCSI
        driver module to your <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>
        that tells kerneld which of the many possible SCSI controller
        modules it should load: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>        alias scd0 sr_mod               # sr_mod for SCSI CD-ROM's ...
        alias scsi_hostadapter aha1542  # ... need the Adaptec driver</PRE
></FONT
></TD
></TR
></TABLE
><P
>This only works with kernel version 1.3.82 or later. </P
><P
>This works if you have only one SCSI controller. If you
        have more than one, things become a little more
        difficult.</P
><P
>In general, you cannot have kerneld load a driver for a
        SCSI host adapter, if a driver for another host adapter is
        already installed. You must either build both drivers into
        your kernel (not as modules), or load the modules
        manually.</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.png"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>There <EM
>is</EM
> a way that you can
        have kerneld load multiple SCSI drivers. James Tsiao came up
        with this idea:</P
><A
NAME="AEN322"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
> You can easily have kerneld load the second scsi
            driver by setting up the dependency in your modules.dep by
            hand.  You just need an entry like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>      /lib/modules/2.0.30/scsi/st.o: /lib/modules/2.0.30/scsi/aha1542.o</PRE
></FONT
></TD
></TR
></TABLE
><P
>To have kerneld load the
            <TT
CLASS="FILENAME"
>aha1542.o</TT
> before it loads
            <TT
CLASS="FILENAME"
>st.o</TT
>.  My machine at home is set up
            almost exactly like the setup above, and it works fine for
            all my secondary scsi devices, including tape, cd-rom, and
            generic scsi devices.  The drawback is that
            <B
CLASS="COMMAND"
>depmod -a</B
> can't autodetect these
            dependencies, so the user needs to add them by hand, and
            not run <B
CLASS="COMMAND"
>depmod -a</B
> on boot up.  But once
            it is set up, kerneld will autoload the
            <TT
CLASS="FILENAME"
>aha1542.o</TT
> just
            fine.</P
></BLOCKQUOTE
></TD
></TR
></TABLE
></DIV
><P
>You should be aware, that this technique only works if
        you have different kinds of SCSI devices on the two
        controllers, for example, hard disks on one controller, and
        cd-rom drives, tapes or generic SCSI devices on another.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRE-POST"
>5.3. When loading a module isn't enough: The
        <TT
CLASS="LITERAL"
>post-install</TT
> entry</A
></H3
><P
>Sometimes, just loading the module is not enough to get
        things working.  For instance, if you have your sound card
        compiled as a module, it is often convenient to set a certain
        volume level. Only problem is, the setting vanishes the next
        time the module is loaded. Here is a neat trick from Ben
        Galliart (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bgallia@luc.edu"
>bgallia@luc.edu</A
>&#62;</CODE
>): </P
><A
NAME="AEN337"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>The final solution required installing the <A
HREF="ftp://sunsite.unc.edu/pub/Linux/apps/sound/mixers/"
TARGET="_top"
>          <SPAN
CLASS="PRODUCTNAME"
>setmix</SPAN
> package</A
> and then
          adding the following line to my
          <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>: </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>post-install sound /usr/local/bin/setmix -f /etc/volume.conf</PRE
></FONT
></TD
></TR
></TABLE
></BLOCKQUOTE
><P
>What this does is that after the sound module is loaded,
        kerneld runs the command indicated by the
        <TT
CLASS="LITERAL"
>post-install sound</TT
> entry. So the sound
        module gets configured with the command
        <B
CLASS="COMMAND"
>/usr/local/bin/setmix -f
        /etc/volume.conf</B
>.</P
><P
>This may be useful for other modules as well, for
        example the <TT
CLASS="FILENAME"
>lp</TT
> module can be configured
        with the <TT
CLASS="FILENAME"
>tunelp</TT
> program by adding
        </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        post-install lp tunelp options</PRE
></FONT
></TD
></TR
></TABLE
><P
>For kerneld to recognize these options, you will need a
        version of kerneld that is 1.3.69f or later.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>An earlier version of this mini-HOWTO mentioned a
          pre-remove option, that might be used to run a command just
          before kerneld removed a module. However, this has never
          worked and its use is therefore discouraged - most likely,
          this option will disappear in a future kerneld release.  The
          whole issue of module settings is undergoing some change at
          the moment, and may look different on your system by the
          time you read this. </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPYING"
>6. Spying on kerneld</A
></H2
><P
>If you have tried everything, and just cannot figure out
      what the kernel is asking kerneld to do, there is a way of
      seeing the requests that kerneld receives, and hence to figure
      out what should go into <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>:
      The <B
CLASS="COMMAND"
>kdstat</B
> utility. </P
><P
>This nifty little program comes with the modules-package,
      but it is not compiled or installed by default. To build it, go
      to the directory where you have the kerneld sources and type
      <B
CLASS="COMMAND"
>make kdstat</B
>.  Then, to make kerneld display
      information about what it is doing, run <B
CLASS="COMMAND"
>kdstat debug
      </B
> and kerneld will start spewing messages on the
      console about what it is doing. If you then try and run the
      command that you want to use, you will see the kerneld requests;
      these can be put into <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> and
      aliased to the module needed to get the job done. </P
><P
>To turn off the debugging, run <B
CLASS="COMMAND"
>/sbin/kdstat
       nodebug</B
>. </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GOODIES"
>7. Special kerneld uses</A
></H2
><P
>I knew you would ask about how to setup the screen-saver
      module!</P
><P
>The <TT
CLASS="FILENAME"
>kerneld/GOODIES</TT
> directory in
      modules package has a couple of kernel patches for screen-saver
      and console-beep support in kerneld; these are not yet part of
      the official kernel, so you will need to install the
      kernel-patches and rebuild the kernel. </P
><P
>To install a patch, you use the patch command: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  cd /usr/src/linux
  patch -s -p1 /usr/src/modules-*/kerneld/GOODIES/blanker_patch</PRE
></FONT
></TD
></TR
></TABLE
><P
>Then rebuild and install the new kernel. </P
><P
>When the screen-saver triggers, kerneld will run the
      command <TT
CLASS="FILENAME"
>/sbin/screenblanker</TT
>; this file may
      be anything you like, for example, a shell script that runs your
      favorite screen-saver. </P
><P
>When the kernel wants to unblank the screen, it sends a
      <SPAN
CLASS="TOKEN"
>SIGQUIT</SPAN
> signal to the process running
      <TT
CLASS="FILENAME"
>/sbin/screenblanker</TT
>. Your shell script or
      screen-saver should trap this, and terminate. Remember to restore
      the screen to the original text mode! </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="COMMONPROBLEMS"
>8. Common problems and things that make you wonder</A
></H2
><DIV
CLASS="QANDASET"
><DL
><DT
>8.1. <A
HREF="#AEN381"
>Why do I get <SPAN
CLASS="ERRORNAME"
>Cannot locate module for
            net-pf-</SPAN
><CODE
CLASS="VARNAME"
>X</CODE
> messages when I
            run <B
CLASS="COMMAND"
>/sbin/ifconfig</B
>?</A
></DT
><DT
>8.2. <A
HREF="#AEN398"
>After starting kerneld, my system slows to a crawl
            when I activate my ppp-connection</A
></DT
><DT
>8.3. <A
HREF="#AEN410"
>kerneld does not load my SCSI driver!</A
></DT
><DT
>8.4. <A
HREF="#AEN418"
>modprobe complains about
             <SPAN
CLASS="ERRORNAME"
>gcc2_compiled</SPAN
> being
             undefined</A
></DT
><DT
>8.5. <A
HREF="#AEN424"
>My sound driver keeps forgetting its settings for
            volume etc</A
></DT
><DT
>8.6. <A
HREF="#AEN432"
>DOSEMU needs some modules; how can I get kerneld to
            load those ?</A
></DT
><DT
>8.7. <A
HREF="#AEN437"
>Why do I get <SPAN
CLASS="ERRORNAME"
>Ouch, kerneld timed out,
            message failed</SPAN
> messages ?</A
></DT
><DT
>8.8. <A
HREF="#AEN449"
>Mount doesn't wait for kerneld to load the
            filesystem module</A
></DT
><DT
>8.9. <A
HREF="#AEN455"
>kerneld fails to load the <TT
CLASS="LITERAL"
>ncpfs</TT
>
            module</A
></DT
><DT
>8.10. <A
HREF="#AEN464"
>kerneld fails to load the <TT
CLASS="FILENAME"
>smbfs</TT
>
            module</A
></DT
><DT
>8.11. <A
HREF="#AEN472"
>I built everything as modules, and now my system
            cannot boot or kerneld fails to load the root filesystem
            module!</A
></DT
><DT
>8.12. <A
HREF="#AEN488"
>kerneld will not load at boot time; it complains
            about libgdbm</A
></DT
><DT
>8.13. <A
HREF="#AEN498"
>I get Cannot load module <CODE
CLASS="VARNAME"
>xxx</CODE
> but
            I just reconfigured my kernel without
            <CODE
CLASS="VARNAME"
>xxx</CODE
> support!</A
></DT
><DT
>8.14. <A
HREF="#AEN507"
>I rebuilt my kernel and modules, and still get
            messages about unresolved symbols when
            booting</A
></DT
><DT
>8.15. <A
HREF="#AEN516"
>I installed Linux 2.1/2.3 and now I cannot
          load <EM
>any</EM
> modules!</A
></DT
><DT
>8.16. <A
HREF="#AEN532"
>What about dial-on-demand networking?</A
></DT
></DL
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN381"
></A
><B
>8.1. </B
>Why do I get <SPAN
CLASS="ERRORNAME"
>Cannot locate module for
            net-pf-</SPAN
><CODE
CLASS="VARNAME"
>X</CODE
> messages when I
            run <B
CLASS="COMMAND"
>/sbin/ifconfig</B
>?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Around kernel version 1.3.80, the networking code
            was changed to allow loading protocol families (e.g. IPX,
            AX.25 and AppleTalk) as modules. This caused the addition
            of a new kerneld request:
            <TT
CLASS="LITERAL"
>net-pf-</TT
><CODE
CLASS="VARNAME"
>X</CODE
>, where
            <CODE
CLASS="VARNAME"
>X</CODE
> is a number identifying the protocol
            (see
            <TT
CLASS="FILENAME"
>/usr/src/linux/include/linux/socket.h</TT
>
            for the meaning of the various numbers).  Unfortunately,
            <B
CLASS="COMMAND"
>ifconfig</B
> accidentally triggers these
            messages, so a lot of people get a couple of messages
            logged when the system boots and it runs
            <B
CLASS="COMMAND"
>ifconfig</B
> to setup the loopback
            device. The messages are harmless, and you can disable
            them by adding the lines</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>        alias net-pf-3 off      # Forget AX.25
        alias net-pf-4 off      # Forget IPX
        alias net-pf-5 off      # Forget AppleTalk</PRE
></FONT
></TD
></TR
></TABLE
><P
>to <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>. Of
            course, if you do use IPX as a module, you should not add
            a line to disable IPX. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN398"
></A
><B
>8.2. </B
>After starting kerneld, my system slows to a crawl
            when I activate my ppp-connection</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>There have been a couple of reports of this. It
            seems to be an unfortunate interaction between kerneld and
            the <SPAN
CLASS="PRODUCTNAME"
>tkPPP</SPAN
> script that is used
            on some systems to setup and monitor the PPP
            connection. The script apparently runs loops while running
            <B
CLASS="COMMAND"
>ifconfig</B
>. This triggers kerneld, to
            look for the
            <TT
CLASS="LITERAL"
>net-pf-</TT
><CODE
CLASS="VARNAME"
>X</CODE
> modules
            (see above), keeping the system load high and possibly
            pouring lots of Cannot locate module for
            <TT
CLASS="LITERAL"
>net-pf-</TT
><CODE
CLASS="VARNAME"
>X</CODE
> messages
            into the system log. There is no known workaround, other
            than not use <SPAN
CLASS="PRODUCTNAME"
>tkPPP</SPAN
>, or change
            it to use some other way of monitoring the
            connection.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN410"
></A
><B
>8.3. </B
>kerneld does not load my SCSI driver!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Add an entry for the SCSI hostadapter to your
            <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>. See the
            description of the <A
HREF="#SCSIDEVS"
><TT
CLASS="LITERAL"
>scsi_hostadapter</TT
></A
>
            entry above.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN418"
></A
><B
>8.4. </B
>modprobe complains about
             <SPAN
CLASS="ERRORNAME"
>gcc2_compiled</SPAN
> being
             undefined</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>This is a bug in the module utilities, that show up
            only with binutils 2.6.0.9 and later, and it is also
            documented in the release note for the binutils. So read
            that, or fetch an upgrade to the module-utilities that fix
            this bug. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN424"
></A
><B
>8.5. </B
>My sound driver keeps forgetting its settings for
            volume etc</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>The settings for a module are stored inside the
            module itself when it is loaded. So when kerneld
            auto-unloads a module, any settings you have made are
            forgotten, and the next time the module loads it reverts
            to the default settings. </P
><P
>You can tell kerneld to configure a module by
            running a program after the module has been
            auto-loaded. See <A
HREF="#PRE-POST"
>Pre/Post Install</A
> on the
            <TT
CLASS="LITERAL"
>post-install</TT
> entry. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN432"
></A
><B
>8.6. </B
>DOSEMU needs some modules; how can I get kerneld to
            load those ?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>You cannot. None of the dosemu versions, official or
            development versions, support loading the dosemu modules
            through kerneld. However, if you are running kernel 2.0.26
            or later, you do not need the special dosemu modules any
            longer; just upgrade dosemu to 0.66.1 or higher.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN437"
></A
><B
>8.7. </B
>Why do I get <SPAN
CLASS="ERRORNAME"
>Ouch, kerneld timed out,
            message failed</SPAN
> messages ?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>When the kernel sends a request off to kerneld,
            it expects to receive an acknowledgment back within one
            second. If kerneld does not send this acknowledgment,
            this message is logged. The request is retransmitted, and
            should get through eventually. </P
><P
>This usually happens on systems with a very high
            load. Since kerneld is a user-mode process, it is
            scheduled just like any other process on the system. At
            times of high load, it may not get to run in time to send
            back the acknowledgment before the kernel times
            out. </P
><P
>If this happens even when the load is light, try
            restarting kerneld.  Kill the kerneld process, and start
            it again with the command <B
CLASS="COMMAND"
>/usr/sbin/kerneld</B
>.  If the problem persists,
            you should mail a bug report to
            <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-kernel@vger.rutgers.edu"
>linux-kernel@vger.rutgers.edu</A
>&#62;</CODE
>, but
            <EM
>please</EM
> make sure that your versions
            of the kernel, kerneld and the module utilities are
            up-to-date before posting about the problem. Check the
            requirements in
            <TT
CLASS="FILENAME"
>linux/Documentation/Changes</TT
></P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN449"
></A
><B
>8.8. </B
>Mount doesn't wait for kerneld to load the
            filesystem module</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>There has been a number of reports that the mount(8)
            command does not wait for kerneld to load the filesystem
            module. <B
CLASS="COMMAND"
>lsmod</B
> does show that kerneld
            loads the module, and if you repeat the mount command
            immediately it will succeed. This appears to be a bug in
            the module-utilities version 1.3.69f that affects some
            Debian users. It can be fixed by getting a later version
            of the module-utilities. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN455"
></A
><B
>8.9. </B
>kerneld fails to load the <TT
CLASS="LITERAL"
>ncpfs</TT
>
            module</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>You need to compile the ncpfs utilities with
            <SPAN
CLASS="TOKEN"
>-DHAVE_KERNELD</SPAN
>. See the
            <SPAN
CLASS="PRODUCTNAME"
>ncpfs</SPAN
>
            <TT
CLASS="FILENAME"
>Makefile</TT
>. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN464"
></A
><B
>8.10. </B
>kerneld fails to load the <TT
CLASS="FILENAME"
>smbfs</TT
>
            module</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>You are using an older version of the
            <SPAN
CLASS="PRODUCTNAME"
>smbmount</SPAN
> utilities. Get the
            latest version (0.10 or later) from <A
HREF="ftp://tsx-11.mit.edu/pub/linux/filesystems/smbfs/"
TARGET="_top"
>the
            SMBFS archive one TSX-11</A
></P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN472"
></A
><B
>8.11. </B
>I built everything as modules, and now my system
            cannot boot or kerneld fails to load the root filesystem
            module!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>You cannot modularize
            <EM
>everything</EM
>: The kernel must have
            enough drivers built in for it to be able to mount your
            root filesystem, and run the necessary programs to start
            kerneld<A
NAME="AEN477"
HREF="#FTN.AEN477"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>. You cannot modularize </P
><P
></P
><UL
><LI
><P
>the driver for the hard disk
            where your root filesystem lives </P
></LI
><LI
><P
>the root filesystem driver itself
              </P
></LI
><LI
><P
>the binary format loader for init,
              kerneld and other programs </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN488"
></A
><B
>8.12. </B
>kerneld will not load at boot time; it complains
            about libgdbm</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Newer versions of kerneld need the GNU dbm library,
            <TT
CLASS="FILENAME"
>libgdbm.so</TT
>, to run. Most
            installations have this file in
            <TT
CLASS="FILENAME"
>/usr/lib</TT
>, but you are probably
            starting kerneld before the <TT
CLASS="FILENAME"
>/usr</TT
>
            filesystem is mounted. One symptom of this is that kerneld
            will not start during boot-up (from your rc-scripts), but
            runs fine if you start it by hand after that system is
            up. The solution is to either move the kerneld startup to
            after your <TT
CLASS="FILENAME"
>/usr</TT
> is mounted, or move
            the gdbm library to your root filesystem, e.g. to
            <TT
CLASS="FILENAME"
>/lib</TT
>.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN498"
></A
><B
>8.13. </B
>I get Cannot load module <CODE
CLASS="VARNAME"
>xxx</CODE
> but
            I just reconfigured my kernel without
            <CODE
CLASS="VARNAME"
>xxx</CODE
> support!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>The Slackware installation (possibly others) builds
            a default <TT
CLASS="FILENAME"
>/etc/rc.d/rc.modules</TT
> which
            does an explicit modprobe on a variety of modules. Exactly
            which modules get modprobed depends on the original
            kernel's configuration. You have probably reconfigured
            your kernel to exclude one or more of the modules that is
            getting modprobed in rc.modules, thus, the error
            message(s). Update your rc.modules by commenting out any
            modules you no longer use, or remove the
            <TT
CLASS="FILENAME"
>rc.modules</TT
> entirely and let kerneld
            load the modules when they are needed.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN507"
></A
><B
>8.14. </B
>I rebuilt my kernel and modules, and still get
            messages about unresolved symbols when
            booting</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>You probably reconfigured/rebuilt your kernel and
            excluded some modules.  You've got some old modules that
            you no longer use hanging around in the
            <TT
CLASS="FILENAME"
>/lib/modules</TT
> directory. The easiest
            fix is to delete your
            <TT
CLASS="FILENAME"
>/lib/modules/</TT
><CODE
CLASS="VARNAME"
>x.y.z</CODE
>
            directory and do a <B
CLASS="COMMAND"
>make modules_install</B
>
            from the kernel source directory again. Note that this
            problem only occurs when reconfiguring your kernel without
            changing versions. If you see this error when moving to a
            newer kernel version you've got some other problem.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN516"
></A
><B
>8.15. </B
>I installed Linux 2.1/2.3 and now I cannot
          load <EM
>any</EM
> modules!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Odd numbered Linux are development kernels. As such,
            it should be expected that things break from time to
            time. One of the things that has changed significantly is
            the way modules are handled, and where the kernel and
            modules are loaded into memory.</P
><P
>In brief, if you want to use modules with a
            development kernel, you must</P
><P
></P
><UL
><LI
><P
>read the
              <TT
CLASS="FILENAME"
>Documentation/Changes</TT
> file and see
              what packages need upgrading on your system</P
></LI
><LI
><P
>use the latest modutils package,
              available from <A
HREF="ftp://ftp.redhat.com/pub/alphabits/"
TARGET="_top"
>AlphaBits on
              Red Hat</A
> or the mirror site at <A
HREF="ftp://tsx-11.mit.edu/pub/linux/packages/alphabits/"
TARGET="_top"
>TSX-11</A
></P
></LI
></UL
><P
>I recommend using at least kernel 2.1.29, if you
            want to use modules with a 2.1 kernel.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN532"
></A
><B
>8.16. </B
>What about dial-on-demand networking?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>kerneld originally had some support for establishing
            dial-up network connections on demand; trying to send
            packets to a network without being connected would cause
            kerneld to run the
            <TT
CLASS="FILENAME"
>/sbin/request_route</TT
> script to setup a
            PPP or SLIP connection.</P
><P
>This turned out to be a bad idea. Alan Cox of Linux
            networking fame wrote on the linux-kernel mailing list</P
><A
NAME="AEN538"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>The request-route stuff is obsolete, broken and
              not required [...]  Its also removed from 2.1.x
              trees.</P
></BLOCKQUOTE
><P
>Instead of using the request-route script and
            kerneld, I highly recommend Eric Schenk's <A
HREF="http://www.dna.lth.se/~erics/diald.html"
TARGET="_top"
>diald
            package</A
> to manage your demand dialing.</P
></DIV
></DIV
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN192"
HREF="#AEN192"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Some
      distributions call this file
      <TT
CLASS="FILENAME"
>modules.conf</TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN477"
HREF="#AEN477"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Actually, this is not true. Late
            1.3.x and all 2.x kernels support the use of an initial
            ram-disk that is loaded by LILO or LOADLIN; it is possible
            to load modules from this disk very early in the boot
            process. How to do it is described in the
            <TT
CLASS="FILENAME"
>linux/Documentation/initrd.txt</TT
> file
            that comes with the kernel source-files. </P
></TD
></TR
></TABLE
></BODY
></HTML
>