<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Network Boot and Exotic Root HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Network Boot and Exotic Root HOWTO</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Brieuc Jeunhomme</A
></H3
><DIV
CLASS="AFFILIATION"
><SPAN
CLASS="ORGNAME"
>frtest<BR></SPAN
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bbp@via.ecp.fr"
>bbp@via.ecp.fr</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="CORPAUTHOR"
>Logilab S.A.</H3
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.3</TD
><TD
ALIGN="LEFT"
>2002-04-28</TD
><TD
ALIGN="LEFT"
>Revised by: bej</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Many feedback inclusions, added links to several projects</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.2.2</TD
><TD
ALIGN="LEFT"
>2001-12-08</TD
><TD
ALIGN="LEFT"
>Revised by: dcm</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Licensed GFDL</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.2.1</TD
><TD
ALIGN="LEFT"
>2001-05-21</TD
><TD
ALIGN="LEFT"
>Revised by: logilab</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Fixed bibliography and artheader</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.2</TD
><TD
ALIGN="LEFT"
>2001-05-19</TD
><TD
ALIGN="LEFT"
>Revised by: bej</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Many improvements and included Ken Yap's feedback.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1.1</TD
><TD
ALIGN="LEFT"
>2001-04-09</TD
><TD
ALIGN="LEFT"
>Revised by: logilab</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>First public draft.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1</TD
><TD
ALIGN="LEFT"
>2000-12-09</TD
><TD
ALIGN="LEFT"
>Revised by: bej</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial draft.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN13"
></A
><P
>This document explains how to quickly setup a linux server to provide what diskless linux clients require to get up and running, using an IP network. It includes data and partly rewritten text from the Diskless-HOWTO, the Diskless-root-NFS-HOWTO, the linux kernel documentation, the etherboot project's documentation, the linux terminal server project's homepage, and the author's personal experience, acquired when working for Logilab. Eventually this document may end up deprecating the Diskless-HOWTO and Diskless-root-NFS-HOWTO. Please note that you'll also find useful information in the From-PowerUp-to-bash-prompt-HOWTO and the Thin-Client-HOWTO, and the Claus-Justus Heine's page about NFS swapping.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN46"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN48"
>What is this all about?</A
></DT
><DT
>1.2. <A
HREF="#AEN51"
>Thanks</A
></DT
><DT
>1.3. <A
HREF="#AEN57"
>Diskless booting advocacy</A
></DT
><DT
>1.4. <A
HREF="#AEN92"
>Requirements</A
></DT
><DT
>1.5. <A
HREF="#AEN104"
>Acknowledgements and related documentation</A
></DT
><DT
>1.6. <A
HREF="#AEN113"
>Feedback</A
></DT
><DT
>1.7. <A
HREF="#COPYRIGHT"
>Copyright Information</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#AEN122"
>Diskless booting operation overview</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN125"
>Obtaining IP parameters</A
></DT
><DT
>2.2. <A
HREF="#AEN136"
>Loading the kernel</A
></DT
><DT
>2.3. <A
HREF="#AEN142"
>Mounting the root filesystem</A
></DT
><DT
>2.4. <A
HREF="#AEN146"
>Terminating the boot process</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN150"
>Building the kernel</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN169"
>When the root filesystem is on a ramdisk</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#AEN219"
>Daemons setup</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN221"
>NFS daemon</A
></DT
><DT
>4.2. <A
HREF="#AEN226"
>BOOTP daemon</A
></DT
><DT
>4.3. <A
HREF="#AEN242"
>TFTP</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#AEN251"
>Clients setup, creation of the root filesystem</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN256"
>Creating the first files and directories</A
></DT
><DT
>5.2. <A
HREF="#AEN301"
>The <TT
CLASS="FILENAME"
>/var</TT
> and <TT
CLASS="FILENAME"
>/etc</TT
> directories</A
></DT
><DT
>5.3. <A
HREF="#AEN326"
>Last details</A
></DT
><DT
>5.4. <A
HREF="#AEN351"
>Trial...</A
></DT
><DT
>5.5. <A
HREF="#AEN355"
>And Error!</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#AEN359"
>Several ways of obtaining the kernel</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN362"
>BOOTP or DHCP capable NICs</A
></DT
><DT
>6.2. <A
HREF="#AEN365"
>Kernel on a local floppy or hard drive</A
></DT
><DT
>6.3. <A
HREF="#AEN376"
>Bootloader without kernel on a local floppy or hard drive</A
></DT
><DT
>6.4. <A
HREF="#AEN386"
>Creating ROMs for the clients</A
></DT
><DT
>6.5. <A
HREF="#AEN411"
>Local CDROM</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#AEN537"
>How to create diskless MS-Windows stations?</A
></DT
><DT
>8. <A
HREF="#AEN542"
>Troubleshooting, tips, tricks, and useful links</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#AEN544"
>Transparently handling workstations'specific files</A
></DT
><DT
>8.2. <A
HREF="#AEN551"
>Reducing diskless workstations'memory usage</A
></DT
><DT
>8.3. <A
HREF="#AEN562"
>Swapping over NFS</A
></DT
><DT
>8.4. <A
HREF="#AEN580"
>Swapping over network block devices</A
></DT
><DT
>8.5. <A
HREF="#AEN597"
>Getting rid of error messages about <TT
CLASS="FILENAME"
>/etc/mtab</TT
> or unmounted directories on shutdown</A
></DT
><DT
>8.6. <A
HREF="#AEN604"
>Installing new packages on workstations</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#AEN610"
>Non-Volatile Memory chips</A
></DT
><DT
>B. <A
HREF="#AEN628"
>Determining the size and speed of EPROMs to plug in a NIC</A
></DT
><DT
>C. <A
HREF="#AEN645"
>Companies selling diskless computers</A
></DT
><DT
><A
HREF="#AEN658"
>References</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN46"
>1. Introduction</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN48"
>1.1. What is this all about?</A
></H3
><P
>Recent linux kernels offer the possibility to boot a linux box entirely from network, by loading its kernel and root filesystem from a server. In that case, the client may use several ways to get the first instructions it has to execute when booting: home made eproms, special network cards implementing the RARP, BOOTP or DHCP protocols, cdroms, or bootloaders loaded from a boot floppy or a local hard drive.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN51"
>1.2. Thanks</A
></H3
><P
>Logilab sponsored this HOWTO. Check their <A
HREF="http://www.logilab.org"
TARGET="_top"
>website</A
> for new versions of this document.  I also thank the etherboot, netboot, plume and linux terminal server project developers and webmasters, who made it really possible to boot a Linux worstation over a network.</P
><P
>Very special thanks go to Ken Yap, member of the etherboot project, whose comments greatly helped to improve the quality of this document.</P
><P
>I also thank Jerome Warnier, main developer of the plume project, Pierre Mondié, Kyle Bateman, Peter T. Breuer, Charles Howes, and Thomas Marteau for their comments and contributions.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN57"
>1.3. Diskless booting advocacy</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN59"
>1.3.1. Buying is cheaper than building</A
></H4
><P
>Sometimes, buying a diskless linux computer will be cheaper than building! Checkout the list of commercial sites given in appendix, which are selling diskless linux network cards and diskless computers. These companies do mass production of linux diskless computers selling millions of units and thereby reducing the cost per unit.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN62"
>1.3.2. Advantages of diskless computers</A
></H4
><P
>Diskless computers will become more and more popular in the next years. They will be very successful because of the availability of very high-speed network cards at very low prices. Today 100 Megabit per second (12.5 MB per sec transfer rate) network cards are common and in about 1 to 2 years 1000 MBit (125 MB per sec transfer rate) network cards will become very cheap and will be the standard.</P
><P
>In near future, monitor manufacturers will place the CPU, NIC, RAM right inside the monitor to form a diskless computer. This eliminates the diskless computer box and saves space. The monitor will have outlet for mouse, keyboard, network RJ45 and power supply.</P
><P
>The following are benefits of using diskless computers:</P
><P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Total cost of ownership is very low in case of diskless computers. Total cost of ownership is cost of initial purchasing + cost of maintenance. The cost of maintenance is usually 3 to 5 times the cost of initial computer purchase and this cost is recurring year after year. In case of diskless computers, the cost of maintenance is completely eliminated.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>All the backups are centralized at one single main server.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>No need of UPS battery, air-conditioning, dust proof environment for diskless clients, only server needs UPS battery, A/C and dust proof environment.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>A better protection from virus attack - Some computer virus cannot attack diskless computers as they do not have any hard disk. This kind of virus cannot do any damage to diskless computers. Only one single server box needs to be protected against virus attack. This saves millions of dollars for the company by avoiding installation of vaccines and cleaning the hard disks.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Servers can have large powerful/high performance hard disks, can optimize the usage of disk space via sharing by many diskless computer users. Fault tolerance of hard disk failure is possible by using RAID on main server.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>On some installations: sharing of central server RAM memory by many diskless computer users. For example, if many users are running a web browser remotely on a server, then there will be only one copy of this web browser in its RAM.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Very few system administrators required to maintain central server.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Zero administration at diskless client side. Diskless computers are absolutely maintenance free and troublefree.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Long life of diskless clients.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Eliminates install/upgrade of hardware, software on diskless client side.
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Eliminates cost of cdrom, floppy, tape drive, modem, UPS battery, printer parallel ports, serial ports etc...
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Can operate in places like factory floor where a hard disk might be too fragile.
            </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN92"
>1.4. Requirements</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN94"
>1.4.1. Hardware requirements</A
></H4
><P
>The most important thing in order to boot from network is to have an equipment which enables the stations to execute a bootloader, which will get the kernel on the server and launch it. Another solution is to use a device which will load a local kernel, which will mount the root filesystem on the server. There are several solutions: home made eproms containing the first instructions to execute when booting the station, boot with BOOTP/DHCP capable network adapters, or a local floppy, a tiny hard drive, or a cdrom to load the kernel. Note that some vendors also sell network booting capable stations: for instance, some Sun stations implement the BOOTP protocol.</P
><P
>Other hardware requirements depend on the configuration you plan to use: on some sites, every application run by the stations is executed remotely on the server, this implies that a very high-performance server is required, but only light stations are required: depending on what they will have to do, 80486 CPUs with 16 MB of RAM may be enough. On the other side, if application programs are really executed locally on the stations, the requirements for the stations depend completely on these applications. In that case, only a small server is required. A 80486 CPU with 32 MB of RAM will be sufficient for a small number of stations, but more memory will be necessary in very large installations with hundreds or thousands of machines. Note the server's CPU does not really matter for such an installation.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN98"
>1.4.2. Software requirements</A
></H4
><P
>Linux kernel version 2.0 or above sources are required. All tools required to build a linux kernel are also necessary (see the linux kernel documentation for more information on this).</P
><P
>A BOOTP daemon (a DHCP daemon may also do fine, but I won't explain how to configure this), a NFS daemon (if you want to mount the root filesystem on a remote server), are also required. We will also need a TFTP daemon if you plan to load the kernel remotely. At last, the mknbi utility provided with the <A
HREF="http://etherboot.sourceforge.net"
TARGET="_top"
>etherboot distribution</A
>, and, if you use LanWorks EPROMs, like those included in the 3c905 3com ethernet adapter, you will also need the imggen utility, available at <A
HREF="http://www.ltsp.org/contrib/"
TARGET="_top"
>http://www.ltsp.org/contrib/</A
>.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN104"
>1.5. Acknowledgements and related documentation</A
></H3
><P
>This documentation has been written for experimented system administrators, who are already aware of linux fundamentals, like the use of grep, sed, and awk, basic shell programming, the init process and the boot scripts, kernel compilation, and NFS server configuration. Experience of kernel arguments passing should also help. Information on these subjects can be found respectively in the grep, sed, awk, and bash man/info pages, in the Bootdisk-HOWTO, the From-PowerUp-To-Bash-Prompt-HOWTO, the Kernel-HOWTO, the BootPrompt-HOWTO, the bootparam man page, the rdev man page, the NFS-HOWTO, and the exports manual page.</P
><P
>There are many sources of information on network booting, but, and this is why I wrote this HOWTO, none describes all the existing ways of booting over a network, and much of them are specific to a way of operating. The most useful to me has been the documentation provided by the <A
HREF="http://www.ltsp.org"
TARGET="_top"
>linux terminal server project</A
>, although I did not use the packages they recommend, and I have chosen to describe here how to proceed without these packages, because they configure things so that every application program is executed remotely on a server. Useful information can also be found on the <A
HREF="http://etherboot.sourceforge.net"
TARGET="_top"
>etherboot project's homepage</A
>.</P
><P
>At last, you can also find useful but succinct information in the kernel's source tree, in <TT
CLASS="FILENAME"
>/usr/src/linux/Documentation</TT
>, assuming your kernel source tree resides in <TT
CLASS="FILENAME"
>/usr/src/linux</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN113"
>1.6. Feedback</A
></H3
><P
>I will highly appreciate any feedback about this document. Please feel free to mail me at <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bbp@via.ecp.fr"
>bbp@via.ecp.fr</A
>&#62;</CODE
> if you have any comment, correction, or suggestion. You may also use <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:contact@logilab.fr"
>contact@logilab.fr</A
>&#62;</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="COPYRIGHT"
>1.7. Copyright Information</A
></H3
><P
>    This document is copyrighted (c) 2001 and 
    is distributed under the terms of the GNU Free Documentation License.
    You should have received a copy along with it. If not, it is available from
    <A
HREF="http://www.fsf.org/licenses/fdl.html"
TARGET="_top"
>http://www.fsf.org/licenses/fdl.html</A
>.
   </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN122"
>2. Diskless booting operation overview</A
></H2
><P
>Hey, you think it's time to start with the real stuff, right? Here we go.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN125"
>2.1. Obtaining IP parameters</A
></H3
><P
>One could wonder how a station may boot over an IP network if it doesn't even know its own IP address. In fact, three protocols enable the client to obtain this information and some additional configuration parameters:

      <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>RARP: this is the simplest of these protocols. However I guess it does not enable the server to specify how the client should download the kernel, so we won't use it (In fact, there is a convention that uses the IP address of the workstation as filename, e.g. a client getting the address 192.168.42.12 by RARP might ask for <TT
CLASS="FILENAME"
>/tftpboot/192.168.42.12</TT
> by TFTP, as the linux kernel does. The filename might also be the hex form of the IP address, this is implementation dependant, and is not mandatory.).</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>BOOTP: this protocol allows a server to provide the client (identified by its hardware MAC address) with much information, in particular its IP address, subnet mask, broadcast address, network address, gateway address, host name, and kernel loading path. This is the one we will use.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>DHCP: this is an extension of BOOTP.</P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN136"
>2.2. Loading the kernel</A
></H3
><P
>When the client has got its IP parameters, if the kernel is not on a local support (like a floppy, a cdrom, or a hard drive), the client will start to download it via TFTP. Its location is given by the BOOTP/DHCP server. A server (not necessarily the BOOTP/DHCP server) will also have to run a TFTP daemon for non local kernels. The kernel one obtains after compilation can not be used "as is" for BOOTP/DHCP operation, its binary image has to be modified with the <B
CLASS="COMMAND"
>mknbi</B
> utility (and then modified again with the <B
CLASS="COMMAND"
>imggen</B
> utility if you use LanWorks EPROMs). The <B
CLASS="COMMAND"
>mknbi</B
> utility should also be used to modify kernels that will be written in a ROM.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN142"
>2.3. Mounting the root filesystem</A
></H3
><P
>After the kernel has started, it will try to mount its root filesystem. The location of this filesystem is also obtained through BOOTP/DHCP, and it is mounted via NFS. It means a client may use BOOTP twice for booting: the first time to get its kernel, and the second time to learn the location of the root filesystem (which may be on a third server).</P
><P
>Another solution is to use a ramdisk as root filesystem. In this case, the ramdisk image is obtained with the kernel via TFTP.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN146"
>2.4. Terminating the boot process</A
></H3
><P
>When the root filesystem is mounted, you can start breathing: you can at least use your swiss army knife with its sh, sed, and awk blades. In fact, you will have to customize the initialization scripts of the client's filesystem: for instance, you will have to remove all hard drive, floppy or cdrom related stuff from <TT
CLASS="FILENAME"
>/etc/fstab</TT
> (when your stations are not equipped with these devices), you may also have to inhibit swap partitions activation (note there is a way to swap over NFS or network block devices). You also will have to automagically generate all network configuration files at boot time if several clients use the same remote root filesystem.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN150"
>3. Building the kernel</A
></H2
><P
>First of all, build a kernel for the clients. I suggest you build it on the server, this will be useful later for modules installation. Use a zImage to reduce its size. Include everything you need, but try to use as many modules as possible, because many BOOTP client implementations are unable to load very large kernels (at least on intel x86 architectures). Also include iramdisk support, NFS protocol support, root filesystem on NFS support, support for your NIC, kernel level IP autoconfiguration via BOOTP; <EM
>do not use modules for these!</EM
> Then, if you plan to use the same remote root filesystem for several clients, add support for ext2fs or some other filesystem and ramdisks (16 Megabytes ramdisks will do fine on most systems). You can then modify the kernel arguments as usual (see the BootPrompt-HOWTO for information on this topic), but you will have another opportunity to modify kernel arguments later.</P
><P
>Then, if you plan to use BOOTP, copy the kernel zImage on the server. We will assume it resides in <TT
CLASS="FILENAME"
>/tftpboot</TT
>, its name is zImage, the name of the image you want to create from this zImage for BOOTP operation is kernel, and the nfs root filesystem will reside in <TT
CLASS="FILENAME"
>/nfsroot</TT
>.</P
><P
>Issue the following commands on the server (the mknbi package should be installed):

    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>cd /tftpboot
      <SAMP
CLASS="PROMPT"
># </SAMP
>chmod 0555 zImage
      <SAMP
CLASS="PROMPT"
># </SAMP
>chown root:root zImage
      <SAMP
CLASS="PROMPT"
># </SAMP
>mknbi-linux zImage --output=kernel --rootdir=/nfsroot
    </PRE
></FONT
></TD
></TR
></TABLE
>

  </P
><P
>If you are using LanWorks EPROMs, also issue the following commands (you need the imggen utility):

    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>mv -f kernel tmpkernel
      <SAMP
CLASS="PROMPT"
># </SAMP
>imggen -a tmpkernel kernel
      <SAMP
CLASS="PROMPT"
># </SAMP
>rm -f tmpkernel
    </PRE
></FONT
></TD
></TR
></TABLE
>

  </P
><P
>Your kernel is ready for BOOTP/DHCP/ROM operation. You of course don't need to do this if you plan to use a local drive.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN169"
>3.1. When the root filesystem is on a ramdisk</A
></H3
><P
>It is possible to use a ramdisk for the root filesystem. In this case, the command used to modify the kernel's binary image is slightly different. If you choose to do so, you have to enable support for initial ramdisk (initrd), and you probably don't need NFS support, or you probably can compile it as a module.</P
><P
>Its time to give an overview of what happens when you use initrd. The full documentation for this is in your kernel source tree, in the <TT
CLASS="FILENAME"
>Documentation/initrd.txt</TT
> file. I have to warn you I did never try this :).</P
><P
>When initrd is enabled, the boot loader first loads the kernel and the inital ramdisk into memory. Then, the ramdisk is mounted read-write as root filesystem. The kernel looks for a <TT
CLASS="FILENAME"
>/linuxrc</TT
> file (a binary executable or a script beginning with #!). When <TT
CLASS="FILENAME"
>/linuxrc</TT
> terminates, the traditionnal root filesystem is mounted as <TT
CLASS="FILENAME"
>/</TT
>, and the usual boot sequence is performed. So, if you want to run your box entirely from ramdisk, you just have to create a link from <TT
CLASS="FILENAME"
>/linuxrc</TT
> to <TT
CLASS="FILENAME"
>/sbin/init</TT
>, or to write there a shell script to perform any action you like, and then shutdown the computer.</P
><P
>After the kernel has been compiled, you have to build a root filesystem for your installation. This is explained in the "Clients setup, creation of the root filesystem" section. I will assume here that this is already done and that the root filesystem for your clients temporarily resides in <TT
CLASS="FILENAME"
>/tmp/rootfs</TT
>. You now have to create a ramdisk image. A simple way to do so is the following:

      <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Make sure the computer you are working on has support for ramdisks and has such a device (<TT
CLASS="FILENAME"
>/dev/ram0</TT
>).</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Create an empty filesystem with the appropriate size on this ramdisk:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>	      <SAMP
CLASS="PROMPT"
># </SAMP
>mke2fs -m0 /dev/ram0 300
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Mount it somewhere:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>	      <SAMP
CLASS="PROMPT"
># </SAMP
>mount -t ext2 /dev/ram0 /mnt
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Copy what you need for your new root filesystem, and create your future <TT
CLASS="FILENAME"
>/linuxrc</TT
> if you did not create it in <TT
CLASS="FILENAME"
>/tmp/rootfs/linuxrc</TT
>:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>	      <SAMP
CLASS="PROMPT"
># </SAMP
>cp -a /tmp/rootfs/* /mnt
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Unmount the ramdisk:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>	      <SAMP
CLASS="PROMPT"
># </SAMP
>umount /mnt
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Save the ramdisk image to some file and free it:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>	      <SAMP
CLASS="PROMPT"
># </SAMP
>dd if=/dev/ram0 of=initrd bs=1024 count=300
	      <SAMP
CLASS="PROMPT"
># </SAMP
>freeramdisk /dev/ram0
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	  </P
></LI
></UL
>

      What was toled above about LanWorks PROMs is also true if you use initrd.

    </P
><P
>Then, you have to modify the kernel image, as was told above, with the <B
CLASS="COMMAND"
>mknbi-linux</B
> utility. Its invocation will slightly differ from the above, though (I will assume your just compiled zImage resides in <TT
CLASS="FILENAME"
>/tftpboot/zImage</TT
> and your initial ramdisk image resides in <TT
CLASS="FILENAME"
>/tmp/initrd</TT
>):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>cd /tftpboot
        <SAMP
CLASS="PROMPT"
># </SAMP
>chmod 0555 zImage
        <SAMP
CLASS="PROMPT"
># </SAMP
>chown root:root zImage
	<SAMP
CLASS="PROMPT"
># </SAMP
>rdev zImage /dev/ram0
        <SAMP
CLASS="PROMPT"
># </SAMP
>mknbi-linux zImage --output=kernel --rootdir=/dev/ram0 /tmp/initrd
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN219"
>4. Daemons setup</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN221"
>4.1. NFS daemon</A
></H3
><P
>Just export the directory in which the client's root filesystem will reside (see the exports manpage for more information about this topic). The simplest is to export it no_root_squash and rw, but a perfect setup would export most of the root filesystem root_squash and ro, and have separate lines in the <TT
CLASS="FILENAME"
>/etc/exports</TT
> for directories which really require no_root_squash and/or rw. Just start with everything rw and no_root_squash, the fine tuning will be done later.</P
><P
>Of course, you don't need any NFS server at all if you plan to run your clients entirely from ramdisk.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN226"
>4.2. BOOTP daemon</A
></H3
><P
>I assume you have installed the bootpd package. The default configuration file is <TT
CLASS="FILENAME"
>/etc/bootptab</TT
>, and its syntax is detailed in the bootptab manpage. Let's create it.</P
><P
>First, open as root your favourite text editor. It is vim. Yes, it is. If it is not, it has to become. Now, enter the following lines (they are the default attributes). All the attributes you give here and do not override in a machine's specific attributes list will be given to clients):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        .default\
                :sm=your subnet mask\
                :ds=the IP address of your DNS server\
                :ht=ethernet\
                :dn=your domain name\
                :gw=the IP address of your gateway\
                :sa=the IP address of the TFTP server\
                :bf=path to find the kernel image\
                :rp=path of the root filesystem\
                :hn
      </PRE
></FONT
></TD
></TR
></TABLE
>

    Of course, not all these parameters are required, this depends on your network configuration and BOOTP implementations, but these will work in most cases.</P
><P
>Then, add an entry per client in your network. An entry should look like this:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        dns of the client\
                :ha=MAC address of the client\
                :ip=IP address of the client
      </PRE
></FONT
></TD
></TR
></TABLE
>

    The MAC address above is the hexadecimal hardware address of the client without the ':' characters.</P
><P
>Here is a sample <TT
CLASS="FILENAME"
>/etc/bootptab</TT
> file:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>              .default\
                      :sm=255.255.0.0\
                      :ds=192.168.0.2\
                      :ht=ethernet\
                      :dn=frtest.org\
                      :gw=192.168.0.1\
                      :sa=192.168.0.2\
                      :bf=/tftpboot/kernel\
                      :rp=/nfsroot\
                      :hn

              foo\
                      :ha=001122334455\
                      :ip=192.168.2.12

              bar\
                      :ha=00FFEEDDCCBB\
                      :ip=192.168.12.42\
                      :ds=192.168.2.42
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>Then, run the bootpd daemon with the bootpd -s command (it is also a good idea to add it to your startup scripts), or add the following line to your <TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
>:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        bootps dgram udp wait root /usr/sbin/tcpd bootpd -i -t 120
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>If you want to test the BOOTP server, add an entry to your <TT
CLASS="FILENAME"
>/etc/bootptab</TT
> and use the bootptest program.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN242"
>4.3. TFTP</A
></H3
><P
>Setting up the TFTP daemon is not the hard part: just install the tftpd package if you have one, and add the following line to your <TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
> (again, I assume <TT
CLASS="FILENAME"
>/tftpboot</TT
> is the directory where the kernel image resides):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        tftp dgram udp wait root /usr/sbin/tcpd in.tftpd /tftpboot
      </PRE
></FONT
></TD
></TR
></TABLE
>

    Don't forget to chmod 555 the <TT
CLASS="FILENAME"
>/tftpboot</TT
> directory, as most TFTP servers won't send the files if they are not world readable.</P
><P
>You should be aware of the limitations implied by running the TFTP daemon from the inetd. Most inetd's will shutdown a service if it is spawned to frequently. So if you have many clients, you should look for another inetd like xinetd, or run a standalone TFTP daemon.</P
><P
>Now you have properly setup all daemons, you can restart the inetd and take a coffee. Don't forget to tell everyone the server setup is over, so you think you're a hero before you start building the root filesystem for the clients.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN251"
>5. Clients setup, creation of the root filesystem</A
></H2
><P
>Tired? No you're not. Remember you're a hero. Here comes the tricky part. We will (err... <EM
>you</EM
> will) build the client's root filesystem. This shouldn't be very hard, but you probably will have to use trial and error.</P
><P
>The simplest way to create a root filesystem is to use an already working filesystem and customize it for the needs of diskless operation. Of course, you can also build one by hand (like in the good old times) if you like:=), but I won't explain this here.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN256"
>5.1. Creating the first files and directories</A
></H3
><P
>First, <B
CLASS="COMMAND"
>cd</B
> to your future station's root directory. You can safely create the future <TT
CLASS="FILENAME"
>/home</TT
> directory with the <B
CLASS="COMMAND"
>mkdir</B
> command, or by copying it from anywhere you want (you can use <B
CLASS="COMMAND"
>cp -a</B
> to do a recursive copy preserving owners, groups, symlinks, and permissions). Same thing for the future <TT
CLASS="FILENAME"
>/mnt</TT
>, <TT
CLASS="FILENAME"
>/root</TT
>, <TT
CLASS="FILENAME"
>/tmp</TT
> (don't forget to <B
CLASS="COMMAND"
>chmod 0</B
> it, this is only a mount point for the actual <TT
CLASS="FILENAME"
>/tmp</TT
> we will use, because each workstation needs to have its own <TT
CLASS="FILENAME"
>/tmp</TT
>). Then, copy some existing <TT
CLASS="FILENAME"
>/bin</TT
>, <TT
CLASS="FILENAME"
>/sbin</TT
>, <TT
CLASS="FILENAME"
>/boot</TT
>, and <TT
CLASS="FILENAME"
>/usr</TT
> into this future root directory (use <B
CLASS="COMMAND"
>cp -a</B
>). You can create the <TT
CLASS="FILENAME"
>/proc</TT
> directory with mkdir, and <B
CLASS="COMMAND"
>chmod 0</B
> it. Note some applications need write access to their user's home directory.</P
><P
>The <TT
CLASS="FILENAME"
>/lib</TT
> directory can be safely copied from somewhere else, but you will have to put the proper modules in it. To do so, use the following commands (assuming you have compiled the kernel for your clients on the server in <TT
CLASS="FILENAME"
>/usr/src/linux</TT
>, and the root filesystem will reside in <TT
CLASS="FILENAME"
>/nfsroot</TT
>):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>cd /usr/src/linux
        <SAMP
CLASS="PROMPT"
># </SAMP
>make modules_install INSTALL_MOD_PATH=/nfsroot
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>Don't forget to put the <TT
CLASS="FILENAME"
>System.map</TT
> file in <TT
CLASS="FILENAME"
>/nfsroot/boot</TT
>. A first problem we will have to fix is that, depending on your configuration, your system may try to run fsck on the root filesystem at boot time. It shouldn't if there is no hard drive in the box. Most distributions will also skip this fsck if they find a <TT
CLASS="FILENAME"
>fastboot</TT
> file in the root directory. So, issue the following commands if you do not plan to mount any hard drive:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>cd /nfsroot
        <SAMP
CLASS="PROMPT"
># </SAMP
>touch fastboot
        <SAMP
CLASS="PROMPT"
># </SAMP
>chmod 0 fastboot
      </PRE
></FONT
></TD
></TR
></TABLE
>

    Another method is tell <B
CLASS="COMMAND"
>fsck</B
> that checking a NFS filesystem always succeeds:

    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>cd /nfsroot/sbin
      <SAMP
CLASS="PROMPT"
># </SAMP
>ln -s ../bin/true fsck.nfs
    </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>The <TT
CLASS="FILENAME"
>/dev</TT
> directory can also be safely copied from another place into <TT
CLASS="FILENAME"
>/nfsroot</TT
>. But permissions and symlinks have to be preserved, so use <B
CLASS="COMMAND"
>cp -a</B
>. Another solution is to use kernel 2.2.x devfs feature, which will reduce memory consumption and improve performance, but the drawback of this method is that all symlinks created in <TT
CLASS="FILENAME"
>/dev</TT
> will be lost. The point to remember is that each workstation needs to have its own <TT
CLASS="FILENAME"
>/dev</TT
>, so you will have to copy it on a ramdisk if you plan to use several clients and not to use devfs.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN301"
>5.2. The <TT
CLASS="FILENAME"
>/var</TT
> and <TT
CLASS="FILENAME"
>/etc</TT
> directories</A
></H3
><P
>We will use ramdisks for these directories, because each client needs to have its own one. But we still need them at the beginning to create their standard structure. Note you are not required to do so if you use a single client. So copy these directories (<B
CLASS="COMMAND"
>cp -a</B
>) from another place into <TT
CLASS="FILENAME"
>/nfsroot</TT
>. Then you can make some cleanup in <TT
CLASS="FILENAME"
>/var</TT
>: you can remove everything in <TT
CLASS="FILENAME"
>/nfsroot/var/log</TT
> and <TT
CLASS="FILENAME"
>/nfsroot/var/run</TT
>. You also probably can remove everything in <TT
CLASS="FILENAME"
>/nfsroot/var/spool/mail</TT
>, if you plan to export it via NFS. You also will have to remove the files containing host specific information in /nfsroot/etc to build them on the fly during the boot process.</P
><P
>The startup scripts will have to be customized in order to mount some
    parts of the filesystem: the <TT
CLASS="FILENAME"
>/dev</TT
> directory, if you don't use devfs, the <TT
CLASS="FILENAME"
>/tmp</TT
>, the <TT
CLASS="FILENAME"
>/var</TT
>, and the <TT
CLASS="FILENAME"
>/etc</TT
> directories. Here is some code which will achieve this:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        # this part only if you don't use devfs
        mke2fs -q -i 1024 /dev/ram0 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram0 /dev
        # this part for everyone
        mke2fs -q -i 1024 /dev/ram1 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram1 /tmp
        chmod 1777 /tmp
        cp -a /etc /tmp
        mke2fs -q -i 1024 /dev/ram2 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram2 /etc
        find /tmp/etc -maxdepth 1 -exec cp -a '{}' /etc ';'
        mount -f -t ext2 -o rw,suid,dev,exec, \
            async,nocheck,remount /dev/ram2 /etc
        mount -f -o remount /
        cp -a /var /tmp
        mke2fs -q -i 1024 /dev/ram3 16384
        mount -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram3 /var
        find /tmp/var -maxdepth 1 -exec cp -a '{}' /var ';'
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>If you plan to use more than a single client, you will also have to change files dynamically at boot time in <TT
CLASS="FILENAME"
>/etc</TT
>: the files which contain the IP and hostname of the client. These files depend on your distribution, but you will easily find them with a few greps. Just remove client-specific information from them, and add code into your startup files to generate this information again at boot time <EM
>but only once the new <TT
CLASS="FILENAME"
>/etc</TT
> has been mounted on the ramdisk!</EM
> A way to obtain your IP address and hostname at bootup is the following (if you have the bootpc package installed on the workstations'filesystem):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        IPADDR="$(bootpc | awk '/IPADDR/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[0-9.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }
                               ')"

        HOST="$(bootpc | awk '/HOSTNAME/ \
                              {
                                match($0,"[A-Za-z]+")
                                s=substr($0,RSTART+RLENGTH)
                                match(s,"[A-Za-z0-9-]+")
                                print substr(s,RSTART,RLENGTH)
                              }')"

        DOMAIN="$(bootpc | awk '/DOMAIN/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[A-Za-z0-9-.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }')"
      </PRE
></FONT
></TD
></TR
></TABLE
>

    This is a complicated solution, but I guess it should work on most sites. The IP address can alternatively be obtained with the output of <B
CLASS="COMMAND"
>ifconfig</B
> and the hostname can be obtained from the output of the host command, but this is not portable, because these outputs differ from system to system depending on the distribution you are using, and the locales settings.</P
><P
>Then, the hostname should be set with the <B
CLASS="COMMAND"
>hostname $HOSTNAME</B
> command. When this is done, it is time to generate on the fly the configuration files which contain the IP address or the hostname of the client.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN326"
>5.3. Last details</A
></H3
><P
>Now, it's time to do the fine tuning of the client. As <TT
CLASS="FILENAME"
>/var</TT
> will be mounted on a ramdisk (unless you have a single client), you will have to send the logs to a logs server if you want to keep them. One way to do that is to delete the <TT
CLASS="FILENAME"
>/nfsroot/etc/syslog.conf</TT
> file and replacing it by the following file (see man syslog.conf for details):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        *.*     /dev/tty12
        *.*     @dns or IP of the logs server
      </PRE
></FONT
></TD
></TR
></TABLE
>

    If you do so, the logs server will have to run <B
CLASS="COMMAND"
>syslogd</B
> with the -r option (see the syslogd manual page).</P
><P
>If you use <B
CLASS="COMMAND"
>logrotate</B
> and you have done the preceding operation, you should replace the <B
CLASS="COMMAND"
>logrotate</B
> configuration file (<TT
CLASS="FILENAME"
>/etc/logrotate.conf</TT
> on most boxes) by an empty file:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>rm -f /etc/logrotate.conf
        <SAMP
CLASS="PROMPT"
># </SAMP
>touch /etc/logrotate.conf
      </PRE
></FONT
></TD
></TR
></TABLE
>

    If you don't use it, just remove the logs rotation scripts from the crontab, and as you no longer have log files in <TT
CLASS="FILENAME"
>/var/log</TT
>, put an <B
CLASS="COMMAND"
>exit 0</B
> at the beginning of your logs rotation scripts.</P
><P
>In the <TT
CLASS="FILENAME"
>/nfsroot/etc/fstab</TT
> file, remove anything related to the hard drive, floppy disk reader, or cdrom if you don't have such devices on your workstations. Add an entry for the <TT
CLASS="FILENAME"
>/var/spool/mail</TT
> directory, which should be exported by the server through NFS or any other network filesystem. You probably also want to put an entry for the <TT
CLASS="FILENAME"
>/home</TT
> directory in this file.</P
><P
>You can also comment the lines running newaliases, activating swap, and running depmod -a and remove the <TT
CLASS="FILENAME"
>/nfsroot/etc/mtab</TT
> file. Comment out the line(s) removing <TT
CLASS="FILENAME"
>/fastboot</TT
>, <TT
CLASS="FILENAME"
>/fsckoptions</TT
>, and <TT
CLASS="FILENAME"
>/forcefsck</TT
> in your startup scripts. Also remove or comment any line in the startup scripts that would try to write on the root filesystem except for really necessary writes, which should all be redirected to some ramdisk location if you use several clients.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN351"
>5.4. Trial...</A
></H3
><P
>Time has come for a small trial. MAKE A BACKUP OF YOUR NEWLY CREATED
    <TT
CLASS="FILENAME"
>/nfsroot</TT
>. tar -cvvIf should do
    fine. Take a minute to verify we didn't forget anything. Try to boot a
    client.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN355"
>5.5. And Error!</A
></H3
><P
>Look carefully at the client's screen during the boot process. Oh, I didn't tell you to connect a screen... Run, forest! Run an get one. You will probably see some error messages. Fix the problems, and make frequent backups of your <TT
CLASS="FILENAME"
>/nfsroot</TT
>. One day, the client will boot properly. This day, you will have to fix errors occurring during shutdown;=P.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN359"
>6. Several ways of obtaining the kernel</A
></H2
><P
>We have spoken so far about the client and server's configuration for operation after the BOOTP request has been issued by the client, but the first problem is that most computers are not able to behave as BOOTP clients by default. We will see in this section how to fix this.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN362"
>6.1. BOOTP or DHCP capable NICs</A
></H3
><P
>This is the most simple case: some network cards provide a supplement to the BIOS, containing a BOOTP or DHCP client, so just setup them for BOOTP or DHCP operation in the BIOS, and you're done.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN365"
>6.2. Kernel on a local floppy or hard drive</A
></H3
><P
>These cases are also quite simple: the kernel is loaded from a local drive, and all the kernel has to do is to obtain its network parameters from BOOTP, and mount its root filesystem over NFS; this should not cause any problem. By the way, a local hard drive is a good place to leave a <TT
CLASS="FILENAME"
>/var</TT
>, <TT
CLASS="FILENAME"
>/tmp</TT
>, and a <TT
CLASS="FILENAME"
>/dev</TT
>...</P
><P
>If you have a local hard drive, all you have to do is to use lilo or your favourite boot loader as usual. If you use a floppy, you can use a bootloader or simply write the kernel on the floppy: a kernel is directly bootable.This enables you to use a command like the following:
    
    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>dd if=zImage of=/dev/fd0 bs=8192
    </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>However, Alan Cox told in a linux-kernel thread that this feature of the linux kernel will be removed sooner or later, you thus will have to use a bootloader even on floppies some day. I know this still works with 2.4.11 kernels, but support seems to have been removed in the 2.4.13 version. See the sixth chapter of the <A
HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html"
TARGET="_top"
>boot-disk-HOWTO</A
> for this topic.

    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN376"
>6.3. Bootloader without kernel on a local floppy or hard drive</A
></H3
><P
>Certain bootloaders are network aware, you may thus use them to download the kernel image from the network. Some of them are listed below:</P
><P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
><A
HREF="http://netboot.sourceforge.net"
TARGET="_top"
>netboot</A
>, a bootloader dedicated to network boot.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
><A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>GRUB</A
>, the GNU project's GRand Unified Bootloader, which is a very general purpose bootloader.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN386"
>6.4. Creating ROMs for the clients</A
></H3
><P
>Many network cards include a slot in which one can insert an EPROM with additional BIOS code. This enables one to add, for instance, BOOTP capabilities to the BI0S. To do so, you will first have to find how to enable the EPROM socket. You may need a jumper or a special software to do so. Some cards like the 3Com 905B have slots for EEPROMs which enable one to change the software in the EEPROM in place. In appendix, you'll find the information about EPROM and various types of memory chips.</P
><P
>For a list of EPROM burner manufacturers visit the Yahoo site and go to <A
HREF="http://dir.yahoo.com/Business_and_Economy/Companies/Computers/Hardware/Peripherals/Device_Programmers/"
TARGET="_top"
>economy-&#62;company-&#62;Hardware-&#62;Peripherals-&#62;Device programmers</A
> or check out the old Diskless-HOWTO <EM
>List of EPROM burner manufacturers</EM
> section.</P
><P
>If you choose to create your own ROMS, you will have to load a BOOTP or DHCP capable software in the ROM, and then, you will be in the case of BOOTP or DHCP capable NICs described above.</P
><P
>You will also need to find the proper EPROM size and speed for your NIC. Some methods to do so are provided in appendix, because the NICs manufacturers often do not provide this information.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN394"
>6.4.1. LanWorks BootWare PROMs</A
></H4
><P
>This information may save you time. In order to make LanWorks BootWare(tm) PROMs to correctly start up a linux kernel image, the "bootsector" part of the image must be modified so as to enable the boot prom to jump right into the image start address. The net-bootable image format created by netboot/etherboot's `mknbi-linux' tool differs and will not run if used with BootWare PROMs.</P
><P
>A modified bootsector together with a Makefile to create a BootWare-bootable image after kernel compilation can be found at:

        <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Bwimage package: <A
HREF="ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz"
TARGET="_top"
>ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz</A
></P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>See also <A
HREF="http://www.patoche.org/LTT/net/00000096.html"
TARGET="_top"
>http://www.patoche.org/LTT/net/00000096.html</A
></P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>LanWorks BootWare Boot ROMs: <A
HREF="http://www.3com.com/lanworks"
TARGET="_top"
>http://www.3com.com/lanworks</A
></P
></LI
></UL
>

      </P
><P
>Refer to the README file for installation details. Currently, only "zImage"-type kernels are supported. Unfortunately, kernel parameters are ignored.</P
><P
>This section was initially written by Jochen Kmietsch for the Diskless-HOWTO, email to: <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:jochen.kmietsch@tu-clausthal.de"
>jochen.kmietsch@tu-clausthal.de</A
>&#62;</CODE
> for any questions.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN411"
>6.5. Local CDROM</A
></H3
><P
>This section was originally written by Hans de Goede <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:j.w.r.degoede@et.tudelft.nl"
>j.w.r.degoede@et.tudelft.nl</A
>&#62;</CODE
> for the Diskless-root-NFS-HOWTO. I modified it slightly in order to reflect some differences between this document and the Diskless-root-NFS-HOWTO.</P
><P
>Much of the above also goes for booting from cdrom. Why would one want to boot a machine from cdrom? Booting from cdrom is interesting everywhere one wants to run a very specific application, like a kiosk, a library database program or an internet cafe, and one doesn't have a network or a server to use a root over nfs setup.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN416"
>6.5.1. Creating a test setup</A
></H4
><P
>Now that we know what we want to do and how, it's time to create a test setup:

        <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>For starters just take one of the machines which you want to use and put in a big disk and a cd burner.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Install your linux of choice on this machine, and leave a 650 MB partition free for the test setup. This install will be used to make the iso image and to burn the cd's from, so install the necessary tools. It will also be used to restore any booboo's which leave the test setup unbootable.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>On the 650 mb partition install your linux of choice with the setup you want to have on the cd, this will be the test setup.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Boot the test setup.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Compile a kernel with isofs and cdrom support compiled in.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Configure the test setup as described above with the root filesystem mounted read only.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Verify that the test setup automagically boots and everything works.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Boot the main install and mount the 650 MB partition on <TT
CLASS="FILENAME"
>/test</TT
> of the main install.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Put the following in a file called <TT
CLASS="FILENAME"
>/test/etc/rc.d/rc.iso</TT
>, this file will be sourced at the beginning of <TT
CLASS="FILENAME"
>rc.sysinit</TT
> to create <TT
CLASS="FILENAME"
>/var</TT
>:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                #/var
                echo Creating /var ...
                mke2fs -q -i 1024 /dev/ram1 16384
                mount /dev/ram1 /var -o defaults,rw
                cp -a /lib/var /
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Edit <TT
CLASS="FILENAME"
>/test/etc/rc.sysinit</TT
>, comment the lines where the root is remounted rw, and add the following 2 lines directly after setting the PATH:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                #to boot from cdrom
                . /etc/rc.d/rc.iso
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Copy the following to a script and execute it to make a template for <TT
CLASS="FILENAME"
>/var</TT
> and create <TT
CLASS="FILENAME"
>/tmp</TT
> and <TT
CLASS="FILENAME"
>/etc/mtab</TT
> links.

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;                #!/bin/sh
                echo tmp
                rm -fR /test/tmp
                ln -s var/tmp /test/tmp

                ###
                echo mtab
                touch /test/proc/mounts
                rm /test/etc/mtab
                ln -s /proc/mounts /test/etc/mtab

                ###
                echo var
                mv /test/var/lib /test/lib/var-lib
                mv /test/var /test/lib
                mkdir /test/var
                ln -s /lib/var-lib /test/lib/var/lib
                rm -fR /test/lib/var/catman
                rm -fR /test/lib/var/log/httpd
                rm -f /test/lib/var/log/samba/*
                for i in `find /test/lib/var/log -type f`; do
                  cat /dev/null &#62; $i;
                done
                rm `find /test/lib/var/lock -type f`
                rm `find /test/lib/var/run -type f`

              </PRE
></FONT
></TD
></TR
></TABLE
>

            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Remove the creation of <TT
CLASS="FILENAME"
>/etc/issue*</TT
> from <TT
CLASS="FILENAME"
>/test/etc/rc.local</TT
>: it will only fail.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Now boot the test partition again, it will be read only just like a cdrom. If something doesn't work reboot to the working partition fix it, try again etc. Or you could remount <TT
CLASS="FILENAME"
>/</TT
> rw, fix it, then reboot straight into to test partition again. To remount <TT
CLASS="FILENAME"
>/</TT
> rw type:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                <SAMP
CLASS="PROMPT"
># </SAMP
>mount -o remount,rw /
              </PRE
></FONT
></TD
></TR
></TABLE
>

            </P
></LI
></UL
>

      </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN463"
>6.5.2. Creating the CD</A
></H4
><P
>If you need more information than you can find below, please refer to the CD-Writing-HOWTO.</P
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN466"
>6.5.2.1. Creating a boot image</A
></H5
><P
>First of all, boot into the working partition. To create a bootable cd we'll need an image of a bootable floppy. Just dd-ing a zImage doesn't work since the loader at the beginning of the zimage doesn't seem to like the fake floppydrive a bootable cd creates. So we'll use syslinux instead.

        <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Get boot.img from a redhat cd.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Mount boot.img somewhere through loopback by typing:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                <SAMP
CLASS="PROMPT"
># </SAMP
>mount boot.img somewhere -o loop -t vfat
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Remove everything from boot.img except for ldlinux.sys and
            syslinux.cfg.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Cp the kernel-image from the test partition to boot.img.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Edit <TT
CLASS="FILENAME"
>syslinux.cfg</TT
> so that it contains the following, of course replace <TT
CLASS="FILENAME"
>zImage</TT
> by the appropriate image name:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;                default linux 

                label linux
                kernel zImage
                append root=/dev/&#60;insert your cdrom device here&#62;

              </PRE
></FONT
></TD
></TR
></TABLE
>

            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Umount boot.img:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                <SAMP
CLASS="PROMPT"
># </SAMP
>umount somewhere
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>If your <TT
CLASS="FILENAME"
>/etc/mtab</TT
> is a link to <TT
CLASS="FILENAME"
>/proc/mounts</TT
>, umount won't automagically free <TT
CLASS="FILENAME"
>/dev/loop0</TT
> so free it by typing:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                <SAMP
CLASS="PROMPT"
># </SAMP
>losetup -d /dev/loop0
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
></UL
>

        </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN496"
>6.5.2.2. Creating the iso image</A
></H5
><P
>Now that we have the boot image and an install that can boot from a readonly mount it's time to create an iso image of the cd:

          <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Copy boot.img to <TT
CLASS="FILENAME"
>/test</TT
></P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Cd to the directory where you want to store the image and make sure it's on a partition with enough free space.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Now generate the image by typing:

                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                  <SAMP
CLASS="PROMPT"
># </SAMP
>mkisofs -R -b boot.img -c boot.catalog -o boot.iso /test
                </PRE
></FONT
></TD
></TR
></TABLE
>
              </P
></LI
></UL
>

        </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN509"
>6.5.2.3. Verifying the iso image</A
></H5
><P
>          <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Mounting the image through the loopbackdevice by typing:

                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                  <SAMP
CLASS="PROMPT"
># </SAMP
>mount boot.iso somewhere -o loop -t iso9660
                </PRE
></FONT
></TD
></TR
></TABLE
>
              </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Umount boot.iso:

                <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                  <SAMP
CLASS="PROMPT"
># </SAMP
>umount somewhere
                </PRE
></FONT
></TD
></TR
></TABLE
>
              </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>If your <TT
CLASS="FILENAME"
>/etc/mtab</TT
> is a link to <TT
CLASS="FILENAME"
>/proc/mounts</TT
> umount won't automagically free <TT
CLASS="FILENAME"
>/dev/loop0</TT
> so free it by typing:

              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>                <SAMP
CLASS="PROMPT"
># </SAMP
>losetup -d /dev/loop0
              </PRE
></FONT
></TD
></TR
></TABLE
>
              </P
></LI
></UL
>

        </P
></DIV
><DIV
CLASS="SECT4"
><HR><H5
CLASS="SECT4"
><A
NAME="AEN528"
>6.5.2.4. Writing the actual CD</A
></H5
><P
>Assuming that you've got <B
CLASS="COMMAND"
>cdrecord</B
> installed and configured for your cd-writer type:

          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>            <SAMP
CLASS="PROMPT"
># </SAMP
>cdrecord -v speed=&#60;desired writing speed&#62; dev=&#60;path to your writers generic scsi device&#62; boot.iso
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN534"
>6.5.3. Boot the cd and test it</A
></H4
><P
>Well the title of this paragraph says it all;)</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN537"
>7. How to create diskless MS-Windows stations?</A
></H2
><P
>Since MS-Windows does not support diskless booting, a simple workaround is presented here: the solution is to use software like <A
HREF="http://www.vmware.com"
TARGET="_top"
>VMWare</A
> or its free alternative, <A
HREF="http://www.plex86.org"
TARGET="_top"
>plex86</A
>. Although the plex86 seems to have been abandonned, one can still boot certain versions of MS-Windows using this software. These enable MS-Windows to be executed transparently on the linux box.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN542"
>8. Troubleshooting, tips, tricks, and useful links</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN544"
>8.1. Transparently handling workstations'specific files</A
></H3
><P
>&#13;      The previous sections discussed a simple way to handle workstations'specific files and directories like <TT
CLASS="FILENAME"
>/var</TT
>. Most of them are simply build on the fly and put on ramdisks, you may however prefer to deal with this problem on the NFS server. The clusternfs project provides a network filesystem server that can serve different files based on several criteria including the client's IP address or host name. The basic idea is that if the client whose IP address is 10.2.12.42 requests a file named, for instance, <TT
CLASS="FILENAME"
>myfile</TT
>, the server will look for a file named <TT
CLASS="FILENAME"
>myfile$$IP=10.2.12.42$$</TT
> and serve this file instead of <TT
CLASS="FILENAME"
>myfile</TT
> if it is available.

    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN551"
>8.2. Reducing diskless workstations'memory usage</A
></H3
><P
>One simple way to reduce memory consumption is to put several dynamically created directories on the same ramdisk. For instance, let's say the first ramdisk will contain the <TT
CLASS="FILENAME"
>/tmp</TT
> directory. Then, one may move the <TT
CLASS="FILENAME"
>/var/tmp</TT
> directory on that ramdisk with the following commands issued on the server:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>mkdir /nfsroot/tmp/var
        <SAMP
CLASS="PROMPT"
># </SAMP
>chmod 0 /nfsroot/tmp/var
        <SAMP
CLASS="PROMPT"
># </SAMP
>ln -s /tmp/var /nfsroot/var/tmp
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>Another good way to reduce memory consumption if you don't have local hard drives and do not swap over a network block device is to disable the <B
CLASS="COMMAND"
>Swapping to block devices</B
> option during kernel compilation.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN562"
>8.3. Swapping over NFS</A
></H3
><P
>If your stations do not have enough memory and do not have local drives, you may want to swap over NFS. You have to be warned the cod eto do so is still under development and this method is generally quite slow. The full documentation for this can be found at <A
HREF="http://www.instmath.rwth-aachen.de/~heine/nfs-swap/"
TARGET="_top"
>http://www.instmath.rwth-aachen.de/~heine/nfs-swap/</A
>.</P
><P
>The first thing to do if you want to apply this solution is to patch your kernel (you need a kernel version 2.2 or above). First download the patch at the above url, and cd to <TT
CLASS="FILENAME"
>/usr/src/linux</TT
>. I assume the patch is in <TT
CLASS="FILENAME"
>/usr/src/patch</TT
>. Then issue the following command:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>cat ../patch | patch -p1 -l -s
      </PRE
></FONT
></TD
></TR
></TABLE
>

      Then, compile your kernel normally and enable the <B
CLASS="COMMAND"
>Swapping via network sockets (EXPERIMENTAL)</B
> and <B
CLASS="COMMAND"
>Swapping via NFS (EXPERIMENTAL)</B
> options.

    </P
><P
>Then export a directory read-write and no_root_squash from the NFS server. Setup the clients so that they will mount it somewhere (say on <TT
CLASS="FILENAME"
>/mnt/swap</TT
>). It should be mounted with a rsize and wsize smaller than the page size used by the kernel (ie. 4 kilobytes on Intel architectures), otherwise your machine may run out of memory due to memory fragmentation; see the nfs manual page for details about rsize and wsize. Now, to create a 20 MB swap file, issue the following commands (which should be placed in the clients'initialization scripts):

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>dd if=/dev/zero of=/mnt/swap/swapfile bs=1k count=20480
	<SAMP
CLASS="PROMPT"
># </SAMP
>mkswap /mnt/swap/swapfile
	<SAMP
CLASS="PROMPT"
># </SAMP
>swapon /mnt/swap/swapfile
      </PRE
></FONT
></TD
></TR
></TABLE
>

      Of course, this was just for an example, because if you have several workstations, you will have to change the swap file name or directory, or all your workstations will use the same swap file for their swap...

    </P
><P
>Let's say a word about the drawbacks of NFS swapping: the first drawback is that it is generally slow, except you have specially fast network cards. Then, this possibility has not been very well tested yet. At last, this is not secure at all: anyone on the network is able to read the swapped data.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN580"
>8.4. Swapping over network block devices</A
></H3
><P
>Although I have never tried it personally, I got report that the trick described below works, at least with recent kernels.</P
><P
>The general principle for swapping over network block devices is the same than to swap over NFS. The good point is you won't have to patch the kernel. But most of the same drawbacks also apply to the NBD method.</P
><P
>To create a 20 MB swap file, you will have to first create it on the server, export it to the client, and do an <B
CLASS="COMMAND"
>mkswap</B
> on the file. Note that the <B
CLASS="COMMAND"
>mkswap</B
> must be done on the server, because mkswap uses system calls which are not handled by NBD. Moreover, this command must be issued after the server starts exporting the file, because the data on the file may be destroyed when the server starts exporting it. If we assume the server's name is NBDserver, the client's name is NBDclient, and the TCP port used for the export is 1024, the commands to issue on the server are the following:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>dd if=/dev/zero of=/swap/swapfile bs=1k count=20480
	<SAMP
CLASS="PROMPT"
># </SAMP
>nbd-server NBDclient 1024 /swap/swapfile
	<SAMP
CLASS="PROMPT"
># </SAMP
>mkswap /swap/swapfile
      </PRE
></FONT
></TD
></TR
></TABLE
>

    Now, the client should use the following command:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>swapon /dev/nd0
      </PRE
></FONT
></TD
></TR
></TABLE
>

    </P
><P
>Again, this was just to show the general principle. The files'names should also be dependant on the workstations'names or IPs.</P
><P
>Another solution to swap over a network block device is to create an ext2 filesystem on the NBD, then create a regular file on this filesystem, and at last, use <B
CLASS="COMMAND"
>mkswap</B
> and <B
CLASS="COMMAND"
>swapon</B
> to start swapping on this file. This second method is closer to the swap over NFS method than the first solution.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN597"
>8.5. Getting rid of error messages about <TT
CLASS="FILENAME"
>/etc/mtab</TT
> or unmounted directories on shutdown</A
></H3
><P
>The following commands, issued on the server may solve the problem:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>ln -s /proc/mounts /nfsroot/etc/mtab
        <SAMP
CLASS="PROMPT"
># </SAMP
>touch /nfsroot/proc/mounts
      </PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN604"
>8.6. Installing new packages on workstations</A
></H3
><P
>A simple way to do so is to use, on the server, a chroot and then execute your favourite installation commands normally. To chroot to the appropriate place, use the following command:

      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>        <SAMP
CLASS="PROMPT"
># </SAMP
>chroot /nfsroot
      </PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>Debian users will be particularly interested in the --root option of dpkg, which simply tells dpkg where the root of the target system is.
    </P
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="AEN610"
>A. Non-Volatile Memory chips</A
></H1
><P
>Here is a brief descriptions of memory chips and their types:

    <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>PROM: Pronounced prom, an acronym for programmable read-only memory. A PROM is a memory chip on which data can be written only once. Once a program has been written onto a PROM, it remains there forever. Unlike RAM, PROMs retain their contents when the computer is turned off. The difference between a PROM and a ROM (read-only memory) is that a PROM is manufactured as blank memory, whereas a ROM is programmed during the manufacturing process. To write data onto a PROM chip, you need a special device called a PROM programmer or PROM burner. The process of programming a PROM is sometimes called burning the PROM. An EPROM (erasable programmable read-only memory) is a special type of PROM that can be erased by exposing it to ultraviolet light. Once it is erased, it can be reprogrammed. An EEPROM is similar to a PROM, but requires only electricity to be erased.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>EPROM: Acronym for erasable programmable read-only memory, and pronounced e-prom, EPROM is a special type of memory that retains its contents until it is exposed to ultraviolet light. The ultraviolet light clears its contents, making it possible to reprogram the memory. To write to and erase an EPROM, you need a special device called a PROM programmer or PROM burner. An EPROM differs from a PROM in that a PROM can be written to only once and cannot be erased. EPROMs are used widely in personal computers because they enable the manufacturer to change the contents of the PROM before the computer is actually shipped. This means that bugs can be removed and new versions installed shortly before delivery. A note on EPROM technology: The bits of an EPROM are programmed by injecting electrons with an elevated voltage into the floating gate of a field-effect transistor where a 0 bit is desired. The electrons trapped there cause that transistor to conduct, reading as 0. To erase the EPROM, the trapped electrons are given enough energy to escape the floating gate by bombarding the chip with ultraviolet radiation through the quartz window. To prevent slow erasure over a period of years from sunlight and fluorescent lights, this quartz window is covered with an opaque label in normal use.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>EEPROM: Acronym for electrically erasable programmable read-only memory. Pronounced double-e-prom or e-e-prom, an EEPROM is a special type of PROM that can be erased by exposing it to an electrical charge. Like other types of PROM, EEPROM retains its contents even when the power is turned off. Also like other types of ROM, EEPROM is not as fast as RAM. EEPROM is similar to flash memory (sometimes called flash EEPROM). The principal difference is that EEPROM requires data to be written or erased one byte at a time whereas flash memory allows data to be written or erased in blocks. This makes flash memory faster.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>FRAM: Short for Ferroelectric Random Access Memory, a type of non-volatile memory developed by Ramtron International Corporation. FRAM combines the access speed of DRAM and SRAM with the non-volatility of ROM. Because of its high speed, it is replacing EEPROM in many devices. The term FRAM itself is a trademark of Ramtron.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>NVRAM: Abbreviation of Non-Volatile Random Access Memory, a type of memory that retains its contents when power is turned off. One type of NVRAM is SRAM that is made non-volatile by connecting it to a constant power source such as a battery. Another type of NVRAM uses EEPROM chips to save its contents when power is turned off. In this case, NVRAM is composed of a combination of SRAM and EEPROM chips.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Bubble Memory: A type of non-volatile memory composed of a thin layer of material that can be easily magnetized in only one direction. When a magnetic field is applied to circular area of this substance that is not magnetized in the same direction, the area is reduced to a smaller circle, or bubble. It was once widely believed that bubble memory would become one of the leading memory technologies, but these promises have not been fulfilled. Other non-volatile memory types, such as EEPROM, are both faster and less expensive than bubble memory.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Flash Memory: A special type of EEPROM that can be erased and reprogrammed in blocks instead of one byte at a time. Many modern PCs have their BIOS stored on a flash memory chip so that it can easily be updated if necessary. Such a BIOS is sometimes called a flash BIOS. Flash memory is also popular in modems because it enables the modem manufacturer to support new protocols as they become standardized.</P
></LI
></UL
>

  </P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="AEN628"
>B. Determining the size and speed of EPROMs to plug in a NIC</A
></H1
><P
>This section comes from the etherboot project's documentation version 5.0. It provides tips to determine the size and speed of EPROMs  to use with a particular NIC</P
><P
>The smallest EPROM that is accepted by network cards is an 8k EPROM (2764). 16 kB (27128) or 32 kB (27256) are the norm. Some cards will even go up to 64 kB EPROMs (27512). (You will often see a C after the 27, e.g. 27C256. This indicates a CMOS EPROM, which is equivalent to the non-C version and is a good thing because of lower power consumption.) You want to use the smallest EPROM you can so that you don't take up more of the upper memory area than needed as other extensions BIOSes may need the space. However you also want to get a good price for the EPROM. Currently the 32 kB and 64 kB EPROMs (27256 and 27512) seem to be the cheapest per unit. Smaller EPROMs appear to be more expensive because they are out of mainstream production.</P
><P
>If you cannot find out from the documentation what capacity of EPROM your card takes, for ISA NICs only, you could do it by trial and error. (PCI NICs do not enable the EPROM until the BIOS tells the NIC to.) Take a ROM with some data on it (say a character generator ROM) and plug it into the socket. Be careful not to use an extension BIOS for this test because it may be detected and activated and prevent you from booting your computer. Using the debug program under DOS, dump various regions of the memory space. Say you discover that you can see the data in a memory window from CC00:0 to CC00:3FFF (= 4000 hex = 16384 decimal locations). This indicates that a 16 kB EPROM is needed. However if you see an alias in parts of the memory space, say the region from CC00:0 to CC00:1FFF is duplicated in CC00:2000 to CC00:3FFF, then you have put an 8 kB EPROM into a 16 kB slot and you need to try a larger EPROM.</P
><P
>Note that because pinouts for 28 pin EPROMs are upward compatible after a fashion, you can probably use a larger capacity EPROM in a slot intended for a smaller one. The higher address lines will probably be held high so you will need to program the image in the upper half or upper quarter of the larger EPROM, as the case may be. However you should double check the voltages on the pins armed with data sheet and a meter because CMOS EPROMs don't like floating pins.</P
><P
>If the ROM is larger than the size of the image, for example, a 32 kB ROM containing a 16 kB image, then you can put the image in either half of the ROM. You will sometimes see advice to put two copies of the image in the ROM. This will work but is not recommended because the ROM will be activated twice if it's a legacy ROM and may not work at all if it's a PCI/PnP ROM. It is tolerated by Etherboot because the code checks to see if it's been activated already and the second activation will do nothing. The recommended method is to fill the unused half with blank data. All ones data is recommended because it is the natural state of the EPROM and involves less work for the PROM programmer. Here is a Unix command line that will generate 16384 bytes of 0xFF and combine it with a 16 kB ROM into a 32 kB image for your PROM programmer.

    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>(perl -e 'print "\xFF" x 16384'; cat bin32/3c509.lzrom) &#62; 32kbimage
    </PRE
></FONT
></TD
></TR
></TABLE
>

  </P
><P
>The speed of the EPROM needed depends on how it is connected to the computer bus. If the EPROM is directly connected to the computer bus, as in the case of many cheap NE2000 clones, then you will probably have to get an EPROM that is at least as fast as the ROMs used for the main BIOS. This is typically 120-150 ns. Some network cards mediate access to the EPROM via circuitry and this may insert wait states so that slower EPROMs can be used. Incidentally the slowness of the EPROM doesn't affect Etherboot execution speed much because Etherboot copies itself to RAM before executing. I'm told Netboot does the same thing.</P
><P
>If you have your own EPROM programming hardware, there is a nice collection of EPROM file format conversion utilities at <A
HREF="http://www.canb.auug.org.au/~millerp/srecord.html"
TARGET="_top"
>http://www.canb.auug.org.au/~millerp/srecord.html</A
>. The files produced by the Etherboot build process are plain binary. A simple binary to Intel hex format converter can be found at the Etherboot web site at <A
HREF="http://etherboot.sourceforge.net/bin2intelhex.c"
TARGET="_top"
>http://etherboot.sourceforge.net/bin2intelhex.c</A
>. You may alternatively use the objcopy utility, included in the binutils package:

    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>      <SAMP
CLASS="PROMPT"
># </SAMP
>objcopy --input-target binary --output-target ihex binary.file intelhex.file
      <SAMP
CLASS="PROMPT"
># </SAMP
>objcopy --input-target ihex --output-target binary intelhex.file binary.file
    </PRE
></FONT
></TD
></TR
></TABLE
>

  </P
><P
>Etherboot is believed to make PnP compliant ROMs for PCI NICs. A long-standing bug in the headers has been tracked down. However some faulty old BIOSes are out there so I have written a Perl script swapdevids.pl to switch the header around if necessary. You'll have to experiment with it both ways to find out which works. Or you could dump a ROM image that works (e.g. RPL, PXE ROM) using the Perl script disrom.pl. The fields to look at are Device (base, sub, interface) Type. It should be 02 00 00, but some BIOSes want 00 00 02 due to ambiguity in the original specification.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="AEN645"
>C. Companies selling diskless computers</A
></H1
><P
>The original Diskless-HOWTO mentions the names of the following vendors of diskless computers:

    <P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>Linux Systems Labs Inc., USA <A
HREF="http://www.lsl.com"
TARGET="_top"
>http://www.lsl.com</A
>. Click on "Shop On-line" and then click on "HardWare" where all the diskless computers will be listed. Phone 1-888-LINUX-88.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Diskless Workstations Corporation, USA <A
HREF="http://www.disklessworkstations.com"
TARGET="_top"
>http://www.disklessworkstations.com</A
>.</P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>Unique Systems of Holland Inc., Ohio, USA <A
HREF="http://www.uniqsys.com"
TARGET="_top"
>http://www.uniqsys.com</A
></P
></LI
></UL
>
  </P
></DIV
><A
NAME="AEN658"
></A
><HR><H1
><A
NAME="AEN658"
></A
>References</H1
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN660"
></A
><P
>[Diskless-HOWTO]&nbsp;<I
>Diskless-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.linuxdoc.org/HOWTO/Diskless-HOWTO.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN663"
></A
><P
>[Diskless-root-NFS-HOWTO]&nbsp;<I
>Diskless-root-NFS-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.linuxdoc.org/HOWTO/Diskless-root-NFS-HOWTO.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN666"
></A
><P
>[Bootdisk-HOWTO]&nbsp;<I
>Boot-disk-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN669"
></A
><P
>[ltsp]&nbsp;<I
>linux terminal server project</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><DIV
CLASS="ABSTRACT"
><P
>A set of utilities and documentation for diskless stations, based on the red hat distribution.</P
></DIV
><P
CLASS="ADDRESS"
>http://www.ltsp.org</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN674"
></A
><P
>[plume]&nbsp;<I
>plume</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><DIV
CLASS="ABSTRACT"
><P
>A beginning project whose goal is to provide a set of utilities for diskless stations and associated servers, based on the debian distribution.</P
></DIV
><P
CLASS="ADDRESS"
>http://plume.sourceforge.net</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN679"
></A
><P
>[logilab]&nbsp;<I
>Logilab.org web site</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.logilab.org</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN682"
></A
><P
>[PowerUp2Bash]&nbsp;<I
>From-PowerUp-to-bash-prompt-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.linuxdoc.org/HOWTO/From-PowerUp-to-bash-prompt-HOWTO.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN685"
></A
><P
>[ThinClient]&nbsp;<I
>Thin-Client-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.linuxdoc.org/HOWTO/Thin-Client-HOWTO.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN688"
></A
><P
>[cdwriting]&nbsp;<I
>CD-Writing-HOWTO</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://www.linuxdoc.org/HOWTO/CD-Writing-HOWTO.html</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN691"
></A
><P
>[etb]&nbsp;<I
>etherboot project</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><P
CLASS="ADDRESS"
>http://etherboot.sourceforge.net</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN694"
></A
><P
>[VMWare]&nbsp;<I
>VMWare</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><DIV
CLASS="ABSTRACT"
><P
>A non free virtual machine software.</P
></DIV
><P
CLASS="ADDRESS"
>http://www.vmware.com</P
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN699"
></A
><P
>[plex86]&nbsp;<I
>plex86</I
>.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left: 0.5in"
><DIV
CLASS="ABSTRACT"
><P
>A free virtual machine software.</P
></DIV
><P
CLASS="ADDRESS"
>http://www.plex86.org</P
></DIV
></DIV
></DIV
></BODY
></HTML
>