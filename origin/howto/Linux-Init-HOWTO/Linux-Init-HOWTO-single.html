<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>Linux 2.4.x Initialization for IA-32 HOWTO</TITLE>
</HEAD>
<BODY>
<H1>Linux 2.4.x Initialization for IA-32 HOWTO</H1>

<H2>Randy Dunlap, <CODE>rddunlap@ieee.org</CODE></H2>v1.0, 2001-05-17
<HR>
<EM>This document contains a description of the Linux 2.4 kernel
initialization sequence on IA-32 processors.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>


<P>Portions of this text come from comments in the kernel source
files (obviously).  I have added annotations in many places.
I hope that this will be useful to kernel developers -- either
new ones or experienced ones who need more of this type of
information.  However, if there's not enough detail here for
you, "Use the Source."</P>

<H2><A NAME="ss1.1">1.1 Overview</A>
</H2>


<P>This description is organized as a brief overview which
lists the sections that are described later in more detail.</P>
<P>The description is in three main sections.  The first section covers
early kernel initialization on IA-32 (but only after your boot loader of
choice and other intermediate loaders have run; i.e., this description
does not cover loading the kernel).
This section is based on the code in "linux/arch/i386/boot/setup.S"
and "linux/arch/i386/boot/video.S".</P>
<P>The second major section covers Linux initialization that is
x86- (or i386- or IA-32-) specific.  This section is based on the source
files "linux/arch/i386/kernel/head.S" and "linux/arch/i386/kernel/setup.c".</P>
<P>The third major section covers Linux initialization that is
architecture-independent.  This section is based on the flow in the
source file "linux/init/main.c".</P>
<P>See the References section for other valuable documents
about booting, loading, and initialization.</P>

<H2><A NAME="ss1.2">1.2 This document</A>
</H2>


<P>This document describes Linux 2.4.x initialization on IA-32
(or i386 or x86) processors -- after one or more kernel boot loaders
(if any) have done their job.</P>
<P>You can format it using the commands (for example):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
% sgml2txt ia32_init_240.sgml
</PRE>
</CODE></BLOCKQUOTE>

or
<BLOCKQUOTE><CODE>
<PRE>
% sgml2html ia32_init_240.sgml
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This will produce plain ASCII or HTML files respectively.
You can also produce LaTeX, GNU, and RTF info by using the proper
sgmltool (man sgmltools).</P>

<H2><A NAME="ss1.3">1.3 Contributions</A>
</H2>


<P>Additions and corrections are welcome.  Please send them
to me (rddunlap@ieee.org).  Contributions of section
descriptions that are used will be credited to their author(s).</P>

<H2><A NAME="ss1.4">1.4 Trademarks</A>
</H2>


<P>All trademarks are the property of their respective owners.</P>

<H2><A NAME="ss1.5">1.5 License</A>
</H2>


<P>Copyright (C) 2001 Randy Dunlap.</P>
<P>This document may be distributed only subject to the terms
and conditions set forth in the LDP (Linux Documentation Project)
License at "http://www.linuxdoc.org/COPYRIGHT.html".</P>

<H2><A NAME="s2">2. Linux init ("ASCII art")</A></H2>


<P>Pictorially (loosely speaking :), Linux initialization looks like
this, where "[...]" means optional (depends on the kernel's
configuration) and "{...}" is a comment.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>

  +-------------------------------+
  | arch/i386/boot/setup.S:: +    |
  | arch/i386/boot/video.S::      |
  |-------------------------------|
  | start_of_setup:               |
  |   check that loaded OK        |
  |   get system memory size      |
  |   get video mode(s)           |
  |   get hard disk parameters    |
  |   get MC bus information      |
  |   get mouse information       |
  |   get APM BIOS information    |
  |   enable address line A20     |
  |   reset coprocessor           |
  |   mask all interrupts         |
  |   move to protected mode      |
  |   jmp to startup_32           |
  +-------------------------------+
                  |
                  v
  +-------------------------------+
  | arch/i386/kernel/head.S::     |
  |-------------------------------|
  | startup_32:                   |
  |   set segment registers to    |
  |     known values              |
  |   init basic page tables      |
  |   setup the stack pointer     |
  |   clear kernel BSS            |
  |   setup the IDT               |
  |   checkCPUtype                |
  |   load GDT, IDT, and LDT      |
  |     pointer registers         |
  |   start_kernel                |
  |     {it does not return}      |
  +-------------------------------+
                  |
                  v
  +-------------------------------+     +-------------------------------+
  | init/main.c::                 |  +->| arch/i386/kernel/setup.c::    |
  |-------------------------------|  |  |-------------------------------|
  | start_kernel():               |  |  | setup_arch():                 |
  |   lock_kernel                 |  |  |   copy boot parameters        |
  |   setup_arch                  |--+  |   init ramdisk                |
  |   parse_options               |&lt;-+  |   setup_memory_region         |
  |   trap_init                   |  |  |   parse_cmd_line              |
  |     cpu_init                  |  |  |   use the BIOS memory map to  |
  |   init_IRQ                    |  |  |     setup page frame info.    |
  |   sched_init                  |  |  |   reserve physical page 0     |
  |     init_timervecs            |  |  |  [find_smp_config]            |
  |   time_init                   |  |  |   paging_init                 |
  |   softirq_init                |  |  |  [get_smp_config]             |
  |   console_init                |  |  |  [init_apic_mappings]         |
  |  [init_modules]               |  |  |  [reserve INITRD memory]      |
  |  [profiling setup]            |  |  |   probe_roms to search        |
  |   kmem_cache_init             |  |  |     for option ROMs           |
  |   sti                         |  |  |   request_resource to         |
  |   calibrate_delay             |  |  |     reserve video RAM memory  |
  |  [INITRD setup]               |  |  |   request_resource to         |
  |   mem_init                    |  |  |     reserve all standard PC   |
  |     free_all_bootmem          |  +--|     I/O system board resources|
  |   kmem_cache_sizes_init       |     +-------------------------------+
  |  [proc_root_init]             |
  |   fork_init                   |
  |   proc_caches_init            |
  |   vfs_caches_init             |
  |   buffer_init                 |
  |   page_cache_init             |
  |   kiobuf_setup                |
  |   signals_init                |     +-------------------------------+
  |   bdev_init                   |     | init/main.c::                 |
  |   inode_init                  |     | init(): {...init thread...}   |
  |  [ipc_init]                   |     |   do_basic_setup              |
  |  [dquot_init_hash]            |     |     {bus/dev init &amp; initcalls}|
  |   check_bugs                  |     |   free_initmem                |
  |  [smp_init] {*below}          |     |   open /dev/console           |
  |   start init thread {---->}   |.....| exec init script or shell     |
  |   unlock_kernel               |     |   or panic                    |
  |   cpu_idle                    |     +-------------------------------+
  +-------------------------------+


  +-------------------------------+
  | smpboot.c::smp_init           |
  |-------------------------------|
  | arch/i386/kernel/smpboot.c::  |
  | smp_boot_cpus():              |
  |  [mtrr_init_boot_cpu]         |
  |   smp_store_cpu_info          |
  |   print_cpu_info              |
  |   save CPU ID/APIC ID mappings|
  |   verify_local_APIC           |
  |   connect_bsp_APIC            |
  |   setup_local_APIC            |
  |   foreach valid APIC ID       |
  |     do_boot_cpu(apicid)       |
  |   setup_IO_APIC               |
  |   setup_APIC_clocks           |
  |   synchronize_tsc_bp          |
  +-------------------------------+
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="s3">3. Linux early setup</A></H2>


<P>(from linux/arch/i386/boot/setup.S and linux/arch/i386/boot/video.S)</P>
<P>NOTE:  Register notation is %regname and constant notation is a number,
with or without a leading '$' sign.</P>

<H2><A NAME="ss3.1">3.1 IA-32 Kernel Setup </A>
</H2>


<P>"setup.S" is responsible for getting the system data from the BIOS
and putting them into the appropriate places in system memory.</P>
<P>Both "setup.S" and the kernel have been loaded by the boot block.</P>
<P>"setup.S" is assembled as 16-bit real-mode code.
It switches the processor to 32-bit protected mode and jumps to
the 32-bit kernel code.</P>
<P>This code asks the BIOS for memory/disk/other parameters, and
puts them in a "safe" place: 0x90000-0x901FF, that is, where the
boot block used to be.  It is then up to the protected mode
system to read them from there before the area is overwritten
for buffer-blocks.</P>
<P>The "setup.S" code begins with a jmp instruction around the
"setup header", which must begin at location %cs:2.</P>
<P>This is the setup header:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
                .ascii  "HdrS"          # header signature
                .word   0x0202          # header version number
realmode_swtch: .word   0, 0            # default_switch, SETUPSEG
start_sys_seg:  .word   SYSSEG
                .word   kernel_version  # pointer to kernel version string
type_of_loader: .byte   0
loadflags:
LOADED_HIGH     = 1             # If set, the kernel is loaded high
#ifndef __BIG_KERNEL__
                .byte   0
#else
                .byte   LOADED_HIGH
#endif
setup_move_size: .word  0x8000  # size to move, when setup is not
                                # loaded at 0x90000.
code32_start:                   # here loaders can put a different
                                # start address for 32-bit code.
#ifndef __BIG_KERNEL__
                .long   0x1000  # default for zImage
#else
                .long   0x100000# default for big kernel
#endif
ramdisk_image:  .long   0       # address of loaded ramdisk image
ramdisk_size:   .long   0       # its size in bytes
bootsect_kludge: .word  bootsect_helper, SETUPSEG
heap_end_ptr:   .word   modelist+1024   # (Header version 0x0201 or later)
                                        # space from here (exclusive) down to
                                        # end of setup code can be used by setup
                                        # for local heap purposes.
pad1:           .word   0
cmd_line_ptr:   .long   0       # (Header version 0x0202 or later)
                                # If nonzero, a 32-bit pointer
                                # to the kernel command line.
trampoline:     call    start_of_setup  # no return from start_of_setup
                .space  1024
# End of setup header #####################################################
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

<H3>start_of_setup: </H3>



<H3>Read second hard drive DASD type </H3>


<P>Read the DASD type of the second hard drive (BIOS int. 0x13,
%ax=0x1500, %dl=0x81).</P>
<P># Bootlin depends on this being done early. [TBD:why?]</P>

<H3>Check that LILO loaded us right </H3>


<P>Check the signature words at the end of setup.
Signature words are used to ensure that LILO loaded us right.
If the two words are not found correctly, copy the
setup sectors and check for the signature words again.
If they still aren't found, panic("No setup signature found ...").</P>

<H3>Check old loader trying to load a big kernel </H3>


<P>If the kernel image is "big" (and hence is "loaded high"), then
if the loader cannot handle "loaded high" images, then
panic ("Wrong loader, giving up...").</P>


<H3>Determine system memory size </H3>


<P>Get the extended memory size {above 1 MB} in KB.
First clear the extended memory size to 0.</P>
<P>#ifndef STANDARD_MEMORY_BIOS_CALL</P>
<P>Clear the E820 memory area counter.</P>
<P>Try three different memory detection schemes. <BR>
First, try E820h, which lets us assemble a memory map, then try E801h,
which returns a 32-bit memory size, and finally 88h, which
returns 0-64 MB.</P>
<P>Method E820H populates a table in the empty_zero_block that contains
a list of usable address/size/type tuples.
In "linux/arch/i386/kernel/setup.c", this information is
transferred into the e820map, and in "linux/arch/i386/mm/init.c", that
new information is used to mark pages reserved or not.</P>
<P>Method E820H: <BR>
Get the BIOS memory map.  E820h returns memory classified into
different types and allows memory holes.
We scan through this memory map and build a list of the first
32 memory areas {up to 32 entries or BIOS says that there are no
more entries}, which we return at "E820MAP".
[See URL: http://www.teleport.com/&nbsp;acpi/acpihtml/topic245.htm]</P>
<P>Method E801H: <BR>
We store the 0xe801 memory size in a completely different place,
because it will most likely be longer than 16 bits.</P>
<P>This is the sum of 2 registers, normalized to 1 KB chunk sizes:
%ecx = memory size from 1 MB to 16 MB range, in 1 KB chunks +
%edx = memory size above 16 MB, in 64 KB chunks.</P>
<P>Ye Olde Traditional Methode: <BR>
BIOS int. 0x15/AH=0x88 returns the memory size (up to 16 MB or 64 MB,
depending on the BIOS).
We always use this method, regardless of the results of the other
two methods.</P>
<P>#endif</P>
<P>Set the keyboard repeat rate to the maximum rate using
using BIOS int. 0x16.</P>

<H3>Video adapter modes </H3>


<P>Find the video adapter and its supported modes and allow the
user to browse video modes.</P>
<P>call video           # {see Video section below}</P>

<H3>Get Hard Disk parameters </H3>


<P>Get hd0 data:
Save the hd0 descriptor (from int. vector 0x41) at INITSEG:0x80 length 0x10.</P>
<P>Get hd1 data:
Save the hd1 descriptor (from int. vector 0x46) at INITSEG:0x90 length 0x10.</P>
<P>Check that there IS an hd1, using BIOS int. 0x13.
If not, clear its descriptor.</P>

<H3>Get Micro Channel bus information </H3>


<P>Check for Micro Channel (MCA) bus:
<UL>
<LI> Set MCA feature table length to 0 in case not found.</LI>
<LI> Get System Configuration Parameters (BIOS int. 0x15/%ah=0xc0).
This sets %es:%bx to point to the system feature table.</LI>
<LI> We keep only the first 16 bytes of the system feature table if found:
Structure size, Model byte, Submodel byte, BIOS revision,
and Feature information bytes 1-5.
Bit 0 or 1 (either one) of Feature byte 1 indicates that the system
contains a Micro Channel bus.</LI>
</UL>
</P>

<H3>Check for mouse </H3>


<P>Check for PS/2 pointing device by using BIOS int. 0x11 {get equipment list}.
<UL>
<LI> Clear the pointing device flag (default).</LI>
<LI> BIOS int. 0x11: get equipment list.</LI>
<LI> If bit 2 (value 0x04) is set, then a mouse is installed and the
pointing device flag is set to indicate that the device is present.</LI>
</UL>
</P>

<H3>Check for APM BIOS support </H3>


<P>Check for an APM BIOS (if kernel is configured for APM support):
<UL>
<LI> start: clear version field to 0, which means no APM BIOS present.</LI>
<LI> Check for APM BIOS installation using BIOS int. 0x15.</LI>
<LI> If not present, done.</LI>
<LI> Check for "PM" signature returned in %bx.</LI>
<LI> If no signature, then no APM BIOS: done.</LI>
<LI> Check for 32-bit support in %cx.</LI>
<LI> If no 32-bit support, no (good) APM BIOS: done.
Must have 32-bit APM BIOS support to be used by Linux.</LI>
<LI> Save the BIOS code segment, BIOS entry point offset,
BIOS 16-bit code segment, BIOS data segment,
BIOS code segment length, and BIOS data segment length.</LI>
<LI> Record the APM BIOS version and flags.</LI>
</UL>
</P>

<H3>Prepare to move to protected mode </H3>


<P>We build a jump instruction to the kernel's code32_start address.
(The loader may have changed it.)</P>
<P>Move the kernel to its correct place if necessary.</P>
<P>Load the segment descriptors (load %ds = %cs).</P>
<P>Make sure that we are at the right position in memory, to
accommodate the command line and boot parameters at their
fixed locations.</P>
<P>Load the IDT pointer register with 0,0.</P>
<P>Calculate the linear base address of the kernel GDT (table) and load the
GDT pointer register with its base address and limit.
This early kernel GDT describes kernel code as 4 GB, with base address 0,
code/readable/executable, with granularity of 4 KB.
The kernel data segment is described as 4 GB, with base address 0,
data/readable/writable, with granularity of 4 KB.</P>

<H3>Enable address line A20 </H3>


<P>
<UL>
<LI> Empty the 8042 (keyboard controller) of any queued keys.</LI>
<LI> Write 0xd1 (Write Output Port) to Command Register port 0x64.</LI>
<LI> Empty the 8042 (keyboard controller) of any queued keys.</LI>
<LI> Write 0xdf (Gate A20 + more) to Output port 0x60.</LI>
<LI> Empty the 8042 (keyboard controller) of any queued keys.</LI>
<LI> Set bit number 1 (value 0x02: FAST_A20) in the "port 0x92"
system control register.  This enables A20 on some systems, depending
on the chipset used in them.</LI>
<LI> Wait until A20 really *is* enabled; it can take a fair amount of
time on certain systems.
The memory location used here (0x200) is the int 0x80
vector, which should be safe to use.
When A20 is disabled, the test memory locations are an alias
of each other (segment 0:offset 0x200 and segment 0xffff:offset 0x210).
{0xffff0 + 0x210 = 0x100200, but if A20 is disabled, this becomes
0x000200.}
We just wait (busy wait/loop) until these memory locations are
no longer aliased.</LI>
</UL>
</P>

<H3>Make sure any possible coprocessor is properly reset </H3>


<P>
<UL>
<LI> Write 0 to port 0xf0 to clear the Math Coprocessor '-busy' signal.</LI>
<LI> Write 0 to port 0xf1 to reset the Math Coprocessor.</LI>
</UL>
</P>

<H3>Mask all interrupts </H3>


<P>Now we mask all interrupts; the rest is done in init_IRQ().</P>
<P>
<UL>
<LI> Mask off all interrupts on the slave PIC: write 0xff to port 0xa1.</LI>
<LI> Mask off all interrupts on the master PIC except for IRQ2,
which is the cascaded IRQ input from the slave PIC: write 0xfb to port 0x21.</LI>
</UL>
</P>

<H3>Move to Protected Mode </H3>


<P>Now is the time to actually move into protected mode.  To make
things as simple as possible, we do no register setup or anything,
we let the GNU-compiled 32-bit programs do that.  We just jump to
absolute address 0x1000 (or the loader supplied one),
in 32-bit protected mode.</P>
<P>Note that the short jump isn't strictly needed, although there are
reasons why it might be a good idea.  It won't hurt in any case.</P>
<P>Set the PE (Protected mode Enable) bit in the MSW and jump to the
following instruction to flush the instruction fetch queue.</P>
<P>Clear %bx to indicate that this is the BSP (first CPU only).</P>

<H3>Jump to startup_32 code </H3>


<P>Jump to the 32-bit kernel code (startup_32).</P>
<P>NOTE:  For high-loaded big kernels we need: <BR>
<BLOCKQUOTE><CODE>
<PRE>
        jmpi    0x100000,__KERNEL_CS
</PRE>
</CODE></BLOCKQUOTE>

but we yet haven't reloaded the %cs register, so the default size 
of the target offset still is 16 bit.
However, using an operand prefix (0x66), the CPU will properly
take our 48-bit far pointer. (INTeL 80386 Programmer's Reference
Manual, Mixing 16-bit and 32-bit code, page 16-6).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        .byte 0x66, 0xea                # prefix + jmpi-opcode
code32: .long   0x1000                  # or 0x100000 for big kernels
        .word   __KERNEL_CS
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This jumps to "startup_32" in "linux/arch/i386/kernel/head.S".</P>

<H2><A NAME="ss3.2">3.2 Video Setup </A>
</H2>


<P>"linux/arch/i386/boot/video.S" is included into
"linux/arch/i386/boot/setup.S", so they are assembled together.
The file separation is a logical module separation even though
the two modules aren't built separately.</P>
<P>"video.S" handles Linux/i386 display adapter and video mode setup.
For more information about Linux/i386 video modes, see
"linux/Documentation/svga.txt" by Martin Mares [mj@ucw.cz].</P>
<P>Video mode selection is a kernel build option.  When it is
enabled, You can select a specific (fixed) video mode to be used
during kernel booting or you can ask to view a selection menu
and then choose a video mode from that menu.</P>
<P>There are a few esoteric (!) "video.S" build options that
not covered here.  See "linux/Documentation/svga.txt" for all
of them.</P>
<P>CONFIG_VIDEO_SVGA (for automatic detection of SVGA adapters and
modes) is normally #undefined.  The normal method of video
adapter detection on Linux/i386 is VESA (CONFIG_VIDEO_VESA,
for autodetection of VESA modes).</P>
<P>"video:" is the main entry point called by "setup.S".
The %ds register *must* be pointing to the bootsector.
The "video.S" code uses different segments from the main "setup.S" code.</P>
<P>This is a simplified description of the code flow in "video.S".
It does not address the CONFIG_VIDEO_LOCAL, CONFIG_VIDEO_400_HACK,
and CONFIG_VIDEO_GFX_HACK build options and it does not dive deep
into video BIOS calls or video register accesses.</P>

<H3>video: </H3>


<P>
<UL>
<LI> %fs is set to the original %ds value</LI>
<LI> %ds and %es are set to %cs</LI>
<LI> %gs is set to zero</LI>
<LI> Detect the video adapter type and supported modes. (call basic_detect)</LI>
<LI> #ifdef CONFIG_VIDEO_SELECT</LI>
<LI> If the user wants to see a list of the supported VGA adapter
modes, list them. (call mode_menu)</LI>
<LI> Set the selected video mode. (call mode_set)</LI>
<LI> #ifdef CONFIG_VIDEO_RETAIN</LI>
<LI> Restore the screen contents. (call restore_screen)</LI>
<LI> #endif /* CONFIG_VIDEO_RETAIN */</LI>
<LI> #endif /* CONFIG_VIDEO_SELECT */</LI>
<LI> Store mode parameters for kernel. (call mode_params)</LI>
<LI> Restore original DS register value.</LI>
</UL>
</P>

<H3>basic_detect: </H3>


<P>
<UL>
<LI> Detect if we have CGA, MDA, HGA, EGA, or VGA and pass it to the kernel.</LI>
<LI> Check for EGA/VGA using BIOS int. 0x10 calls.
This also tells whether the video adapter is CGA/MDA/HGA.</LI>
<LI> The "adapter" variable is returned as 0 for CGA/MDA/HGA, 1 for EGA,
and 2 for VGA.</LI>
</UL>
</P>

<H3>mode_params: </H3>


<P>
<UL>
<LI> Store the video mode parameters for later use by the kernel.
This is done by asking the BIOS for mode parameters except for the
rows/columns parameters in the default 80x25 mode -- these are set directly,
because some very obscure BIOSes supply insane values.</LI>
<LI> #ifdef CONFIG_VIDEO_SELECT</LI>
<LI> For graphics mode with a linear frame buffer, goto mopar_gr.</LI>
<LI> #endif /* CONFIG_VIDEO_SELECT */</LI>
<LI> For MDA/CGA/HGA/EGA/VGA:</LI>
<LI> Read and save cursor position.</LI>
<LI> Read and save video page/mode/width.</LI>
<LI> For MDA/HGA, change the video_segment to $0xb000.
(Leave it at its initial value of $0xb800 for all other adapters.)</LI>
<LI> Get the Font size (valid only on EGA/VGA).</LI>
<LI> Save the number of video columns and lines.</LI>
</UL>
</P>
<P>#ifdef CONFIG_VIDEO_SELECT</P>

<H3>mopar_gr: </H3>


<P>
<UL>
<LI> Get VESA frame buffer parameters.</LI>
<LI> Get video mem size and protected mode interface information
using BIOS int. 0x10 calls.</LI>
</UL>
</P>

<H3>mode_menu: </H3>


<P>Build the mode list table and display the mode menu.</P>

<H3>mode_set: </H3>


<P>For the selected video mode, use BIOS int. 0x10 calls or register
writes as needed to set some or all of:
<UL>
<LI> Reset the video mode</LI>
<LI> Number of scan lines</LI>
<LI> Font pixel size</LI>
<LI> Save the screen size in force_size.  "force_size" is used
to override possibly broken video BIOS interfaces and is used
instead of the BIOS variables.</LI>
</UL>
</P>
<P>Some video modes require register writes to set:
<UL>
<LI> Location of the cursor scan lines</LI>
<LI> Vertical sync start</LI>
<LI> Vertical sync end</LI>
<LI> Vertical display end</LI>
<LI> Vertical blank start</LI>
<LI> Vertical blank end</LI>
<LI> Vertical total</LI>
<LI> (Vertical) overflow</LI>
<LI> Correct sync polarity</LI>
<LI> Preserve clock select bits and color bit</LI>
</UL>
</P>
<P>{end of mode_set}</P>
<P>#ifdef CONFIG_VIDEO_RETAIN   /* Normally _IS_ #defined */</P>

<H3>store_screen: </H3>


<P>CONFIG_VIDEO_RETAIN is used to retain screen contents when
switching modes.
This option stores the screen contents to a temporary memory buffer
(if there is enough memory) so that they can be restored later.</P>
<P>
<UL>
<LI> Save the current number of video lines and columns,
cursor position, and video mode.</LI>
<LI> Calculate the image size.</LI>
<LI> Save the screen image.</LI>
<LI> Set the "do_restore" flag so that the screen contents
will be restored at the end of video mode detection/selection.</LI>
</UL>
</P>

<H3>restore_screen: </H3>


<P>Restores screen contents from temporary buffer (if already saved).</P>
<P>
<UL>
<LI> Get parameters of current mode.</LI>
<LI> Set cursor position.</LI>
<LI> Restore the screen contents.</LI>
</UL>
</P>
<P>#endif /* CONFIG_VIDEO_RETAIN */</P>

<H3>mode_table: </H3>


<P>Build the table of video modes at `modelist'.</P>
<P>
<UL>
<LI> Store standard modes.</LI>
<LI> Add modes for standard VGA.</LI>
<LI> #ifdef CONFIG_VIDEO_LOCAL</LI>
<LI> Add locally-defined video modes. (call local_modes)</LI>
<LI> #endif /* CONFIG_VIDEO_LOCAL */</LI>
<LI> #ifdef CONFIG_VIDEO_VESA</LI>
<LI> Auto-detect VESA VGA modes. (call vesa_modes)</LI>
<LI> #endif /* CONFIG_VIDEO_VESA */</LI>
<LI> #ifdef CONFIG_VIDEO_SVGA</LI>
<LI> Detect SVGA cards &amp; modes. (call svga_modes)</LI>
<LI> #endif /* CONFIG_VIDEO_SVGA */</LI>
<LI> #ifdef CONFIG_VIDEO_COMPACT</LI>
<LI> Compact the video modes list, removing duplicate entries.</LI>
<LI> #endif /* CONFIG_VIDEO_COMPACT */</LI>
</UL>
</P>

<H3>mode_scan: </H3>


<P>Scans for video modes.</P>
<P>
<UL>
<LI> Start with mode 0.</LI>
<LI> Test the mode.</LI>
<LI> Test if it's a text mode.</LI>
<LI> OK, store the mode.</LI>
<LI> Restore back to mode 3.</LI>
</UL>
</P>
<P>#ifdef CONFIG_VIDEO_SVGA</P>

<H3>svga_modes: </H3>


<P>Try to detect the type of SVGA card and supply (usually approximate)
video mode table for it.</P>
<P>
<UL>
<LI> Test all known SVGA adapters.</LI>
<LI> Call the test routine for each adapter.</LI>
<LI> If adapter is found, copy the video modes.</LI>
<LI> Store pointer to card name.</LI>
</UL>
</P>
<P>#endif       /* CONFIG_VIDEO_SVGA */</P>
<P>#endif /* CONFIG_VIDEO_SELECT */</P>

<H2><A NAME="s4">4. Linux architecture-specific initialization</A></H2>


<P>(from "linux/arch/i386/kernel/head.S")</P>
<P>The boot code in "linux/arch/i386/boot/setup.S" transfers execution
to the beginning code in "linux/arch/i386/kernel/head.S"
(labeled "startup_32:").</P>
<P>To get to this point, a small uncompressed kernel function
decompresses the remaining compressed kernel image
and then it jumps to the new kernel code.</P>
<P>This is a description of what the "head.S" code does.</P>

<H2><A NAME="ss4.1">4.1 startup_32:</A>
</H2>


<P>swapper_pg_dir is the top-level page directory, address 0x00101000.</P>
<P>On entry, %esi points to the real-mode code as a 32-bit pointer.</P>

<H2><A NAME="ss4.2">4.2 Set segment registers to known values</A>
</H2>


<P>Set the %ds, %es, %fs, and %gs registers to __KERNEL_DS.</P>

<H2><A NAME="ss4.3">4.3 SMP BSP (Bootstrap Processor) check</A>
</H2>


<P>#ifdef CONFIG_SMP</P>
<P>If %bx is zero, this is a boot on the Bootstrap Processor (BSP),
so skip this.  Otherwise, for an AP (Application Processor):</P>
<P>If the desired %cr4 setting is non-zero, turn on the paging options
(PSE, PAE, ...) and skip "Initialize page tables" (jump to "Enable paging").</P>
<P>#endif /* CONFIG_SMP */</P>

<H2><A NAME="ss4.4">4.4 Initialize page tables</A>
</H2>


<P>Begin at pg0 (page 0) and init all pages to 007 (PRESENT + RW + USER).</P>

<H2><A NAME="ss4.5">4.5 Enable paging</A>
</H2>


<P>Set %cr3 (page table pointer) to swapper_pg_dir.</P>
<P>Set the paging ("PG") bit of %cr0 to <BR>
<B>********** enable paging **********</B>.</P>
<P>Jump $ to flush the prefetch queue.</P>
<P>Jump *[$] to make sure that %eip is relocated.</P>
<P>Setup the stack pointer (lss stack_start, %esp).</P>
<P>#ifdef CONFIG_SMP</P>
<P>If this is not the BSP (Bootstrap Processor), clear all flags bits
and jump to checkCPUtype.</P>
<P>#endif /* CONFIG_SMP */</P>

<H2><A NAME="ss4.6">4.6 Clear BSS</A>
</H2>


<P>The BSP clears all of BSS (area between __bss_start and _end)
for the kernel.</P>

<H2><A NAME="ss4.7">4.7 32-bit setup</A>
</H2>


<P>Setup the IDT for 32-bit mode (call setup_idt).
setup_idt sets up an IDT with 256 entries pointing to the default
interrupt handler "ignore_int" as interrupt gates.  It doesn't actually
load the IDT; that can be done only after paging has been enabled
and the kernel moved to PAGE_OFFSET.  Interrupts
are enabled elsewhere, when we can be relatively
sure everything is OK.</P>
<P>Clear the eflags register (before switching to protected mode).</P>

<H2><A NAME="ss4.8">4.8 Copy boot parameters and command line out of the way</A>
</H2>


<P>First 2 KB of _empty_zero_page is for boot parameters,
second 2 KB is for the command line.</P>

<H2><A NAME="ss4.9">4.9 checkCPUtype</A>
</H2>


<P>Initialize X86_CPUID to -1.</P>
<P>Use Flags register, push/pop results, and CPUID instruction(s) to
determine CPU type and vendor:
Sets X86, X86_CPUID, X86_MODEL, X86_MASK, and X86_CAPABILITY.
Sets bits in %cr0 accordingly.</P>
<P>Also checks for presence of an 80287 or 80387 coprocessor.
Sets X86_HARD_MATH if a math coprocessor or floating point unit is found.</P>

<H2><A NAME="ss4.10">4.10 Count this processor</A>
</H2>


<P>For CONFIG_SMP builds, increment the "ready" counter to keep a tally
of the number of CPUs that have been initialized.</P>

<H2><A NAME="ss4.11">4.11 Load descriptor table pointer registers</A>
</H2>


<P>Load GDT with gdt_descr and IDT with idt_descr.
The GDT contains 2 entries for the kernel (4 GB each for code and
data, beginning at 0) and 2 userspace entries (4 GB each for code and
data, beginning at 0).  There are 2 null descriptors between the
userspace descriptors and the APM descriptors.</P>
<P>The GDT also contains 4 entries for APM segments.
The APM segments have byte granularity and their bases and limits
are set at runtime.</P>
<P>The rest of the gdt_table (after the APM segments) is space for
TSSes and LDTs.</P>
<P>Jump to __KERNEL_CS:%eip to cause the GDT to be used.  Now in <BR>
<B>********** protected mode **********</B>.</P>
<P>Reload all of the segment registers:
Set the %ds, %es, %fs, and %gs registers to __KERNEL_DS.</P>
<P>#ifdef CONFIG_SMP</P>
<P>Reload the stack pointer segment only (%ss) with __KERNEL_DS.</P>
<P>#else /* not CONFIG_SMP */</P>
<P>Reload the stack pointer (%ss:%esp) with stack_start.</P>
<P>#endif /* CONFIG_SMP */</P>
<P>Clear the LDT pointer to 0.</P>
<P>Clear the processor's Direction Flag (DF) to 0 for gcc.</P>

<H2><A NAME="ss4.12">4.12 Start other processors</A>
</H2>


<P>For CONFIG_SMP builds,
if this is not the first (Bootstrap) CPU, call initialize_secondary(),
which does not return.  The secondary (AP) processor(s) are
initialized and then enter idle state until processes are
scheduled on them.</P>
<P>If this is the first or only CPU, call start_kernel(). (see below)</P>
<P>/* the calls above should never return, but in case they do: */</P>
<P>L6:  jmp L6</P>

<H2><A NAME="s5">5. Linux architecture-independent initialization</A></H2>


<P>(from "linux/init/main.c")</P>
<P>"linux/init/main.c" begins execution with the start_kernel() function,
which is called from "linux/arch/i386/kernel/head.S".
start_kernel() never returns to its caller.  It ends by calling the
cpu_idle() function.</P>

<H2><A NAME="ss5.1">5.1 start_kernel:</A>
</H2>


<P>Interrupts are still disabled.  Do necessary setups, then enable them.</P>
<P>Lock the kernel (BKL: big kernel lock).</P>
<P>Print the linux_banner string (this string resides in "linux/init/version.c")
using printk().  NOTE:  printk() doesn't actually print this to the console
yet; it just buffers the string until a console device registers itself with
the kernel, then the kernel passes the buffered console log contents to the
registered console device(s).  There can be multiple registered console
devices.</P>
<P>********** printk() can be called very early because it doesn't actually
print to anywhere.  It just logs the message to "log_buf",
which is allocated statically in "linux/kernel/printk.c".
The messages that are saved in "log_buf" are passed to registered
console devices as they register. **********</P>

<H3>More architecture-specific init</H3>


<P>Call setup_arch(&amp;command_line):</P>
<P>This performs architecture-specific initializations
(details below).
Then back to architecture-independent initialization....</P>
<P>The remainder of start_kernel() is done as follows for all
processor architecures, although several of these function
calls are to architecture-specific setup/init functions.</P>

<H3>Continue architecture-independent init</H3>

<P>Print the kernel command line.</P>

<H3>Parsing command line options</H3>


<P>parse_options(command_line):
Parse the kernel options on the command line.
This is a simple kernel command line parsing function.  It parses the
command line and fills in the arguments and environment to init (thread)
as appropriate.  Any command-line option is taken to be an environment
variable if it contains the character '='.
It also checks for options meant for the kernel by calling
checksetup(), which checks the command line for kernel parameters,
these being specified by declaring them using "__setup", as in:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
__setup("debug", debug_kernel);
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>This declaration causes the debug_kernel() function to be
called when the string "debug" is scanned.
See "linux/Documentation/kernel-parameters.txt" for the list of
kernel parameters.</P>
<P>These options are not given to init -- they are for internal kernel
use only.  The default argument list for the init thread is
{"init", NULL}, with a maximum of 8 command-line arguments.
The default environment list for the init thread is
{"HOME=/", "TERM=linux", NULL}, with a maximum of 8
command-line environment variable settings.
In case LILO is going to boot us with default command line,
it prepends "auto" before the whole cmdline which makes
the shell think it should execute a script with such name.
So we ignore all arguments entered _before_ init=... [MJ]</P>

<H3>trap_init</H3>


<P>(in linux/arch/i386/kernel/traps.c)</P>
<P>Install exception handlers for basic processor exceptions,
i.e., not hardware device interrupt handlers.</P>
<P>Install the handler for the system call software interrupt.</P>
<P>Install handlers for lcall7 (for iBCS) and lcall27 (for
Solaris/x86 binaries).</P>
<P>Call cpu_init() to do:
<UL>
<LI> initialize per-CPU state</LI>
<LI> reload the GDT and IDT</LI>
<LI> mask off the eflags NT (Nested Task) bit</LI>
<LI> set up and load the per-CPU TSS and LDT</LI>
<LI> clear 6 debug registers (0, 1, 2, 3, 6, and 7)</LI>
<LI> stts(): set the 0x08 bit (TS: Task Switched) in CR0 to enable
lazy register saves on context switches</LI>
</UL>
</P>

<H3>init_IRQ</H3>


<P>(in linux/arch/i386/kernel/i8259.c)</P>
<P>Call init_ISA_irqs() to initialize the two 8259A interrupt controllers
and install default interrupt handlers for the ISA IRQs.</P>
<P>Set an interrupt gate for all unused interrupt vectors.</P>
<P>For CONFIG_SMP configurations, set up IRQ 0 early, since it's
used before the IO APIC is set up.</P>
<P>For CONFIG_SMP, install the interrupt handler for CPU-to-CPU
IPIs that are used for the "reschedule helper."</P>
<P>For CONFIG_SMP, install the interrupt handler for the IPI that is
used to invalidate TLBs.</P>
<P>For CONFIG_SMP, install the interrupt handler for the IPI that is
used for generic function calls.</P>
<P>For CONFIG_X86_LOCAL_APIC configurations, install the interrupt
handler for the self-generated local APIC timer IPI.</P>
<P>For CONFIG_X86_LOCAL_APIC configurations, install interrupt handlers
for spurious and error interrupts.</P>
<P>Set the system's clock chip to generate a timer tick interrupt
every HZ Hz.</P>
<P>If the system has an external FPU, set up IRQ 13 to handle
floating point exceptions.</P>

<H3>sched_init</H3>


<P>(in linux/kernel/sched.c)</P>
<P>
<UL>
<LI> Set the init_task's processor ID.</LI>
<LI> Clear the pidhash table. TBD: Why? isn't it in BSS?</LI>
<LI> call init_timervecs()</LI>
<LI> call init_bh() to init "bottom half" queues for timer_bh,
tqueue_bh, and immediate_bh.</LI>
</UL>
</P>

<H3>time_init</H3>


<P>(in linux/arch/i386/kernel/time.c)</P>
<P>Initialize the system's current time of day (xtime) from CMOS.</P>
<P>Install the irq0 timer tick interrupt handler.</P>

<H3>softirq_init</H3>


<P>(in linux/kernel/softirq.c)</P>

<H3>console_init</H3>


<P>(in linux/drivers/char/tty_io.c)</P>
<P>HACK ALERT! This is early. We're enabling the console before
we've done PCI setups etc., and console_init() must be aware of
this.  But we do want output early, in case something goes wrong.</P>

<H3>init_modules</H3>


<P>(in linux/kernel/module.c)</P>
<P>For CONFIG_MODULES configurations, call init_modules().
This initializes the size (or number of symbols) of the kernel
symbol table.</P>

<H3>Profiling setup</H3>


<P>if profiling ("profile=#" on the kernel command line):
calculate the kernel text (code) profile "segment" size;
calculate the profile buffer size in pages (round up);
allocate the profile buffer: prof_buffer = alloc_bootmem(size);</P>

<H3>kmem_cache_init</H3>


<P>(in linux/mm/slab.c)</P>

<H3>sti</H3>


<P><B>********** Interrupts are now enabled. **********</B> <BR>
This allows "calibrate_delay()" (below) to work.</P>

<H3>calibrate_delay</H3>


<P>Calculate the "loops_per_jiffy" delay loop value and print
it in BogoMIPS.</P>

<H3>INITRD setup</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
#ifdef CONFIG_BLK_DEV_INITRD

        if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;
                        initrd_start &lt; (min_low_pfn &lt;&lt; PAGE_SHIFT)) {
                printk("initrd overwritten (initrd_start &lt; (min_low_pfn &lt;&lt; PAGE_SHIFT)) - disabling it.\n");
                initrd_start = 0;       // mark initrd as disabled
        }

#endif /* CONFIG_BLK_DEV_INITRD */
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>mem_init</H3>


<P>(in linux/arch/i386/mm/init.c)</P>
<P>
<UL>
<LI> Clear the empty_zero_page.</LI>
<LI> Call free_all_bootmem() and add that released memory to
totalram_pages.</LI>
<LI> Count the number of reserved RAM pages.</LI>
<LI> Print the system memory sizes (free/total), kernel code size, reserved
memory size, kernel data size, kernel "init" size, and the highmem
size.</LI>
<LI> For CONFIG_SMP, call zap_low_mappings().</LI>
</UL>
</P>
<P>********** get_free_pages() can be used after mem_init(). **********</P>

<H3>kmem_cache_sizes_init</H3>


<P>(in linux/mm/slab.c)</P>
<P>Set up remaining internal and general caches.  Called after the
"get_free_page()" functions have been enabled and before smp_init().</P>
<P>********** kmalloc() can be used after kmem_cache_sizes_init(). **********</P>

<H3>proc_root_init</H3>


<P>(in linux/fs/proc/root.c)</P>
<P>For CONFIG_PROC_FS configurations:
<UL>
<LI> call proc_misc_init()</LI>
<LI> mkdir /proc/net</LI>
<LI> for CONFIG_SYSVIPC, mkdir /proc/sysvipc</LI>
<LI> for CONFIG_SYSCTL, mkdir /proc/sys</LI>
<LI> mkdir /proc/fs</LI>
<LI> mkdir /proc/driver</LI>
<LI> call proc_tty_init()</LI>
<LI> mkdir /proc/bus</LI>
</UL>
</P>

<H3>mempages = num_physpages;</H3>



<H3>fork_init(mempages)</H3>


<P>(in linux/kernel/fork.c)</P>
<P>The default maximum number of threads is set to a safe value:
the thread structures can take up at most half of memory.</P>

<H3>proc_caches_init()</H3>


<P>(in linux/kernel/fork.c)</P>
<P>Call kmem_cache_create() to create slab caches for signal_act (signal
action), files_cache (files_struct), fs_cache (fs_struct), vm_area_struct,
and mm_struct.</P>

<H3>vfs_caches_init(mempages)</H3>


<P>(in linux/fs/dcache.c)</P>
<P>Call kmem_cache_create() to create slab caches for buffer_head,
names_cache, filp, and for CONFIG_QUOTA, dquot.</P>
<P>Call dcache_init() to create the dentry_cache and dentry_hashtable.</P>

<H3>buffer_init(mempages)</H3>


<P>(in linux/fs/buffer.c)</P>
<P>Allocate the buffer cache hash table and init the free list. <BR>
Use get_free_pages() for the hash table to decrease TLB misses;
use SLAB cache for buffer heads. <BR>
Setup the hash chains, free lists, and LRU lists.</P>

<H3>page_cache_init(mempages)</H3>


<P>(in linux/mm/filemap.c)</P>
<P>Allocate and clear the page-cache hash table.</P>

<H3>kiobuf_setup()</H3>


<P>(in linux/fs/iobuf.c)</P>
<P>Call kmem_cache_create() to create the kernel iobuf cache.</P>

<H3>signals_init()</H3>


<P>(in linux/kernel/signal.c)</P>
<P>Call kmem_cache_create() to create the "sigqueue" SLAB cache.</P>

<H3>bdev_init()</H3>


<P>(in linux/fs/block_dev.c)</P>
<P>Initialize the bdev_hashtable list heads.</P>
<P>Call kmem_cache_create() to create the "bdev_cache" SLAB cache.</P>

<H3>inode_init(mempages)</H3>


<P>(in linux/fs/inode.c)</P>
<P>
<UL>
<LI> Allocate memory for the inode_hashtable.</LI>
<LI> Intialize the inode_hashtable list heads.</LI>
<LI> Call kmem_cache_create() to create the inode SLAB cache.</LI>
</UL>
</P>

<H3>ipc_init()</H3>


<P>(in linux/ipc/util.c)</P>
<P>For CONFIG_SYSVIPC configurations, call ipc_init().</P>
<P>The various System V IPC resources (semaphores, messages, and shared
memory) are initialized.</P>

<H3>dquot_init_hash()</H3>


<P>(in linux/fs/dquot.c)</P>
<P>For CONFIG_QUOTA configurations, call dquot_init_hash().</P>
<P>
<UL>
<LI> Clear dquot_hash.  TBD: Why? Is it in BSS? Yes.</LI>
<LI> Clear dqstats.     TBD: Why? Is it in BSS? Yes.</LI>
</UL>
</P>

<H3>check_bugs()</H3>


<P>(in linux/include/asm-i386/bugs.h)</P>
<P>
<UL>
<LI> identify_cpu()</LI>
<LI> For non-CONFIG_SMP configurations, print_cpu_info()</LI>
<LI> check_config()</LI>
<LI> check_fpu()</LI>
<LI> check_hlt()</LI>
<LI> check_popad()</LI>
<LI> Update system_utsname.machine{byte 1} with boot_cpu_data.x86</LI>
</UL>
</P>

<H3>Start other SMP processors (as applicable) </H3>


<P>smp_init() works in one of three ways, depending upon the kernel
configuration.</P>
<P>For a uniprocessor (UP) system without an IO APIC
(CONFIG_X86_IO_APIC is not defined), smp_init() is empty -- it
has nothing to do.</P>
<P>For a UP system with (an) IO APIC for interrupt
routing, it calls IO_APIC_init_uniprocessor().</P>
<P>For an SMP system, its main job is to call the architecture-specific
function "smp_boot_cpus()", which does the following.</P>
<P>
<UL>
<LI> For CONFIG_MTRR kernels, calls mtrr_init_boot_cpu(), which must be
done before the other processors are booted.</LI>
<LI> Stores and prints the BSP CPU information.</LI>
<LI> Saves the BSP APIC ID and BSP logical CPU ID (latter is 0).</LI>
<LI> If an MP BIOS interrupt routing table was not found, revert to
using only one CPU and exit.</LI>
<LI> Verify existence of a local APIC for the BSP.</LI>
<LI> If the "maxcpus" boot option was used to limit the number of CPUs
actually used to 1 (not SMP), then ignore the MP BIOS interrupt
routing table.</LI>
<LI> Switch the system from PIC mode to symmetric I/O interrupt mode.</LI>
<LI> Setup the BSP's local APIC.</LI>
<LI> Use the CPU present map to boot the APs serially.  Wait for each
AP to finish booting before starting the next one.</LI>
<LI> If using (an) IO APIC {which is True unless the "noapic" boot option
was used}, setup the IO APIC(s).</LI>
</UL>
</P>

<H3>Start init thread</H3>


<P>We count on the initial thread going OK.</P>
<P>Like idlers, init is an unlocked kernel thread,
which will make syscalls (and thus be locked).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kernel_thread(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>{details below}</P>

<H3>unlock_kernel()</H3>


<P>Release the BKL.</P>

<H3>current->need_resched = 1;</H3>



<H3>cpu_idle()</H3>


<P>This function remains as process number 0.  Its purpose is
to use up idle CPU cycles.  If the kernel is configured for
APM support or ACPI support, cpu_idle() invokes the supported
power-saving features of these specifications.  Otherwise it
nominally executes a "hlt" instruction.</P>
<P>{end of start_kernel()}</P>

<H2><A NAME="ss5.2">5.2 setup_arch</A>
</H2>


<P>(in "linux/arch/i386/kernel/setup.c")</P>

<H3>Copy and convert system parameter data</H3>


<P>Copy and convert parameter data passed from 16-bit
real mode to the 32-bit startup code.</P>

<H3>For RAMdisk-enabled configs (CONFIG_BLK_DEV_RAM)</H3>


<P>Initialize rd_image_start, rd_prompt, and rd_doload from the
real-mode parameter data.</P>

<H3>setup_memory_region</H3>


<P>Use the BIOS-supplied memory map to setup memory regions.</P>

<H3>Set memory limits</H3>


<P>Set values for the start of kernel code, end of kernel code,
end of kernel data, and "_end" (end of kernel code = the "brk"
address).</P>
<P>Set values for code_resource start and end and data_resource
start and end.</P>

<H3>parse_mem_cmdline</H3>


<P>Parse any "mem=" parameters on the kernel command line and
remember them.</P>

<H3>Setup Page Frames</H3>


<P>Use the BIOS-supplied memory map to setup page frames.</P>
<P>Register available low RAM pages with the bootmem allocator.</P>
<P>Reserve physical page 0: "it's a special BIOS page on many boxes,
enabling clean reboots, SMP operation, laptop functions."</P>

<H3>Handle SMP and IO APIC Configurations</H3>


<P>For CONFIG_SMP, reserve the page immediately above page 0 for
stack and trampoline usage, then call smp_alloc_memory()
to allocate low memory for AP processor(s) real mode trampoline code.</P>
<P>For CONFIG_X86_IO_APIC configurations, call find_smp_config()
to find and reserve any boot-time SMP configuration information
memory, such as MP (Multi Processor) table data from the BIOS.</P>

<H3>paging_init()</H3>


<P>paging_init() sets up the page tables - note that the first 8 MB
are already mapped by head.S.</P>
<P>This routine also unmaps the page at virtual kernel address 0, so
that we can trap those pesky NULL-reference errors in the kernel.</P>

<H3>Save the boot-time SMP configuration</H3>


<P>For CONFIG_X86_IO_APIC configurations, call get_smp_config()
to read and save the MP table IO APIC interrupt routing
configuration data.</P>
<P>For CONFIG_X86_LOCAL_APIC configurations, call init_apic_mappings().</P>

<H3>Reserve INITRD memory</H3>


<P>For CONFIG_BLK_DEV_INITRD configurations, if there is enough
memory for the initial RamDisk, call reserve_bootmem() to
reserve RAM for the initial RamDisk.</P>

<H3>Scan for option ROMs</H3>


<P>Call probe_roms() and reserve their memory space resource(s)
if found and valid.  This is done for the standard video BIOS
ROM image, any option ROMs found, and for the system board
extension ROM (space).</P>

<H3>Reserve system resources</H3>


<P>Call request_resource() to reserve video RAM memory.</P>
<P>Call request_resource() to reserve all standard PC I/O system board
resources.</P>
<P>{end of setup_arch()}</P>

<H2><A NAME="ss5.3">5.3 init thread</A>
</H2>


<P>The init thread begins at the init() function in
"linux/init/main.c".  This is always expected to be process
number 1.</P>
<P>init() first locks the kernel and then calls do_basic_setup()
to perform lots of bus and/or device initialization
{more detail below}.  After do_basic_setup(), most kernel
initialization has been completed.  init() then frees
any memory that was specified as being for initialization
only [marked with "__init", "__initdata", "__init_call",
or "__initsetup"] and unlocks the kernel (BKL).</P>
<P>init() next opens /dev/console and duplicates that file
descriptor two times to create stdin, stdout,
and stderr files for init and all of its children.</P>
<P>Finally init() tries to execute the command specified
on the kernel parameters command line if there was one,
or an init program or script if it can find one in
{/sbin/init, /etc/init, /bin/init}, and lastly
/bin/sh.  If init() cannot execute any of these,
it panics ("No init found.  Try passing init= option to kernel.")</P>

<H2><A NAME="ss5.4">5.4 do_basic_setup {part of the init thread}</A>
</H2>


<P>The machine is now initialized.  None of the devices
have been touched yet, but the CPU subsystem is up and
running, and memory and process management works.</P>

<H3>Be the reaper of orphaned children</H3>


<P>The init process handles all orphaned tasks.</P>

<H3>MTRRs</H3>


<P>// SMP init is completed before this. <BR>
For CONFIG_MTRR, call mtrr_init() [in linux/arch/i386/kernel/mtrr.c].</P>

<H3>SYSCTLs</H3>


<P>For CONFIG_SYSCTL configurations, call sysctl_init()
[in linux/kernel/sysctl.c].</P>

<H3>Init Many Devices</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
/*
 * Ok, at this point all CPU's should be initialized, so
 * we can start looking into devices..
 */
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>PCI</H3>


<P>For CONFIG_PCI configurations, call pci_init()
[in linux/drivers/pci/pci.c].</P>

<H3>Micro Channel</H3>


<P>For CONFIG_MCA configurations, call mca_init()
[in linux/arch/i386/kernel/mca.c].</P>

<H3>ISA PnP</H3>


<P>For CONFIG_ISAPNP configurations, call isapnp_init()
[in linux/drivers/pnp/isapnp.c].</P>

<H3>Networking Init</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
        /* Networking initialization needs a process context */
        sock_init();
</PRE>
</CODE></BLOCKQUOTE>

[in linux/net/socket.c]</P>

<H3>Initial RamDisk</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
#ifdef CONFIG_BLK_DEV_INITRD

        real_root_dev = ROOT_DEV;
        real_root_mountflags = root_mountflags;
        if (initrd_start &amp;&amp; mount_initrd)
                root_mountflags &amp;= ~MS_RDONLY;      // change to read/write
        else
                mount_initrd =0;

#endif /* CONFIG_BLK_DEV_INITRD */
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Start the kernel "context" thread (keventd)</H3>


<P>[in linux/kernel/context.c]</P>

<H3>Initcalls</H3>


<P>Call all functions marked as "__initcall": <BR>
<BLOCKQUOTE><CODE>
<PRE>
        do_initcalls();
</PRE>
</CODE></BLOCKQUOTE>

[in linux/init/main.c]</P>
<P>This initializes many functions and some subsystems --- in no specific or
guaranteed order unless fixed in their Makefiles --- if they were built
into the kernel, such as:</P>
<P>
<UL>
<LI> APM: apm_init() {in linux/arch/i386/kernel/apm.c}</LI>
<LI> cpuid: cpuid_init() {in linux/arch/i386/kernel/cpuid.c}</LI>
<LI> DMI: dmi_scan_machine() {in linux/arch/i386/kernel/dmi_scan.c}</LI>
<LI> microcode: microcode_init() {in linux/arch/i386/kernel/microcode.c}</LI>
<LI> MSR: msr_init() {in linux/arch/i386/kernel/msr.c}</LI>
<LI> partitions: partition_setup() {in linux/fs/partitions/check.s}</LI>
<LI> file systems, pipes, buffer and cache management, various binary
format loaders, NLS character sets:
too numerous to list {in linux/fs/*}</LI>
<LI> user cache (for limits): uid_cache_init() {in linux/kernel/user.c}</LI>
<LI> kmem_cpu_cache: kmem_cpucache_init() {in linux/mm/slab.c}</LI>
<LI> shmem: init_shmem_fs() {in linux/mm/shmem.c}</LI>
<LI> kswapd: kswapd_init() {in linux/mm/vmscan.c}</LI>
<LI> networking, TCP/IP, IPv6, sockets, 802.2, SNAP, LLC,
X.25, AX.25, IPX, kHTTPd, ATM LAN emulation (LANE),
IP chains/forwarding, NAT/masquerading, packet matching/filtering/logging,
firewalling, DECnet, bridging,
and other networking protocols too numerous to list {in linux/net/*}</LI>
<LI> drivers, some of which are not exactly device drivers, but
help out with bus/device enumeration and initialization, such as:</LI>
<LI> ACPI: acpi_init() {in linux/drivers/acpi/*}</LI>
<LI> PCI: pci_proc_init() {in linux/drivers/pci/*}</LI>
<LI> PCMCIA controllers {in linux/drivers/pcmcia/*}</LI>
<LI> and...</LI>
<LI> atm drivers {in linux/drivers/atm/*}</LI>
<LI> block drivers {in linux/drivers/block/*}</LI>
<LI> CD-ROM drivers {in linux/drivers/cdrom/*}</LI>
<LI> character drivers {in linux/drivers/char/*}</LI>
<LI> I2O drivers {in linux/drivers/i2o/*}</LI>
<LI> IDE drivers {in linux/drivers/ide/*}</LI>
<LI> input drivers (keyboard/mouse/joystick) {in linux/drivers/input/*}</LI>
<LI> ISDN drivers {in linux/drivers/isdn/*}</LI>
<LI> md, LVM, and RAID drivers {in linux/drivers/md/*}</LI>
<LI> radio drivers {in linux/drivers/media/radio/*}</LI>
<LI> video drivers {in linux/drivers/media/video/*}</LI>
<LI> MTD drivers {in linux/drivers/mtd/*}</LI>
<LI> network drivers, including PLIP, PPP, dummy, Ethernet, bonding,
Arcnet, hamradio, PCMCIA, Token Ring, and WAN</LI>
<LI> SCSI logical and physical drivers {in linux/drivers/scsi/*}</LI>
<LI> sound drivers {in linux/drivers/sound/*}</LI>
<LI> telephony drivers {in linux/drivers/telephony/*}</LI>
<LI> USB host controllers and device drivers {in linux/drivers/usb/*}</LI>
<LI> video frame buffer drivers {in linux/drivers/video/*}</LI>
</UL>
</P>

<H3>Filesystems</H3>


<P>Call filesystem_setup():
<UL>
<LI> init_devfs_fs();  /*  Header file may make this empty  */</LI>
<LI> For CONFIG_NFS_FS configurations, call init_nfs_fs().</LI>
<LI> For CONFIG_DEVPTS_FS configurations, call init_devpts_fs().</LI>
</UL>

[in linux/fs/filesystems.c]</P>

<H3>IRDA</H3>


<P>For CONFIG_IRDA configurations, call irda_device_init(). <BR>
/* Must be done after protocol initialization */ <BR>
[in linux/net/irda/irda_device.c]</P>

<H3>PCMCIA</H3>


<P>/* Do this last */ <BR>
For CONFIG_PCMCIA configurations, call init_pcmcia_ds(). <BR>
[in linux/drivers/pcmcia/ds.c]</P>

<H3>Mount the root filesystem</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
        mount_root();
</PRE>
</CODE></BLOCKQUOTE>

[in linux/fs/super.c]</P>

<H3>Mount the dev (device) filesystem</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
        mount_devfs_fs ();
</PRE>
</CODE></BLOCKQUOTE>

[in linux/fs/devfs/base.c]</P>

<H3>Switch to the Initial RamDisk</H3>


<P>
<BLOCKQUOTE><CODE>
<PRE>
#ifdef CONFIG_BLK_DEV_INITRD

        if (mount_initrd &amp;&amp; MAJOR(ROOT_DEV) == RAMDISK_MAJOR &amp;&amp; MINOR(ROOT_DEV) == 0) {
                // Start the linuxrc thread.
                pid = kernel_thread(do_linuxrc, "/linuxrc", SIGCHLD);
                if (pid > 0)
                        while (pid != wait(&amp;i));
                if (MAJOR(real_root_dev) != RAMDISK_MAJOR
                     || MINOR(real_root_dev) != 0) {
                        error = change_root(real_root_dev,"/initrd");
                        if (error)
                                printk(KERN_ERR "Change root to /initrd: "
                                    "error %d\n",error);
                }
        }

#endif /* CONFIG_BLK_DEV_INITRD */
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>See "linux/Documentation/initrd.txt" for more information on
initial RAM disks.</P>
<P>{end of do_basic_setup()}</P>

<H2><A NAME="s6">6. Glossary</A></H2>


<P>AP:  Application Processor, any x86 processor other than the
Bootstrap Processor on IA-32 SMP systems</P>
<P>ACPI:  Advanced Configuration and Power Interface</P>
<P>APIC:  Advanced Programmable Interrupt Controller</P>
<P>APM:  Advanced Power Management, a BIOS-managed power management
specification for personal computers</P>
<P>BSP:  Bootstrap Processor, the primary booting processor on IA-32
SMP systems</P>
<P>BSS:  Block Started by Symbol: the uninitialized data segment</P>
<P>BKL:  Big Kernel Lock, the Linux global kernel lock</P>
<P>CRn:  Control Register n, i386-specific control registers</P>
<P>FPU:  Floating Point Unit, a separate math coprocessor device</P>
<P>GB:  gigabyte (1024 * 1024 * 1024 bytes)</P>
<P>GDT:  Global Descriptor Table, an i386 memory management table</P>
<P>IA:  Intel Architecture (also i386, x86)</P>
<P>IDT:  Interrupt Descriptor Table, an i386-specific table that contains
information used in handling interrupts</P>
<P>initrd:  initial RAM disk (see "linux/Documentation/initrd.txt")</P>
<P>IPC:  Inter-Process Communication</P>
<P>IPI:  Inter-processor Interrupt, a method of signaling interrupts
between multiple processors on an SMP system</P>
<P>IRDA:  InfraRed Data Association</P>
<P>IRQ:  Interrupt ReQuest</P>
<P>ISA:  Industry Standard Architecture</P>
<P>KB:  kilobyte (1024 bytes)</P>
<P>LDT:  Local Descriptor Table, an i386-specific memory management table
that is used to describe memory for each non-kernel process</P>
<P>MB:  megabyte (1024 * 1024 bytes)</P>
<P>MCA:  Micro Channel Architecture, used in IBM PS/2 computers</P>
<P>MP:  Multi-processor</P>
<P>MSW:  Machine Status Word</P>
<P>MTRR:  Memory Type Range Registers</P>
<P>PAE:  Physical Address Extension: extends the address space to 64 GB
instead of 4 GB</P>
<P>PCI:  Peripheral Component Interconnect, an industry standard
for connecting devices on a local bus in a computer system</P>
<P>PCMCIA:  Personal Computer Memory Card International Association;
defines standards for PCMCIA cards and CardBus PC Cards</P>
<P>PIC:  Programmable Interrupt Controller</P>
<P>PNP:  Plug aNd Play</P>
<P>PSE:  Page Size Extension: allows 4 MB pages</P>
<P>SMP:  Symmetric Multi Processor/Processing</P>
<P>TLB:  Translation Lookaside Buffer, i386-specific processor cache
of recent page directory and page table entries</P>
<P>TSS:  Task State Segment, an i386-specific task data structure</P>
<P>UP:  Uniprocessor (single CPU) system.</P>

<H2><A NAME="s7">7. References</A></H2>


<P>
<OL>
<LI> Tigran Aivazian, "Linux Kernel Internals"
(URL: http://www.moses.uklinux.net/patches/lki.html)</LI>
<LI> Werner Almesberger, x86 Booting.
(URL: ftp://icaftp.epfl.ch/pub/people/almesber/booting/)</LI>
<LI> Werner Almesberger, "LILO Generic boot loader for Linux:
Technical overview."  December 4, 1998.  Included in LILO distribution.</LI>
<LI> Werner Almesberger and Hans Lermen, Using the initial RAM disk (initrd).
(file: linux/Documentation/initrd.txt)</LI>
<LI> H. Peter Anvin, "The Linux/I386 Boot Protocol (file:
linux/Documentation/i386/boot.txt)</LI>
<LI> Michael Beck et al, "Linux Kernel Internals," second edition.
Addison-Wesley, 1998.</LI>
<LI> Ralf Brown's Interrupt List,
URL: http://www.ctyme.com/intr/int.htm {browsable}</LI>
<LI> Ralf Brown's Interrupt List,
URL: http://www.delorie.com/djgpp/doc/rbinter/ix/ {browsable}</LI>
<LI> Ralf Brown's Interrupt List,
URL: http://www.cs.cmu.edu/&nbsp;ralf/files.html {zipped, not browsable}</LI>
<LI> E820 memory sizing method:
URL: http://www.teleport.com/&nbsp;acpi/acpihtml/topic245.htm</LI>
<LI> IBM Personal Computer AT Technical Reference.  1985.</LI>
<LI> IBM Personal System/2(r) and Personal Computer BIOS Interface
Technical Reference, second edition.  1988.</LI>
<LI> Hans Lermen and Martin Mares, "Summary of empty_zero_page layout."
(file: linux/Documentation/i386/zero-page.txt)</LI>
<LI> linux/Documentation directory files</LI>
<LI> Martin Mares, "Video Mode Selection Support." (file: 
linux/Documentation/svga.txt)</LI>
<LI> Scott Maxwell, "Linux Core Kernel Commentary."  Coriolis Press, 1999.</LI>
<LI> Mindshare, Inc., Tom Shanley, "Pentium(r) Pro and Pentium(r) II
System Architecture," second edition.  Addison-Wesley, 1998.</LI>
<LI> Allesandro Rubini, "Linux Device Drivers."  O'Reilly and
Associates, 1998.</LI>
<LI> URL: ftp://linux01.gwdg.de/pub/cLIeNUX/interim/Janet_Reno.tgz</LI>
<LI> URL: http://www.eecs.wsu.edu/~cs640/ (was dead at last check)</LI>
<LI> URL: http://www.linuxbios.org + "Papers"
</LI>
</OL>
</P>

</BODY>
</HTML>
