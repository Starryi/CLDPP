<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>LinuxDoc+Emacs+Ispell-HOWTO</TITLE>
</HEAD>
<BODY>
<H1>LinuxDoc+Emacs+Ispell-HOWTO</H1>

<H2>Author: Philippe MARTIN
     (
<A HREF="mailto:feloy@wanadoo.fr">feloy@wanadoo.fr</A>) <BR>
     Translator: S&eacute;bastien Blondeel
     (
<A HREF="mailto:Sebastien.Blondeel@lifl.fr">Sebastien.Blondeel@lifl.fr</A>)
   </H2>v0.4, 27 February 1998
   
<HR>
<EM>     This document is aimed at writers and translators of Linux HOWTOs or
any other paper for the Linux Documentation Project. It gives them hints at
using tools including Emacs and Ispell.
   </EM>
<HR>
<H2>Appendix</H2>
<H2><A NAME="s1">1. Preamble    </A></H2>

<H2><A NAME="ss1.1">1.1 Copyright     </A>
</H2>

<P>Copyright Philippe Martin 1998<BR>
You may redistribute and/or modify this document as long as you
comply with the terms of the GNU General Public Licence, version 2 or
later.</P>

<H2><A NAME="ss1.2">1.2 Credits     </A>
</H2>

<P>Special thanks go to S&eacute;bastien Blondeel, who is a nasty bugger and
asked me so much about Emacs setup. His clever questions have allowed me to
understand it better and pass the knowledge to you through this
document.</P>

<H2><A NAME="ss1.3">1.3 Comments     </A>
</H2>

<P>Do not hesitate to tell me any thing you think will help make this
document better. I will examine your critics thoroughly.<BR>
Do not hesitate as well to ask me any questions related to topics discussed
here. I will be more than happy to answer them, as they may help me
further improve this document.
<BLOCKQUOTE>Translator note: If the English is ugly, well then that goes to me!</BLOCKQUOTE>
</P>

<H2><A NAME="ss1.4">1.4 Versions     </A>
</H2>

<P>This paper is about the following versions:
<UL>
<LI>Sgml-tools version 0.99,</LI>
<LI>Emacs version 19.34,</LI>
<LI>Ispell version 3.1,</LI>
<LI>All Emacs libraries referred to in this document are distributed
with the above Emacs version, apart from <CODE>iso-sgml</CODE>, which is
distributed with XEmacs, and <CODE>psgml</CODE>, which is a stand-alone library.</LI>
</UL>
</P>


<H2><A NAME="s2">2. Introduction    </A></H2>

<H2><A NAME="ss2.1">2.1 SGML     </A>
</H2>

<P><I>Standard Generalised Mark-up Language</I>, or 
<B>SGML</B>, is a language to define document types.</P>
<P>For instance, one may define the document type <I>recipe</I>, with a
first part presenting the ingredients, a second part introducing the
accessories, a third part giving step by step instructions for baking
the cake, and a nice final picture to show the outcome of it all.</P>
<P>     
This is called a <I>Document Type Definition</I>. 
It does not define what the final product will look like, it only defines
what it may contain.</P>
<P>     
To use the same example again, I'm sure that upon reading my idea
of a recipe, you recognised yours, or your favourite cook's. Nevertheless,
they actually look different: mine have a picture in the upper left corner of
the bathroom cupboard, and the ingredients list can be found in the back
garden, between the swimming pool and the barbecue. Yours?   </P>
<P>     
Thanks to this standard definition, one can write a document,
without taking into account what it will look like in the end to 
the reader.</P>

<H2><A NAME="ss2.2">2.2 The <CODE>LinuxDoc</CODE> Type Definition     </A>
</H2>

<P>This type is used to write, as you might have guessed, 
documents related to Linux.</P>
<P>Such documents are generally built as follows: they start with a title
followed by the name of the author, and the version number and
date. Then comes the abstract (so you don't have to browse through it
before realizing it isn't what you were looking for after all), 
then the contents which show the
structure so that those in a rush can go directly to the part they
want to read.</P>
<P>Then comes a list of chapters, sections, paragraphs. Among these, one
can insert bits of programs, change the font to emphasise a word or a
sentence, insert lists, refer to another part of the document, etc.</P>
<P>To write such a document, you just need to specify at the right time
the title, the author, the date, and the document version, the chapters
and sections, say when a list is to be inserted, what its elements are
etc.</P>

<H2><A NAME="ss2.3">2.3 <CODE>SGML-Tools</CODE></A>
    </H2>

<P><B>SGML-Tools</B> will turn the specification of a document into
the final result in the form you prefer. If you want it in your personal
library, you will choose <I>PostScript</I>. If you want to share it with
the world through the Web, it will be <I>HTML</I>. If you can't help it
and must read it under Windows, you can turn it into <I>RTF</I> to be
able to read it with any word processor. Or maybe use all three formats
to accommodate your changing moods.</P>
<P>SGML-Tools are available via anonymous FTP at 
<A HREF="ftp://ftp.lip6.fr/pub/sgml-tools/">ftp://ftp.lip6.fr/pub/sgml-tools/</A></P>

<H2><A NAME="s3">3. Your first document.     </A></H2>


<H2><A NAME="ss3.1">3.1 From a text document      </A>
</H2>

<P>If you want to turn a text document into SGML to port it to other
formats, this is the way to go:</P>
<P>
<OL>
<LI>Add the following lines at the very beginning:
       
<PRE>
        &lt;!doctype linuxdoc system>
         &lt;article>
          &lt;title>Title Goes Here&lt;/title>
          &lt;author>
           name of author, author's e-mail, etc.
          &lt;/author>
          &lt;date>
           version and date 
          &lt;/date>
       
</PRE>

       </LI>
<LI>If you describe briefly the contents of the document in the
beginning, surround that paragraph with the 
<CODE>&lt;abstract&gt;</CODE> and <CODE>&lt;/abstract&gt;</CODE> tags.
       </LI>
<LI>Then insert the <CODE>&lt;toc&gt;</CODE> tag, which stands for <EM>Table
Of Contents</EM>. 
</LI>
<LI>At the beginning of each new chapter, replace the line giving the
number and title of the chapter with: 

<PRE>
       &lt;sect>The Title Of The Chapter
       
</PRE>

and add the <CODE>&lt;/sect&gt;</CODE> tag at the end of the
chapter.<BR>
<P><B>Note&nbsp;:</B> You don't have to put the chapter number, this
is done automatically.</P>

</LI>
<LI>Proceed in the same way for sections. You need to
delete their numbers and tag their titles with <CODE>&lt;sect1&gt;</CODE>
and they end with <CODE>&lt;/sect1&gt;</CODE>.
</LI>
<LI>You can also define as many as 4 levels of nesting in the sections,
using <CODE>&lt;sectn&gt;</CODE> and <CODE>&lt;/sectn&gt;</CODE> where
<CODE>n=</CODE> 2, 3, or 4 in a similar way.
</LI>
<LI>In the beginning of each paragraph, insert the <CODE>&lt;p&gt;</CODE>
tag.
</LI>
<LI>If you need to emphasise some parts, tag them with
<CODE>&lt;it&gt;</CODE> and <CODE>&lt;/it&gt;</CODE>
(<I>italics</I>), <CODE>&lt;bf&gt;</CODE> and <CODE>&lt;/bf&gt;</CODE>
(<B>bold face</B>), or <CODE>&lt;tt&gt;</CODE> and <CODE>&lt;/tt&gt;</CODE>
(<CODE>typewriter style</CODE>).
</LI>
<LI>To insert a list like the following one: 

<PRE>
        This is a four lines list:

         - first line goes here
         - second line comes next
         - yet another one
         - that's it.
       
</PRE>

       
you must replace it with:
       
<PRE>
        This is a four lines list:
       &lt;itemize>
       &lt;item>first line goes here
       &lt;item>second line come next
       &lt;item>yet another one
       &lt;item>that's it.
       &lt;/itemize>
        
</PRE>

</LI>
<LI>When a whole block is a part of a program, or something else that
needs to stick out: 

<PRE>
       &lt;verb>
        10 REM Oh my God what's this?
        20 REM I thought this had long disappeared!
        30 PRINT "I am back to";
        40 PRINT "save the world."
        50 INPUT "From whom, do you reckon? ",M$
        60 IF M$="Bill" THEN PRINT "Thou art wise.":GOTO PARADISE
        70 ELSE PRINT "You ain't got a clue...":GOTO RICHMOND
        &lt;/verb>
       
</PRE>

</LI>
<LI>Thus far, your SGML formating skills are fairly decent. If you want to
refine your document, you may have a look at the user's guide for
<B>SGML-Tools</B>, which gives more details about the
<B>LinuxDoc</B> document type.
</LI>
</OL>
</P>
<H2><A NAME="s4">4. Configuring <CODE>Emacs</CODE></A>    </H2>


<H2><A NAME="ss4.1">4.1 Accented Characters      </A>
</H2>

<P>If you want to write documents in French or in any other western
European language, you will need 8-bit characters. This is how to set Emacs
up to tell it to accept such characters.</P>

<H3>The displaying of 8-bit characters       </H3>

<P>To let Emacs display 8-bit characters, you will need the following
lines in your <CODE>.emacs</CODE> file:
<PRE>
       (standard-display-european 1)
       (load-library "iso-syntax")
       
</PRE>
</P>
<P>If you are using Emacs on a terminal which has no 8-bit support, you
can use the <CODE>iso-ascii</CODE> library (<CODE>(load-library "iso-ascii")</CODE>), 
which tells Emacs to display such characters to its best approximation.</P>

<H3>The typing of 8-bit characters       </H3>

<P>If your keyboard allows you to enter accented characters, no
problem. If not here are some remedies:</P>

<H3>The <CODE>iso-acc</CODE> library       </H3>

<P>The Emacs <CODE>iso-acc</CODE> library will let you type 8-bit
characters from a 7-bit keyboard.</P>
<P>To use it, insert the following in your <CODE>.emacs</CODE> file:
<PRE>
      (load-library "iso-acc")
      
</PRE>
</P>
<P>Then, upon running Emacs and opening the file you need to edit, type
<CODE>Meta-x iso-accents-mode</CODE>.</P>
<P>You can then enter the <B>&eacute;</B> of the French word <EM>caf&eacute;</EM>
typing <B>'</B> then <CODE>e</CODE>. More generally, you will type an
accented character typing the accent first, then the letter to accent
(upper or lower case). The following are the accents you may use:</P>
<P>
<LI><CODE>'</CODE>&nbsp;: Acute</LI>
<LI><CODE>`</CODE>&nbsp;: Grave</LI>
<LI><CODE>^</CODE>&nbsp;: Circumflex</LI>
<LI><CODE>"</CODE>&nbsp;: Dieresis</LI>
<LI><CODE>~</CODE>&nbsp;: Tilde, cedilla, and other particular
cases (cf iso-acc.el).</LI>
<LI><CODE>/</CODE>&nbsp;: To bar a letter, etc.</LI>
      </P>
<P>If you need one of these characters and not an accented letter, type
a space next to it. For instance, to type 
<I>l'&eacute;l&eacute;phant</I>, type <CODE>l ' spc ' e l ' e ...</CODE></P>
<P>You will find all the possible combinations in the 
<CODE>iso-acc.el</CODE> file.</P>

<H3>The Meta key       </H3>

<P>Some terminals will let you type 8-bit characters with the 
Meta (or Alt) key. For example, pressing
<B>Meta-i</B> will get you the <B>&eacute;</B> character.</P>
<P>But Emacs reserved the Meta key for other uses, and I know
of no library which lets you use it for accented characters.</P>
<P>This is a solution:</P>
<P>
<PRE>
      (global-set-key "\ei" '(lambda () (interactive) (insert ?\351)))
                         _                                      ___
      
</PRE>
</P>
<P>Such a line, if inserted in your 
<CODE>.emacs</CODE> file, will let you type
<B>&eacute;</B> using the <B>Meta-i</B> keystroke. 
You can redefine in such a way the combinations you need
if you replace <B>i</B> with the right key and 
<B>351</B> with the right code (the code being taken from the 
ISO-8859-1 character set).</P>
<P><B>Warning!</B> Some local modes may redefine such key
combinations.</P>

<H3>The displaying of 8-bit SGML characters       </H3>

<P>Under SGML, you can type accented characters with macros. For
example, the <B>&eacute;</B> key is <B>&amp;eacute;</B>. Generally, the applications
that need to read SGML can read 8-bit characters and there is no need to
use these macros. But some may not be able to do so. Given that there is a
way to solve this problem, it would be a waste to let these crash.</P>
<P>The <CODE>iso-sgml</CODE> library will let you type accented characters
under Emacs, like always, but upon saving your file to the disk, it will
turn these 8-bit characters into their SGML equivalent.</P>
<P>It is therefore easy, thanks to this library, to type and reread
your document under Emacs, and you can be sure a non 8-bit clean
application will accept you document. </P>
<P>To use this library, you just need to add the following lines to your
<CODE>.emacs</CODE> file:</P>
<P>
<PRE>
      (setq sgml-mode-hook
      '(lambda () "Defaults for SGML mode."
       (load-library "iso-sgml")))
      
</PRE>
</P>

<H2><A NAME="ss4.2">4.2 SGML mode      </A>
</H2>

<P>Upon loading a file with the <B>.sgml</B> extension,
Emacs enters the <B>sgml mode</B> automatically. If it doesn't, you
can tell it to do so manually by typing <CODE>Meta-x sgml-mode</CODE>, or 
automatically by adding the following lines to your <CODE>.emacs</CODE> file:</P>
<P>
<PRE>
      (setq auto-mode-alist
      (append '(("\.sgml$"  . sgml-mode))
                auto-mode-alist))
     
</PRE>
</P>
<P>This mode will let you choose how to insert 8-bit characters for
example. With <CODE>Meta-x sgml-name-8bit-mode</CODE> (or the menu item
<I>SGML/Toggle 8-bit insertion</I>), you can choose to type 8-bit
characters as is, or in SGML form, i.e. in the form <B>&amp;...;</B>.</P>
<P>It will as well let you hide or show SGML tags, with <CODE>Meta-x
sgml-tags-invisible</CODE> (or the menu item <I>SGML/Toggle Tag
Visibility</I>).</P>


<H2><A NAME="ss4.3">4.3 PSGML mode     </A>
</H2>

<P>PSGML mode helps a lot to edit SGML documents with Emacs.</P>
<P>The 
<A HREF="http://www.linux-france.com/article/psgml-linuxdoc">psgml-linuxdoc</A>
documentation explains how to install this mode and use it with 
<I>LinuxDoc</I>. </P>

<H2><A NAME="ss4.4">4.4 Miscellaneous      </A>
</H2>


<H3>auto-fill mode       </H3>

<P>In the normal mode, when you type a paragraph and get to the end of
the line, you must use the 
Return key yourself to get to the next line, or else your line
goes on through the whole paragraph.  When you use 
Return to get to the next line, you get a paragraph
with ragged right margins.</P>
<P>If you let some lines go beyond a
reasonable width, you won't be able to see them with some editors.</P>
<P>The <B>auto-fill</B> mode automates this boring task: when you go
further than a certain column (the 70th by default), you are automatically
taken to the next line.</P>
<P>This is how to use this mode, and set the width of your lines to 80:</P>
<P>
<PRE>
       (setq sgml-mode-hook
             '(lambda () "Defaults for SGML mode."
                 (auto-fill-mode)       
                 (setq fill-column 80)))
       
</PRE>
</P>

<H2><A NAME="s5">5. Ispell     </A></H2>

<P>If you want to spell-check your document from within Emacs, you may
use the <B>Ispell</B> package and its Emacs mode.</P>

<H2><A NAME="ss5.1">5.1 Choosing your default dictionaries      </A>
</H2>

<P>You can set up Emacs so that upon loading a file, it chooses
automatically which dictionaries to use (you can use several). The first
one, certainly the most important, is the main dictionary, distributed
with Ispell. You can choose among several languages. The second one is
your personal dictionary, where Ispell will insert words it couldn't
find in the main dictionary but you told it to remember. </P>
<P>If you wish to use as a default dictionary the French dictionary
that comes with Ispell, and if you wish to use the file
<CODE>.ispell-dico-perso</CODE> in your home directory as a personal
dictionary, insert the following lines in your <CODE>.emacs</CODE> file:</P>
<P>
<PRE>
       (setq sgml-mode-hook
       '(lambda () "Defauts for SGML mode."
       (setq ispell-personal-dictionary "~/.ispell-dico-perso")
       (ispell-change-dictionary "francais")
       ))
       
</PRE>
</P>

<H2><A NAME="ss5.2">5.2 Selecting special dictionaries for certain files      </A>
</H2>

<P>You may have a little problem if you do not spell-check documents in
the same language at all times. If you translate documents, it is very
likely that you swap languages (and dictionaries) very often.</P>

<P>I don't know of any Lisp way of selecting, either automatically, or
with a single mouse click, the main and personal dictionaries associated
to the language currently being used. (If you do, please tell me!)</P>

<P>However, it is possible to indicate, at the end of the file, which
dictionaries you want to use for the current file (and only this one).
It suffices to add them as commentaries, so that Ispell can read them
upon launching a spell-check:</P>
<P>
<PRE>
      &lt;!-- Local IspellDict: english -->
      &lt;!-- Local IspellPersDict: ~/emacs/.ispell-english -->
     
</PRE>
</P>
<P>If you have previously defined, in your <CODE>.emacs</CODE> file, that
your default dictionaries are the French dictionaries, then you can add
these lines in the end of any file written in English.</P>

<H2><A NAME="ss5.3">5.3 Spell-checking your document       </A>
</H2>

<P>To spell-check the whole of your document, use, from anywhere in
the document the <CODE>Meta-x ispell-buffer</CODE> command. You may as well
only run the checking on a region in your document:</P>
<P>
<UL>
<LI> Mark the beginning of the region with <CODE>Ctrl-Spc</CODE>
(mark-set-command),</LI>
<LI> Go to the end of the region to check,</LI>
<LI> type <CODE>Meta-x ispell-region</CODE>.</LI>
</UL>
</P>
<P>Emacs then runs Ispell. Upon meeting an unknown word, this one
shows you said word (usually highlighted) and prompts you for a key:</P>
<P>
<UL>
<LI><B>spc </B>accepts the word, this time only,</LI>
<LI><B>i </B>accepts the word and inserts it in your personal
dictionary, </LI>
<LI><B>a </B>accepts the word for this session,</LI>
<LI><B>A </B>accepts the word for this file, and inserts it
in the local file dictionary</LI>
<LI><B>r </B>allows you to correct the word by hand</LI>
<LI><B>R </B>allows you to correct all the occurrences of the
misspelled word,</LI>
<LI><B>x </B>stops the checking, and puts the cursor back in
place,</LI>
<LI><B>X </B>stops the checking and leaves the cursor where
it is, letting you correct your file; you will be able to continue the
spell-checking later if you type <CODE>Meta-x ispell-continue</CODE>,</LI>
<LI><B>? </B>gives you online help.</LI>
</UL>
</P>
<P>If ispell finds one or several words close to the unknown one, it
will show them in a little window, each one of them preceded by a digit.
Just type this digit to replace the misspelled word with the corresponding
word.</P>

<H2><A NAME="ss5.4">5.4 Personal dictionary versus local file dictionary       </A>
</H2>

<P>The <B>i</B> key will let you insert a word in your personal
dictionary, whereas <B>A</B> will let you insert a word in the local
file dictionary.</P>

<P>The local file dictionary is a sequence of words inserted at the
end of the file, as comments, reread by Ispell each time it is run on
the file. This way, you can accept some words, acceptable in this file, 
but not necessarily acceptable in other files.</P>

<P>As far as I am concerned, I think it is better that the personal
dictionary be reserved for words the main dictionary doesn't know but
which belong to the language (like hyphenated words), plus some common
words like proper nouns or others (like <I>Linux</I>), if they don't
look too much like a real word of the main dictionary; adding too many
words in the personal dictionary, such as first names, may be dangerous,
because they may look like a word of the language (one can imagine
Ispell being mystified on the following:
`<I>When the going gets tof, the tof get going</I>
<BLOCKQUOTE><EM>Tof</EM> is a French abbreviation for the first name
<EM>Christophe</EM>.</BLOCKQUOTE>
'!).</P>

<H2><A NAME="ss5.5">5.5 Typing spell-checking       </A>
</H2>

<P>Ispell can spell-check your file while you're typing. You need to
use <B>ispell-minor-mode</B> for this. To start it or stop it, type
<CODE>Meta-x ispell-minor-mode</CODE>. Ispell will <EM>beep</EM> you each
time you type a word it doesn't know.</P>

<P>If those <EM>beeps</EM> hassle you (or your roommate 
is taking a nap), you can replace those annoying <EM>beeps</EM> 
with a flash on the screen, with
the command <CODE>Meta-x set-variable RET visible-bell RET t RET</CODE>. You
can add the following line in your <CODE>.emacs</CODE> and silence Emacs 
forever:</P>
<P>
<PRE>
       (setq visible-bell t)
      
</PRE>
</P>

<H2><A NAME="s6">6. Dirty Tricks    </A></H2>

<H2><A NAME="ss6.1">6.1 Inserting a header automatically     </A>
</H2>

<P>Emacs allows you to <EM>hook</EM> some actions to any event
(opening of a file, saving, running a new mode, etc).</P>

<P>The <B>autoinsert</B> library uses this feature: when you open a
new file under Emacs, this library inserts, according to the type of the
file, a <EM>standard</EM> header.</P>

<P>In our case, this <EM>standard</EM>
header could well be the part declaring
the document type (LinuxDoc), the title, the author, and the date.</P>

<P>I will describe here two ways to insert such a header. You could
insert a template file containing the information to insert, or you could run
an <B>elisp</B> routine.</P>

<H3>by inserting a file     </H3>

<P>You must first tell Emacs to run the <CODE>auto-insert</CODE> when
opening a file, then to read the <B>autoinsert</B> library which
declares the <CODE>auto-insert-alist</CODE> list which we need to change. This
list defines the header to insert for each file type. By default, the
file to insert must be in the <CODE>~/insert/</CODE> directory, but it is
possible to redefine the <CODE>auto-insert-directory</CODE> variable
if you want to put it somewhere else.</P>

<P>Add the following lines to your <CODE>.emacs</CODE> file to insert the
<CODE>~/emacs/sgml-insert.sgml</CODE> file each time you open a new SGML
file:</P>
<P>
<PRE>
      (add-hook 'find-file-hooks 'auto-insert)
      (load-library "autoinsert")
      (setq auto-insert-directory "~/emacs/")
      (setq auto-insert-alist
            (append '((sgml-mode .  "sgml-insert.sgml"))
                    auto-insert-alist))
      
</PRE>
</P>
<P>You can then write in the <CODE>~/emacs/sgml-insert.sgml</CODE> file
your customised header, then re-run Emacs and open some
<CODE>foobar.sgml</CODE> file. Emacs should ask you to confirm the automatic
insertion, and if you answer yes, insert your header.</P>

<H3>by running a routine     </H3>

<P>This works like before, but instead of setting the
<CODE>auto-insert-alist</CODE> to a file to insert, you need to set it to a
function to execute. This is how to proceed, taking for granted you want
to write this function in a file named <CODE>~/emacs/sgml-header.el</CODE>.
(there's no need to burden your <CODE>.emacs</CODE> file with such a
function, as it may turn out to be quite long):</P>
<P>
<PRE>
      (add-hook 'find-file-hooks 'auto-insert)
      (load-library "autoinsert")
      (add-to-list 'load-path "~/emacs")
      (load-library "sgml-header")
      (setq auto-insert-alist
            (append '(((sgml-mode .  "SGML Mode") . insert-sgml-header))
                    auto-insert-alist))
      
</PRE>
</P>
<P>You will find in 
<A HREF="#insert-sgml-header">appendix</A> an
example of <CODE>insert-sgml-header</CODE> function.</P>


<H2><A NAME="insert-sgml-header"></A> <A NAME="s7">7. An <CODE>insert-sgml-header</CODE> function </A>   </H2>

<P>This function will let the user insert a customised header for a
Linux Documentation Project document in a file. It can be called
automatically when one opens a new file, or explicitly, by the user.</P>

<P>This function prompts the user, through the <EM>mini-buffer</EM>,
for some pieces of information, some of which are necessary, some of which are
not.</P>
<P>First comes the title. If none is given, the function returns
immediately, and inserts nothing. Then comes the date, the author, his
e-mail and home page (these last two are optional).</P>
<P>Then comes a request for the name of the translator. If there is
none, just type <EM>Return</EM>, and no further prompting about a
hypothetical translator will be done. If there is one, you are asked for
his e-mail and home page (optional as well).</P>
<P>This function then prints your request to the current buffer,
including of course all the information you typed in a set up form, and
including as well the tags which will serve for the abstract and the
first chapter. It finally puts the cursor
in the place where the abstract needs to be typed.</P>
<P>
<PRE>
(defun insert-sgml-header ()
  "Inserts the header for a LinuxDoc document"
  (interactive)
  (let (title author email home translator email-translator home-translator date 
              starting-point)
    (setq title (read-from-minibuffer "Title: "))
    (if (> (length title) 0)
        (progn 
          (setq date (read-from-minibuffer "Date: ")
                author (read-from-minibuffer "Author: ")
                email (read-from-minibuffer "Author e-mail: ")
                home (read-from-minibuffer "Author home page: http://")
                translator (read-from-minibuffer "Translator: "))
          (insert "&lt;!doctype linuxdoc system>\n&lt;article>\n&lt;title>")
          (insert title)
          (insert "&lt;/title>\n&lt;author>\nAuthor: ") (insert author) (insert "&lt;newline>\n")
          (if (> (length email) 0)
              (progn
                (insert "&lt;htmlurl url=\"mailto:")
                (insert email) (insert "\" name=\"") (insert email)
                (insert "\">&lt;newline>\n")))
          (if (> (length home) 0)
              (progn
                (insert "&lt;htmlurl url=\"http://")
                (insert home) (insert "\" name=\"") (insert home)
                (insert "\">\n&lt;newline>")))
          (if (> (length translator) 0)
              (progn
                (setq email-translator (read-from-minibuffer "Translator e-mail: ")
                      home-translator (read-from-minibuffer "Translator home page: http://"))
                (insert "Translator : ") 
                (insert translator) 
                (insert "&lt;newline>\n")
                (if (> (length email-translator) 0)
                    (progn 
                      (insert "&lt;htmlurl url=\"mailto:") 
                      (insert email-translator) (insert "\" name=\"") 
                      (insert email-translator)
                      (insert "\">&lt;newline>\n")))
                (if (> (length home-translator) 0)
                    (progn 
                      (insert "&lt;htmlurl url=\"http://") 
                      (insert home-translator) (insert "\" name=\"")
                      (insert home-translator)
                      (insert "\">&lt;newline>\n")))))
          (insert "&lt;/author>\n&lt;date>\n")
          (insert date)
          (insert "\n&lt;/date>\n\n&lt;abstract>\n")
          (setq point-beginning (point))
          (insert "\n&lt;/abstract>\n&lt;toc>\n\n&lt;sect>\n&lt;p>\n\n\n&lt;/sect>\n\n&lt;/article>\n")
          (goto-char point-beginning)
          ))))
 
</PRE>
</P>
</BODY>
</HTML>
