<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>5. Keyboard numbering(order of detection)</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="XFree Local Multi-User HOWTO"><link rel="up" href="ch03.html" title="Chapter 3. Installing the kernel"><link rel="prev" href="ch03s04.html" title="4. Notes on using multiple VT's &amp; VGA console"><link rel="next" href="ch04.html" title="Chapter 4. Setting up the X servers"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Keyboard numbering(order of detection)</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s04.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Installing the kernel</th><td width="20%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="inst_kern_kbd"></a>5. Keyboard numbering(order of detection)</h2></div></div></div><p>In the following chapters you will read about 1st keyboard, 2nd keyboard and so on, so here I will explain what is meant by n-th keyboard.  </p><p>When a keyboard device is found, it is bound to a free VT (given that there are free VT's). The first keyboard found will be bound to VT0 (tty1-tty16), the second to VT1 (tty17), the third to VT2 (tty18).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Older versions of the bruby patch (released before Oct 7 2003) use :</p><p>first keyboard found =&gt; VT0 (tty0-tty7)</p><p>second =&gt; VT1 (tty8-tty15)</p><p>third =&gt; VT2 (tty16-tty23)</p></div><p>The order of detecting the keyboards depends on the configuration of your kernel :</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>If you are using kernel with integrated USB input the USB keyboard devices will be registered first, then the AT/PS2 keyboards will follow when the modules are loaded</p></li><li class="listitem"><p>If you are using kernel with integrated PS2 input the AT/PS2 keyboard devices will be registered first, then the USB keyboards will follow when the modules are loaded</p></li><li class="listitem"><p>If you are using kernel with integrated PS2 &amp; USB input the AT/PS2 keyboard devices will be registered first, then the USB keyboards will follow</p></li></ul></div><p>But there are some caveats:</p><p>Most USB keyboards represent themselves as more than one keyboard; it is common that the multimedia keys or the number-pad identify themselves as a different keyboard device. So if you are running a kernel with integrated USB input and have one USB keyboard with multimedia keys and one PS2 keyboard, the USB keyboard will be bound to VT0(real keyboard) and VT1(multimedia keys), the PS2 keyboard will be bound to VT2 (in case you have enough DUMB consoles).</p><p>There are several ways to work around these issues. Here I'll explain the easiest way to follow.  It's definitely not the best one, but the shortest explanation, and I just want to make it clear to you that the problem is not that big. The better solutions will follow later in their own section. </p><p>All you need to do is to start the Backstreet Ruby/ Ruby kernel with dumbcon=n , where n is the sum of your AT/PS2 keyboards plus the sum of your USB keyboards multiplied by 2 (I suppose this is the maximum number of interfaces a USB keyboard registers), so all keyboards will be bound to a VT. Now you should find out which VT's the real keyboards are bound to (the keyboards excluding the multimedia keys) and start X using the appropriate tty ranges. Thanks to the proc interface integrated in Backstreet Ruby, you can easily find the assignment of keyboards to VT's. Each VT creates a file  <code class="filename">/proc/bus/console/[n]/keyboard</code>  (n is the number of the VT, for VT0 n will be 00, for VT1 - 01, ... , for VT11 - 11); reading this file will give you the assigned keyboard.
 </p><pre class="screen">[root@svetljo root]# cat /proc/bus/console/*/*
usb-00:10.1-1.1/input0
usb-00:10.1-1.1/input1
isa0060/serio0/input0</pre><p>tells us that: 
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>USB keyboard (real) is bound to VT0</p></li><li class="listitem"><p>USB keyboard (multimedia keys) is bound to VT1</p></li><li class="listitem"><p>PS2 keyboard is bound to VT2</p></li></ul></div><p>Now we can start X on the VT's with real keyboards, in this case VT0 and VT2.</p><p>Of course in this simple example with only 2 keyboards (one USB and one PS2) the problem could be easily avoided by using a kernel with primary PS2 input support. The PS2 keyboard would be found first and bound to VT0, the USB keyboard would follow and it's real keyboard interface would be bound to VT1, so there is no need for additional dumb consoles (for the multimedia interfaces of USB keyboards).</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Notes on using multiple VT's &amp; VGA console </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. Setting up the X servers</td></tr></table></div></body></html>
