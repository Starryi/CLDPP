<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3. What advantages does framebuffer devices have?</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Framebuffer HOWTO"><link rel="up" href="index.html" title="Framebuffer HOWTO"><link rel="prev" href="ar01s02.html" title="2. What is a framebuffer device?"><link rel="next" href="ar01s04.html" title="4. Using framebuffer devices on x86 platforms"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. What advantages does framebuffer devices have?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm134"></a>3. What advantages does framebuffer devices have?</h2></div></div></div><p>Penguin logo! :o) Seriously, the major advantage of the
			framebuffer devices is that it presents a generic
			interface across all platforms. It was the case until
			late in the 2.1.x kernel development process that the
			x86 platform had console drivers completely different
			from the other console drivers for other platforms.
			With the introduction of the 2.1.109 kernel, all this
			has changed for the better, and introduced more uniform
			handling of the console under the x86 platforms and
			also introduced true bitmapped graphical consoles
			bearing the Penguin logo on x86 for the first time, and
			allowed code to be shared across different platforms.
			Note that 2.0.x kernels do not support framebuffer
			devices, but it is possible someday someone will
			backport the code from the 2.1.x kernels to 2.0.x
			kernels.  There is an exception to that rule in that
			the 0.9.x kernel port for m68k platforms does have the
			framebuffer device support included.</p><p><span class="emphasis"><em>With the release of the 2.2.x kernels,
				framebuffer device support is very solid and
				stable. You should use the framebuffer device
				if your graphic card supports it, if you are
				using 2.2.x kernels. Older 2.0.x kernels does
				not support framebuffer devices, at least on
				the x86 platform.</em></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0.9.x - introduced m68k framebuffer
					devices. Note that m68k 0.9.x is
					functionally equivalent to x86 1.0.9
					(plus 1.2.x
					enhancements)</p></li><li class="listitem"><p>2.1.107 - introduced x86
					framebuffer/new console devices and
					added generic support, without
					scrollback buffer
					support.</p></li><li class="listitem"><p>2.1.113 - scrollback buffer support
					added to vgacon.</p></li><li class="listitem"><p>2.1.116 - scrollback buffer support
					added to vesafb.</p></li><li class="listitem"><p>2.2.x - includes matroxfb (Matrox
					cards) and atyfb (ATI
					cards).</p></li></ul></div><p>There are some cool features of the framebuffer devices,
			in that you can give generic options to the kernel at
			bootup-time, including options specific to a particular
			framebuffer device. These are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">video=xxx:off</code> - disable
					probing for a particular framebuffer
					device</p></li><li class="listitem"><p><code class="code">video=map:octal-number</code> -
					maps the virtual consoles (VCs) to
					framebuffer (FB)
					devices</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">video=map:01</code> will
						map VC0 to FB0, VC1 to FB1, VC2
						to FB0, VC3 to
						FB1...</p></li><li class="listitem"><p><code class="code">video=map:0132</code>
						will map VC0 to FB0, VC1 to
						FB1, VC2 to FB3, VC4 to FB2,
						VC5 to FB0...</p></li></ul></div></li></ul></div><p>Normally framebuffer devices are probed for in the order
			specified in the kernel, but by specifying the
			<code class="code">video=xxx</code> option, you can add the specific
			framebuffer device you want probed before the others
			specified in the kernel.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. What is a framebuffer device? </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. Using framebuffer devices on x86 platforms</td></tr></table></div></body></html>
