<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Framebuffer HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content=" This document describes how to use the framebuffer devices in Linux with a variety of platforms. This also includes how to set up multi-headed displays."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="Framebuffer-HOWTO"></a>Framebuffer HOWTO</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Alex</span> <span class="surname">Buell</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:alex.buell@munted.org.uk">alex.buell@munted.org.uk</a>&gt;</code></p></div></div></div></div><div><p class="pubdate">2010-08-05, version 1.3</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision v1.3</td><td align="left">2010-08-05</td></tr><tr><td align="left" colspan="2">Converted to DocBook from
					LinuxDoc</td></tr><tr><td align="left">Revision v1.2</td><td align="left">2000-01-22</td></tr><tr><td align="left" colspan="2">Last public release</td></tr><tr><td align="left">Revision v1.1</td><td align="left">1999-07-22</td></tr><tr><td align="left" colspan="2">With some additional information</td></tr><tr><td align="left">Revision v1.0</td><td align="left">1999-06-07</td></tr><tr><td align="left" colspan="2">First public release</td></tr></table></div></div><div><div class="abstract"><p class="title"><b></b></p><p>This document describes how to use the
				framebuffer devices in Linux with a variety of
				platforms. This also includes how to set up
				multi-headed displays.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idm34">1. Contributors</a></span></dt><dt><span class="section"><a href="#idm131">2. What is a framebuffer device?</a></span></dt><dt><span class="section"><a href="#idm134">3. What advantages does framebuffer devices have?</a></span></dt><dt><span class="section"><a href="#idm168">4. Using framebuffer devices on x86 platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idm170">4.1. What is vesafb?</a></span></dt><dt><span class="section"><a href="#idm179">4.2. How do I activate the vesafb drivers?</a></span></dt><dt><span class="section"><a href="#idm235">4.3. What VESA modes are available to me?</a></span></dt><dt><span class="section"><a href="#idm317">4.4. Got a Matrox card?</a></span></dt><dt><span class="section"><a href="#idm361">4.5. Got a Permedia card?</a></span></dt><dt><span class="section"><a href="#idm452">4.6. Got an ATI card?</a></span></dt><dt><span class="section"><a href="#idm521">4.7. Which graphic cards are VESA 2.0 compliant?</a></span></dt><dt><span class="section"><a href="#idm567">4.8. Can I compile vesafb as a module?</a></span></dt><dt><span class="section"><a href="#idm570">4.9. How do I modify the cursor</a></span></dt></dl></dd><dt><span class="section"><a href="#idm591">5. Using framebuffer devices on m68k platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idm593">5.1. Atari platforms</a></span></dt><dt><span class="section"><a href="#idm773">5.2. Amiga platforms</a></span></dt></dl></dd><dt><span class="section"><a href="#idm899">6. Using framebuffer devices on PowerPC platforms</a></span></dt><dt><span class="section"><a href="#idm902">7. Using framebuffer devices on Alpha platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idm904">7.1. What modes are available?</a></span></dt><dt><span class="section"><a href="#idm907">7.2. Which graphic cards can work on Alpha?</a></span></dt></dl></dd><dt><span class="section"><a href="#idm914">8. Using framebuffer devices on SPARC platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idm916">8.1. Which graphic cards can work on the SPARC</a></span></dt><dt><span class="section"><a href="#idm954">8.2. Configuring the framebuffer devices</a></span></dt></dl></dd><dt><span class="section"><a href="#idm995">9. Using framebuffer devices on MIPS platforms</a></span></dt><dt><span class="section"><a href="#idm998">10. Using framebuffer devices on ARM platforms</a></span></dt><dd><dl><dt><span class="section"><a href="#idm1000">10.1. Netwinders</a></span></dt><dt><span class="section"><a href="#idm1004">10.2. Acorn Archimedes</a></span></dt><dt><span class="section"><a href="#idm1007">10.3. Other ARM ports (SA7710s et. al.)</a></span></dt></dl></dd><dt><span class="section"><a href="#idm1010">11. Using multi-headed framebuffers</a></span></dt><dd><dl><dt><span class="section"><a href="#idm1013">11.1. Introduction</a></span></dt><dt><span class="section"><a href="#idm1019">11.2. Feedback</a></span></dt><dt><span class="section"><a href="#idm1023">11.3. Contributors</a></span></dt><dt><span class="section"><a href="#idm1033">11.4. Standard Disclaimer</a></span></dt><dt><span class="section"><a href="#idm1036">11.5. Copyright Information</a></span></dt><dt><span class="section"><a href="#idm1047">11.6. What hardware is supported?</a></span></dt><dt><span class="section"><a href="#idm1056">11.7. Commercial support</a></span></dt><dt><span class="section"><a href="#idm1059">11.8. Getting all the stuff</a></span></dt><dt><span class="section"><a href="#idm1078">11.9. Getting Started</a></span></dt><dt><span class="section"><a href="#idm1124">11.10. Summary</a></span></dt><dt><span class="section"><a href="#idm1157">11.11. Other Notes and Problems</a></span></dt><dt><span class="section"><a href="#idm1208">11.12. Appendix A. Octave "<code class="code">ctmodem.m</code>" script</a></span></dt><dt><span class="section"><a href="#idm1215">11.13. Appendix B. Bourne Shell "<code class="code">cvtfile</code>"
				script</a></span></dt></dl></dd><dt><span class="section"><a href="#idm1223">12. Using / Changing Fonts</a></span></dt><dt><span class="section"><a href="#idm1228">13. Changing Console Modes</a></span></dt><dt><span class="section"><a href="#idm1232">14. Setting up the X11 FBdev driver</a></span></dt><dt><span class="section"><a href="#idm1274">15. How do I convert XFree86 mode-lines into framebuffer device timings?</a></span></dt><dt><span class="section"><a href="#idm1368">16. Changing the Linux Logo</a></span></dt><dt><span class="section"><a href="#idm1375">17. Looking for further information</a></span></dt></dl></div><p>Copyright © 1999&#8212;2010 Alex Buell, GNU Free Documentation Licence (GFPL)</p><p>Permission is granted to copy, distribute and/or modify this
		document under the terms of the GNU Free Documentation License,
		Version 1.2 or any later version published by the Free Software
		Foundation. A copy of the licence can be retrieved from <a class="ulink" href="http://www.gnu.org/copyleft" target="_top">the Free Software
			Foundation.</a></p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm34"></a>1. Contributors</h2></div></div></div><p>Thanks go to those people listed below who helped improve the Framebuffer HOWTO. I've taken the
		liberty of removing e-mail addresses as this document is more than ten years old!</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Jeff Noxon</p></li><li class="listitem"><p>Francis Devereux</p></li><li class="listitem"><p>Andreas Ehliar</p></li><li class="listitem"><p>Martin McCarthy</p></li><li class="listitem"><p>Simon Kenyon</p></li><li class="listitem"><p>David Ford</p></li><li class="listitem"><p>Chris Black</p></li><li class="listitem"><p>N. Becker</p></li><li class="listitem"><p>Bob Tracy</p></li><li class="listitem"><p>Marius Hjelle</p></li><li class="listitem"><p>James Cassidy</p></li><li class="listitem"><p>Andreas U. Trottmann</p></li><li class="listitem"><p>Lech Szychowski</p></li><li class="listitem"><p>Aaron Tiensivu</p></li><li class="listitem"><p>Jan-Frode Myklebust for his info on permedia cards</p></li><li class="listitem"><p>Many others too numerous to add, but thanks!</p></li></ul></div><p>Thanks go to Rick Niles who has very kindly handed over
			his Multi-Head Mini-HOWTO for inclusion in this HOWTO.</p><p>Thanks to these people listed below who built libc5/glibc2 versions of the
			XF86_FBdev X11 framebuffer driver for X11 on x86 platforms:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Brion Vibber</p></li><li class="listitem"><p>Gerd Knorr</p></li></ul></div><p>And, of course, the authors of the framebuffer device drivers:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Martin Schaller - original author of the framebuffer driver concept</p></li><li class="listitem"><p>Roman Hodek</p></li><li class="listitem"><p>Andreas Schwab</p></li><li class="listitem"><p>Günther Kelleter</p></li><li class="listitem"><p>Geert Uytterhoeven</p></li><li class="listitem"><p>Roman Zippel</p></li><li class="listitem"><p>Pavel Machek</p></li><li class="listitem"><p>Gerd Knorr</p></li><li class="listitem"><p>Miguel de Icaza</p></li><li class="listitem"><p>David Carter</p></li><li class="listitem"><p>William Ricklidge</p></li><li class="listitem"><p>Jes Sorensen</p></li><li class="listitem"><p>Sigurdur Asgeirsson</p></li><li class="listitem"><p>Jeffrey Kuskin</p></li><li class="listitem"><p>Michal Rehacek</p></li><li class="listitem"><p>Peter Zaitcev</p></li><li class="listitem"><p>David S. Miller</p></li><li class="listitem"><p>Dave Redman</p></li><li class="listitem"><p>Jay Estabrook</p></li><li class="listitem"><p>Martin Mares</p></li><li class="listitem"><p>Dan Jacobowitz</p></li><li class="listitem"><p>Emmnauel Marty</p></li><li class="listitem"><p>Eddie C. Dost</p></li><li class="listitem"><p>Jakub Jelinek</p></li><li class="listitem"><p>Philip Blundell</p></li><li class="listitem"><p>Anyone else, stand up and be counted!</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm131"></a>2. What is a framebuffer device?</h2></div></div></div><p>A framebuffer device is an abstraction for the graphic
			hardware. It represents the frame buffer of some video
			hardware, and allows application software to access the
			graphic hardware through a well-defined interface, so
			that the software doesn't need to know anything about
			the low-level interface stuff [Taken from Geert
			Uytterhoeven's framebuffer.txt in the linux kernel
			sources]</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm134"></a>3. What advantages does framebuffer devices have?</h2></div></div></div><p>Penguin logo! :o) Seriously, the major advantage of the
			framebuffer devices is that it presents a generic
			interface across all platforms. It was the case until
			late in the 2.1.x kernel development process that the
			x86 platform had console drivers completely different
			from the other console drivers for other platforms.
			With the introduction of the 2.1.109 kernel, all this
			has changed for the better, and introduced more uniform
			handling of the console under the x86 platforms and
			also introduced true bitmapped graphical consoles
			bearing the Penguin logo on x86 for the first time, and
			allowed code to be shared across different platforms.
			Note that 2.0.x kernels do not support framebuffer
			devices, but it is possible someday someone will
			backport the code from the 2.1.x kernels to 2.0.x
			kernels.  There is an exception to that rule in that
			the 0.9.x kernel port for m68k platforms does have the
			framebuffer device support included.</p><p><span class="emphasis"><em>With the release of the 2.2.x kernels,
				framebuffer device support is very solid and
				stable. You should use the framebuffer device
				if your graphic card supports it, if you are
				using 2.2.x kernels. Older 2.0.x kernels does
				not support framebuffer devices, at least on
				the x86 platform.</em></span></p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0.9.x - introduced m68k framebuffer
					devices. Note that m68k 0.9.x is
					functionally equivalent to x86 1.0.9
					(plus 1.2.x
					enhancements)</p></li><li class="listitem"><p>2.1.107 - introduced x86
					framebuffer/new console devices and
					added generic support, without
					scrollback buffer
					support.</p></li><li class="listitem"><p>2.1.113 - scrollback buffer support
					added to vgacon.</p></li><li class="listitem"><p>2.1.116 - scrollback buffer support
					added to vesafb.</p></li><li class="listitem"><p>2.2.x - includes matroxfb (Matrox
					cards) and atyfb (ATI
					cards).</p></li></ul></div><p>There are some cool features of the framebuffer devices,
			in that you can give generic options to the kernel at
			bootup-time, including options specific to a particular
			framebuffer device. These are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">video=xxx:off</code> - disable
					probing for a particular framebuffer
					device</p></li><li class="listitem"><p><code class="code">video=map:octal-number</code> -
					maps the virtual consoles (VCs) to
					framebuffer (FB)
					devices</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">video=map:01</code> will
						map VC0 to FB0, VC1 to FB1, VC2
						to FB0, VC3 to
						FB1...</p></li><li class="listitem"><p><code class="code">video=map:0132</code>
						will map VC0 to FB0, VC1 to
						FB1, VC2 to FB3, VC4 to FB2,
						VC5 to FB0...</p></li></ul></div></li></ul></div><p>Normally framebuffer devices are probed for in the order
			specified in the kernel, but by specifying the
			<code class="code">video=xxx</code> option, you can add the specific
			framebuffer device you want probed before the others
			specified in the kernel.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm168"></a>4. Using framebuffer devices on x86 platforms</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm170"></a>4.1. What is vesafb?</h3></div></div></div><p>Vesafb is a framebuffer driver for x86
				architecture that works with VESA 2.0 compliant
				graphic cards. It is closely related to the
				framebuffer device drivers in the
				kernel.</p><p>vesafb is a display driver that enables the use
				of graphical modes on your x86 platform for
				bitmapped text consoles. It can also display a
				logo, which is probably the main reason why
				you'd want to use vesafb :o)</p><p>Unfortunately, you can not use vesafb
				successfully with VESA 1.2 cards.  This is
				because these 1.2 cards do not use
				<span class="emphasis"><em>linear</em></span> frame buffering.
				Linear frame buffering simply means that the
				system's CPU is able to access every bit of the
				display. Historically, older graphic adapters
				could allow the CPU to access only 64K at a
				time, hence the limitations of the dreadful
				CGA/EGA graphic modes! It may be that someone
				will write a vesafb12 device driver for these
				cards, but this will use up precious kernel
				memory and involve a nasty hack.</p><p>There is however a potential workaround to add
				VESA 2.0 extensions for your legacy VESA 1.2
				card. You may be able to download a TSR type
				program that will run from DOS, and used with
				loadlin, can help configure the card for the
				appropriate graphic console modes.  Note that
				this will not always work, as an example some
				Cirrus Logic cards such as the VLB 54xx series
				are mapped to a range of memory addresses (for
				example, within the 15MB-16MB range) for frame
				buffering which preludes these from being used
				successfully with systems that have more than
				32MB of memory. There is a way to make this
				work, i.e. if you have a BIOS option to leave a
				memory hole at 15MB-16MB range, it might work,
				Linux doesn't support the use of memory holes.
				However there are patches for this option
				though [Who has these and where do one gets
				them from?]. If you wish to experiment with
				this option, there are plenty of TSR style
				programs available, a prime example is UNIVBE,
				which can be found on the Internet.</p><p>Alternatively, you may be able to download kernel
				patches to allow your VESA 1.2 card to work
				with the VESA framebuffer driver. For example,
				there are patches for use with older S3 boards
				(such as S3 Trio, S3 Virge) that supports VESA
				1.2. For these cards, you can pick up patches
				from <a class="ulink" href="ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff.gz" target="_top">ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff.gz</a>.
			</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm179"></a>4.2. How do I activate the vesafb drivers?</h3></div></div></div><p>Assuming you are using menuconfig, you will need
				to do the following steps:</p><p>If your processor (on x86 platforms) supports
				MTRRs, enable this. It speeds up memory copies
				between the processor and the graphic card, but
				not strictly necessary. You can of course, do
				this after you have the console device
				working.</p><p><span class="emphasis"><em>IMPORTANT: For 2.1.x kernels, go into
					the Code Maturity Level menu, and
					enable the prompt for development
					and / or incomplete drivers.  This is
					no longer necessary for the 2.2.x
					kernels.</em></span></p><p>Go into the Console Drivers menu, and enable the
				following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>VGA Text Console</p></li><li class="listitem"><p>Video Selection
						Support</p></li><li class="listitem"><p>Support for frame buffer
						devices
						(experimental)</p></li><li class="listitem"><p>VESA VGA Graphic
						console</p></li><li class="listitem"><p>Advanced Low Level
						Drivers</p></li><li class="listitem"><p>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</p></li></ul></div><p>VGA Chipset Support (text only) -
				<code class="code">vgafb</code> - used to be part of the
				list above, but it has been removed as it is
				now deprecated and no longer supported. It will
				be removed shortly. Use VGA Text Console
				(<code class="code">fbcon</code>) instead. VGA
				Character/Attributes is only used with VGA
				Chipset Support, and doesn't need to be
				selected.</p><p>Ensure that the Mac variable bpp packed pixel
				support is not enabled.  Linux kernel release
				2.1.111 (and 112) seemed to enable this
				automatically if Advanced Low Level Drivers was
				selected for the first time. This no longer
				happens with 2.1.113.</p><p>There is also the option to compile in fonts into
				memory, but this isn't really necessary, and
				you can always use <code class="code">kbd-0.99</code>'s (see
				section on fonts) setfont utility to change
				fonts by loading fonts into the console
				device.</p><p>Make sure these aren't going to be modules. [Not
				sure if it's possible to build them as modules
				yet - please correct me on this]</p><p>You'll need to create the framebuffer device in
				<code class="code">/dev</code>. You need one per framebuffer
				device, so all you need to do is to type in
				<code class="code">mknod /dev/fb0 c 29 0</code> for the
				first one. Subsequent ones would be in
				multiples of 32, so for example to create
				<code class="code">/dev/fb1</code>, you would need to type
				in <code class="code">mknod /dev/fb1 c 29 32</code>, and so
				on up to the eighth framebuffer device
				(<code class="code">mknod /dev/fb7 c 29 224</code>)</p><p>Then rebuild the kernel, modify
				<code class="code">/etc/lilo.conf</code> to include the
				<code class="code">VGA=ASK</code> parameter, and run
				<code class="code">lilo</code>, this is required in order
				for you to be able to select the modes you wish
				to use.</p><p>Here's a sample LILO configuration (taken from my
				machine)</p><div class="literallayout"><p><code class="code"><br>
# LILO configuration file<br>
boot = /dev/hda3<br>
delay = 30<br>
prompt<br>
vga = ASK # Let user enter the desired modes<br>
image = /vmlinuz<br>
  root = /dev/hda3<br>
  label = Linux<br>
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking<br>
		  	</code></p></div><p>Reboot the kernel, and as a simple test, try
				entering <code class="code">0301</code> at the VGA prompt
				(this will give you 640x480 @ 256), and you
				should be able to see a cute little Penguin
				logo.</p><p>Note, that at the VGA prompt, you're required to
				type in the number in the format of "0" plus
				the three-digit number, and miss out the 'x'.
				This isn't necessary if you're using
				LILO.</p><p>Once you can see that's working well, you can
				explore the various VESA modes (see below) and
				decide on the one that you like the best, and
				hardwire that into the "<code class="code">VGA=x</code>" parameter in
				<code class="code">lilo.conf</code>. When you have chosen
				the one you like the best, look up the
				equivalent hexadecimal number from the table
				below and use that (i.e. for 1280x1024 @ 256,
				you just use "<code class="code">VGA=0x307</code>"), and
				re-run lilo. That's all there it is to it.  For
				further references, read the LoadLin/LILO
				HOWTOs.</p><p><span class="emphasis"><em>NOTE!</em></span> vesafb does not enable
				scrollback buffering as a default. You will
				need to pass to the kernel the option to enable
				it. Use <code class="code">video=vesa:ypan</code> or
				<code class="code">video=vesa:ywrap</code> to activate it.
				Both does the same thing, but in different
				ways. <code class="code">ywrap</code> is a lot faster than
				<code class="code">ypan</code> but may not work on slightly
				broken VESA 2.0 graphic cards.
				<code class="code">ypan</code> is slower than
				<code class="code">ywrap</code> but a lot more compatible.
				This option is only present in kernel 2.1.116
				and above.  Earlier kernels did not have the
				ability to allow scrollback buffering in
				vesafb.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm235"></a>4.3. What VESA modes are available to me?</h3></div></div></div><p>This really depends on the type of VESA 2.0
				 compliant graphic card that you have in your
				 system, and the amount of video memory
				 available. This is just a matter of testing
				 which modes work best for your graphic
				 card.</p><p>The following table shows the mode numbers you
				can input at the VGA prompt or for use with the
				LILO program. (actually these numbers are plus
				0x200 to make it easier to refer to the
				table)</p><div class="table"><a name="idm239"></a><p class="title"><b>Table 1. VESA modes</b></p><div class="table-contents"><table class="table" summary="VESA modes" border="1"><colgroup><col align="right"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="right">Depth</th><th align="center">640x400</th><th align="center">640x480</th><th align="center">800x600</th><th align="center">1024x768</th><th align="center">1152x864</th><th align="center">1280x1024</th><th align="center">1600x1200</th></tr></thead><tbody><tr><td align="right">4 bits</td><td align="center">?</td><td align="center">?</td><td align="center">0x302</td><td align="center">?</td><td align="center">?</td><td align="center">?</td><td align="center">?</td></tr><tr><td align="right">8 bits</td><td align="center">0x300</td><td align="center">0x301</td><td align="center">0x303</td><td align="center">0x305</td><td align="center">0x161</td><td align="center">0x307</td><td align="center">0x31C</td></tr><tr><td align="right">15 bits</td><td align="center">?</td><td align="center">0x310</td><td align="center">0x313</td><td align="center">0x316</td><td align="center">0x162</td><td align="center">0x319</td><td align="center">0x31D</td></tr><tr><td align="right">16 bits</td><td align="center">?</td><td align="center">0x311</td><td align="center">0x314</td><td align="center">0x317</td><td align="center">0x163</td><td align="center">0x31A</td><td align="center">0x31E</td></tr><tr><td align="right">24 bits</td><td align="center">?</td><td align="center">0x312</td><td align="center">0x315</td><td align="center">0x318</td><td align="center">?</td><td align="center">0x31B</td><td align="center">0x31F</td></tr><tr><td align="right">32 bits</td><td align="center">?</td><td align="center">?</td><td align="center">?</td><td align="center">?</td><td align="center">0x164</td><td align="center">?</td><td align="center">?</td></tr></tbody></table></div></div><br class="table-break"><p>Key: 8 bits = 256 colours, 15 bits = 32,768
				colours, 16 bits = 65,536 colours, 24 bits =
				16.8 million colours, 32 bits - same as 24
				bits, but the extra 8 bits can be used for
				other things, and fits perfectly on a 32 bit
				PCI/VLB/EISA bus.</p><p>Additional modes are at the discretion of the
				manufacturer, as the VESA 2.0 document only
				defines modes up to 0x31F. You may need to do
				some fiddling around to find these extra
				modes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm317"></a>4.4. Got a Matrox card?</h3></div></div></div><p>If you've got a Matrox graphic card, you don't
				actually need vesafb, you need the matroxfb
				driver instead. This greatly enhances the
				capabilities of your card. Matroxfb will work
				with Matrox Mystique Millennium I &amp; II,
				G100 and G200. It also supports multiheaded
				systems (that is, if you have two Matrox cards
				in your machine, you can use two displays on
				the same machine!). To configure for Matrox,
				you will need to do the following:</p><p>You might want to upgrade the Matrox BIOS first,
				you can download the BIOS upgrade from <a class="ulink" href="http://www.matrox.com/mgaweb/drivers/ftp_bios.htm" target="_top">http://www.matrox.com/mgaweb/drivers/ftp_bios.htm</a>
				Beware that you will need DOS to do
				this.</p><p>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</p><p>Go into the Console Drivers menu, and enable the
				following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>VGA Text
						Console</p></li><li class="listitem"><p>Video Selection
						Support</p></li><li class="listitem"><p>Support for frame buffer
						devices
						(experimental)</p></li><li class="listitem"><p>Matrox
						Acceleration</p></li><li class="listitem"><p>Select the following depending
						on the card that you
						have</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Millennium I /
								II
								support</p></li><li class="listitem"><p>Mystique
								support</p></li><li class="listitem"><p>G100 / G200
								support</p></li></ul></div></li><li class="listitem"><p>Enable Multihead Support if you
						want to use more than one
						Matrox card</p></li><li class="listitem"><p>Advanced Low Level
						Drivers</p></li><li class="listitem"><p>elect Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</p></li></ul></div><p>Rebuild your kernel. Then you will need to modify
				your <code class="code">lilo.conf</code> file to enable the
				Matroxfb device. The quickest and simplest way
				is re-use mine.</p><div class="literallayout"><p><code class="code"><br>
# LILO configuration file<br>
boot = /dev/hda3<br>
delay = 30<br>
prompt<br>
vga = 792    # You need to do this so it boots up in a sane state<br>
# Linux bootable partition config begins<br>
image = /vmlinuz<br>
append = "video=matrox:vesa:440" # then switch to Matroxfb<br>
  root = /dev/hda3<br>
  label = Linux<br>
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking<br>
			</code></p></div><p>Lastly, you'll need to create the framebuffer
				device in <code class="code">/dev</code>. You need one per
				framebuffer device, so all you need to do is to
				type in <code class="code">mknod /dev/fb0 c 29 0</code> for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				<code class="code">/dev/fb1</code>, you would need to type
				in <code class="code">mknod /dev/fb1 c 29 32</code>, and so
				on up to the eight framebuffer device
				(<code class="code">mknod /dev/fb7 c 29 224i</code>)</p><p>And that should be it! [NOTE: Is anyone using
				this multiheaded support, please get in touch
				with me ASAP - I need to talk to you about it
				so I can document it!</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm361"></a>4.5. Got a Permedia card?</h3></div></div></div><p>Permedia cards cannot be used with the vesafb
				driver, but fortunately, there is the Permedia
				framebuffer driver available to use. Assuming
				you are using menuconfig, do the
				following:</p><p>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</p><p>Go into the Console Drivers menu and select the
				following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>VGA Text
						Console</p></li><li class="listitem"><p>Video Selection
						Support</p></li><li class="listitem"><p>Support for frame buffer
						devices
						(experimental)</p></li><li class="listitem"><p>Permedia2 support
						(experimental)</p></li><li class="listitem"><p>Generic Permedia2 PCI board
						support</p></li><li class="listitem"><p>Advanced Low Level
						Drivers</p></li><li class="listitem"><p>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</p></li><li class="listitem"><p>Optionally, select the
						following, if you wish to use
						the compiled in
						fonts</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Select
								compiled-in
								fonts</p></li><li class="listitem"><p>Select Sparc
								console 12x22
								font</p></li></ul></div></li></ul></div><p>Rebuild your kernel. Then you will need to modify
				your <code class="code">lilo.conf</code> file to enable the
				pm2fb device.  The quickest and simplest way is
				re-use the following:</p><div class="literallayout"><p><code class="code"><br>
# LILO configuration file<br>
boot = /dev/hda3<br>
delay = 30<br>
prompt<br>
vga = 792    # You need to do this so it boots up in a sane state<br>
# Linux bootable partition config begins<br>
image = /vmlinuz<br>
append = "video=pm2fb:mode:1024x768-75,font:SUN12x22,ypan" # then switch to pm2fb<br>
  root = /dev/hda3<br>
  label = Linux<br>
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking<br>
			</code></p></div><p>The line
				"<code class="code">pm2fb:mode:1024x768-75,font:SUN12x22,ypan</code>"
				indicates you are selecting a 1024x768 mode at
				75Hz, with the <code class="code">SUN12x22</code> font
				selected (if you did select it), including ypan
				for scrollback support. You may select other
				modes if you desire.</p><p>Lastly, you'll need to create the framebuffer
				device in <code class="code">/dev</code>. You need one per
				framebuffer device, so all you need to do is to
				type in <code class="code">mknod /dev/fb0 c 29 0</code> for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				<code class="code">/dev/fb1</code>, you would need to type
				in <code class="code">mknod /dev/fb1 c 29 32</code>, and so
				on up to the eight framebuffer device
				(<code class="code">mknod /dev/fb7 c 29 224</code>)</p><p>For more information on the other features of the
				Permedia framebuffer driver, point your browser
				at <a class="ulink" href="http://www.cs.unibo.it/~nardinoc/pm2fb/index.html" target="_top">http://www.cs.unibo.it/~nardinoc/pm2fb/index.html</a></p><p><code class="code">video=pm2fb:[option[,option[,option...]]]</code></p><p>where option is one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">off</code> - disables the
						driver</p></li><li class="listitem"><p><code class="code">mode:resolution</code> -
						sets the console resolution.
						The modes have been taken from
						the <code class="code">fb.modes.ATI</code>
						file in Geert's
						<code class="code">fbset</code> package. The
						depth for all the modes is 8
						bpp. This the list of available
						modes:</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">640x480-(60,72,75,90,100)</code></p></li><li class="listitem"><p><code class="code">640x480-(60,72,75,90,100)</code></p></li><li class="listitem"><p><code class="code">1024x768-(60,70,72,75,90,100,illo)
									illo=80KHz
									100Hz</code></p></li><li class="listitem"><p><code class="code">152x864-(60,70,75,80)</code></p></li><li class="listitem"><p><code class="code">1280x1024-(60,70,74,75)</code></p></li><li class="listitem"><p><code class="code">1600x1200-(60,66,76)</code></p></li></ul></div></li><li class="listitem" style="list-style-type: none"><p>The default
						resolution is
						640x480-60</p></li><li class="listitem"><p><code class="code">font:name</code> - sets
						the console font. Example
						<code class="code">font:SUN12x12</code></p></li><li class="listitem"><p><code class="code">ypan</code> - sets the
						current virtual height as big
						as video memory
						permits.</p></li><li class="listitem"><p><code class="code">oldmem</code> - used for
						CybervisionPPC boards only with
						Fujitsi SGRAMs mounted. Applies
						to all CyberVisionPPCs made
						before
						30-Dec-1998.</p></li><li class="listitem"><p><code class="code">virtual</code> - used
						with kernels capable of
						remapping the PCI
						regions</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm452"></a>4.6. Got an ATI card?</h3></div></div></div><p>[Note: This information is at best, only
				second-hand or third-hand, since I don't have
				an ATI card to test it with. Feel free to
				correct me if I am wrong or flame me!] 8)</p><p>ATI cards can be used with the vesafb driver, but
				you may or may not have problems, depending on
				how horribly broken the card is. Fortunately,
				there is the atyfb framebuffer driver available
				to use. Assuming you are using menuconfig, do
				the following:</p><p>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</p><p>Go into the Console Drivers menu and select the
				following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>VGA Text
						Console</p></li><li class="listitem"><p>Video Selection
						Support</p></li><li class="listitem"><p>Support for frame buffer
						devices
						(experimental)</p></li><li class="listitem"><p>ATI Mach64 display
						support</p></li><li class="listitem"><p>Advanced Low Level
						Drivers</p></li><li class="listitem"><p>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</p></li><li class="listitem"><p>Optionally, select the
						following, if you wish to use
						the compiled in
						fonts</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Select
								compiled-in
								fonts</p></li><li class="listitem"><p>Select Sparc
								console 12x22
								font</p></li></ul></div></li></ul></div><p>Rebuild your kernel. Then you will need to modify
				your <code class="code">lilo.conf</code> file to enable the
				<code class="code">atyfb</code> device.  The quickest and
				simplest way is re-use the following:</p><div class="literallayout"><p><code class="code"><br>
# LILO configuration file<br>
boot = /dev/hda3<br>
delay = 30<br>
prompt<br>
vga = 792    # You need to do this so it boots up in a sane state<br>
# Linux bootable partition config begins<br>
image = /vmlinuz<br>
append = "video=atyfb:mode:1024x768,font:SUN12x22"<br>
  root = /dev/hda3<br>
  label = Linux<br>
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking<br>
			</code></p></div><p>The line "<code class="code">atyfb:mode:1024x768,font:SUN12x22</code>"
				indicates you are selecting a 1024x768
				mode.</p><p>Lastly, you'll need to create the framebuffer
				device in <code class="code">/dev</code>. You need one per
				framebuffer device, so all you need to do is to
				type in <code class="code">mknod /dev/fb0 c 29 0</code> for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				<code class="code">/dev/fb1</code>, you would need to type
				in <code class="code">mknod /dev/fb1 c 29 32</code>, and so
				on up to the eight framebuffer device
				(<code class="code">mknod /dev/fb7 c 29 224</code>)</p><p><code class="code">video=atyfb:[option[,option[,option...]]]</code></p><p>where option is one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">font</code> - selects
						font to use (compiled into
						kernel)</p></li><li class="listitem"><p><code class="code">noblink</code> - turns
						off blinking</p></li><li class="listitem"><p><code class="code">noaccel</code> - disables
						acceleration</p></li><li class="listitem"><p><code class="code">vram</code> - how much
						video memory is there on the
						card</p></li><li class="listitem"><p><code class="code">pll</code> -
						unknown</p></li><li class="listitem"><p><code class="code">mclk</code> -
						unknown</p></li><li class="listitem"><p><code class="code">vmode</code> -
						unknown</p></li><li class="listitem"><p><code class="code">cmode</code> - sets
						colour depth (4, 8, 15, 16, 24
						and 32)</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm521"></a>4.7. Which graphic cards are VESA 2.0 compliant?</h3></div></div></div><p>This lists all the graphic devices that are known
				to work with the vesafb device driver:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ATI PCI VideoExpression 2MB
						(max. 1280x1024 @
						8bit)</p></li><li class="listitem"><p>ATI PCI
						All-in-Wonder</p></li><li class="listitem"><p>Matrox Millennium PCI - BIOS
						v3.0</p></li><li class="listitem"><p>Matrox Millennium II PCI - BIOS
						v1.5</p></li><li class="listitem"><p>Matrox Millennium II AGP - BIOS
						v1.4</p></li><li class="listitem"><p>Matrox Millennium G200 AGP -
						BIOS v1.3</p></li><li class="listitem"><p>Matrox Mystique &amp; Mystique
						220 PCI - BIOS
						v1.8</p></li><li class="listitem"><p>Matrox Mystique G200 AGP - BIOS
						v1.3</p></li><li class="listitem"><p>Matrox Productiva G100 AGP -
						BIOS v1.4</p></li><li class="listitem"><p>All Riva 128 based
						cards</p></li><li class="listitem"><p>Diamond Viper V330 PCI
						4MB</p></li><li class="listitem"><p>Genoa Phantom 3D/S3
						ViRGE/DX</p></li><li class="listitem"><p>Hercules Stingray 128/3D with
						TV output</p></li><li class="listitem"><p>Hercules Stingray 128/3D
						without TV output - needs BIOS
						upgrade (free from
						support@hercules.com)</p></li><li class="listitem"><p>SiS 6326 PCI/AGP
						4MB</p></li><li class="listitem"><p>STB Lightspeed 128 (Nvida Riva
						128 based)
						PCI</p></li><li class="listitem"><p>STB Velocity 128 (Nvida Riva
						128 based)
						PCI</p></li><li class="listitem"><p>Jaton Video-58P ET6000 PCI
						2MB-4MB (max. 1600x1200 @
						8bit)</p></li><li class="listitem"><p>Voodoo2 2000</p></li></ul></div><p>This list below blacklists graphic cards that
				doesn't work with the vesafb device:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>TBD</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm567"></a>4.8. Can I compile vesafb as a module?</h3></div></div></div><p>As far as is known, vesafb can't be modularised,
				although at some point in time, the developer
				of vesafb may decide to modify the sources for
				modularising. Note that even if modularising is
				possible, at boot time you will not be able to
				see any output on the display until vesafb is
				modprobed. It's probably a lot wiser to leave
				it in the kernel, for these cases when there
				are booting problems.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm570"></a>4.9. How do I modify the cursor</h3></div></div></div><p>With thanks to Martin Mares, taken from his
				VGA-softcursor.txt document.</p><p>Linux now has some ability to manipulate cursor
				appearance.  Normally, you can set the size of
				hardware cursor (and also work around some ugly
				bugs in those miserable Trident cards -- see
				<code class="code">#define TRIDENT_GLITCH</code> in
				<code class="code">drivers/char/vga.c</code>).  In case you
				enable "Software generated cursor" in the
				system configuration, you can play a few new
				tricks:  you can make your cursor look like a
				non-blinking red block, make it inverse
				background of the character it's over or to
				highlight that character and still choose
				whether the original hardware cursor should
				remain visible or not. There may be other
				things I have never thought of.</p><p>The cursor appearance is controlled by a
				<code class="code">&lt;ESC&gt;[?1;2;3c</code> escape
				sequence where 1, 2 and 3 are parameters
				described below. If you omit any of them, they
				will default to zeroes.</p><p>Parameter 1 specifies cursor size (0 = default, 1
				= invisible, 2 = underline, ..., 8 = full
				block) + 16 if you want the software cursor to
				be applied + 32 if you want to always change
				the background colour + 64 if you dislike
				having the background the same as the
				foreground.  Highlights are ignored for the
				last two flags.</p><p>The second parameter selects character attribute
				bits you want to change (by simply XORing them
				with the value of this parameter). On standard
				VGA, the high four bits specify background and
				the low four the foreground. In both groups,
				low three bits set colour (as in normal colour
				codes used by the console) and the most
				significant one turns on highlight (or
				sometimes blinking - it depends on the
				configuration of your VGA).</p><p>The third parameter consists of character
				attribute bits you want to set.  Bit setting
				takes place before bit toggling, so you can
				simply clear a bit by including it in both the
				set mask and the toggle mask.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>To get normal blinking
						underline, use: <code class="code">echo -e
							'\033&lt;ESC&gt;[?2c'</code></p></li><li class="listitem"><p>To get blinking block, use:
						<code class="code">echo -e
							'\033&lt;ESC&gt;[?6c'</code></p></li><li class="listitem"><p>To get red non-blinking block,
						use: <code class="code">echo -e
							'\033i&lt;ESC&gt;[?17;0;64c'</code></p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm591"></a>5. Using framebuffer devices on m68k platforms</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm593"></a>5.1. Atari platforms</h3></div></div></div><p>This section describe framebuffer options on Atari platforms</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm596"></a>5.1.1. What modes are available?</h4></div></div></div><div class="table"><a name="idm598"></a><p class="title"><b>Table 2. Atari modes</b></p><div class="table-contents"><table class="table" summary="Atari modes" border="1"><colgroup><col align="right"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="right">Depth</th><th align="center">320x200</th><th align="center">320x480</th><th align="center">640x200</th><th align="center">640x400</th><th align="center">640x480</th><th align="center">896x608</th><th align="center">1280x960</th></tr></thead><tbody><tr><td align="right">1 bit</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">sthigh</td><td align="center">vga2</td><td align="center">falh2</td><td align="center">tthigh</td></tr><tr><td align="right">2 bits</td><td align="center"> </td><td align="center"> </td><td align="center">stmid</td><td align="center"> </td><td align="center">vga4</td><td align="center"> </td><td align="center"> </td></tr><tr><td align="right">4 bits</td><td align="center">stlow</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">ttmid/vga16</td><td align="center">falh16</td><td align="center"> </td></tr><tr><td align="right">8 bits</td><td align="center"> </td><td align="center">ttlow</td><td align="center"> </td><td align="center"> </td><td align="center">vga256</td><td align="center"> </td><td align="center"> </td></tr></tbody></table></div></div><br class="table-break"><p><span class="emphasis"><em>ttlow, ttmid and
						ttmhigh</em></span> are only
					used on the TT, whilst <span class="emphasis"><em>vga2,
						vga4, vga16, vga256, falh3 and
						falh16</em></span> are only used
					on the Falcon.</p><p>When used with the kernel option
					<code class="code">video=xxx</code>, and no
					suboption is given, the kernel will
					probe for the modes in the following
					order until it finds a mode that is
					possible with the given
					hardware:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">ttmid</code></p></li><li class="listitem"><p><code class="code">tthigh</code></p></li><li class="listitem"><p><code class="code">vga16</code></p></li><li class="listitem"><p><code class="code">sthigh</code></p></li><li class="listitem"><p><code class="code">stmid</code></p></li></ul></div><p>You may specify the particular mode you
					wish to use, if you don't wish to
					auto-probe for the modes you desire.
					For example, <code class="code">video=vga16</code>
					gives you a 4 bit 640x480
					display.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm679"></a>5.1.2. Additional suboptions</h4></div></div></div><p>There are a number of suboptions
					available with the
					<code class="code">video=xxx</code>
					parameter:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">inverse</code> -
							inverts the display so
							that the
							background/foreground
							colours are reversed.
							Normally the background
							is black, but with this
							suboption, it gets sets
							to
							white.</p></li><li class="listitem"><p><code class="code">font</code> -
							sets the font to use in
							text modes. Currently
							you can only select
							<code class="code">VGA8x8</code>,
							<code class="code">VGA8x16</code>,
							<code class="code">PEARL8x8</code>.
							The default is to use
							the <code class="code">VGA8x8</code>
							only if the vertical
							size of the display is
							less than 400 pixels,
							otherwise it defaults
							to
							<code class="code">VGA8x16</code>.</p></li><li class="listitem"><p><code class="code">internal</code> -
							a very interesting
							option. See the next
							section for
							information.</p></li><li class="listitem"><p><code class="code">external</code>
								- as
								above.</p></li><li class="listitem"><p><code class="code">monitorcap</code>
								- describes the
								capabilities
								for multisyncs.
								DON'T use with
								a fixed sync
								monitor!</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm704"></a>5.1.2.1. Using the <code class="code">internal</code>
						suboption</h5></div></div></div><p>Syntax:
						<code class="code">internal:(xres);(yres)[;(xres_max);(yres_max);(offset)]</code></p><p>This option specifies the
						capabilities of some extended
						internal video hardware, i.e
						OverScan modes.
						<code class="code">(xres)</code> and
						<code class="code">(yres)</code> gives the
						extended dimensions of the
						screen.</p><p>If your OverScan mode needs a
						black border, you'll need to
						write the last three arguments
						of the <code class="code">internal:</code>
						suboption.
						<code class="code">(xres_max)</code> is the
						maximum line length that the
						hardware allows,
						<code class="code">(yres_max)</code> is the
						maximum number of lines, and
						<code class="code">(offset)</code> is the
						offset of the visible part of
						the screen memory to its
						physical start, in
						bytes.</p><p>Often extended internal video
						hardware has to be activated,
						for this you will need the
						<code class="code">"switches=*"</code>
						options.  [Note: Author would
						like extra information on this,
						please. The m68k documentation
						in the kernel isn't clear
						enough on this point, and he
						doesn't have an Atari! Examples
						would be helpful too]</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm719"></a>5.1.2.2. Using the <code class="code">external</code> suboption</h5></div></div></div><p>Syntax:
						<code class="code">external:(xres);(yres);(depth);(org);(scrmem)[;(scrlen)[;(vgabase)[;(colw)[;(coltype)[;(xres_virtual)]]]]]</code></p><p>This is quite complicated, so
						this document will attempt to
						explain as clearly as possible,
						but the Author would appreciate
						if someone would give this a
						look over and see that he
						hasn't fscked something up!
						:o)</p><p>This suboption specifies that you
						have an external video hardware
						(most likely a graphic board),
						and how to use it with Linux.
						The kernel is basically limited
						to what it knows of the
						internal video hardware, so you
						have to supply the parameters
						it needs in order to be able to
						use external video hardware.
						There are two limitations; you
						must switch to that mode before
						booting, and once booted, you
						can't change modes.</p><p>The first three parameters are
						obvious; gives the dimensions
						of the screen as pixel height,
						width and depth. The depth
						supplied should be the number
						of colours is 2^n that of the
						number of planes required. For
						example, if you desire to use a
						256 colour display, then you
						need to give 8 as the depth.
						This depends on the external
						graphic hardware, though so you
						will be limited by what the
						hardware can do.</p><p>Following from this, you also
						need to tell the kernel how the
						video memory is organised -
						supply a letter as the
						<code class="code">(org)</code>
						parameter</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">n</code>
								- use normal
								planes, i.e one
								whole plane
								after another
						</p></li><li class="listitem"><p><code class="code">i</code>
								- use
								interleaved
								planes, i.e.
								16 bits of the
								first plane,
								then the 16
								bits of the
								next plane and
								so on.  Only
								built-in Atari
								video modes
								uses this - and
								there are no
								graphic card
								that supports
								this mode.
						</p></li><li class="listitem"><p><code class="code">p</code>
								- use packed
								pixels, i.e
								consecutive
								bits stands for
								all planes for
								a pixel. This
								is the most
								common mode for
								256 colour
								displays
								on graphic cards.</p></li><li class="listitem"><p><code class="code">t</code>
								- use true
								colour, i.e
								this is
								actually packed
								pixels, but
								does not
								require a
								colour lookup
								table like what
								other packed
								pixel modes
								uses. These
								modes are
								normally 24 bit
								displays, and
								provides 16.8
								million
								colours.</p></li></ul></div><p><span class="emphasis"><em>However</em></span>, for
						monochrome modes, the
						<code class="code">(org)</code> parameter
						has a different meaning:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">n</code>
								- use normal
								colours, i.e. 0
								= white, 1 =
								black</p></li><li class="listitem"><p><code class="code">i</code>
								- use inverted
								colours, i.e. 0
								= black, 1 =
								white</p></li></ul></div><p>The next important item about the
						video hardware is the base
						address of the video memory.
						That is given by the
						<code class="code">(scrmem)</code> parameter
						as a hexadecimal number with an
						<code class="code">0x</code> prefix. You
						will need to find this out from
						the documentation that comes
						with your external video
						hardware.</p><p>The next paramter
						<code class="code">(scrlen)</code> tells the
						kernel about the size of the
						video memory. If it's missing,
						this is calculated from the
						<code class="code">(xres)</code>, and
						<code class="code">(depth)</code>
						parameters. It's not useful to
						write a value here these days
						anyway. To leave this empty,
						give two consecutive semicolons
						if you need to give the
						<code class="code">(vgabase)</code>
						parameter, otherwise, just
						leave it.</p><p>The <code class="code">(vgabase)</code>
						parameter is optional. If it
						isn't given, the kernel can't
						read/write any colour registers
						of the video hardware, and thus
						you have to set up the
						appropriate colours before you
						boot Linux. But if your card is
						VGA compatible, you can give it
						the address where it can locate
						the VGA register set so it can
						change the colour lookup
						tables. This information can be
						found in your external video
						hardware documentation. To make
						this
						<span class="emphasis"><em>clear</em></span>,
						<code class="code">(vgabase)</code> is the
						<code class="code">base</code> address, i.e
						a 4k aligned address. For
						reading/writing the colour
						registers, the kernel uses the
						address range between
						<code class="code">(vgabase) + 0x3c7</code> and
						<code class="code">(vgabase) + 0x3c9</code>.
						This parameter is given in
						hexadecimal and must have a
						<code class="code">0x</code> prefix, just
						like <code class="code">(scrmem)</code>.
						<code class="code">(colw)</code> is only
						meaningful, if the
						<code class="code">(vgabase)</code>
						parameter is specified. It
						tells the kernel how wide each
						of the colour register is, i.e
						the number of bits per single
						colour (red/green/blue).
						Default is usually 6 bits, but
						it is also common to specify 8
						bits.</p><p><code class="code">(xres_virtual)</code> is
						only required for the
						ProMST/ET4000 cards where the
						physical linelength differs
						from the visible length. With
						ProMST, you need to supply
						2048, whilst for ET4000, it
						depends on the initialisation
						of the video board.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm773"></a>5.2. Amiga platforms</h3></div></div></div><p>This section describes the options for Amigas,
				which are quite similar to those of the Atari
				platform</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm776"></a>5.2.1. What modes are available?</h4></div></div></div><p>This depends on the chipset used in the
					Amiga. There are three main ones;
					<code class="code">OCS</code>, <code class="code">ECS</code> and
					<code class="code">AGA</code> which all uses the
					colour frame buffers.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>NTSC modes</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">ntsc</code>
									-
									640x200</p></li><li class="listitem"><p><code class="code">ntsc-lace</code>
									-
									640x400</p></li></ul></div></li><li class="listitem"><p>PAL
							modes</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">pal</code>
									-
									640x256</p></li><li class="listitem"><p><code class="code">pal-lace</code>
									-
									640x512</p></li></ul></div></li><li class="listitem"><p>ECS modes - 2 bit
							colours on ECS
							chipsets, 8 bit colours
							on AGA chipsets
							only</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">multiscan</code>
									-
									640x480</p></li><li class="listitem"><p><code class="code">multiscan-lace</code>
									-
									640x960</p></li><li class="listitem"><p><code class="code">euro36</code>
									-
									640x200</p></li><li class="listitem"><p><code class="code">euro36-lace</code>
									-
									640x400</p></li><li class="listitem"><p><code class="code">euro72</code>
									-
									640x480</p></li><li class="listitem"><p><code class="code">euro72-lace</code>
									-
									640x800</p></li><li class="listitem"><p><code class="code">super72</code>
									-
									800x300</p></li><li class="listitem"><p><code class="code">super72-lace</code>
									-
									800x400</p></li><li class="listitem"><p><code class="code">dblntsc</code>
									-
									640x200</p></li><li class="listitem"><p><code class="code">dblpal</code>
									-
									640x256</p></li><li class="listitem"><p><code class="code">dblntsc-ff</code>
									-
									640x400</p></li><li class="listitem"><p><code class="code">dblntsc-lace</code>
									-
									640x800</p></li><li class="listitem"><p><code class="code">dblpal-ff</code>
									-
									640x512</p></li><li class="listitem"><p><code class="code">dblpal-lace</code>
									-
									640x1024</p></li></ul></div></li><li class="listitem"><p>VGA modes - 2 bit
							colours on ECS
							chipsets, 8 bit colours
							on AGA
							chipsets</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="code">vga</code>
									-
									640x480</p></li><li class="listitem"><p><code class="code">vga70</code>
									-
									640x400</p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm859"></a>5.2.2. Additional suboptions</h4></div></div></div><p>These are similar to the Atari
					suboptions. They are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">depth</code> -
							specifies the pixel bit
							depth</p></li><li class="listitem"><p><code class="code">inverse</code> -
							does the same thing as
							the Atari
							suboption</p></li><li class="listitem"><p><code class="code">font</code> -
							does the same thing as
							the Atari suboption,
							although the
							<code class="code">PEARL8x8</code>
							font is used instead of
							the <code class="code">VGA8x8</code>
							font if the display
							size is less than 400
							pixels
							wide.</p></li><li class="listitem"><p><code class="code">monitorcap</code>
							- specifies the
							capabilities of the
							multisync monitor. Do
							not use with fixed sync
							monitors</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm877"></a>5.2.3. Supported Amiga graphic expansion
					boards</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">Phase5
								CyberVision
								64</code> (S3
							Trio64
							chipset)</p></li><li class="listitem"><p><code class="code">Phase5
								CyberVision 64
								3D</code> (S3
							ViRGE
							chipset)</p></li><li class="listitem"><p><code class="code">MacroSystems
								Retina
								Z3</code> (NCR
							77C32BLT
							chipset)</p></li><li class="listitem"><p><code class="code">Helfrich Piccolo,
								SD64, GVP ECS
								Spectrum,
								Village Tronic
								Picasso II /
								II+ and
								IV</code>
							(Cirrus Logic GD542x /
							543x
							chipsets)</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm892"></a>5.2.4. Macintosh platforms</h4></div></div></div><p>Currently, the framebuffer device
					implemented only supports the mode
					selected in MacOS before booting into
					Linux, and also supports 1, 2, 4 and 8
					bit colours modes.</p><p>Framebuffer suboptions are selected using
					the following syntax:</p><p><code class="code">video=macfb:&lt;font&gt;:&lt;inverse&gt;</code></p><p>You can select fonts such as VGA8x8,
					VGA8x16 and 6x11 etc. The inverse
					option allows you to use reverse
					video.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm899"></a>6. Using framebuffer devices on PowerPC platforms</h2></div></div></div><p>The author would love to receive information on the use
			of framebuffer device drivers on this platform.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm902"></a>7. Using framebuffer devices on Alpha platforms</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm904"></a>7.1. What modes are available?</h3></div></div></div><p>So far, there is only the TGA PCI card, which
				only does 80x30 with a resolution of 640x480 at
				either 8 bits or 24 / 32 bits.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm907"></a>7.2. Which graphic cards can work on Alpha?</h3></div></div></div><p>This lists all the graphic cards that are known
				to work:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">DEC TGA PCI
							(DEC21030)</code> -
						640x480 &amp; 8 bits or 24 / 32
						bits versions</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm914"></a>8. Using framebuffer devices on SPARC platforms</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm916"></a>8.1. Which graphic cards can work on the SPARC</h3></div></div></div><p>This lists all the graphic cards
				available:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">MG1 / MG2</code> - SBus
						or integrated on Sun3 - max
						1600 x 1200 &amp; mono
						(<code class="code">BWtwo</code>)</p></li><li class="listitem"><p><code class="code">CGthree</code> - Similar
						to MG1 / MG2 but supports
						colour</p></li><li class="listitem"><p>GX - SBus - max. 1152 x 900
						&amp; 8 bit
						(<code class="code">CGsix</code>)</p></li><li class="listitem"><p>TurboGX - SBus - max. 1152 x
						900 &amp; 8 bit
						(<code class="code">CGsix</code>)</p></li><li class="listitem"><p>SX (SS10 / SS20 only) - max.
						1280 x 1024 &amp; 24 bit
						(<code class="code">CGfourteen</code>)</p></li><li class="listitem"><p>ZX (TZX) - SBus - accelerated
						24 bit 3D card
						(<code class="code">Leo</code>)</p></li><li class="listitem"><p>TCX (Sparc 4 only) - max 1280 x
						1024 &amp; 8
						bit</p></li><li class="listitem"><p>TCX (Sparc 5 only) - max 1152 x
						900 &amp; 24
						bit</p></li><li class="listitem"><p>Creator - SBus - max 1280 x
						1024 &amp; 24 bit
						(<code class="code">FFB</code></p></li><li class="listitem"><p>Creator3D - SBus - max 1920 x
						1200 &amp; 24 bit
						(<code class="code">FFB</code></p></li><li class="listitem"><p>ATI Mach64 - PCI - accelerated
						8 / 24 bit UltraSparc
						only</p></li></ul></div><p>There is the option to use the PROM to output
				characters to the display or to a serial
				console.</p><p>Also, have a look at the Sparc Frame Buffer FAQ
				at <a class="ulink" href="http://c3-a.snvl1.sfba.home.com/Framebuffer.html" target="_top">http://c3-a.snvl1.sfba.home.com/Framebuffer.html</a></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm954"></a>8.2. Configuring the framebuffer devices</h3></div></div></div><p>During make config, you need to choose whether to
				compile <code class="code">promcon</code> and / or
				<code class="code">fbcon</code>. You can select both, but if
				you do this, you will need to set the kernel
				flags to select the device. <code class="code">fbcon</code>
				always takes precedence if not set. If
				<code class="code">promcon</code> is not selected in, on
				boot up, it defaults to <code class="code">dummycon</code>.
				If <code class="code">promcon</code> is selected, it will
				use this device. Once the buses are booted, and
				<code class="code">fbcon</code> is compiled in, the kernel
				probes for the above framebuffers and will use
				<code class="code">fbcon</code>. If there is no framebuffer
				devices, it will default to
				<code class="code">promcon</code></p><p>Here are the kernel options</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">video=sbus:options</code></p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>where options
								is a comma
								separated
								list:</p></li><li class="listitem" style="list-style-type: none"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p><code class="code">nomargins</code>
										-
										sets
										margins
										to
										0,
										0</p></li><li class="listitem"><p><code class="code">margins=12x24</code>
										-
										sets
										margins
										to
										12,
										24
										(default
										is
										computed
										from
										resolution)</p></li><li class="listitem"><p><code class="code">off</code>
										-
										don't
										probe
										for
										any
										SBus
										/
										UPA
										framebuffers</p></li><li class="listitem"><p><code class="code">font=SUN12x22</code>
										-
										use
										a
										specific
										font</p></li></ul></div></li></ul></div></li></ul></div><p>So for example, booting with
				<code class="code">video=sbus:nomargins,font=SUN12x22</code>
				gives you a nice fast text console with a text
				resolution of 96x40, looks similar to a Solaris
				console but with colours and virtual terminals
				just like on the x86 platform.</p><p>If you want to use the <code class="code">SUN12x22</code>
				font, you need to enable it during make config
				(disable the <code class="code">fontwidth != 8</code>
				option). The accelerated framebuffers can
				support any font width between one to sixteen
				pixels, whilst dumb frame buffers only supports
				4, 8, 12 and 16 pixel font widths.</p><p>It is recommended that you grab a recent
				consoletools packages.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm995"></a>9. Using framebuffer devices on MIPS platforms</h2></div></div></div><p>There is no need to change anything for this platform,
			this is all handled for you automatically. Indys in
			particular are hardwired to use a console size of
			160x64. However, moves are afoot to rewrite the console
			code for these Indys, so keep an eye on this
			section.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm998"></a>10. Using framebuffer devices on ARM platforms</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1000"></a>10.1. Netwinders</h3></div></div></div><p>For the Netwinders (which uses the ARM SA110 RISC chip -
			a lovely British processor), there are two versions of
			the Cyber2000 framebuffer driver - one for 2.0.x
			kernels and one for 2.2.x kernels. It is quite
			straightforward to enable and use this driver on both
			kernels, however, the older version is hardcoded for
			depth and resolution (blech), but the good news is that
			the newer version in the 2.2.x kernels is much more
			flexible, but currently in a state of flux as it is
			still in development. To get this up and running, your
			best bet is to read the documentation that comes with
			the ARM port of the kernel sources.</p><p>The Netwinders uses a VGA compatible chipset, but
			unfortunately noone has ported vgafb to it yet. That
			might happen if someone has some time on their
			hands. [I would do it if someone would give me a
			NetWinder to play with]</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1004"></a>10.2. Acorn Archimedes</h3></div></div></div><p>Acorns have always had framebuffer support since
				the Linux 1.9.x days. However the Acornfb
				driver in 2.2.x is totally new since the
				generic framebuffer interface changed during
				the development of 2.1.x kernels (which, of
				course, became 2.2.x). As previously, it is a
				simple matter to activate the driver and
				set depths and resolutions.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1007"></a>10.3. Other ARM ports (SA7710s et. al.)</h3></div></div></div><p>Surprisingly, there is even a framebuffer driver
				for the Psion 5 and the Geofox!  I have been
				told that it displays the Penguin quite well.
				[Someone please donate me a Psion 5!]</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1010"></a>11. Using multi-headed framebuffers</h2></div></div></div><p>This part of the document was very kindly donated by
			Frederick A. Niles, who retains all rights to the
			information contained herewith in this section of the
			HOWTO.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1013"></a>11.1. Introduction</h3></div></div></div><p>The main goal of this document is to get you
				started with running a dual head configuration
				of Linux.  While this process is pretty
				straight forward there are numerous things that
				one can do wrong along the way.</p><p>The example I concentrate on is getting an
				X-server running on a second monitor.  I find
				this nice as you can usually find old large 19"
				to 21" fixed frequency monitors around that
				people are giving away because they can't use
				them.  This way you can boot off a small
				multisync and then use X on a nice big
				monitor.</p><p>Please understand dual head support is currently
				developing so this information changes rapidly.
				Anything in this document could be out of date
				or just plain incorrect by the time you are
				reading this.</p><p>** WARNING ** This document was written before
				any XFree86 4.0 release.  If you are reading
				this and XFree86 4.0 is already released many
				things may have changed.  Try getting a newer
				version of this document if it's
				available.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1019"></a>11.2. Feedback</h3></div></div></div><p>Feedback is most certainly welcome for this
				document. Without your submissions and input,
				this document wouldn't exist. So, please post
				your additions, comments and criticisms to:
				<code class="email">&lt;<a class="email" href="mailto:Frederick.A.Niles@gsfc.nasa.gov">Frederick.A.Niles@gsfc.nasa.gov</a>&gt;</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1023"></a>11.3. Contributors</h3></div></div></div><p>The following people have contributed to this
				mini-HOWTO.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Petr
						Vandrovec</p></li><li class="listitem"><p>Andreas Ehliar
						(x2x)</p></li><li class="listitem"><p>Marco Bizzarri (multiple X
						servers)</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1033"></a>11.4. Standard Disclaimer</h3></div></div></div><p>No liability for the contents of this document
				can be accepted.  Use the concepts, examples
				and other content at your own risk.  As this is
				a new edition of this document, there may be
				errors and inaccuracies that could be damaging
				to your system.  Proceed with caution, and
				although this is highly unlikely, I don't take
				any responsibility for that.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1036"></a>11.5. Copyright Information</h3></div></div></div><p>This section of the document is copyrighted
				© 1999 Frederick Niles and distributed
				under the following terms:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Linux HOWTO documents may be
						reproduced and distributed in
						whole or in part, in any medium
						physical or electronic, as long
						as this copyright notice is
						retained on all copies.
						Commercial redistribution is
						allowed and encouraged;
						however, the author would like
						to be notified of any such
						distributions.</p></li><li class="listitem"><p>All translations, derivative
						works, or aggregate works
						incorporating any Linux HOWTO
						documents must be covered under
						this copyright notice.  That
						is, you may not produce a
						derivative work from a HOWTO
						and impose additional
						restrictions on its
						distribution. Exceptions to
						these rules may be granted
						under certain conditions;
						please contact the Linux HOWTO
						coordinator at the address
						given below.</p></li><li class="listitem"><p>If you have questions, please
						contact, the Linux HOWTO
						coordinator, at
						<code class="email">&lt;<a class="email" href="mailto:linux-howto@sunsite.unc.edu">linux-howto@sunsite.unc.edu</a>&gt;</code></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1047"></a>11.6. What hardware is supported?</h3></div></div></div><p>Most video cards assume they will be the only one
				in the system and are permanently set with the
				addressing of the primary display adapter.
				There are a few exceptions.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Matrox cards: This includes
						Matrox Millennium, Matrox
						Millennium II, Matrox Mystique,
						Matrox Mystique 220, Matrox
						Productiva G100, Matrox
						Mystique G200, Matrox
						Millennium G200 and Matrox
						Marvel G200 video
						cards</p></li><li class="listitem"><p>MDA: This includes monochrome
						Hercules graphics adapters among
						others. This for text only
						second head
						support.</p></li></ul></div><p>Note: it's only the second adapter that
					has to be one of the above.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1056"></a>11.7. Commercial support</h3></div></div></div><p>This mini-HOWTO in primarily concerned with free
				software.  However, there are commercial X
				servers with multi-head support.  These include
				Metro Link's (www.metrolink.com) Metro-X and Xi
				Graphics' (www.xig.com) Accelerated-X.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1059"></a>11.8. Getting all the stuff</h3></div></div></div><p>You'll need the following patches and programs:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">fbset</code> program -
						try <a class="ulink" href="http://www.cs.kuleuven.ac.be/~geert/bin/" target="_top">http://www.cs.kuleuven.ac.be/~geert/bin/</a>
						(note: RedHat 6.0 already has
						this program
						included)</p></li><li class="listitem"><p><code class="code">fbaddon</code> Matrix
						dual head patches for Linux
						kernel - try <a class="ulink" href="ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/" target="_top">ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/</a></p></li><li class="listitem"><p><code class="code">con2fb</code> program -
						try <a class="ulink" href="ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/" target="_top">ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/</a></p></li><li class="listitem"><p>The X11 frame buffer server
						<code class="code">XF86_FBDev</code>.  This
						is a standard part of XFree86
						3.3.1.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1078"></a>11.9. Getting Started</h3></div></div></div><p>The first thing you'll need to do is to patch a
				copy of the Linux source with the
				"<code class="code">fbaddon</code>" patch.  Then you need to
				configure the kernel and turn on frame buffer
				support.  If you have Matrox cards turn on
				Matrox unified accelerated driver support as
				well as the particular type of card you have.
				Don't turn on VESA frame buffer support. It can
				cause a conflict.  Do turn on multi-head
				support (obviously). Build the kernel and
				reboot.</p><p>Now you need to install the "<code class="code">fbset</code>"
				program and carefully read all the
				documentation on how to adjust the settings.
				Using a "<code class="code">/etc/fb.modes</code>" file is
				highly recommended once you've decided on your
				settings.  The fbset program includes a Perl
				script to convert your XF86Config file to
				fb.modes settings.  I've included my
				octave/Borne shell script to convert your
				XF86Config file in Appendix A &amp; B.</p><p>You need to get comfortable with using the frame
				buffer device on one monitor, understanding any
				issues that can arise from your set up that
				have nothing to do with multi-head support.
				This can save a lot of head scratching
				later.</p><p>I'm going to concentrate my explanation on
				getting X running on the second monitor as
				doing most other configurations will just be a
				obvious subset of the procedure.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1087"></a>11.9.1. Move a console over...</h4></div></div></div><p>Compile the "con2fb" program.  If you run
					it without any arguments you'll get the
					following usage message: "<code class="code">usage:
						con2fb fbdev
						console</code>".</p><p>Thus, an example command would be
					"<code class="code">con2fb /dev/fb1
						/dev/tty6</code>" to move
					virtual console number six over to the
					second monitor.  Use Ctrl-Alt-F6 to
					move over to that console and see that
					it does indeed show up on the second
					monitor.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1093"></a>11.9.2. Use "<code class="code">fbset</code>" to adjust the
					settings on this second display</h4></div></div></div><p>Only set the "<code class="code">fbset</code>"
					settings on the monitor you run the
					"<code class="code">fbset</code>" command on.
					Therefore, you must be careful to use
					the "<code class="code">-fb</code>" flag on the
					second monitor.  In particular, if you
					do nothing else you'll probably want to
					at least set the virtual vertical
					resolution to your actually vertical
					resolution.</p><p>e.g. "<code class="code">fbset -fb /dev/fb1 -vyres
						600</code>"</p><p>This will seriously slow down text mode,
					but X will be obnoxious without
					it.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1103"></a>11.9.3. Set up X for framebuffer support.</h4></div></div></div><p>The framebuffer.txt file explains this
					better than I can, but here's the two
					important points.</p><p>Make sure you set the link for "X" to
					point to "XF86_FBDev".</p><p>Next you need to add a monitor section to
					your XF86Config file for the frame
					buffer device.  Here's an example:</p><div class="literallayout"><p><code class="code"><br>
# The Frame Buffer server<br>
<br>
Section "Screen"<br>
    Driver      "fbdev"<br>
    Device      "Millennium"<br>
    Monitor     "NEC MultiSync 5FGp"<br>
    Subsection "Display"<br>
        Depth       8<br>
        Modes       "default"<br>
        ViewPort    0 0<br>
    EndSubsection Subsection "Display"<br>
        Depth       16<br>
        Modes       "default"<br>
        ViewPort    0 0<br>
    EndSubsection<br>
    Subsection "Display"<br>
        Depth       24<br>
        Modes       "default"<br>
        ViewPort    0 0<br>
    EndSubsection<br>
    Subsection "Display"<br>
        Depth       32<br>
        Modes       "default"<br>
        ViewPort    0 0<br>
    EndSubsection<br>
EndSection<br>
				</code></p></div><p>Use the "<code class="code">default</code>" modes as I don't think
					any other ones will work with the Matrox
					frame buffer.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1113"></a>11.9.4. Try starting the X server on the second
					display</h4></div></div></div><p>Set the environment variable
					<code class="code">FRAMEBUFFER</code> to the second
					frame buffer.</p><p>"<code class="code">export
						FRAMEBUFFER=/dev/fb1</code>" or
					"<code class="code">setenv FRAMEBUFFER
						/dev/fb1</code>"</p><p>You need to start the X server so that it
					both matches the selected color depth
					and it appears on the same monitor you
					start the X server from.</p><p>e.g. "<code class="code">startx -- :0 -bpp 16
						vt06</code>"</p><p>This example will start the "zeroth" X
					server on virtual console six with 16
					bit color.  Using ":1" when launching
					another X server for the other frame
					buffer will allow you to have two X
					servers running.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1124"></a>11.10. Summary</h3></div></div></div><p>The steps involved in getting a X server running
				on a second display can be summrized as
				follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Get the kernel patch,
						<code class="code">fbset</code> and
						<code class="code">con2fb</code></p></li><li class="listitem"><p>Patch the kerenl, configure,
						rebuild and
						reboot</p></li><li class="listitem"><p>Add <code class="code">XF86_FBDev</code>
						section to XF86Config file and
						set X symbolic
						link</p></li></ul></div><p>Then each time you reboot:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Move a console over e.g.
						"<code class="code">con2fb /dev/fb1
							/dev/tty6</code>"</p></li><li class="listitem"><p>Adjust the settings e.g.
						"<code class="code">fbset -fb /dev/fb1
							1280x1024</code>"</p></li><li class="listitem"><p>Set the FRAMEBUFFER e.g. "<code class="code">export FRAMEBUFFER=/dev/fb1</code>"</p></li><li class="listitem"><p>Start the X server e.g. "<code class="code">startx -- -bpp 16 vt06</code>"</p></li></ul></div><p>You can automate this each time you reboot via a
				shell alias.  It must be an alias and not a
				shell script since it needs to detect the
				current console number.  This is my csh alias
				to start up X on a second fixed frequency
				monitor:</p><div class="literallayout"><p><code class="code"><br>
alias startxfb = "<br>
setenv FRAMEBUFFER /dev/fb\!*;    # Set the env var to the cmd arg.<br>
con2fb $FRAMEBUFFER /dev/$tty;    # Move the fb to the current tty.<br>
fbset -fb $FRAMEBUFFER 1280x1024@62;  # Favorite from /etc/fb.modes<br>
startx -- :\!* -bpp 16 vt0`echo $tty | cut -dy f 2`' # X on this tty.<br>
"<br>
			</code></p></div><p>In my .cshrc file these are all on the same line
				together without the comments, but it's easier
				to read here with line breaks and comments
				inserted.  I just give the number of the frame
				buffer as an argument and it starts right
				up.</p><p>I'm not sure how to do this same alias in bash.
				I don't know how to determine the current tty
				or get the arguments to an alias in bash.  If
				someone lets me know I'll insert it here.
				However, you can use the "tty" command to get
				the name of the current VT and just make two
				separate aliases for each X server.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1157"></a>11.11. Other Notes and Problems</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Both "<code class="code">fbset</code>" and
						"<code class="code">startx</code>" commands
						MUST be run from the same frame
						buffer as the one being
						affected.  This places serious
						limits on how much of these
						commands can be automated via
						scripts.</p></li><li class="listitem"><p>XFree86 4.0 will have "proper"
						multi-head support, but 3.3.1
						does not.  You can run two
						servers with 3.3.1 and use
						"<code class="code">x2x</code>" to switch
						between them
						however...(see the next
						bullet)</p></li><li class="listitem"><p>The inactive frame buffer will
						just hold the last image of
						when it was active, no updates
						with occur.</p></li><li class="listitem"><p>The monitor that's not selected
						doesn't always preseve it's
						state when not active. (But it
						usually does)</p></li><li class="listitem"><p>Geert Uytterhoeven (the frame
						buffer maintainer) and Linus
						Torvalds don't agree with the
						current "frame buffer per VT"
						multi-head console support
						changes (i.e.
						"<code class="code">fbaddon</code>") so it
						may never be in the mainstream
						kernel tree. (This was heard
						third hand and may be wildly
						untrue.)</p></li><li class="listitem"><p>If you "break the rules" and
						start the X server (run
						"<code class="code">startx</code>") from a
						different monitor, the machine
						can eventually crash badly with
						the keyboard and mouse input
						all mixed
						together.</p></li><li class="listitem"><p>The documentation
						framebuffer.txt in the kernel
						source explains that you can
						use the Modeline settings in
						your XF86Config file directly
						when running X.  Using the
						Matrox frame buffer seems to
						force the X server to drop all
						of those.  So you can only have
						the one
						("<code class="code">default</code>")
						setting at a time (the same
						one you had in text
						mode).</p></li><li class="listitem"><p>The XF86_FBDev driver is
						unaccelerated. However, there
						are patches for accelerated
						Matrox support at <a class="ulink" href="http://www.in-berlin.de/User/kraxel/xfree86/" target="_top">http://www.in-berlin.de/User/kraxel/xfree86/</a></p></li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1183"></a>11.11.1. Getting "<code class="code">init level 5</code>"
					(i.e. <code class="code">xdm</code> /
					<code class="code">gdm</code>) to work</h4></div></div></div><p>I have not yet figured out a way to boot
					with init level 5 with a dual monitor
					configuration (and actually have the
					server on either the second montior or
					both).  While it seems easy enough to
					add a line to the gdm/xdm Xservers
					file, the constraint that you must start
					the X server from the same frame buffer
					prevents the obvious solution from
					working.  If anyone finds a way please
					e-mail me and I'll add it here.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1189"></a>11.11.2. Using the "<code class="code">x2x</code>" program</h4></div></div></div><p>There's a nice little program called
					<code class="code">x2x</code> that will switch X
					servers for you when you get to the
					edge of the screen.  Last known home
					for this program was: <a class="ulink" href="http://ftp.digital.com/pub/DEC/SRC/x2x/" target="_top">http://ftp.digital.com/pub/DEC/SRC/x2x/</a>
					It's also an optional Debian package.
					I haven't tried it yet but some users
					have reported success.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm1195"></a>11.11.3. Other useful commands</h4></div></div></div><p>These are existing linux commands that
					are worth remembering when dealing with
					a multi-head configuration (especially
					in writing scripts).</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>"<code class="code">chvt</code>"
							will allow you to
							switch between virtual
							terminals.</p></li><li class="listitem"><p>"<code class="code">openvt</code>"
							start a program on a
							new virtual terminal
							(VT).</p></li><li class="listitem"><p>"<code class="code">tty</code>" will
							report the name of the
							current
							terminal.</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1208"></a>11.12. Appendix A. Octave "<code class="code">ctmodem.m</code>" script</h3></div></div></div><p>(note the bpp settings)</p><div class="literallayout"><p><code class="code"><br>
#!/usr/bin/octave -q<br>
bpp = 16;<br>
DCF = sscanf(argv(1,:), "%f");<br>
HR  = sscanf(argv(2,:), "%f");<br>
SH1 = sscanf(argv(3,:), "%f");<br>
SH2 = sscanf(argv(4,:), "%f");<br>
HFL = sscanf(argv(5,:), "%f");<br>
VR  = sscanf(argv(6,:), "%f");<br>
SV1 = sscanf(argv(7,:), "%f");<br>
SV2 = sscanf(argv(8,:), "%f");<br>
VFL = sscanf(argv(9,:), "%f");<br>
pixclock = 1000000 / DCF;<br>
left_margin = HFL - SH2;<br>
right_margin = SH1 - HR;<br>
hsync_len = SH2 - SH1;<br>
<br>
# 3) vertical timings:<br>
upper_margin = VFL - SV2;<br>
lower_margin = SV1 - VR;<br>
vsync_len = SV2 - SV1;<br>
<br>
RR = DCF / (HFL * VFL) *1e6;<br>
HSF = DCF / HFL * 1e3;<br>
printf("mode \"%dx%d\"\n",HR,VR);<br>
printf("   # D: %3.2f MHz, H: %3.2f kHz, V: %2.2f Hz\n", DCF, HSF, RR);<br>
printf("   geometry %d %d %d %d %d\n", HR, VR, HR, VR, bpp);<br>
printf("   timings %d %d %d %d %d %d %d\n", ...<br>
	pixclock, left_margin, right_margin, ...<br>
	upper_margin, lower_margin, ...<br>
	hsync_len, vsync_len);<br>
printf("endmode\n");<br>
			</code></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm1215"></a>11.13. Appendix B. Bourne Shell "<code class="code">cvtfile</code>"
				script</h3></div></div></div><p>(This calls the octave script
				"<code class="code">cvtmode</code>")</p><div class="literallayout"><p><code class="code"><br>
#!/bin/sh<br>
<br>
# Shell script to convert XF86Config file to fb.modes file.<br>
# Uses octave script cvtmode.m<br>
<br>
if [ -z $1 ]; then<br>
  FILE=/etc/X11/XF86Config<br>
else<br>
  FILE=$1<br>
fi<br>
<br>
i=1<br>
LEN=`grep Modeline $FILE | wc -l`<br>
while expr $i \&lt; $LEN &gt; /dev/null ;<br>
do<br>
  CURLINE=`grep Modeline $FILE | cut -d'"' -f 3-20 | head -$i | tail -1 `<br>
  ./cvtmode.m $CURLINE<br>
  echo " "<br>
  i=`expr $i + 1`<br>
done<br>
			</code></p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1223"></a>12. Using / Changing Fonts</h2></div></div></div><p>To get the capability to change fonts, you need kbd-0.99.
			You may obtain this from <a class="ulink" href="ftp://ftp.win.tue.nl/pub/linux/utils/kbd" target="_top">ftp://ftp.win.tue.nl/pub/linux/utils/kbd</a></p><p>One advantage of downloading and installing kbd-0.99 is
			that you will be able to load international fonts (i.e
			Euro symbol) into your console device. On my keyboard I
			can have three symbols on my keyboard, the dollar sign,
			the English pound sign and the Euro sign.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1228"></a>13. Changing Console Modes</h2></div></div></div><p>To get the capability to change modes (i.e 640x480,
			800x800 etc), you need fbset (currently
			fbset-19990118.tar.gz) - you may ftp it from <a class="ulink" href="http://www.cs.kuleuven.ac.be/~geert/bin/fbset-19990118.tar.gz" target="_top">http://www.cs.kuleuven.ac.be/~geert/bin/fbset-19990118.tar.gz</a>.
			This comes with a full set of instructions on how to
			operate this.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1232"></a>14. Setting up the X11 FBdev driver</h2></div></div></div><p>If you are not using XFree86 3.3.3.1 or later, you are
			urged to upgrade to XFree86 3.3.3.1, as it includes a
			FBdev X driver for framebuffer devices. Otherwise,
			follow the steps below to either download or build your
			own FBdev driver for older XFree86 versions such as
			3.3.2, 3.3.3 etc.</p><p>Go to <a class="ulink" href="http://www.xfree86.org" target="_top">http://www.xfree86.org</a>, and
			download the latest XServer sources archive, unpack,
			and configure the drivers, following these
			steps:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Edit
					<code class="code">xc/config/cf/xf86site.def</code>,
					uncomment the <code class="code">#define</code> for
					<code class="code">XF68FBDevServer</code></p></li><li class="listitem"><p>Comment out <span class="emphasis"><em>all</em></span>
					references to
					<code class="code">FB_VISUAL_STATIC_DIRECTCOLOR</code>,
					as those are bogus and are not used any
					more. If you are using XFree86 3.3.3.1,
					there is no need to do this step as
					this has all been
					removed.</p></li><li class="listitem"><p>Edit
					<code class="code">xc/programs/Xserver/hw/xfree86/os-support/linux/lnx_io.c</code>,
					and change <code class="code">K_RAW</code> to
					<code class="code">K_MEDIUMRAW</code></p></li></ul></div><p>And then build the driver. Don't worry about the m68k
			references, it supports x86 platforms. Then build the
			whole thing - it'll take a long time though as it's a
			large source tree.</p><p>Alternatively, if you don't have the time to spare, you
			can obtain the binaries from the sites below. Please
			note that these are 'unofficial' builds and you use
			them at your risk.</p><p>For libc5, use the one at: <a class="ulink" href="http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.gz" target="_top">http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.gz</a>.
			For glibc2, download from these URLs (<a class="ulink" href="http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.libc6.gz" target="_top">http://user.cs.tu-berlin.de/~kraxel/linux/XF68_FBDev.libc6.gz</a>
			or <a class="ulink" href="http://pobox.com/~brion/linux/fbxserver.html" target="_top">     http://pobox.com/~brion/linux/fbxserver.html</a></p><p>There have been reports that X11 is non functional on
			certain graphic cards with this vesafb feature enabled,
			if this is happening, try the new XF86_FBdev driver for
			X11.</p><p>This driver, along with vesafb can also help run X11 in
			higher graphic resolutions with certain graphic
			chipsets which are not supported by any of the current
			X11 drivers. Examples are Matrox G200 et. al.</p><p>To configure the XF86_FBdev driver with your X11 system,
			you'll need to edit your XF86Config for the
			following:</p><div class="literallayout"><p><code class="code"><br>
Section "Screen"<br>
        Driver          "FBDev"<br>
        Device          "Primary Card"<br>
        Monitor         "Primary Monitor"<br>
        SubSection      "Display"<br>
                Modes           "default"<br>
        EndSubSection<br>
EndSection<br>
		</code></p></div><p>You'll also need to set XkbDisable in the keyboard
			section as well, or invoke the XF86_FBDev server with
			the '<code class="code">-kb</code>' option to set up your keyboard
			so it works properly. If you forget to set XkbDisable,
			you will have to put the following lines in your
			<code class="code">.Xmodmap</code> to straighten out the keyboard
			mappings. Alternatively, you can edit your xkb to
			reflect the list below.</p><p><span class="emphasis"><em>This is fixed in XFree86 3.3.3.1, and it is a
				good idea to upgrade to this version anyway
				because there are quite a few bug fixes, and
				also, it includes FBDev as one of the drvers,
				as I've mentioned previously.</em></span></p><div class="literallayout"><p><code class="code"><br>
! Keycode settings required<br>
keycode 104 = KP_Enter<br>
keycode 105 = Control_R<br>
keycode 106 = KP_Divide<br>
keycode 108 = Alt_R Meta_R<br>
keycode 110 = Home<br>
keycode 111 = Up<br>
keycode 112 = Prior<br>
keycode 113 = Left<br>
keycode 114 = Right<br>
keycode 115 = End<br>
keycode 116 = Down<br>
keycode 117 = Next<br>
keycode 118 = Insert<br>
keycode 119 = Delete<br>
		</code></p></div><p>You may need to do some fiddling around with this (try
			copying the original definition from the original X11
			driver that you were using and editing the name of the
			driver to FBDev), but basically this is what you need
			to do to use the vesafb X11 driver.</p><p>Hopefully the X11 problems with supported graphic cards
			will be fixed in future releases.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1274"></a>15. How do I convert XFree86 mode-lines into framebuffer device timings?</h2></div></div></div><p>If you have XFree86 (X11) installed on your machine, and
			you can use it successfully, it is a simple matter to
			convert the mode-lines in your XF86Config file to the
			required timings needed by the framebuffer
			devices.</p><p>The framebuffer device requires the following
			fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">pixclock</code> - pixel clock in
					pico seconds</p></li><li class="listitem"><p><code class="code">left_margin</code> - time between
					sync to display</p></li><li class="listitem"><p><code class="code">right_margin</code> - time
					between display to
					sync</p></li><li class="listitem"><p><code class="code">upper_margin</code> - time
					between sync to
					display</p></li><li class="listitem"><p><code class="code">lower_margin</code> - time
					between display to
					sync</p></li><li class="listitem"><p><code class="code">hsync_len</code> - horizontal
					sync length </p></li><li class="listitem"><p><code class="code">vsync_len</code> - vertical sync
					length</p></li></ul></div><p>An XFree86 mode line has the following fields:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">Modeline "1280x1024" DCF HR SH1
						SH2 HFL VR SV1 SV2
						VFL</code></p></li></ul></div><p>It is necessary to do some simple calculations to
			translate the XF86 mode-lines into a set of framebuffer
			device timings. As an example, we shall examine how to
			convert a mode-line taken from my XF86Config file:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">Modeline "1280x1024" 110.0 1280
						1328 1512 1712 1024 1025 1028
						1054</code></p></li></ul></div><p>First, calculate the required pixclock rate. XFree86 uses
			megahertz whilst framebuffer devices uses picoseconds
			(Why, I don't know). Divide one million by DCF.  For
			example: <code class="code">1,000,000 / 110.0 =
				9090.9091</code></p><p>Now we need to calculate the horizontal timings:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">left_margin = HFL -
						SH2</code></p></li><li class="listitem"><p><code class="code">right_margin = SH1 -
						HR</code></p></li><li class="listitem"><p><code class="code">hsync_len = SH2 -
						SH1</code></p></li></ul></div><p>In our example, this would be:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">left_margin = 1712 - 1512 =
						200</code></p></li><li class="listitem"><p><code class="code">right_margin = 1328 - 1280 =
						48</code></p></li><li class="listitem"><p><code class="code">hsync_len = 1512 - 1328 =
						184</code></p></li></ul></div><p>And now we need to calculate the vertical timings.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">upper_margin = VFL -
						SV2</code></p></li><li class="listitem"><p><code class="code">lower_margin = SV1 -
						VR</code></p></li><li class="listitem"><p><code class="code">vsync_len = SV2 -
						SV1</code></p></li></ul></div><p>For our example, this would be:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">upper_margin = 1054 - 1028 =
						26</code></p></li><li class="listitem"><p><code class="code">lower_margin = 1025 - 1024 =
						1</code></p></li><li class="listitem"><p><code class="code">vsync_len = 1028 - 1025 =
						3</code></p></li></ul></div><p>Now we can use this information to set up the framebuffer
			for the desired mode. For example, for the matroxfb
			framebuffer driver, it requires the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">video=matrox:xres:&lt;&gt;,yres:&lt;&gt;,depth:&lt;&gt;,left:&lt;&gt;,right:&lt;&gt;,hslen:&lt;&gt;,upper:&lt;&gt;,lower:&lt;&gt;,vslen:&lt;&gt;</code></p></li></ul></div><p>I put into my <code class="code">/etc/lilo.conf</code> the following line:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">append =
						"video=matroxfb:xres:1280,yres:1024,depth:32,left:200,right:48,hslen:184,upper:26,lower:0,vslen:3"</code></p></li></ul></div><p>Note that in this case the pixel clock isn't used. It's
			only necessary if you don't like the default pixel
			clock rates.  You can supply this as a parameter as
			well. Setting the pixclock is documented in other parts
			of this HOWTO.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1368"></a>16. Changing the Linux Logo</h2></div></div></div><p>It can be customised by changing the file
			<code class="code">linux_logo.h</code> in <code class="code">include/linux</code>
			directory. It is a C header file, and pretty hard to
			change by hand, however there is a plugin available for
			Gimp from <a class="ulink" href="http://registry.gimp.org/detailview.phtml?plugin=Linux+Logo" target="_top">http://registry.gimp.org/detailview.phtml?plugin=Linux+Logo</a>
			that will create one for you. All you need is a picture
			80 pixels in height and width, with less than 224
			colours. You can either let Gimp create the three
			varieties (2, 16, 224 colours), or create them yourself
			and use them with the plug-in. It will ask you where
			you want to store the file, and if you are game you can
			put it into
			<code class="code">($SRCDIR)/include/linux/linux_logo.h</code>. Once
			that is finished all you need to do is recompile the
			kernel as usual, reboot, and if framebuffer is working,
			you will see your new logo upon bootup.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1375"></a>17. Looking for further information</h2></div></div></div><p>For those of you interested in working with the
			framebuffer drivers, point your web browser at <a class="ulink" href="http://www.linux-fbdev.org" target="_top">http://www.linux-fbdev.org</a> for
			more information on programming.</p><p>Parlez-vous Francais? There is a translation at <a class="ulink" href="http://www.freenix.org/unix/linux/HOWTO/mini/Vesafb.html" target="_top">http://www.freenix.org/unix/linux/HOWTO/mini/Vesafb.html</a></p></div></div></body></html>
