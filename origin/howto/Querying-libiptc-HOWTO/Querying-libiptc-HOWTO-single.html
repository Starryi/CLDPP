<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Querying libiptc HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Querying libiptc HOWTO</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
>Leonardo Balliache</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:leonardo@opalsoft.net"
>leonardo@opalsoft.net</A
>&#62;</CODE
></P
></DIV
></DIV
><P
CLASS="PUBDATE"
>Version 0.1 - April 30, 2002<BR></P
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1</TD
><TD
ALIGN="LEFT"
>2002-04-30</TD
><TD
ALIGN="LEFT"
>Revised by: lb</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial release.</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#LEGAL"
>Legal Notice</A
></DT
><DT
>2. <A
HREF="#TRANSLAT"
>Translations</A
></DT
><DT
>3. <A
HREF="#DISCLAIM"
>Disclaimer</A
></DT
><DT
>4. <A
HREF="#CREDITS"
>Credits</A
></DT
><DT
>5. <A
HREF="#OBJECT"
>Objectives</A
></DT
><DT
>6. <A
HREF="#WHATIS"
>What is libiptc?</A
></DT
><DT
>7. <A
HREF="#HOWDIDI"
>How did I obtain this knowledge?</A
></DT
><DT
>8. <A
HREF="#PREVIOUS"
>Previous knowledge and system requirements</A
></DT
><DT
>9. <A
HREF="#INSTALL"
>Installing iptables + libiptc</A
></DT
><DT
>10. <A
HREF="#HOWTOPRG"
>How to create your program(s)</A
></DT
><DT
>11. <A
HREF="#QFUNCTION"
>Functions to query libiptc</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#AEN233"
>iptc_init</A
></DT
><DT
>11.2. <A
HREF="#AEN260"
>iptc_strerror</A
></DT
><DT
>11.3. <A
HREF="#AEN279"
>iptc_first_chain</A
></DT
><DT
>11.4. <A
HREF="#AEN297"
>iptc_next_chain</A
></DT
><DT
>11.5. <A
HREF="#AEN355"
>iptc_is_chain</A
></DT
><DT
>11.6. <A
HREF="#AEN376"
>iptc_builtin</A
></DT
><DT
>11.7. <A
HREF="#AEN396"
>iptc_first_rule</A
></DT
><DT
>11.8. <A
HREF="#AEN417"
>iptc_next_rule</A
></DT
><DT
>11.9. <A
HREF="#AEN440"
>iptc_get_target</A
></DT
><DT
>11.10. <A
HREF="#AEN556"
>iptc_get_policy</A
></DT
><DT
>11.11. <A
HREF="#AEN588"
>iptc_read_counter</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#MFUNCTION"
>Functions to modify firewalling rules and statistics</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#AEN621"
>iptc_commit</A
></DT
><DT
>12.2. <A
HREF="#AEN645"
>iptc_insert_entry</A
></DT
><DT
>12.3. <A
HREF="#AEN674"
>iptc_replace_entry</A
></DT
><DT
>12.4. <A
HREF="#AEN703"
>iptc_append_entry</A
></DT
><DT
>12.5. <A
HREF="#AEN730"
>iptc_delete_num_entry</A
></DT
><DT
>12.6. <A
HREF="#AEN756"
>iptc_flush_entries</A
></DT
><DT
>12.7. <A
HREF="#AEN779"
>iptc_zero_entries</A
></DT
><DT
>12.8. <A
HREF="#AEN802"
>iptc_create_chain</A
></DT
><DT
>12.9. <A
HREF="#AEN825"
>iptc_delete_chain</A
></DT
><DT
>12.10. <A
HREF="#AEN849"
>iptc_rename_chain</A
></DT
><DT
>12.11. <A
HREF="#AEN875"
>iptc_set_policy</A
></DT
><DT
>12.12. <A
HREF="#AEN906"
>iptc_zero_counter</A
></DT
><DT
>12.13. <A
HREF="#AEN932"
>iptc_set_counter</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#BMETER"
>Bandwidth meter</A
></DT
><DT
>14. <A
HREF="#CFLOWS"
>Controlling flows</A
></DT
><DT
>15. <A
HREF="#SOMELINKS"
>Some interesting links</A
></DT
><DT
>16. <A
HREF="#AUTHOR"
>About the author</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="LEGAL"
>1. Legal Notice</A
></H2
><P
>This document is free; you can redistribute it and/or modify it under the 
terms of the GNU General Public License as published by the Free Software 
Foundation; either version 2 of the License, or (at your option) any later 
version. This document is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General 
Public License for more details. You can get a copy of the GNU GPL 
<A
HREF="http://www.gnu.org/copyleft/gpl.html"
TARGET="_top"
>here</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TRANSLAT"
>2. Translations</A
></H2
><P
>If you want to translate this document you are free to do so. However,
you will need to do the following: </P
><P
></P
><OL
TYPE="1"
><LI
><P
> 
Check first that another version of the document doesn't already 
exist at your local LDP. </P
></LI
><LI
><P
> 
Maintain all sections (including 'Legal Notice', 'Translation', 
'Credits', etc., etc.) of the document.</P
></LI
><LI
><P
> 
No need to ask me to translate! You just have to let me know 
(if you want) about your translation. </P
></LI
></OL
><P
> 
Thank for your translation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DISCLAIM"
>3. Disclaimer</A
></H2
><P
>I took this <SPAN
CLASS="QUOTE"
>"disclaimer"</SPAN
> from 
<A
HREF="http://qos.ittc.ukans.edu/howto/howto.html"
TARGET="_top"
>Linux-Advance Networking Overview</A
> by
Saravanan Radhakrishnan (08-1999) because it applies in my own case:</P
><P
>All the text in this document is completely based on my understanding 
of implementations of various features. I have read some documents and
have seen the code myself, and I described them based on my understanding. 
If the reader notices any concept description which appears to be contrary 
to their understanding of the concept, the issue can be taken up for 
discussion and corrections will be made to the document as necessary. I
would appreciate any suggestions and comments made in order to improve the 
quality of this document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CREDITS"
>4. Credits</A
></H2
><P
>I want to thank the following people and organizations who had helped me,
directly or not, to make this document possible:</P
><P
></P
><UL
><LI
><P
>My wife Cielo and my sons Jose, Dario and Gustavo by their patient and
support.</P
></LI
><LI
><P
><A
HREF="http://www.tldp.org"
TARGET="_top"
>Linux Documentation Project</A
>
for publishing and uploading my document. </P
></LI
><LI
><P
> 
The site <A
HREF="http://www.docum.org"
TARGET="_top"
>http://www.docum.org</A
>
drived by Stef Coene that give me some ideas for writing this document.</P
></LI
><LI
><P
> 
Paul <SPAN
CLASS="QUOTE"
>"Rusty"</SPAN
> Rusell who write the kernel firewall code,
the excelent package <EM
>iptables</EM
> and the 
associated library <EM
>libiptc</EM
>. </P
></LI
><LI
><P
> 
Harald Welte who write the utility <EM
>iptables-save</EM
>.</P
></LI
><LI
><P
> 
Alexey Kuznetsov who write the kernel queue discipline code and the 
excelent package <EM
>iproute2</EM
>.</P
></LI
><LI
><P
> 
Tabatha Persad from the 
<A
HREF="http://www.tldp.org"
TARGET="_top"
>Linux Documentation Project</A
>
who revised my english syntax and writing, gave me several ideas to 
improve the content and encouraged me to learn and use DocBook to write
the final version of this document.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OBJECT"
>5. Objectives</A
></H2
><P
>This HOWTO explains how to use the <EM
>libiptc</EM
> library 
included in the <EM
>iptables</EM
> package. This document can 
show you how to use short C or C++ programs to query the internal structure 
of the firewalling code, to check chains and rules, packet and byte counters, 
and in a second phase, if you are a little <SPAN
CLASS="QUOTE"
>"brave"</SPAN
>, to modify 
them.</P
><P
>You can find the latest version of this document at 
<A
HREF="http://opalsoft.net/qos/libiptc/qlibiptc.html"
TARGET="_top"
>Querying libiptc HOWTO.html</A
>.</P
><P
>If you have suggestions to help make this document better, please submit 
your ideas to me at the following address: 
<A
HREF="mailto:leonardo@opalsoft.net"
TARGET="_top"
>leonardo@opalsoft.net</A
>.</P
><P
>While I wrote this HOWTO, I developed a simple bandwith meter using 
user-defined chains to get the data to be measured. This idea was conceived 
looking at <B
CLASS="COMMAND"
>monitor.pl</B
>, a simple perl program for bandwith 
measurement, written by Stef Coene at 
<A
HREF="http://www.docum.org"
TARGET="_top"
>http://www.docum.org</A
>.
I recommend this site to people interested in bandwidth control and 
measurement.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WHATIS"
>6. What is libiptc?</A
></H2
><P
><EM
>libiptc</EM
> is the library that is used to communicate 
with netfilter, the internal kernel code in charge of firewalling and packet
filtering. This code and <EM
>iptables</EM
> were written by Paul 
<SPAN
CLASS="QUOTE"
>"Rusty"</SPAN
> Russell. <EM
>iptables</EM
> was developed 
using <EM
>libiptc</EM
> calls to get the job done.</P
><P
>If you want to have more information about <EM
>iptables</EM
>, 
<EM
>libiptc</EM
> and the firewalling code, have a look at
links at the end of this document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HOWDIDI"
>7. How did I obtain this knowledge?</A
></H2
><P
> 
Just looking at code in <EM
>iptables 1.2.6</EM
> package and 
especially at program <EM
>iptables-save.c</EM
> that use
<EM
>libiptc</EM
> to dump information from firewalling 
kernel code.</P
><P
> 
I will try to be very pragmatic and clear in order to make this HOWTO
useful.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PREVIOUS"
>8. Previous knowledge and system requirements</A
></H2
><P
>You have to have some previous knowledge to follow this document:</P
><P
></P
><OL
TYPE="1"
><LI
><P
><EM
>Very important:</EM
>
You must know how to use the <EM
>iptables</EM
> package as a 
user, such as how to create or list rules and user chains. You do not need 
to be a firewall expert, but you should know how to use 
<EM
>iptables</EM
> fluently.</P
></LI
><LI
><P
>You have to have kernel sources installed in your system, in 
<TT
CLASS="FILENAME"
>/usr/src/linux</TT
> as usual.</P
><P
>I am using a <EM
>2.4.16</EM
> kernel in a 
<EM
>SuSE 7.1</EM
> Linux environment. You need 
<EM
>2.4.x</EM
> kernel code to follow this HOWTO, preferably kernel 
<EM
>2.4.16</EM
>. For <EM
>SuSE</EM
> you can
get the kernel sources at
<A
HREF="ftp://ftp.gwdg.de/pub/linux/suse/ftp.suse.com/suse/i386/update/"
TARGET="_top"
>ftp://ftp.gwdg.de/pub/linux/suse/ftp.suse.com/suse/i386/update</A
>.</P
></LI
><LI
><P
>You have to know how to compile the kernel if you have to update your kernel
version. After activating the netfilter options using 
<B
CLASS="COMMAND"
>make menuconfig</B
>, you
must compile and install the kernel as usual.</P
></LI
><LI
><P
>Reboot your new kernel using <B
CLASS="COMMAND"
>init 6</B
>. Ensure that you 
backup a copy of your previous kernel in <EM
>lilo</EM
> in case 
you encounter a problem and need to retrace your steps.</P
></LI
><LI
><P
>Be sure that your new <EM
>2.4.x</EM
> kernel is running fine. 
To install <EM
>iptables-1.2.6</EM
> you will need to patch the 
kernel again (and re-compile and install it), and it is better if you follow 
the previous two steps to ensure that your kernel is running right before 
applying new iptables patches.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INSTALL"
>9. Installing iptables + libiptc</A
></H2
><P
>To install <EM
>libiptc</EM
> follow these steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Download <EM
>iptables-1.2.6.tar.bz2</EM
> from 
<A
HREF="http://netfilter.samba.org/"
TARGET="_top"
>http://netfilter.samba.org/</A
>.</P
></LI
><LI
><P
>Copy the <EM
>iptables</EM
> tar file into 
<TT
CLASS="FILENAME"
>/usr/local/src</TT
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cp iptables-1.2.6.tar.bz2 /usr/local/src</B
></PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
> Unpack:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tar xjvf iptables-1.2.6.tar.bz2</B
></PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
> Go into the iptables directory:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cd iptables-1.2.6</B
></PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Check to see if your kernel needs some aditional patches with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>make pending-patches</B
> <EM
>KERNEL_DIR=/usr/src/linux</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If your kernel source is located somewhere other than in 
<TT
CLASS="FILENAME"
>/usr/src/linux</TT
>, replace the kernel source directory in 
the command line above with your source directory.</P
><P
>Be careful with this option. This command invokes 
<EM
>patch-o-matic</EM
>, a new patch verification utility by 
Rusty Russell. The utility will show you a list of new patches (some 
proposed, some submitted, some accepted) available for your kernel source. 
As Rusty himself says, <SPAN
CLASS="QUOTE"
>"Some of these new patches have bugs"</SPAN
>, 
and you do not have to apply all of them.</P
><P
>Read the information showed for each patch carefully and answer with 
<B
CLASS="KEYCAP"
>y</B
> (apply the patch) or <B
CLASS="KEYCAP"
>N</B
> (skip this patch). 
In some cases answering <B
CLASS="KEYCAP"
>y</B
> will try to apply the patch, but 
if the patch finds some differences between your sources, it will be 
skipped and the next new one presented.</P
><P
>I did not apply any of the proposed patches and kept my kernel in its
original state before continuing to the next step.</P
></LI
><LI
><P
>Make the iptables package with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>make</B
> <EM
>KERNEL_DIR=/usr/src/linux</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Again, if your kernel source is not at <TT
CLASS="FILENAME"
>/usr/src/linux</TT
>, 
replace the kernel source directory in the command above.</P
><P
>If all goes right the compiler will finish without errors.</P
></LI
><LI
><P
>Before the next step, check to see if you have installed iptables package by
typing:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>rpm -q iptables</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If the iptables rpm is installed, you will see the name and version of the
package, similar to:</P
><P
><EM
>iptables-1.1.2-13</EM
></P
><P
>In this case un-install with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>rpm -e iptables</B
></PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Install the new created package:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>make install</B
> <EM
>KERNEL_DIR=/usr/src/linux</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Again, check your kernel source directory.</P
><P
>This command will install the binaries (<EM
>iptables, iptables-save,
iptables-restore</EM
>) in <TT
CLASS="FILENAME"
>/usr/local/sbin</TT
>, the manuals 
in <TT
CLASS="FILENAME"
>/usr/local/man/man8</TT
> and the modules in 
<TT
CLASS="FILENAME"
>/usr/local/lib/iptables</TT
>.</P
></LI
><LI
><P
>Finally install the headers, development libraries and associated
development man pages, with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>make install-devel</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>This command will install the <EM
>libiptc</EM
> library 
in <TT
CLASS="FILENAME"
>/usr/local/lib</TT
>.</P
><P
>I think something must be wrong with this command. It does not install all
headers files properly, so you must install them yourself using:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cd /usr/local/src/iptables-1.2.6</B
>
bash# <B
CLASS="COMMAND"
>cp include/iptables.h /usr/local/include</B
>
bash# <B
CLASS="COMMAND"
>cp include/iptables_common.h /usr/local/include</B
>
bash# <B
CLASS="COMMAND"
>mkdir /usr/local/include/libiptc</B
>
bash# <B
CLASS="COMMAND"
>cp include/libiptc/libiptc.h /usr/local/include/libiptc</B
>
bash# <B
CLASS="COMMAND"
>cp include/libiptc/ipt_kernel_headers.h /usr/local/include/libiptc</B
>
bash# <B
CLASS="COMMAND"
>cp iptables.o /usr/local/lib</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
><TT
CLASS="FILENAME"
>iptables.o</TT
> is needed above to compile programs to get 
rule information from netfilter. </P
><P
>Now you are ready to create programs that can communicate directly with libiptc.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HOWTOPRG"
>10. How to create your program(s)</A
></H2
><P
>Create your program(s) in <TT
CLASS="FILENAME"
>/usr/local/src</TT
>; 
this way you will not have problems with gcc looking for files in the "include" section.</P
><P
>Your program(s) would be something like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* My program */

#include &#60;getopt.h&#62;
#include &#60;sys/errno.h&#62;
#include &#60;stdio.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;dlfcn.h&#62;
#include &#60;time.h&#62;
#include "libiptc/libiptc.h"
#include "iptables.h"

int main(void)
{
<EM
>  /* Use always this part for your programs .... From here ... **** */</EM
>
  iptc_handle_t h;
  const char *chain = NULL;
  const char *tablename = NULL;

  program_name = "my_program";
  program_version = NETFILTER_VERSION;
<EM
>  /* .... To here .... ******************************************** */</EM
>

<EM
>  /* From here you write your own code */</EM
>
  .... your code ...
  ....
  ....

} /* main */</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>The "include" section is <EM
>a must</EM
> in your c/c++ program(s).</P
></LI
><LI
><P
>If you are using c++ do not forget to write extern "C" for 
these include.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="QFUNCTION"
>11. Functions to query libiptc</A
></H2
><P
>This section explains which functions allow you to query libiptc. We will use
the header file of <EM
>libiptc</EM
>, 
file <TT
CLASS="FILENAME"
>usr/local/include/libiptc/libiptc.h</TT
>, 
containing prototypes of each function as a reference to develop our explanation. </P
><P
>I have also included a brief description (when available) taken from 
<A
HREF="http://netfilter.samba.org/documentation/HOWTO/"
TARGET="_top"
>Linux netfilter Hacking HOWTO</A
> within each function explanation.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN233"
>11.1. iptc_init</A
></H3
><P
><B
>Name: </B
>iptc_init</P
><P
><B
>Usage: </B
>Takes a snapshot of the rules.</P
><P
><B
>Prototype: </B
>iptc_handle_t iptc_init(const char *tablename)</P
><P
><B
>Description: </B
>This function must be called as initiator before any other function can be
called.</P
><P
><B
>Parameters: </B
><EM
>tablename</EM
> is the name of the table we need to query 
and/or modify; this could be <EM
>filter</EM
>, 
<EM
>mangle</EM
>, <EM
>nat</EM
>, etc.</P
><P
><B
>Returns: </B
>Pointer to a structure of type <EM
>iptc_handle_t</EM
> that must 
be used as main parameter for the rest of functions we will call 
from <EM
>libiptc</EM
>. <EM
>iptc_init</EM
> returns the 
pointer to the structure or NULL if it fails. If this happens you can invoke 
<EM
>iptc_strerror</EM
> to get information about the error. 
See below.</P
><P
>Have a look at this section of code in file <TT
CLASS="FILENAME"
>iptables-save.c</TT
>
for how to invoke this function:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  h = iptc_init(tablename);
  if (!h)
    exit_error(OTHER_PROBLEM, "Can't initialize: %s\n",iptc_strerror(errno));</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN260"
>11.2. iptc_strerror</A
></H3
><P
><B
>Name: </B
>iptc_strerror</P
><P
><B
>Usage: </B
>Translates error numbers into more human-readable form.</P
><P
><B
>Prototype: </B
>const char *iptc_strerror(int err)</P
><P
><B
>Description: </B
>This function returns a more meaningful explanation of a failure code in 
the iptc library.  If a function fails, it will always set 
<EM
>errno</EM
>. This value can be passed to 
<EM
>iptc_strerror()</EM
> to yield an error message.</P
><P
><B
>Parameters: </B
><EM
>err</EM
> is an integer indicating the error number.</P
><P
><B
>Returns: </B
>Char pointer containing the error description.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN279"
>11.3. iptc_first_chain</A
></H3
><P
><B
>Name: </B
>iptc_first_chain</P
><P
><B
>Usage: </B
>Iterator functions to run through the chains.</P
><P
><B
>Prototype: </B
>const char *iptc_first_chain(iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function returns the first chain name in the table.</P
><P
><B
>Parameters: </B
>Pointer to a structure of type <EM
>iptc_handle_t</EM
> that was
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Char pointer to the name of the chain.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN297"
>11.4. iptc_next_chain</A
></H3
><P
><B
>Name: </B
>iptc_next_chain</P
><P
><B
>Usage: </B
>Iterator functions to run through the chains.</P
><P
><B
>Prototype: </B
>const char *iptc_next_chain(iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function returns the next chain name in the table; NULL means 
no more chains.</P
><P
><B
>Parameters: </B
>Pointer to a structure of type <EM
>iptc_handle_t</EM
> that was
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Char pointer to the name of the chain.</P
><P
>These two previous functions allow to us to iterate through the chains of the table
getting the name of each of the chains; <EM
>iptc_first_chain</EM
> 
returns the name of the first chain of the table; <EM
>iptc_next_chain</EM
>
returns the name of next chains and NULL when the function reaches the end.</P
><P
>We can create <EM
>Program #1</EM
> to exercise our understanding of 
these previous four functions:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/*
 * How to use libiptc- program #1
 * /usr/local/src/p1.c
 */

#include &#60;getopt.h&#62;
#include &#60;sys/errno.h&#62;
#include &#60;stdio.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;dlfcn.h&#62;
#include &#60;time.h&#62;
#include "libiptc/libiptc.h"
#include "iptables.h"

int main(void)
{
  iptc_handle_t h;
  const char *chain = NULL;
  const char *tablename = "filter";

  program_name = "p1";
  program_version = NETFILTER_VERSION;

  h = iptc_init(tablename);
  if ( !h )   {
     printf("Error initializing: %s\n", iptc_strerror(errno));
    exit(errno);
  }

  for (chain = iptc_first_chain(&#38;h); chain; chain = iptc_next_chain(&#38;h))  {
    printf("%s\n", chain);
  }

  exit(0);

} /* main */</PRE
></FONT
></TD
></TR
></TABLE
><P
>Write this program and save it as <TT
CLASS="FILENAME"
>p1.c</TT
>
in <TT
CLASS="FILENAME"
>/usr/local/src</TT
>.</P
><P
>Now write this <SPAN
CLASS="QUOTE"
>"bash"</SPAN
> script to simplify the compiling process:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>#!/bin/bash

gcc -Wall -Wunused -DNETFILTER_VERSION=\"1.2.6\" -rdynamic -o $1 $1.c \
/usr/local/lib/iptables.o /usr/local/lib/libiptc.a -ldl</PRE
></FONT
></TD
></TR
></TABLE
><P
>Save it as <TT
CLASS="FILENAME"
>ipt-cc</TT
> and do not forget to 
<EM
>chmod 0700 ipt-cc</EM
>.</P
><P
>Now compile your <EM
>p1</EM
> program:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./ipt-cc p1</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>And run it:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./p1</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You will get:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>INPUT
FORWARD
OUTPUT</PRE
></FONT
></TD
></TR
></TABLE
><P
>These are the three built-in iptables chains.</P
><P
>Now create some new chains using iptables and run your program again:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>iptables -N chain_1</B
>
bash# <B
CLASS="COMMAND"
>iptables -N chain_2</B
>
bash# <B
CLASS="COMMAND"
>./p1</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You will get:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>INPUT
FORWARD
OUTPUT
chain_1
chain_2</PRE
></FONT
></TD
></TR
></TABLE
><P
>Try to generate an error initializing tablename to <EM
>myfilter</EM
> 
instead of <EM
>filter</EM
>. When you compile and execute your program 
again, you will get:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
><EM
>Error initializing: Table does not exist (do you need to insmod?)</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>iptables</EM
> informs you that <EM
>myfilter</EM
> does 
not exist as a table.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN355"
>11.5. iptc_is_chain</A
></H3
><P
><B
>Name: </B
>iptc_is_chain</P
><P
><B
>Usage: </B
>Check if a chain exists.</P
><P
><B
>Prototype: </B
>int iptc_is_chain(const char *chain, const iptc_handle_t handle)</P
><P
><B
>Description: </B
>This function checks to see if the chain described in the parameter
<EM
>chain</EM
> exists in the table.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer containing the name of
the chain we want to check to. <EM
>handle</EM
> is a pointer to a 
structure of type <EM
>iptc_handle_t</EM
> that was
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>integer value 1 (true) if the chain exists; integer value 0 (false) 
if the chain does not exist.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN376"
>11.6. iptc_builtin</A
></H3
><P
><B
>Name: </B
>iptc_builtin</P
><P
><B
>Usage: </B
>Is this a built-in chain?</P
><P
><B
>Prototype: </B
>int iptc_builtin(const char *chain, const iptc_handle_t handle)</P
><P
><B
>Description: </B
>This function is used to check if a given chain name is a built-in 
chain or not.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer containing the name of
the chain we want to check to. <EM
>handle</EM
> is a pointer to a 
structure of type <EM
>iptc_handle_t</EM
> that was
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if the given chain name is the name 
of a builtin chain; returns integer value 0 (false) is not.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN396"
>11.7. iptc_first_rule</A
></H3
><P
><B
>Name: </B
>iptc_first_rule</P
><P
><B
>Usage: </B
>Get first rule in the given chain.</P
><P
><B
>Prototype: </B
>const struct ipt_entry *iptc_first_rule(const char *chain, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function returns a pointer to the first rule in the given chain
name; NULL for an empty chain.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer containing the name of
the chain we want to get the rules to. <EM
>handle</EM
> is a 
pointer to a structure of type <EM
>iptc_handle_t</EM
> that was
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns a pointer to an <EM
>ipt_entry</EM
> structure 
containing information about the first rule of the chain. See below
for an explanation of this structure.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN417"
>11.8. iptc_next_rule</A
></H3
><P
><B
>Name: </B
>iptc_next_rule</P
><P
><B
>Usage: </B
>Get the next rule in the given chain.</P
><P
><B
>Prototype: </B
>const struct ipt_entry *iptc_next_rule(const struct ipt_entry *prev, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function returns a pointer to the next rule in the given chain
name; NULL means the end of the chain.</P
><P
><B
>Parameters: </B
><EM
>prev</EM
> is a pointer to a structure of type 
<EM
>ipt_entry</EM
> that must be obtained first by a previous call to 
the function <EM
>iptc_first_rule</EM
>. In order to get the second 
and subsequent rules you have to pass a pointer to the structure containing the 
information about the previous rule of the chain. <EM
>handle</EM
> is 
a pointer to a structure of type <EM
>iptc_handle_t</EM
> that was 
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns a pointer to an <EM
>ipt_entry</EM
> structure 
containing information about the next rule of the chain. See below
for an explanation of this structure.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN440"
>11.9. iptc_get_target</A
></H3
><P
><B
>Name: </B
>iptc_get_target</P
><P
><B
>Usage: </B
>Get a pointer to the target name of this entry.</P
><P
><B
>Prototype: </B
>const char *iptc_get_target(const struct ipt_entry *e, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function gets the target of the given rule.  If it is an extended
target, the name of that target is returned.  If it is a jump to another chain, 
the name of that chain is returned.  If it is a verdict (eg. DROP), that name 
is returned.  If it has no target (an accounting-style rule), then the empty 
string is returned. Note that this function should be used instead of using 
the value of the <EM
>verdict</EM
> field of the 
<EM
>ipt_entry</EM
> structure directly, as it offers the above further 
interpretations of the standard verdict.</P
><P
><B
>Parameters: </B
><EM
>e</EM
> is a pointer to a structure of type 
<EM
>ipt_entry</EM
> that must be obtained first by a previous call to 
the function <EM
>iptc_first_rule</EM
> or the function 
<EM
>iptc_next_rule</EM
>. <EM
>handle</EM
> is 
a pointer to a structure of type <EM
>iptc_handle_t</EM
> that was 
obtained by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns a char pointer to the target name. See <EM
>Description</EM
> 
above for more information.</P
><P
>Now it is time to explain the <EM
>ipt_entry</EM
> structure; these pieces
of code are taken from <EM
>iptables</EM
> package sources:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* Internet address. */
struct in_addr {
  __u32  s_addr;
};

/* Yes, Virginia, you have to zero the padding. */
struct ipt_ip {
  /* Source and destination IP addr */
  struct in_addr src, dst;
  /* Mask for src and dest IP addr */
  struct in_addr smsk, dmsk;
  char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
  unsigned char iniface_mask[IFNAMSIZ], outiface_mask[IFNAMSIZ];

  /* Protocol, 0 = ANY */
  u_int16_t proto;

  /* Flags word */
  u_int8_t flags;
  /* Inverse flags */
  u_int8_t invflags;
};

struct ipt_counters
{
  u_int64_t pcnt, bcnt;      /* Packet and byte counters */
};

/* This structure defines each of the firewall rules.  Consists of 3
   parts which are 1) general IP header stuff 2) match specific
   stuff 3) the target to perform if the rule matches */
struct ipt_entry
{
  struct ipt_ip ip;

  /* Mark with fields that we care about. */
  unsigned int nfcache;

  /* Size of ipt_entry + matches */
  u_int16_t target_offset;
  /* Size of ipt_entry + matches + target */
  u_int16_t next_offset;

  /* Back pointer */
  unsigned int comefrom;

  /* Packet and byte counters. */
  struct ipt_counters counters;

  /* The matches (if any), then the target. */
  unsigned char elems[0];
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>An <EM
>ipt_entry</EM
> structure contains:</P
><P
></P
><UL
><LI
><P
>An <EM
>ipt_ip</EM
> structure containing (for the rule) the 
source address and netmask <EM
>(ip.src.s_addr, ip.smsk.s_addr)</EM
>, 
the destination address and netmask <EM
>(ip.dst.s_addr, ip.dmsk.s_addr)</EM
>, 
the protocol <EM
>(ip.proto)</EM
>, a flags field <EM
>(invflags)</EM
> 
to check for inverse <EM
>(!)</EM
> selections 
<EM
>(eg. ! 192.168.2.0/24, ! eth0, ! tcp, etc)</EM
>, the input 
interface <EM
>(iniface)</EM
>, the output interface 
<EM
>(outiface)</EM
>, the input <EM
>(iniface_mask)</EM
> 
and output <EM
>(outiface_mask)</EM
> interface masks and the 
<EM
>flags</EM
> field to check for fragmented packets.</P
></LI
><LI
><P
>An <EM
>ipt_counters</EM
> structure containing the packet 
<EM
>(pcnt)</EM
> and byte <EM
>(bcnt)</EM
> counter 
of the rule. This information is important for bandwidth measurement.</P
></LI
><LI
><P
><EM
>target_offset</EM
> that is used to get the target information 
of the rule.</P
></LI
><LI
><P
>Unknown fields: <EM
>nfcache, comefrom, elems, next_offset</EM
>.
If someone can give me a feedback about these fields I would be grateful.</P
></LI
></UL
><P
>A simple way to work with all this information is to borrow
some functions from <TT
CLASS="FILENAME"
>iptables-save.c</TT
> by Paul 
Russell and Harald Welte.</P
><P
>Here is another sample program <EM
>Program #2</EM
> written with 
a lot of help from Russell-Welte:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* 
 * How to use libiptc- program #2
 * /usr/local/src/p1.c
 */

#include &#60;getopt.h&#62;
#include &#60;sys/errno.h&#62;
#include &#60;stdio.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;dlfcn.h&#62;
#include &#60;time.h&#62;
#include "libiptc/libiptc.h"
#include "iptables.h"

<EM
>/* Here begins some of the code taken from iptables-save.c **************** */</EM
>
#define IP_PARTS_NATIVE(n)      \
(unsigned int)((n)&#62;&#62;24)&#38;0xFF,   \
(unsigned int)((n)&#62;&#62;16)&#38;0xFF,   \
(unsigned int)((n)&#62;&#62;8)&#38;0xFF,    \
(unsigned int)((n)&#38;0xFF)

#define IP_PARTS(n) IP_PARTS_NATIVE(ntohl(n))

/* This assumes that mask is contiguous, and byte-bounded. */
static void
print_iface(char letter, const char *iface, const unsigned char *mask,
      int invert)
{
  unsigned int i;

  if (mask[0] == 0)
    return;

  printf("-%c %s", letter, invert ? "! " : "");

  for (i = 0; i &#60; IFNAMSIZ; i++) {
    if (mask[i] != 0) {
      if (iface[i] != '\0')
        printf("%c", iface[i]);
    } else {
      /* we can access iface[i-1] here, because 
       * a few lines above we make sure that mask[0] != 0 */
      if (iface[i-1] != '\0')
        printf("+");
      break;
    }
  }

  printf(" ");
}

/* These are hardcoded backups in iptables.c, so they are safe */
struct pprot {
  char *name;
  u_int8_t num;
};

/* FIXME: why don't we use /etc/protocols ? */
static const struct pprot chain_protos[] = {
  { "tcp", IPPROTO_TCP },
  { "udp", IPPROTO_UDP },
  { "icmp", IPPROTO_ICMP },
  { "esp", IPPROTO_ESP },
  { "ah", IPPROTO_AH },
};

static void print_proto(u_int16_t proto, int invert)
{
  if (proto) {
    unsigned int i;
    const char *invertstr = invert ? "! " : "";

    for (i = 0; i &#60; sizeof(chain_protos)/sizeof(struct pprot); i++)
      if (chain_protos[i].num == proto) {
        printf("-p %s%s ",
               invertstr, chain_protos[i].name);
        return;
      }

    printf("-p %s%u ", invertstr, proto);
  }
}

static int print_match(const struct ipt_entry_match *e,
      const struct ipt_ip *ip)
{
  struct iptables_match *match
    = find_match(e-&#62;u.user.name, TRY_LOAD);

  if (match) {
    printf("-m %s ", e-&#62;u.user.name);

    /* some matches don't provide a save function */
    if (match-&#62;save)
      match-&#62;save(ip, e);
  } else {
    if (e-&#62;u.match_size) {
      fprintf(stderr,
        "Can't find library for match `%s'\n",
        e-&#62;u.user.name);
      exit(1);
    }
  }
  return 0;
}

/* print a given ip including mask if neccessary */
static void print_ip(char *prefix, u_int32_t ip, u_int32_t mask, int invert)
{
  if (!mask &#38;&#38; !ip)
    return;

  printf("%s %s%u.%u.%u.%u",
    prefix,
    invert ? "! " : "",
    IP_PARTS(ip));

  if (mask != 0xffffffff) 
    printf("/%u.%u.%u.%u ", IP_PARTS(mask));
  else
    printf(" ");
}

/* We want this to be readable, so only print out neccessary fields.
 * Because that's the kind of world I want to live in.  */
static void print_rule(const struct ipt_entry *e, 
    iptc_handle_t *h, const char *chain, int counters)
{
  struct ipt_entry_target *t;
  const char *target_name;

  /* print counters */
  if (counters)
    printf("[%llu:%llu] ", e-&#62;counters.pcnt, e-&#62;counters.bcnt);

  /* print chain name */
  printf("-A %s ", chain);

  /* Print IP part. */
  print_ip("-s", e-&#62;ip.src.s_addr,e-&#62;ip.smsk.s_addr,
      e-&#62;ip.invflags &#38; IPT_INV_SRCIP);  

  print_ip("-d", e-&#62;ip.dst.s_addr, e-&#62;ip.dmsk.s_addr,
      e-&#62;ip.invflags &#38; IPT_INV_DSTIP);

  print_iface('i', e-&#62;ip.iniface, e-&#62;ip.iniface_mask,
        e-&#62;ip.invflags &#38; IPT_INV_VIA_IN);

  print_iface('o', e-&#62;ip.outiface, e-&#62;ip.outiface_mask,
        e-&#62;ip.invflags &#38; IPT_INV_VIA_OUT);

  print_proto(e-&#62;ip.proto, e-&#62;ip.invflags &#38; IPT_INV_PROTO);

  if (e-&#62;ip.flags &#38; IPT_F_FRAG)
    printf("%s-f ",
           e-&#62;ip.invflags &#38; IPT_INV_FRAG ? "! " : "");

  /* Print matchinfo part */
  if (e-&#62;target_offset) {
    IPT_MATCH_ITERATE(e, print_match, &#38;e-&#62;ip);
  }

  /* Print target name */  
  target_name = iptc_get_target(e, h);
  if (target_name &#38;&#38; (*target_name != '\0'))
    printf("-j %s ", target_name);

  /* Print targinfo part */
  t = ipt_get_target((struct ipt_entry *)e);
  if (t-&#62;u.user.name[0]) {
    struct iptables_target *target
      = find_target(t-&#62;u.user.name, TRY_LOAD);

    if (!target) {
      fprintf(stderr, "Can't find library for target `%s'\n",
        t-&#62;u.user.name);
      exit(1);
    }

    if (target-&#62;save)
      target-&#62;save(&#38;e-&#62;ip, t);
    else {
      /* If the target size is greater than ipt_entry_target
       * there is something to be saved, we just don't know
       * how to print it */
      if (t-&#62;u.target_size != 
          sizeof(struct ipt_entry_target)) {
        fprintf(stderr, "Target `%s' is missing "
            "save function\n",
          t-&#62;u.user.name);
        exit(1);
      }
    }
  }
  printf("\n");
}
<EM
>/* Here ends some of the code taken from iptables-save.c ****************** */</EM
>

int main(void)
{
  iptc_handle_t h;
  const struct ipt_entry *e;
  const char *chain = NULL;
  const char *tablename = "filter";
  const int counters = 1;

  program_name = "p2";
  program_version = NETFILTER_VERSION;

  /* initialize */
  h = iptc_init(tablename);
  if ( !h )   {
     printf("Error initializing: %s\n", iptc_strerror(errno));
    exit(errno);
  }

  /* print chains and their rules */
  for (chain = iptc_first_chain(&#38;h); chain; chain = iptc_next_chain(&#38;h))  {
    printf("%s\n", chain);
    for (e = iptc_first_rule(chain, &#38;h); e; e = iptc_next_rule(e, &#38;h))  {
      print_rule(e, &#38;h, chain, counters);
    }
  }

  exit(0);

} /* main */</PRE
></FONT
></TD
></TR
></TABLE
><P
>The function <EM
>print_rule</EM
> borrowed from 
<TT
CLASS="FILENAME"
>iptables-save.c</TT
> prints the information 
about a rule into a readable form using:</P
><P
></P
><UL
><LI
><P
><EM
>print_ip</EM
> to print the addresses, </P
></LI
><LI
><P
><EM
>print_iface</EM
> to print the interfaces, </P
></LI
><LI
><P
><EM
>print_proto</EM
> to print the protocols, </P
></LI
><LI
><P
><EM
>iptc_get_target</EM
> to get and print the targets 
(using <EM
>save</EM
>).</P
></LI
></UL
><P
>In <EM
>main</EM
> we iterate through each chain and 
for each one we iterate through each rule printing it.</P
><P
>The arguments of <EM
>print_rule</EM
> are:</P
><P
></P
><UL
><LI
><P
>e = pointer to an <EM
>ipt_entry</EM
> structure containing 
information about the rule.</P
></LI
><LI
><P
>h = pointer to an <EM
>iptc_handle_t</EM
> structure returned by 
<EM
>iptc_init</EM
>.</P
></LI
><LI
><P
>chain = name of the chain.</P
></LI
><LI
><P
>counters = 0: do not print counters; 1: print them.</P
></LI
></UL
><P
>OK, compile and run program <EM
>p2</EM
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./ipt-cc p2</B
>
bash# <B
CLASS="COMMAND"
>./p2</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You will get:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>INPUT
FORWARD
OUTPUT
chain_1
chain_2</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now modify the environment using <EM
>iptables</EM
> to add some rules:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>iptables -A INPUT -p tcp -i eth0 -s ! 192.168.1.1 --dport 20 -j ACCEPT</B
>
bash# <B
CLASS="COMMAND"
>iptables -A chain_1 -p udp -o eth1 -s 192.168.2.0/24 --sport 33 -j DROP</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now if you run again <EM
>p2</EM
> you will get:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>INPUT
[0:0] -A INPUT -s ! 192.168.1.1 -i eth0 -p tcp -m tcp --dport 20 -j ACCEPT
FORWARD
OUTPUT
chain_1
[0:0] -A chain_1 -s 192.168.2.0/255.255.255.0 -o eth1 -p udp -m udp --sport 33 -j DROP
chain_2</PRE
></FONT
></TD
></TR
></TABLE
><P
>We have now rules printed for <EM
>INPUT</EM
> and 
<EM
>chain_1</EM
> chains. The numbers in the
brackets at left are packet and byte counters respectively.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN556"
>11.10. iptc_get_policy</A
></H3
><P
><B
>Name: </B
>iptc_get_policy</P
><P
><B
>Usage: </B
>Get the policy of a given built-in chain.</P
><P
><B
>Prototype: </B
>const char *iptc_get_policy(const char *chain, struct ipt_counters *counter, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function gets the policy of a built-in chain, and fills in the
<EM
>counters</EM
> argument with the hit statistics on 
that policy.</P
><P
><B
>Parameters: </B
>You have to pass as arguments the name of the built-in chain you want 
to get the policy to, a pointer to an <EM
>ipt_counters</EM
>
structure to be filled by the function and the 
<EM
>iptc_handle_t</EM
> structure identifying the table we are 
working to. The <EM
>ipt_counters</EM
> structure was explained
in previous section; do not forget that <EM
>iptc_handle_t</EM
>
must be obtained by a previous call to the function <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns a char pointer to the policy name.</P
><P
>Using pieces of programs 1 and 2 we can write <EM
>program #3</EM
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* 
 * How to use libiptc- program #3
 * /usr/local/src/p3.c
 */

#include &#60;getopt.h&#62;
#include &#60;sys/errno.h&#62;
#include &#60;stdio.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;dlfcn.h&#62;
#include &#60;time.h&#62;
#include "libiptc/libiptc.h"
#include "iptables.h"

int main(void)
{
  iptc_handle_t h;
  const char *chain = NULL;
  const char *policy = NULL;
  const char *tablename = "filter";
  struct ipt_counters counters;

  program_name = "p3";
  program_version = NETFILTER_VERSION;

  /* initialize */
  h = iptc_init(tablename);
  if ( !h )   {
     printf("Error initializing: %s\n", iptc_strerror(errno));
    exit(errno);
  }

  /* print built-in chains, their policies and counters */
  printf("BUILT-IN   POLICY  PKTS-BYTES\n");
  printf("-----------------------------\n");
  for (chain = iptc_first_chain(&#38;h); chain; chain = iptc_next_chain(&#38;h))  {
    if ( !iptc_builtin(chain, h) )
      continue;
    if ( (policy = iptc_get_policy(chain, &#38;counters, &#38;h)) )
      printf("%-10s %-10s [%llu:%llu]\n", 
             chain, policy, counters.pcnt, counters.bcnt);
  }

  exit(0);

} /* main */</PRE
></FONT
></TD
></TR
></TABLE
><P
>OK, compile and run program <EM
>p3</EM
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./ipt-cc p3</B
>
bash# <B
CLASS="COMMAND"
>./p3</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You will get something like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>BUILT-IN  POLICY  PKTS-BYTES
----------------------------
INPUT     ACCEPT     [0:0]
FORWARD   ACCEPT     [0:0]
OUTPUT    ACCEPT     [0:0]</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN588"
>11.11. iptc_read_counter</A
></H3
><P
><B
>Name: </B
>iptc_read_counter</P
><P
><B
>Usage: </B
>Read counters of a rule in a chain.</P
><P
><B
>Prototype: </B
>struct ipt_counters *iptc_read_counter(const ipt_chainlabel chain,
unsigned int rulenum, iptc_handle_t *handle);</P
><P
><B
>Description: </B
>This function read and returns packet and byte counters of the entry 
rule in chain <EM
>chain</EM
> positioned at 
<EM
>rulenum</EM
>. Counters are returned in a pointer to a 
type structure <EM
>ipt_counters</EM
>. Rule numbers start at 
1 for the first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be readed; <EM
>rulenum</EM
> is an integer value defined the 
position in the chain of rules of the rule which counters will be read.
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns a pointer to an <EM
>ipt_counters</EM
> structure 
containing the byte and packet counters readed. </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MFUNCTION"
>12. Functions to modify firewalling rules and statistics</A
></H2
><P
>For those of you who are a little brave, <EM
>libiptc</EM
>
has a group of functions to directly modify the firewalling rules and 
statistics <EM
>(use of iptables is really the safest way)</EM
>. </P
><P
>These functions are not covered by this HOWTO and I will limit myself 
to presenting improved information taken from
<TT
CLASS="FILENAME"
>libiptc.h</TT
> and the 
<A
HREF="http://netfilter.samba.org/documentation/HOWTO/"
TARGET="_top"
>Linux netfilter Hacking HOWTO</A
> by Rusty Russell.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN621"
>12.1. iptc_commit</A
></H3
><P
><B
>Name: </B
>iptc_commit</P
><P
><B
>Usage: </B
>Makes the actual changes.</P
><P
><B
>Prototype: </B
>int iptc_commit(iptc_handle_t *handle)</P
><P
><B
>Description: </B
>The tables that you change are not written back until the 
<EM
>iptc_commit()</EM
> function is called.  This means it 
is possible for two library users operating on the same chain to race 
each other; locking would be required to prevent this, and it is not 
currently done. There is no race with counters, however; counters are 
added back in to the kernel in such a way that counter increments 
between the reading and writing of the table still show up in the new 
table. <EM
>To protect the status of the system you must commit 
your changes</EM
>.</P
><P
><B
>Parameters: </B
><EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call 
to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN645"
>12.2. iptc_insert_entry</A
></H3
><P
><B
>Name: </B
>iptc_insert_entry</P
><P
><B
>Usage: </B
>Insert a new rule in a chain.</P
><P
><B
>Prototype: </B
>int iptc_insert_entry(const ipt_chainlabel chain, const struct ipt_entry *e, 
unsigned int rulenum, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function insert a rule defined in structure type 
<EM
>ipt_entry</EM
> in chain <EM
>chain</EM
> into
position defined by integer value <EM
>rulenum</EM
>. Rule numbers 
start at 1 for the first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>e</EM
> is a pointer to a structure of type
<EM
>ipt_entry</EM
> that contains information about the rule to
be inserted. The programmer must fill the fields of this structure with
values required to define his or her rule before passing the pointer as 
parameter to the function. <EM
>rulenum</EM
> is an integer
value defined the position in the chain of rules where the new rule will
be inserted. Rule numbers start at 1 for the first rule. 
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN674"
>12.3. iptc_replace_entry</A
></H3
><P
><B
>Name: </B
>iptc_replace_entry</P
><P
><B
>Usage: </B
>Replace an old rule in a chain with a new one.</P
><P
><B
>Prototype: </B
>int iptc_replace_entry(const ipt_chainlabel chain, const struct ipt_entry *e,
unsigned int rulenum, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function replace the entry rule in chain <EM
>chain</EM
> 
positioned at <EM
>rulenum</EM
> with the rule defined in structure 
type <EM
>ipt_entry</EM
>. Rule numbers start at 1 for the first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>e</EM
> is a pointer to a structure of type
<EM
>ipt_entry</EM
> that contains information about the rule to
be inserted. The programmer must fill the fields of this structure with
values required to define his or her rule before passing the pointer as 
parameter to the function. <EM
>rulenum</EM
> is an integer
value defined the position in the chain of rules where the old rule will
be replaced by the new one. Rule numbers start at 1 for the first rule. 
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN703"
>12.4. iptc_append_entry</A
></H3
><P
><B
>Name: </B
>iptc_append_entry</P
><P
><B
>Usage: </B
>Append a new rule in a chain.</P
><P
><B
>Prototype: </B
>int iptc_append_entry(const ipt_chainlabel chain, const struct ipt_entry *e,
iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function append a rule defined in structure type 
<EM
>ipt_entry</EM
> in chain <EM
>chain</EM
>
(equivalent to insert with rulenum = length of chain).</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>e</EM
> is a pointer to a structure of type
<EM
>ipt_entry</EM
> that contains information about the rule to
be appended. The programmer must fill the fields of this structure with
values required to define his or her rule before passing the pointer as 
parameter to the function. <EM
>handle</EM
> is a pointer to a 
structure of type <EM
>iptc_handle_t</EM
> that was obtained by 
a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN730"
>12.5. iptc_delete_num_entry</A
></H3
><P
><B
>Name: </B
>iptc_delete_num_entry</P
><P
><B
>Usage: </B
>Delete a rule in a chain.</P
><P
><B
>Prototype: </B
>int iptc_delete_num_entry(const ipt_chainlabel chain, unsigned int rulenum,
iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function delete the entry rule in chain <EM
>chain</EM
> 
positioned at <EM
>rulenum</EM
>. Rule numbers start at 1 for the 
first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>rulenum</EM
> is an integer value defined the 
position in the chain of rules where the rule will be deleted.
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN756"
>12.6. iptc_flush_entries</A
></H3
><P
><B
>Name: </B
>iptc_flush_entries</P
><P
><B
>Usage: </B
>Empty a chain.</P
><P
><B
>Prototype: </B
>int iptc_flush_entries(const ipt_chainlabel chain, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function flushes the rule entries in the given chain (ie. empties chain).</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be flushed; <EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN779"
>12.7. iptc_zero_entries</A
></H3
><P
><B
>Name: </B
>iptc_zero_entries</P
><P
><B
>Usage: </B
>Zeroes the chain counters.</P
><P
><B
>Prototype: </B
>int iptc_zero_entries(const ipt_chainlabel chain, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function zeroes the counters in the given chain.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain 
which counters will be zero; <EM
>handle</EM
> is a pointer 
to a structure of type <EM
>iptc_handle_t</EM
> that was obtained 
by a previous call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN802"
>12.8. iptc_create_chain</A
></H3
><P
><B
>Name: </B
>iptc_create_chain</P
><P
><B
>Usage: </B
>Create a new chain.</P
><P
><B
>Prototype: </B
>int iptc_create_chain(const ipt_chainlabel chain, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function create a new chain in the table.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain 
to be created; <EM
>handle</EM
> is a pointer to a structure 
of type <EM
>iptc_handle_t</EM
> that was obtained by a previous 
call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN825"
>12.9. iptc_delete_chain</A
></H3
><P
><B
>Name: </B
>iptc_delete_chain</P
><P
><B
>Usage: </B
>Delete a chain.</P
><P
><B
>Prototype: </B
>int iptc_delete_chain(const ipt_chainlabel chain, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function delete the chain identified by the char pointer 
<EM
>chain</EM
> in the table.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain 
to be deleted; <EM
>handle</EM
> is a pointer to a structure 
of type <EM
>iptc_handle_t</EM
> that was obtained by a previous 
call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN849"
>12.10. iptc_rename_chain</A
></H3
><P
><B
>Name: </B
>iptc_rename_chain</P
><P
><B
>Usage: </B
>Rename a chain.</P
><P
><B
>Prototype: </B
>int iptc_rename_chain(const ipt_chainlabel oldname, const ipt_chainlabel newname,
iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function rename the chain identified by the char pointer
<EM
>oldname</EM
> to a new name <EM
>newname</EM
>
in the table.</P
><P
><B
>Parameters: </B
><EM
>oldname</EM
> is a char pointer to the name of the chain 
to be renamed, <EM
>newname</EM
> is the new name; 
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous 
call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN875"
>12.11. iptc_set_policy</A
></H3
><P
><B
>Name: </B
>iptc_set_policy</P
><P
><B
>Usage: </B
>Set the policy in a built-in chain.</P
><P
><B
>Prototype: </B
>int iptc_set_policy(const ipt_chainlabel chain, const ipt_chainlabel policy,
struct ipt_counters *counters, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function set the policy in chain <EM
>chain</EM
> to the
value represented by the char pointer <EM
>policy</EM
>. If you
want to set at the same time the counters of the chain, fill those values
in a structure of type <EM
>ipt_counters</EM
> and pass a pointer 
to it as parameter <EM
>counters</EM
>. Be careful: the chain
<EM
>must be</EM
> a built-in chain.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>policy</EM
> is a char pointer to the name of 
the policy to be set. <EM
>counters</EM
> is a pointer to an 
<EM
>ipt_counters</EM
> structure to be used to set the counters
of the chain. <EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN906"
>12.12. iptc_zero_counter</A
></H3
><P
><B
>Name: </B
>iptc_zero_counter</P
><P
><B
>Usage: </B
>Zero counters of a rule in a chain.</P
><P
><B
>Prototype: </B
>int iptc_zero_counter(const ipt_chainlabel chain, unsigned int rulenum,
iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function zero packet and byte counters of the entry rule in chain 
<EM
>chain</EM
> positioned at <EM
>rulenum</EM
>. 
Rule numbers start at 1 for the first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>rulenum</EM
> is an integer value defined the 
position in the chain of rules of the rule which counters will be zero.
<EM
>handle</EM
> is a pointer to a structure of type 
<EM
>iptc_handle_t</EM
> that was obtained by a previous call to 
<EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN932"
>12.13. iptc_set_counter</A
></H3
><P
><B
>Name: </B
>iptc_set_counter</P
><P
><B
>Usage: </B
>Set counters of a rule in a chain.</P
><P
><B
>Prototype: </B
>int iptc_set_counter(const ipt_chainlabel chain, unsigned int rulenum,
struct ipt_counters *counters, iptc_handle_t *handle)</P
><P
><B
>Description: </B
>This function set packet and byte counters of the entry rule in chain 
<EM
>chain</EM
> positioned at <EM
>rulenum</EM
>
with values passed in a type structure <EM
>ipt_counters</EM
>.
Rule numbers start at 1 for the first rule.</P
><P
><B
>Parameters: </B
><EM
>chain</EM
> is a char pointer to the name of the chain to
be modified; <EM
>rulenum</EM
> is an integer value defined the 
position in the chain of rules of the rule which counters will be set.
<EM
>counters</EM
> is a pointer to an 
<EM
>ipt_counters</EM
> structure to be used to set the counters
of the rule; the programmer must fill the fields of this structure with
values to be set. <EM
>handle</EM
> is a pointer to a structure 
of type <EM
>iptc_handle_t</EM
> that was obtained by a previous 
call to <EM
>iptc_init</EM
>.</P
><P
><B
>Returns: </B
>Returns integer value 1 (true) if successful; returns integer value 0
(false) if fails. In this case <EM
>errno</EM
> is set to the 
error number generated. Use <EM
>iptc_strerror</EM
> to get a
meaningful information about the problem. If errno == 0, it means there 
was a version error (ie. upgrade <EM
>libiptc</EM
>).</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BMETER"
>13. Bandwidth meter</A
></H2
><P
>In this chapter I am going to develop a simple bandwidth meter using 
the following functions from <EM
>libiptc</EM
>:</P
><P
></P
><UL
><LI
><P
>To initialize the system: 
<EM
>iptc_handle_t iptc_init(const char *tablename)</EM
>.</P
></LI
><LI
><P
> 
To catch from errors: 
<EM
>const char *iptc_strerror(int err)</EM
>.</P
></LI
><LI
><P
> 
To iterate through the chains of the table: 
<EM
>const char *iptc_first_chain(iptc_handle_t *handle)</EM
> and
<EM
>const char *iptc_next_chain(iptc_handle_t *handle)</EM
>.</P
></LI
><LI
><P
> 
To read packet and byte counters for a specific rule: 
<EM
>struct ipt_counters *iptc_read_counter(const ipt_chainlabel chain,
unsigned int rulenum, iptc_handle_t *handle)</EM
>.</P
></LI
></UL
><P
>Also the function <EM
>gettimeofday</EM
> will be used to 
measure elapsed time and the function <EM
>getopt</EM
> to 
get options from the command line.</P
><P
>I don't know really if the term <EM
>bandwidth meter</EM
> is 
well used here. I interpret <EM
>bandwidth</EM
> as a reference to 
a flow capacity; perhaps a better term could be <EM
>flow meter</EM
>.</P
><P
>Here is the <EM
>bandwidth meter</EM
> <TT
CLASS="FILENAME"
>bw.c</TT
>. 
It's well commented to be easy followed by everyone:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/* 
 * How to use libiptc- program #4
 * /usr/local/src/bw.c
 * By Leonardo Balliache - 04.09.2002
 * e-mail: leonardo@opalsoft.net
 * --WELL COMMENTED-- to be easy followed by everyone.
 */

/* include files required */
#include &#60;getopt.h&#62;
#include &#60;sys/errno.h&#62;
#include &#60;sys/time.h&#62;
#include &#60;stdio.h&#62;
#include &#60;fcntl.h&#62;
#include &#60;stdlib.h&#62;
#include &#60;string.h&#62;
#include &#60;dlfcn.h&#62;
#include &#60;time.h&#62;
#include &#60;unistd.h&#62;
#include "libiptc/libiptc.h"
#include "iptables.h"

/* colors to differentiate chains measures */
#define RED     "\033[41m\033[37m"
#define GREEN   "\033[42m\033[30m"
#define ORANGE  "\033[43m\033[30m"
#define BLUE    "\033[44m\033[37m"
#define MAGENTA "\033[45m\033[37m"
#define CYAN    "\033[46m\033[30m"
#define WHITE   "\033[47m\033[30m"
#define BLACK   "\033[40m\033[37m"
#define RESET   "\033[00m"

/* maximum number of chains to be processed */
#define MAXUSERCHAINS 7

/* time between measures in seconds; adjust as you like */
#define SLEEPTIME 1

/* structure to count bytes per chain */
struct bwcnt  {
  int start;           /* the chain was initialized */
  u_int64_t icnt;      /* bytes through; previous measure */
  u_int64_t ocnt;      /* bytes through; current measure */
  double bw;           /* bandwitdh (flow) on this chain */
};

/* function to calculate differences of time in seconds.
 * micro-seconds precision.
 */
double delta(struct timeval a, struct timeval b)
{
  if (a.tv_usec &#38; b.tv_usec)  {
    a.tv_sec--;
    a.tv_usec += 1000000;
  }
  return a.tv_sec-b.tv_sec + (a.tv_usec-b.tv_usec)/1000000.0;
}

/* main function */
int main(int argc, char *argv[])
{
  int i, j, ok;
  double totbw;
  iptc_handle_t h;
  int c, act_bw = 0;
  const char *chain = NULL;
  const char *tablename = "filter";
  struct timeval ti, to;
  struct bwcnt bw[MAXUSERCHAINS];
  struct ipt_counters *counters;
  char *col[9] = { RED,GREEN,ORANGE,BLUE,MAGENTA,CYAN,WHITE,BLACK,RESET };

  program_name = "bw";
  program_version = NETFILTER_VERSION;

 /* check options
  * we have 2 options: 
  *        -c = display current flow (each SLEEPTIME).
  *        -a = display average flow (from start); default option.
  */
  while ((c = getopt (argc, argv, "ac")) != -1)
  switch (c)  {
  case 'a':
    act_bw = 0;
    break;
  case 'c':
    act_bw = 1;
    break;
  case '?':
    if (isprint(optopt))
      fprintf (stderr, "Unknown option `-%c'.\n", optopt);
    else
      fprintf (stderr,"Unknown option character `\\x%x'.\n",optopt);
    exit(1);
  default:
    abort();
  }

  /* initialize array of chains */
  memset(&#38;bw, 0, MAXUSERCHAINS * sizeof(struct bwcnt));

  /* get time to start meter on variable ti */
  gettimeofday(&#38;ti, NULL);

  /* fire meter loop */
  if ( act_bw )  
    printf("Displaying current flow values ...\n");
  else
    printf("Displaying average flow values ...\n");

  /* forever loop; abort the program with ^C */
  while ( 1 )  {
    /* you have to initialize for each measure to be done */
    if ( !(h = iptc_init(tablename)) )  {
      printf("Error initializing: %s\n", iptc_strerror(errno));
      exit(errno);
    }
    ok = 0;    /* we start a new loop */
    gettimeofday(&#38;to, NULL);  /* have a time shoot */

    /* iterate through each chain of the table */
    for (chain = iptc_first_chain(&#38;h), i = 0; 
         chain; 
         chain = iptc_next_chain(&#38;h))  {
      if ( iptc_builtin(chain, h) )
        continue;    /* if it is a built-in chain, ignore it */

      /* ok, read the counters of this chain */
      if ( !(counters = iptc_read_counter(chain, 0, &#38;h)) )  {
         printf("Error reading %s: %s\n", chain, iptc_strerror(errno));
         exit(errno);
      }

      /* check that we do not have more chains than we can process */
      if ( i &#62;= MAXUSERCHAINS )  {
         printf("Maximum of %d user chains exceeded!!\n", MAXUSERCHAINS);
         exit(1);
      }

      /* this chain counter has not been initialized; initialize it */
      if ( bw[i].start == 0 )  {
        bw[i].icnt = counters-&#62;bcnt;
        bw[i].start = 1;
      }

      /* this chain has a previous measure; take the current one */
      else  {
        bw[i].ocnt = counters-&#62;bcnt;
        if ( bw[i].ocnt == bw[i].icnt )    /* no new bytes flowing? */
          bw[i].bw = 0;                    /* flow is zero */
        else
         /* flow in this chain is:
          *   current bytes count (bw[i].octn)    *minus*
          *   previous bytes count (bw[i].icnt)   *divided by*
          *   128.0 to convert bytes to kbits     *and divided by*
          *   difference in times in seconds      *to get*
          *   flow in kbits/sec that is what we want.
          */
          bw[i].bw = (bw[i].ocnt - bw[i].icnt) / (128.0 * delta(to, ti));

       /* do you want current flow of this chain? initialize previous 
        * bytes count to current bytes count; we get the flow in last 
        * SLEEPTIME elapsed time.
        */
        if ( act_bw )
          bw[i].icnt = bw[i].ocnt;
        ok = 1;    /* ok, we have some measure to show */
      }
      ++i;  /* next chain, please */
    }

    /* we iterate and i == 0; we do not have user chains at all */
    if ( i == 0 )  {
       printf("No user chains to meter!!\n");
       exit(1);
    }

   /* do you want to measure current flow? initialize previous time 
    * to actual time; we get the time elapsed in last SLEEPTIME.
    */
    if ( act_bw )
      ti = to;

    /* do we have something to show? ok, display it */
    if ( ok )  {
      totbw = 0;
      for ( j = 0; j &#60; i; ++j )  { 
        totbw = totbw + bw[j].bw;   /* calculate total flow */
      }
      printf("%s%6.1fk:%s ", col[7], totbw, col[8]);  /* display total */
      for ( j = 0; j &#60; i; ++j )  {  /* display flow of each chain in color */
        printf("%s%6.1fk%s ", col[j], bw[j].bw, col[8]);
      }
      printf("\n");
    }
    sleep(SLEEPTIME);  /* rest a little; you go too fast */
  }             /* give us enough time in order to let some bytes flow */

  exit(0);  /* bye, we have our measures!! */

} /* main */</PRE
></FONT
></TD
></TR
></TABLE
><P
>Write your program and compile as before:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./ipt-cc bw</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Before using the meter we need to set our environment.</P
><P
>First, we have to have at least 2 PCs connected in a network. This is our
diagram configuration:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>+--------+ eth0       eth0 +--------+
| PC #1  +-----------------+ PC #2  |
+--------+                 +--------+
eth0=192.168.1.1           eth0=192.168.1.2</PRE
></FONT
></TD
></TR
></TABLE
><P
>Second, we need to install a very nice and useful package called 
<EM
>netcat</EM
> written by Hobbit. This 
<EM
>excellent</EM
> package will help us to inject and receive 
a flow of bytes between 2 NICs. If you don't have the package in your 
system, download it from <A
HREF="http://rr.sans.org/audit/netcat.php"
TARGET="_top"
>http://rr.sans.org/audit/netcat.php</A
>.</P
><P
>The version that I use is <EM
>1.10-277</EM
>. To install it follow 
these instructions:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cp netcat-1.10.tar.gz /usr/local/src</B
>
bash# <B
CLASS="COMMAND"
>tar xzvf netcat-1.10.tar.gz</B
>
bash# <B
CLASS="COMMAND"
>cd netcat-1.10</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>My version requires to make a patch first; check yours if you have a file
with a <EM
>.dif</EM
> extension and apply it too:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>patch -p0 -i netcat-1.10.dif</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Next compile the package using <EM
>make</EM
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>make linux</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Copy the binary <EM
>nc</EM
> to your user bin directory:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cp nc /usr/bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>And also to the second PC in your network:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>scp nc 192.168.1.2:/usr/bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>We are going to use <EM
>netcat</EM
> to 
<SPAN
CLASS="QUOTE"
>"listen"</SPAN
> to a flow of bytes from PC #2 and 
to <SPAN
CLASS="QUOTE"
>"talk"</SPAN
> from PC #1. Using tty1 to tty4 
consoles on PC #2 let's start <EM
>netcat</EM
> to 
listen from this PC. Go to PC #2 and in tty1 type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>nc -n -v -l -s 192.168.1.2 -p 1001 &#62;/dev/null</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>netcat</EM
> must respond with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>listening on [192.168.1.2] 1001 ...</PRE
></FONT
></TD
></TR
></TABLE
><P
>This command started <EM
>netcat</EM
> to listen from address 
<EM
>192.168.1.2</EM
> using port number <EM
>1001</EM
>. 
Arguments are: <EM
>-n</EM
> = use numeric address identification;
<EM
>-v</EM
> = verbose; <EM
>-l</EM
> = listen. All the 
flow that <EM
>netcat</EM
> receives in 
<EM
>192.168.1.2:1001</EM
> will be redirected to the 
<SPAN
CLASS="QUOTE"
>"black hole"</SPAN
> in <TT
CLASS="FILENAME"
>/dev/null</TT
>.</P
><P
>Repeat the command in tty2, tty3 and tty4; change to tty2 using 
<B
CLASS="KEYCAP"
>ALT-F2</B
> and after logging in write:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>nc -n -v -l -s 192.168.1.2 -p 1002 &#62;/dev/null</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now we are <SPAN
CLASS="QUOTE"
>"listening"</SPAN
> to the same address but port 
number <EM
>1002</EM
>.</P
><P
>Go on now with tty3:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>nc -n -v -l -s 192.168.1.2 -p 1003 &#62;/dev/null</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>And tty4:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>nc -n -v -l -s 192.168.1.2 -p 1004 &#62;/dev/null</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now we are listening in PC #2, address 
<EM
>192.168.1.2</EM
> in ports <EM
>1001</EM
>, 
<EM
>1002</EM
>, <EM
>1003</EM
> and 
<EM
>1004</EM
>.</P
><P
>Come back to PC #1 and let's set the environment to allow 
<EM
>iptables</EM
> to help us to complete our tests:</P
><P
>On PC #1, type the into tty1 as follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>iptables -F</B
>
bash# <B
CLASS="COMMAND"
>iptables -X</B
>
bash# <B
CLASS="COMMAND"
>iptables -N chn_1</B
>
bash# <B
CLASS="COMMAND"
>iptables -N chn_2</B
>
bash# <B
CLASS="COMMAND"
>iptables -N chn_3</B
>
bash# <B
CLASS="COMMAND"
>iptables -N chn_4</B
>
bash# <B
CLASS="COMMAND"
>iptables -A chn_1 -j ACCEPT</B
>
bash# <B
CLASS="COMMAND"
>iptables -A chn_2 -j ACCEPT</B
>
bash# <B
CLASS="COMMAND"
>iptables -A chn_3 -j ACCEPT</B
>
bash# <B
CLASS="COMMAND"
>iptables -A chn_4 -j ACCEPT</B
>
bash# <B
CLASS="COMMAND"
>iptables -A OUTPUT -o eth0 -p tcp --dport 1001 -j chn_1</B
>
bash# <B
CLASS="COMMAND"
>iptables -A OUTPUT -o eth0 -p tcp --dport 1002 -j chn_2</B
>
bash# <B
CLASS="COMMAND"
>iptables -A OUTPUT -o eth0 -p tcp --dport 1003 -j chn_3</B
>
bash# <B
CLASS="COMMAND"
>iptables -A OUTPUT -o eth0 -p tcp --dport 1004 -j chn_4</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>These commands will:</P
><P
></P
><UL
><LI
><P
>Flush all chains in table <EM
>filter</EM
>.</P
></LI
><LI
><P
> 
Delete all user chains in table <EM
>filter</EM
>.</P
></LI
><LI
><P
> 
Create user chains <EM
>chn_1</EM
>,
<EM
>chn_2</EM
>, <EM
>chn_3</EM
> and
<EM
>chn_4</EM
>.</P
></LI
><LI
><P
> 
Establish a target <EM
>ACCEPT</EM
> in each user chain.</P
></LI
><LI
><P
> 
Create 4 rules in chain <EM
>OUTPUT</EM
> that matches
port numbers <EM
>1001</EM
> to
<EM
>1004</EM
> and target it to user chains 
<EM
>chn_1</EM
> to <EM
>chn_4</EM
>.</P
></LI
></UL
><P
>Now start the <EM
>bw</EM
> meter using current values:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>./bw -c</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>It must respond with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Displaying current flow values ...
   0.0k:    0.0k    0.0k    0.0k    0.0k
   0.0k:    0.0k    0.0k    0.0k    0.0k
   0.0k:    0.0k    0.0k    0.0k    0.0k
   0.0k:    0.0k    0.0k    0.0k    0.0k</PRE
></FONT
></TD
></TR
></TABLE
><P
>It informs that measures are current flows. Every line is a measure
taken each <EM
>SLEEPTIME</EM
> lapse (1 second in our 
program). First column (in black) are total flow, next columns (in red,
green, orange and blue) are flows in chains <EM
>chn_1</EM
>, 
<EM
>chn_2</EM
>, <EM
>chn_3</EM
> and 
<EM
>chn_4</EM
> respectively. Of course we do not have any 
flow now. However let <EM
>bw</EM
> run and continue reading.</P
><P
>Let's start now one of our byte flows; go to tty2 in PC #1 with
<B
CLASS="KEYCAP"
>ALT-F2</B
> and after logging in, type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>yes 000000000000000000 | nc -n -v -s 192.168.1.1 -p 2001 192.168.1.2 1001</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>netcat</EM
> responds with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>(UNKNOWN) [192.168.1.2] 1000 (?) open</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now we have a flow of bytes from PC #1 to PC #2. <EM
>yes</EM
> 
generates a constant flow of zeroes; this flow is piped to 
<EM
>netcat</EM
> through address <EM
>192.168.1.1</EM
>, 
port <EM
>2001</EM
> and sends it to PC #2, address 
<EM
>192.168.1.2</EM
>, port <EM
>1001</EM
> 
(where PC #2 is listening).</P
><P
>Check now the display of <EM
>bw</EM
> in tty1:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>7653.2k: 7653.2k    0.0k    0.0k    0.0k
7829.5k: 7829.5k    0.0k    0.0k    0.0k
7786.7k: 7786.7k    0.0k    0.0k    0.0k
7892.1k: 7982.1k    0.0k    0.0k    0.0k</PRE
></FONT
></TD
></TR
></TABLE
><P
>Your mileage can vary depending of the physical characteristics of your
system. In mine I have a flow of aproximately 7700 kbits/sec in the first
chain <EM
>chn_1</EM
> which corresponds to port number
<EM
>1001</EM
> in PC #2.</P
><P
>Let's start now the second bytes flow; go to tty3 in PC #1 with 
<B
CLASS="KEYCAP"
>ALT-F3</B
> and after logging in, type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>yes 000000000000000000 | nc -n -v -s 192.168.1.1 -p 2002 192.168.1.2 1002</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>netcat</EM
> responds with:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>(UNKNOWN) [192.168.1.2] 1002 (?) open</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now we have 2 flows of bytes from PC #1 to PC #2; one from 
<EM
>192.168.1.1:2001</EM
> to 
<EM
>192.168.1.2:1001</EM
> and another from 
<EM
>192.168.1.1:2002</EM
> to 
<EM
>192.168.1.2:1002</EM
>.</P
><P
>Now check the display of <EM
>bw</EM
> in tty1:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>7819.6k: 4144.2k 3675.4k    0.0k    0.0k
8090.5k: 3923.9k 4166.6k    0.0k    0.0k
7794.7k: 3920.8k 3873.9k    0.0k    0.0k
7988.3k: 3754.6k 4233.7k    0.0k    0.0k</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now we have 2 flows; each of them is more or less 50% of the total flow
going out of the computer. The Linux kernel tries to balance the bandwidth
available between the 2 channels of output.</P
><P
>To continue, start the 2 aditional flows through channels
<EM
>192.168.1.1:2003-192.168.1.2:1003</EM
> and 
<EM
>192.168.1.1:2004-192.168.1.2:1004</EM
>.</P
><P
>In tty4 type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>yes 000000000000000000 | nc -n -v -s 192.168.1.1 -p 2003 192.168.1.2 1003</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>In tty5 type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>yes 000000000000000000 | nc -n -v -s 192.168.1.1 -p 2004 192.168.1.2 1004</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>The display of <EM
>bw</EM
> in tty1 will be something like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>8120.6k: 1705.3k 2354.9k 1898.6k 2161.8k
7765.3k: 1634.2k 2560.2k 2011.4k 1559.5k
7911.9k: 1699.8k 2090.3k 1768.0k 2353.8k
8309.4k: 1734.5k 1999.7k 1999.9k 2575.3k</PRE
></FONT
></TD
></TR
></TABLE
><P
>Total bandwidth is distributed between the 4 channels of flow.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CFLOWS"
>14. Controlling flows</A
></H2
><P
>In this chapter we are going to try to control the flows using the Linux
kernel queue disciplines. Perhaps, depending on how you compiled your
kernel, you will again need to run <B
CLASS="COMMAND"
>make menuconfig</B
>, 
re-configure your options, re-compile and re-install your kernel.</P
><P
>This chapter <EM
>is not</EM
> and 
<EM
>does not pretend to be</EM
> a tutorial about the 
implementation of <EM
>QoS (Quality of Service)</EM
> in Linux. 
If you don't have previous experience with <EM
>QoS</EM
> 
it's better to read some references at the end of this document to acquire
the concepts required for <EM
>QoS</EM
> implementation.</P
><P
>With this advice, I'm not going to explain in detail each of the 
commands needed to control flows in Linux because it is not the goal of 
this HOWTO. However, the implementation of some of these techniques will
serve us to show the bandwidth meter (based on <EM
>libiptc</EM
>) 
behaviour.</P
><P
>First check if you have QoS implementation options implemented in your 
kernel. Run <B
CLASS="COMMAND"
>make menuconfig</B
>, follow the menu to 
<EM
>Networking options</EM
> and look for last menu of this 
option <EM
>QoS and/or fair queueing</EM
>. Here use (or check 
if they are active) these options:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>       [*] QoS and/or fair queueing
       &#60;M&#62; CBQ packet scheduler
       &#60;M&#62; CSZ packet scheduler
       [*] ATM pseudo-scheduler
       &#60;M&#62; The simplest PRIO pseudoscheduler
       &#60;M&#62; RED queue
       &#60;M&#62; SFQ queue
       &#60;M&#62; TEQL queue
       &#60;M&#62; TBF queue
       &#60;M&#62; GRED queue
       &#60;M&#62; Diffserv field marker
       &#60;M&#62; Ingress Qdisc
       [*] QoS support
       [*]   Rate estimator
       [*] Packet classifier API
       &#60;M&#62;   TC index classifier
       &#60;M&#62;   Routing table based classifier
       &#60;M&#62;   Firewall based classifier
       &#60;M&#62;   U32 classifier
       &#60;M&#62;   Special RSVP classifier
       &#60;M&#62;   Special RSVP classifier for IPv6
       [*]   Traffic policing (needed for in/egress)</PRE
></FONT
></TD
></TR
></TABLE
><P
>Save your configuration, recompile your kernel and modules, and 
re-install it. We are going to use the 
<EM
>CBQ packet scheduler</EM
> to implement some queues 
to control bytes flow in our PC #1 NIC. </P
><P
>Personally I preferred the excellent <EM
>HTB queueing 
discipline implementation</EM
> by Martin Devera but actually this 
implementation is not in standard Linux (but it will be); for 
implementing it you have to patch your kernel before recompiling and 
it's better not to complicate things more. However I have to say that 
this queue discipline is a lot more simple to use than
<EM
>CBQ</EM
> happens to be. More information on 
<EM
>HTB queueing discipline</EM
> are linked at the end of
this document.</P
><P
>Having compiled and re-installed your kernel you have to install the 
<EM
>iproute2</EM
> package that will be used to run the 
commands needed to implement the queues. Download this package from 
<A
HREF="ftp://ftp.inr.ac.ru/ip-routing"
TARGET="_top"
>ftp://ftp.inr.ac.ru/ip-routing</A
>.</P
><P
>I'm working with version <EM
>2.2.4-now-ss001007</EM
>. To install 
it follow these instructions:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cp iproute2-2.2.4-now-ss001007.tar.gz /usr/local/src</B
>
bash# <B
CLASS="COMMAND"
>tar xzvf iproute2-2.2.4-now-ss001007.tar.gz</B
>
bash# <B
CLASS="COMMAND"
>cd iproute2</B
>
bash# <B
CLASS="COMMAND"
>make</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>After <EM
>make</EM
> compiles the <EM
>iproute2</EM
>
package successfully the <EM
>ip</EM
> utility will be in 
<TT
CLASS="FILENAME"
>iproute2/ip</TT
> directory and the 
<EM
>tc</EM
> utility in <TT
CLASS="FILENAME"
>iproute2/tc</TT
>
directory. Copy both of them to <TT
CLASS="FILENAME"
>/usr/bin</TT
> directory:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>cp ip/ip /usr/bin</B
>
bash# <B
CLASS="COMMAND"
>cp tc/tc /usr/bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now, using the <EM
>tc</EM
> utility, we are going to create a 
<EM
>CBQ</EM
> queue in the interface <EM
>eth0</EM
> of 
the PC #1 computer. This queue will have 4 classes as children and each of 
these classes will be used to control the 4 flows from 
<EM
>192.168.1.1</EM
> to <EM
>192.168.1.2</EM
> 
through ports <EM
>1001</EM
> to <EM
>1004</EM
>.</P
><P
>Write and run the following commands:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc qdisc add dev eth0 root handle 1:0 cbq bandwidth 10Mbit \
avpkt 1000 cell 8</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>This command creates the main (root) cbq queue 1:0 in the 
<EM
>eth0</EM
> interface; the bandwidth of this queue is 
10Mbit/sec corresponding to our Ethernet interface.</P
><P
>Now write and run:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit \
rate 1000kbit prio 8 allot 1514 cell 8 maxburst 20 avpkt 1000 bounded</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>This command create the main cbq class 1:1. The rate of this class
will be 1000kbit/sec.</P
><P
>Now we are going to create 4 classes ownned by this class; the classes
will have rates of 100kbit, 200kbit, 300kbit and 400kbit respectively.
Write and run these commands:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 10Mbit \
rate 100kbit prio 5 allot 1514 cell 8 maxburst 20 avpkt 1000</B
>

bash# <B
CLASS="COMMAND"
>tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 10Mbit \
rate 200kbit prio 5 allot 1514 cell 8 maxburst 20 avpkt 1000</B
>

bash# <B
CLASS="COMMAND"
>tc class add dev eth0 parent 1:1 classid 1:5 cbq bandwidth 10Mbit \
rate 300kbit prio 5 allot 1514 cell 8 maxburst 20 avpkt 1000</B
>

bash# <B
CLASS="COMMAND"
>tc class add dev eth0 parent 1:1 classid 1:6 cbq bandwidth 10Mbit \
rate 400kbit prio 5 allot 1514 cell 8 maxburst 20 avpkt 1000</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Each of these classes will have a <EM
>sfq</EM
> queue discipline 
attached to them to dispatch their packets. Write and run these commands:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc qdisc add dev eth0 parent 1:3 handle 30: sfq perturb 15</B
>
bash# <B
CLASS="COMMAND"
>tc qdisc add dev eth0 parent 1:4 handle 40: sfq perturb 15</B
>
bash# <B
CLASS="COMMAND"
>tc qdisc add dev eth0 parent 1:5 handle 50: sfq perturb 15</B
>
bash# <B
CLASS="COMMAND"
>tc qdisc add dev eth0 parent 1:6 handle 60: sfq perturb 15</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>These commands create 4 <EM
>sfq</EM
> queue disciplines, one 
for each class. <EM
>sfq</EM
> queue discipline is some kind of 
<EM
>fair controlling queue</EM
>. It tries to give to each connection 
in an interface same oportunity to their packets to be dispatched to at all.</P
><P
>Finally we are going to create filters to assign flows to ports 
<EM
>1001</EM
>, <EM
>1002</EM
>, <EM
>1003</EM
> 
and <EM
>1004</EM
> to classes <EM
>1:3</EM
>, 
<EM
>1:4</EM
>, <EM
>1:5</EM
> and 
<EM
>1:6</EM
> respectively. Write and run as follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
dport 1001 0xffff flowid 1:3</B
>

bash# <B
CLASS="COMMAND"
>tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
dport 1002 0xffff flowid 1:4</B
>

bash# <B
CLASS="COMMAND"
>tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
dport 1003 0xffff flowid 1:5</B
>

bash# <B
CLASS="COMMAND"
>tc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \
dport 1004 0xffff flowid 1:6</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>After running all these commands, now check your <EM
>bw</EM
> 
meter (you must be running <EM
>netcat</EM
> listening at ports 
<EM
>1001</EM
> to <EM
>1004</EM
> in PC #2 and
talking in PC #1 as was explained in previous chapter and <EM
>bw</EM
> 
running in <EM
>current -c</EM
> mode). You will have something 
like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Current flow values ...
   1099.9k:  108.8k  196.5k  337.9k  456.8k 
   1104.2k:  115.3k  184.9k  339.9k  464.1k 
   1102.1k:  117.3k  174.7k  339.7k  470.5k 
   1114.4k:  113.6k  191.7k  340.7k  468.4k 
   1118.4k:  113.7k  194.3k  340.5k  469.9k </PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>bw</EM
> show us how flows are controlling using queue 
disciplines of the Linux kernel. As you see, 
<EM
>CBQ queue discipline</EM
> is not a very precise queue but 
you more or less have a flow of approximately 
<EM
>1000=100+200+300+400</EM
> on interface 
<EM
>eth0</EM
>.</P
><P
>To step back, write and run as follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>tc qdisc del dev eth0 root handle 1:0 cbq</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>on PC #1, to delete the main (root) queue discipline and owned classes 
and filters.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>killall nc</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>on PC #2 and PC #1, to stop <EM
>netcat</EM
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>iptables -F</B
>
bash# <B
CLASS="COMMAND"
>iptables -X</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>on PC #1, to clear <EM
>iptables</EM
> rules and chains.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>bash# <B
CLASS="COMMAND"
>Ctrl-C</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>on PC #1, tty1 to stop <EM
>bw</EM
> bandwidth meter.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SOMELINKS"
>15. Some interesting links</A
></H2
><P
></P
><OL
TYPE="1"
><LI
><P
> 
<A
HREF="http://netfilter.samba.org/"
TARGET="_top"
>iptables-1.2.6 by Paul Russell</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://netfilter.samba.org/documentation/HOWTO/"
TARGET="_top"
>Linux netfilter Hacking HOWTO by Paul Russell</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://www.linuxgrill.com/iproute2-toc.html"
TARGET="_top"
>iproute2 by Alexey Kuznetsov</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://www.tldp.org/HOWTO/Adv-Routing-HOWTO.html"
TARGET="_top"
>Advance routing Linux HOWTO</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://luxik.cdi.cz/~devik/qos/htb/htbtheory.htm"
TARGET="_top"
>HTB queueing discipline implementation by Martin Devera</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://qos.ittc.ukans.edu/howto/howto.html"
TARGET="_top"
>Linux-Advance Networking Overview by Saravanan Radhakrishnan</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://www.docum.org/"
TARGET="_top"
>monitor.pl by Stef Coene</A
>.</P
></LI
><LI
><P
> 
<A
HREF="http://rr.sans.org/audit/netcat.php"
TARGET="_top"
>netcat by Hobbit</A
>.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AUTHOR"
>16. About the author</A
></H2
><P
> 
Leonardo Balliache is a power electrical engineer that left high voltage 
lines, transformers and protection relays in 1983 to dedicated full of his
time to computer sciences.</P
><P
> 
He is the General Manager of OpalSoft, a venezuelan company dedicated to
business packages software development. </P
><P
> 
In 1989 he started learning Unix using Coherent operating system.  After 
this he was interested in Linux and specially in bandwidth bottleneck 
problems, bandwidth controlling, packet filtering and hierarching, Linux 
QoS (Quality of Service), advanced routing, network protection, firewalling,
private network connection through the Internet and solving line and server 
load balancing problems.</P
><P
> 
His company will be opening a new area of business offering Linux 
QoS solution implementations in Venezuela.</P
><P
> 
Married to Cielo, with 3 sons (Jose, Dario, Gustavo), he can be reached at 
<A
HREF="mailto:leonardo@opalsoft.net"
TARGET="_top"
>leonardo@opalsoft.net</A
>.
He is working now (please be patient) to open a QoS Linux information site 
at <A
HREF="http://opalsoft.net/qos/"
TARGET="_top"
>http://opalsoft.net/qos/</A
> to interchange knowledge with people 
interested and to make his works in the Linux <SPAN
CLASS="QUOTE"
>"best of all"</SPAN
> 
operating system available to the public.</P
><P
>April 30, 2002</P
><P
> 
Caracas, Venezuela</P
></DIV
></DIV
></BODY
></HTML
>