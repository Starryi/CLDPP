<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Booting Linux from DiskOnChip HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="This document discusses how to make the Flash Drives Linux bootable. We will describe how to boot from such a drive, instead of from the normal hard drive."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="index"></a>Booting Linux from DiskOnChip HOWTO</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Rohit</span> <span class="surname">Agarwal</span></h3><div class="affiliation"><div class="address"><p><br>
        <code class="email">&lt;<a class="email" href="mailto:rohdimp_24@rediffmail.com"><a class="ulink" href="mailto:rohdimp_24@rediffmail.com" target="_top">rohdimp_24@rediffmail.com</a></a>&gt;</code><br>
     </p></div></div></div></div><div><div class="author"><h3 class="author"><span class="firstname">Vishnu</span> <span class="surname">Swaminathan</span></h3><div class="affiliation"><div class="address"><p><br>
     <code class="email">&lt;<a class="email" href="mailto:Vishnu.Swaminathan@siemens.com"><a class="ulink" href="mailto:vishnu.swaminathan@siemens.com" target="_top">Vishnu.Swaminathan@siemens.com</a></a>&gt;</code><br>
     </p></div></div></div></div><div><p class="pubdate">20060907</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.0</td><td align="left">2006-09-07</td><td align="left">MG</td></tr><tr><td align="left" colspan="3">Last review for LDP publication</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This document discusses how to make the Flash Drives Linux bootable.  We will describe how to boot from such a drive, instead of from the normal hard drive.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#why">1.1. Why this document?</a></span></dt><dt><span class="sect2"><a href="#NFTL">1.2. NFTL vs. INFTL</a></span></dt><dt><span class="sect2"><a href="#aims">1.3. Practical goals</a></span></dt></dl></dd><dt><span class="sect1"><a href="#refconf">2. Reference configuration</a></span></dt><dt><span class="sect1"><a href="#assumptions">3. Assumptions</a></span></dt><dt><span class="sect1"><a href="#steps">4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux</a></span></dt><dd><dl><dt><span class="sect2"><a href="#step1">4.1. Step 1: Patch the Kernel</a></span></dt><dt><span class="sect2"><a href="#step2">4.2. Step 2: Compile the Kernel</a></span></dt><dt><span class="sect2"><a href="#step3">4.3. Step 3: Create Nodes</a></span></dt><dt><span class="sect2"><a href="#step4">4.4. Step 4: Reboot with the new kernel</a></span></dt><dt><span class="sect2"><a href="#step5">4.5. Step 5: Insert M-Systems Driver/Module in the new Kernel</a></span></dt><dt><span class="sect2"><a href="#step6">4.6. Step 6: Create a filesystem on the DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#step7">4.7. Step 7: Mount the newly created partition to start accessing DOC</a></span></dt></dl></dd><dt><span class="sect1"><a href="#install">5. Install Linux and LILO on DiskOnChip</a></span></dt><dd><dl><dt><span class="sect2"><a href="#copy_firmware">5.1. Step 1: Copying the DOC firmware onto DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#format">5.2. Step 2: Format DiskOnChip using Dos Utilities</a></span></dt><dt><span class="sect2"><a href="#patch-compile">5.3. Step 3: Patch and Compile the kernel 2.4.18</a></span></dt><dt><span class="sect2"><a href="#nodes">5.4. Step 4: Create nodes</a></span></dt><dt><span class="sect2"><a href="#modconf">5.5. Step 5: Modify the /etc/module.conf file</a></span></dt><dt><span class="sect2"><a href="#initrd">5.6. Step 6: Create the initrd image</a></span></dt><dt><span class="sect2"><a href="#insert_driver">5.7. Step 7: Insert the DOC driver into the new kernel</a></span></dt><dt><span class="sect2"><a href="#createfs">5.8. Step 8:  Create a filesystem on the DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#rootfs">5.9. Step 9:  Build Root Filesystem on the DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#rdev">5.10. Step 10: Use rdev to specify the DOC root filesystem location to kernel image</a></span></dt><dt><span class="sect2"><a href="#lilo">5.11. Step 11: Compile lilo-22.3.2</a></span></dt><dt><span class="sect2"><a href="#boot.b">5.12. Step 12: Copy the boot.b file into boot directory of DOC</a></span></dt><dt><span class="sect2"><a href="#liloconf">5.13. Step 13:  Modify the /etc/lilo.conf file</a></span></dt><dt><span class="sect2"><a href="#bootable">5.14. Step 14: Store the new LILO configuration on the DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#fstab">5.15. Step 15: Modify etc/fstab of DiskOnChip root file system</a></span></dt><dt><span class="sect2"><a href="#firmware">5.16. Step16:  Update Firmware</a></span></dt><dt><span class="sect2"><a href="#boot">5.17. Step17: BOOT from DiskOnChip</a></span></dt></dl></dd><dt><span class="sect1"><a href="#devtools">6. Install Development ToolChain on DiskOnChip</a></span></dt><dd><dl><dt><span class="sect2"><a href="#getimage">6.1. Step1: Obtain the latest copy of root_fs_i386.ext2</a></span></dt><dt><span class="sect2"><a href="#fs_swap">6.2. Step2: Replace the root filesystem of the DiskOnChip</a></span></dt><dt><span class="sect2"><a href="#DOS_fstab">6.3. Step3: Modify etc/fstab of DiskOnChip root file system</a></span></dt><dt><span class="sect2"><a href="#reboot">6.4. Step4: Reboot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#refs">7. References</a></span></dt><dt><span class="appendix"><a href="#idm871">A. Output of dinfo</a></span></dt><dt><span class="appendix"><a href="#idm885">B. License</a></span></dt><dt><span class="appendix"><a href="#idm890">C. About Authors</a></span></dt><dt><span class="appendix"><a href="#idm898">D. Dedications</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>1. Introduction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="why"></a>1.1. Why this document?</h3></div></div></div><p>DiskOnChip (DOC) is a flash drive that is manufactured by M-Systems. The use of flash drives is emerging as a substitute for Hard Disks in embedded devices. Embedded Linux is gaining popularity as the operating system of choice in the embedded systems community; as such, there is an increased demand for embedded systems that can boot into Linux from flash drives.</p><p>Much of the documentation currently available on the subject is either incorrect or incomplete; the presentation of the information which is provided by such documents is likely to confuse novice users.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="NFTL"></a>1.2. NFTL vs. INFTL</h3></div></div></div><p>Another fundamental problem is that most of the documents assume the DiskOnChip to be a NFTL (NAND Flash Translation Layer) device, and proceed to describe the booting process for NFTL devices. DiskOnChip architectures come in two variants, each of which requires different booting procedures: NFTL and INFTL (Inverse NFTL). Dan Brown, who has written a boot loader known as DOCBoot, explains the differences between these variants in a README document, which is included with the DOCBoot package: <a class="ulink" href="http://ftp.arm.linux.org.uk/pub/people/dwmw2/mtd/cvs/mtd/docboot/" target="_top">http://ftp.arm.linux.org.uk/pub/people/dwmw2/mtd/cvs/mtd/docboot/</a>.</p><p>An INFTL device is organized as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>IPL</p><p>Media Header</p><p>Partition 0 (BDK or BDTL)</p><p>(Optional) Partition 1(BDK or BDTL)</p><p>.. Up to at most Partition 3</p></blockquote></div><p>Under Linux MTD partitions are created for each partition listed in the INFTL partition table. Thus up to 5 MTD devices are created.</p><p>By contrast the NFTL device is organized as follows:</p><div class="blockquote"><blockquote class="blockquote"><p>Firmware</p><p>Media Header</p><p>BDTL Data</p></blockquote></div><p>Under Linux, normally two MTD devices will be created.</p><p>According to the above excerpt, the process used by the boot loader when fetching the kernel image for an INFTL device is different from the method used for NFTL devices, since both devices have different physical layouts. (repetitive)</p><p>Using a 2.4.x kernel  for an INFTL DiskOnChip device is complicated by the lack of native support in pre-2.6.x kernels (although native NFTL support is present). Such functionality is only available by <span class="emphasis"><em>patching</em></span> the kernel; an approach which is ill-advised.</p><p>Patching the kernel with external INFTL support is discouraged; the developers of the MTD driver, the open source driver available for DiskOnChip, are apprehensive of this approach as well. For more information on this matter, feel free to peruse the mailing list conversation on the subject at <a class="ulink" href="http://lists.infradead.org/pipermail/linux-mtd/2004-August/010165.html" target="_top">http://lists.infradead.org/pipermail/linux-mtd/2004-August/010165.html</a>.</p><p>The drivers that provide native INFTL support in the 2.6.x kernels failed to identify the DiskonChip device used for this exercise, and the following message was reported by the system:</p><pre class="screen">
INFTL no longer supports the old DiskOnChip drivers loaded via docprobe.  
Please use the new diskonchip driver under the NAND subsystem.
</pre><p>So then we decided to use the drivers provided by M-Systems (manufacturer of DiskOnChip).  However, according to the documentation provided by the vendor on these drivers, they were designed for NFTL devices only. As such, we decided to write this HOWTO which will address the use of INFTL devices. We have taken special care to remove any ambiguity in the steps and also tried to give reasons for the need of a particular step so as to make things logically clear. We have explained things in such a way that a person with less experience on Linux can also follow the steps.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="aims"></a>1.3. Practical goals</h3></div></div></div><p>This document aims to act as a guide to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use M-Systems DiskOnChip 2000 TSOP as an additional storage drive along with an IDE HDD running Linux on it.</p></li><li class="listitem"><p>Install Linux on DiskOnChip 2000 TSOP and boot Linux from it.</p></li><li class="listitem"><p>Install the Development Tool-Chain so as to compile and execute programs directly on DiskOnChip.</p></li></ul></div><p>The method described here has been tested for DiskOnChip 2000 TSOP 256MB and DiskOnChip 2000 TSOP 384MB.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="refconf"></a>2. Reference configuration</h2></div></div></div><p>We used the following hard- and software:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>VIA Eden CPU 1GHz clock speed 256MB RAM</p></li><li class="listitem"><p>RTD Enhanced Phoenix - AwardBIOS CMOS Setup Utility (v6.00.04.1601)</p></li><li class="listitem"><p>Kernel 2.4.18 source code downloaded from <a class="ulink" href="www.kernel.org/pub/linux/kernel/v2.4" target="_top">www.kernel.org/pub/linux/kernel/v2.4</a></p></li><li class="listitem"><p>256 MB M-Systems DiskOnChip 2000 TSOP (MD2202-D256)</p></li><li class="listitem"><p>M-Systems TrueFFS Linux driver version 5.1.4 from <a class="ulink" href="http://www.m-sys.com/site/en-US/Support/SoftwareDownload/Driver+Download.htm?driver=linux_binary.5_1_4.tgz" target="_top">http://www.m-sys.com/site/en-US/Support/SoftwareDownload/Driver+Download.htm?driver=linux_binary.5_1_4.tgz</a></p></li><li class="listitem"><p>LILO version 22.3.2 (distributed with driver)</p></li><li class="listitem"><p>DiskOnChip DOS utilities version 5.1.4 and BIOS driver version 5.1.4 from <a class="ulink" href="http://www.m-sys.com/site/en-US/Support/SoftwareDownload/TrueFFS5.x/BIOSDOSdriverandtools.htm" target="_top">http://www.m-sys.com/site/en-US/Support/SoftwareDownload/TrueFFS5.x/BIOSDOSdriverandtools.htm</a></p></li><li class="listitem"><p>Dual bootable Hard Disk with Knoppix 3.9 and Windows XP using Grub 0.96 as the Boot Loader</p></li><li class="listitem"><p>GNU GCC-2.95.3</p></li><li class="listitem"><p>Latest root_fs_i386 image from <a class="ulink" href="http://www.uclibc.org/downloads/root_fs_i386.ext2.bz2" target="_top">http://www.uclibc.org/downloads/root_fs_i386.ext2.bz2</a> or <a class="ulink" href="http://www.uclibc.org/downloads/root_fs_i386.ext2.tar.gz" target="_top">http://www.uclibc.org/downloads/root_fs_i386.ext2.tar.gz</a></p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assumptions"></a>3. Assumptions</h2></div></div></div><p>We have made some assumptions related to working directories and mounting points which we would like to mention before listing the entire procedure for putting Linux on DiskOnChip.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>We will perform all the compilation in <code class="filename">/usr/src</code> of the host machine so downloading of the necessary files must be done into that directory.</p></li><li class="listitem"><p>All the commands listed are executed assuming <code class="filename">/usr/src</code> as the present working directory.</p></li><li class="listitem"><p>We will mount the DiskOnChip partition on <code class="filename">/mnt/doc</code>.</p></li><li class="listitem"><p>The names of the directories will be exactly the same as the files that  have been downloaded so the document will give the actual path as were created on the host system.</p></li><li class="listitem"><p>DiskOnChip and DOC have been used interchangeably to mean M-Systems DiskOnChip 2000 TSOP.</p></li><li class="listitem"><p>The DOS utilities have been downloaded and saved in a Windows partition directory.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="steps"></a>4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux</h2></div></div></div><p>The following are the steps performed for this purpose.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step1"></a>4.1. Step 1: Patch the Kernel</h3></div></div></div><p>Download a fresh copy of Kernel 2.4.18 from <a class="ulink" href="http://www.kernel.org/pub/linux/kernel/v2.4" target="_top">http://www.kernel.org/pub/linux/kernel/v2.4</a>.</p><p>The kernel that is downloaded from the site does not have support for the M-Systems driver so we need to add this functionality.  This is done by adding a patch to the kernel.</p><p>The steps to conduct patching are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Untar the kernel source file and the M-systems TrueFFS Linux driver version 5.14.  If the source code is in <code class="filename">.tar.gz</code> format, use</p><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-xvzf</code> <code class="filename">linux-2.4.18.tar.gz</code></code> </p></div><p>If the source code is in <code class="filename">.tar.bz2</code> format, use</p><div class="cmdsynopsis"><p><code class="command">bunzip2 <code class="filename">linux-2.4.18.tar.bz2</code></code> </p></div><p>After using <span class="command"><strong>bunzip2</strong></span>, you will get a file named <code class="filename">linux-2.4.18.tar</code>.  Untar it using the command</p><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-xvf</code> <code class="filename">linux-2.4.18.tar</code></code> </p></div><p>Unarchiving the driver is done using the command</p><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-xvzf</code> <code class="filename">linux_binary.5_1_4.tgz</code></code> </p></div><p>This results in the creation of two directories: <code class="filename">linux</code> and <code class="filename">linux_binary.5_1_4</code>.</p></li><li class="listitem"><p>The TrueFFS Linux driver package contains three different folders:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">Documentation</code>: this contains a PDF document describing the various functions of TrueFFS.</p></li><li class="listitem"><p><code class="filename">dformat_5_1_4_37</code>: this contains a utility <span class="command"><strong>dformat</strong></span>, which is used to update the firmware on the DiskOnChip (DOC) and to create low level partitions on the DOC.</p></li><li class="listitem"><p><code class="filename">doc-linux-5_1_4_20</code>: this contains patches, <code class="filename">initrd</code> scripts and other utilities.</p></li></ul></div></li><li class="listitem"><p>Now apply the patch to the kernel.  We will use the <code class="filename">linux-2_4_7-patch</code> file that is present in <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver</code>.  The following commands are used for this purpose:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">patch <code class="option">-p1 -d</code> <code class="filename">/usr/src/linux</code> &lt; <code class="filename">linux-2_4_7-patch</code></code> </p></div><p>This will create a directory named <code class="filename">doc</code> in the <code class="filename">linux/drivers/block</code> directory.</p></li><li class="listitem"><p>The patch created the <code class="filename">doc</code> directory, but did not copy the source files of the M-Systems driver, which are necessary in order to build the driver, into this directory.  So execute the following command:</p><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver/doc/* /usr/src/linux/drivers/block/doc</code></code> </p></div></li></ol></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Kernel version</h3><p>The patch will fail for kernels other than 2.4.18 since the source files where the patch is to be applied may be somewhat different in different kernels. The patch has been provided specifically for kernel 2.4.18.</p></div><p>Before moving on to Step 2, do the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Login as root.</p></li><li class="listitem"><p>Make sure that <span class="command"><strong>gcc</strong></span> version is 2.95.3 else the build will fail. Use <span class="command"><strong>gcc <code class="option">--version</code></strong></span> to check this.  If your <span class="command"><strong>gcc</strong></span> version is different compile gcc-2.95.3. Refer to <a class="ulink" href="http://xlife.zuarvra.net.columns/20020316" target="_top">http://xlife.zuarvra.net.columns/20020316</a> for this purpose.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step2"></a>4.2. Step 2: Compile the Kernel</h3></div></div></div><p>Complete the following tasks for compiling the kernel:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="command"><strong>cd <code class="filename">linux</code></strong></span></p></li><li class="listitem"><p><span class="command"><strong>make <em class="parameter"><code>menuconfig</code></em></strong></span></p><p>Check for the following options:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>In the <span class="quote">&#8220;<span class="quote">Block devices menu</span>&#8221;</span>, select:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>M-Systems driver as module i.e. (M)</p></li><li class="listitem"><p>Loopback device support as built-in i.e. (*)</p></li><li class="listitem"><p>RAM disk support as built-in i.e. (*)</p></li><li class="listitem"><p>Initial RAM disk (initrd) support as built .in i.e. (*)</p></li></ul></div></li><li class="listitem"><p>In the <span class="quote">&#8220;<span class="quote">Processor type and features menu</span>&#8221;</span>, select <span class="quote">&#8220;<span class="quote">Disable Symmetric Multiprocessor Support</span>&#8221;</span>.</p></li><li class="listitem"><p>In the <span class="quote">&#8220;<span class="quote">filesystem menu</span>&#8221;</span>, select:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>Ext3 journaling file system support as built-in</p></li><li class="listitem"><p>DOS FAT fs support as built-in<sup>a</sup></p></li><li class="listitem"><p>MSDOS fs support as built-in<sup>b</sup></p></li><li class="listitem"><p>VFAT (Windows-95) fs support as built-in<sup>c</sup> </p></li></ul></div></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">File System Menu</h3><p>a,b,c options should be activated if you want to mount your MS Windows partition, else they can be left out.  It is, however, generally recommended to use them.</p></div><p>An excellent resource on kernel compilation is the <a class="ulink" href="http://www.digitalhermit.com/linux/Kernel-Build-HOWTO.html" target="_top">Kernel Rebuild Guide</a>.</p><p>The configuration file, <code class="filename">linux/.config</code> should essentially contain the following lines (only a part of the config file has been given):</p><pre class="screen">
#
# Loadable module support
#
CONFIG_MODULES=y
CONFIG_MODVERSIONS=y
CONFIG_KMOD=y

#
# Processor type and features
#

# CONFIG_SMP is not set


#
# Memory Technology Devices (MTD)
#
# CONFIG_MTD is not set

#
# Block devices
#
# CONFIG_BLK_DEV_FD is not set
# CONFIG_BLK_DEV_XD is not set
# CONFIG_PARIDE is not set
# CONFIG_BLK_CPQ_DA is not set
# CONFIG_BLK_CPQ_CISS_DA is not set
# CONFIG_BLK_DEV_DAC960 is not set
CONFIG_BLK_DEV_LOOP=y
# CONFIG_BLK_DEV_NBD is not set
CONFIG_BLK_DEV_RAM=y
CONFIG_BLK_DEV_RAM_SIZE=4096
CONFIG_BLK_DEV_INITRD=y
CONFIG_BLK_DEV_MSYS_DOC=m

#
# File systems
#
# CONFIG_QUOTA is not set
# CONFIG_AUTOFS_FS is not set
# CONFIG_AUTOFS4_FS is not set
CONFIG_EXT3_FS=y
CONFIG_FAT_FS=y
CONFIG_MSDOS_FS=y
# CONFIG_UMSDOS_FS is not set
CONFIG_VFAT_FS=y
# CONFIG_EFS_FS is not set
# CONFIG_JFFS_FS is not set
# CONFIG_JFFS2_FS is not set
# CONFIG_CRAMFS is not set
CONFIG_TMPFS=y
# CONFIG_RAMFS is not set
CONFIG_ISO9660_FS=y
# CONFIG_JOLIET is not set
# CONFIG_HPFS_FS is not set
CONFIG_PROC_FS=y
# CONFIG_DEVFS_FS is not set
# CONFIG_DEVFS_MOUNT is not set
# CONFIG_DEVFS_DEBUG is not set
CONFIG_DEVPTS_FS=y
# CONFIG_QNX4FS_FS is not set
# CONFIG_QNX4FS_RW is not set
# CONFIG_ROMFS_FS is not set
CONFIG_EXT2_FS=y
</pre></li><li class="listitem"><p><span class="command"><strong>make <em class="parameter"><code>dep</code></em></strong></span></p></li><li class="listitem"><p><span class="command"><strong>make <em class="parameter"><code>bzImage</code></em></strong></span></p></li><li class="listitem"><p><span class="command"><strong>make <em class="parameter"><code>modules</code></em></strong></span></p></li><li class="listitem"><p><span class="command"><strong>make <em class="parameter"><code>modules_install</code></em></strong></span></p></li><li class="listitem"><p>Copy the newly created <code class="filename">bzImage</code> to the <code class="filename">/bott</code> directory and name it <code class="filename">vmlinuz-2.4.18</code>, using this command:</p><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">/arch/i386/boot/bzImage /boot/vmlinuz-2.4.18</code></code> </p></div></li></ol></div><p>Check for <code class="filename">lib/modules/2.4.18/kernel/drivers/block/doc.o</code>.  This is the M-Systems driver that we need to access DiskOnChip.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step3"></a>4.3. Step 3: Create Nodes</h3></div></div></div><p>Now we will create block devices, which are required to access the DOC
These block devices will use the M-Systems driver that was built in <a class="xref" href="#step2" title="4.2. Step 2: Compile the Kernel">Section 4.2, &#8220;Step 2: Compile the Kernel&#8221;</a> to access the DOC. The script <span class="command"><strong>mknod_fl</strong></span> in <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver</code> is used for this purpose.</p><p>We need to create the block devices with the major number of 62. For this purpose we will pass the argument 62 while creating the nodes:</p><div class="cmdsynopsis"><p><code class="command">./mknod_fl <em class="parameter"><code>62</code></em></code> </p></div><p>This will create the following devices in <code class="filename">/dev/msys</code> with major number 62:</p><pre class="screen">
fla...fla4
flb...flb4
flc...flc4
fld...fld4
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step4"></a>4.4. Step 4: Reboot with the new kernel</h3></div></div></div><p>In order to have the DiskOnChip recognized by Linux OS, we need to insert the DOC driver module into the kernel. Since the currently running kernel doesn't have support for the M-Systems Driver, we need to boot into new kernel we just compiled in <a class="xref" href="#step2" title="4.2. Step 2: Compile the Kernel">Section 4.2, &#8220;Step 2: Compile the Kernel&#8221;</a>.</p><p>For this purpose we need to add the following entries in the <code class="filename">/boot/grub/menu.lst</code> file:</p><pre class="screen">
title Debian GNU/Linux,Kernel 2.4.18
root (hd0,7)
kernel /boot/vmlinuz-2.4.18 root=/dev/hda8
safedefault
boot
</pre><p>Where (hd0,7) is the partition holding the kernel image <code class="filename">vmlinuz-2.4.18</code> and <code class="filename">/dev/hda8</code> is the partition holding the <span class="emphasis"><em>root filesystem</em></span>.  These partitions may vary from one system to another. Now reboot and choose the kernel 2.4.18 option (the kernel that has been compiled in Step 2) in the <span class="command"><strong>grub</strong></span> menu to boot into the new kernel.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step5"></a>4.5. Step 5: Insert M-Systems Driver/Module in the new Kernel</h3></div></div></div><p>The M-Systems driver by default gets loaded with major number 100, but our newly created nodes (see <a class="xref" href="#step3" title="4.3. Step 3: Create Nodes">Section 4.3, &#8220;Step 3: Create Nodes&#8221;</a>) have a major number 62. Therefore we need to insert this module with a major number 62. This can be done in either of two ways:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>While inserting the module using <span class="command"><strong>insmod</strong></span> also mention the major number for the module which needs to be assigned to it otherwise it will take the default major number of 100:</p><div class="cmdsynopsis"><p><code class="command">insmod <em class="parameter"><code>doc major=62</code></em></code> </p></div></li><li class="listitem"><p>Add the following line to <code class="filename">/etc/modules.conf</code>:</p><pre class="screen">options doc major=62</pre><p>Then use <span class="command"><strong>modprobe <em class="parameter"><code>doc</code></em></strong></span> to insert the modules.</p></li></ol></div><p>Check for the correct loading of the module using the <span class="command"><strong>lsmod</strong></span> command without options.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step6"></a>4.6. Step 6: Create a filesystem on the DiskOnChip</h3></div></div></div><p>Before we can start using DiskOnChip we need to create a filesystem on it.  We will create an ext2 filesystem since it is small in size.</p><p>This involves a hidden step of making partitions on the DOC using <span class="command"><strong>fdisk</strong></span>.  The actual steps are as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><div class="cmdsynopsis"><p><code class="command">fdisk <code class="filename">/dev/msys/fla</code></code> </p></div><p>This command will ask to create partitions.  Create a primary partition number 1 with start cylinder as 1 and final cylinder as 1002.</p><p>Check the partition table, which should look like this:</p><pre class="screen">
Device             Boot  Start      End        Blocks    ID     System
/dev/msys/fla1            1         1002        255984   83     Linux
</pre></li><li class="listitem"><p>Make the filesystem on <code class="filename">/dev/msys/fla1</code> with the command</p><div class="cmdsynopsis"><p><code class="command">mke2fs <code class="option">-c</code> <code class="filename">/dev/msys/fla1</code></code> </p></div><p>Where <code class="filename">fla1</code> is the first primary partition on the DOC. (We have created only one partition in order to avoid unnecessary complexity.)</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="step7"></a>4.7. Step 7: Mount the newly created partition to start accessing DOC</h3></div></div></div><p>Create a new mount point for the DiskOnChip in the <code class="filename">/mnt</code> directory:</p><div class="cmdsynopsis"><p><code class="command">mkdir <code class="filename">/mnt/doc</code></code> </p></div><p>Mount the DOC partition on the newly created directory:</p><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-t</code> <em class="parameter"><code>auto</code></em> <code class="filename">/dev/msys/fla1 /mnt/doc</code></code> </p></div><p>You will now be able to read and write to the DOC as an additional storage drive.</p><p>When you reboot your system, make the DOC available by inserting the driver into the kernel (see <a class="xref" href="#step5" title="4.5. Step 5: Insert M-Systems Driver/Module in the new Kernel">Section 4.5, &#8220;Step 5: Insert M-Systems Driver/Module in the new Kernel&#8221;</a>) and mounting the device.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="install"></a>5. Install Linux and LILO on DiskOnChip</h2></div></div></div><p>In this section we will learn how to install Linux operating system on an unformatted DOC and boot from it using LILO as the boot loader.</p><p>In order to get to this state, a procedure will be discussed.  Some steps in this procedure resemble the steps discussed previously in this document.  Even so, this should be considered a separate procedure, rather than a continuation of the steps in <a class="xref" href="#steps" title="4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux">Section 4, &#8220;Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux&#8221;</a>.</p><p>In general, to make a device to boot into Linux, it should have the following components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Kernel Image</p></li><li class="listitem"><p>Root Filesystem</p></li><li class="listitem"><p>Boot loader to load the kernel Image into memory</p></li></ul></div><p>This section will basically try to fulfill the above three requirements.</p><p>The following steps should be followed for achieving the goal of this section.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="copy_firmware"></a>5.1. Step 1: Copying the DOC firmware onto DiskOnChip</h3></div></div></div><p>We will use the <span class="command"><strong>dformat</strong></span> utility from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37</code>.</p><p>M-Systems does not provide the firmware for using the DOC on Linux platforms. We address this problem by making a copy of the firmware shipped with the M-Systems dos utilities into this directory (<span class="quote">&#8220;<span class="quote">dos utilities</span>&#8221;</span> is the term used by the M-Systems people so we have also used this name).  On our system we copied it by mounting the windows partition and extracting it from there:</p><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-t</code> <em class="parameter"><code>auto</code></em><code class="filename">/dev/hda5 /mnt/d</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">/mnt/d/dos\ utilities/doc514.exb linux_binary.5_1_4/dformat_5_1_4_37/</code></code> </p></div><p>Now format the drive, using the <span class="command"><strong>dtformat</strong></span> from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37/</code>:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37/</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">./dformat <code class="option">-WIN:D000 -S:doc514.exb</code></code> </p></div><p><em class="parameter"><code>D000</code></em> specifies the address of the DiskOnChip in the BIOS.</p><p>The following is the BIOS (RTD Enhanced Phoenix - AwardBIOS CMOS Setup Utility (v6.00.04.1601)) setting on our system.</p><p>The Integrated peripherals of the BIOS menu should have:</p><pre class="screen">
SSD Socket #1 to Bios Extension
Bios Ext. Window size 8k
Bios Ext. window [D000:0000]
Fail safe Boot ROM [Disabled]
</pre><p>The Bios Ext. Window denotes the address for your DiskOnChip.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">BIOSes</h3><p>The setting may be different depending upon your BIOS version.</p></div><p>Now shutdown the system and boot into Windows XP.</p><p>From now on you will notice the TrueFFS message and some time delay before the Grub Menu appears.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="format"></a>5.2. Step 2: Format DiskOnChip using Dos Utilities</h3></div></div></div><p>Boot into Windows XP. We will use the M-Systems Dos Utilities for formatting the DiskOnChip. The Dos utility <span class="command"><strong>dformat</strong></span> will copy the firmware to the DOC, and then format it as a <span class="emphasis"><em>fat16</em></span> device.</p><p>Using the command prompt, run the following command from the DOS utilities folder (assuming that you have already downloaded the DOS utilities):</p><div class="cmdsynopsis"><p><code class="command">dformat <code class="option">/WIN:D000 /S:doc514.exb</code></code> </p></div><p>Check the DOC partition using another utility called <span class="command"><strong>dinfo</strong></span>. A sample <span class="command"><strong>dinfo</strong></span> output is given in the appendix.</p><p>Again shutdown the system and now boot into Linux.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Always shutdown</h3><p>After formatting you should always do a full shutdown (power off) and not just a reboot.</p></div><p>Even though Step 1 and Step 2 seem to be the same, the only difference being that Step 1 is done from Linux and Step 2 from Windows XP, they both have to be done.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="patch-compile"></a>5.3. Step 3: Patch and Compile the kernel 2.4.18</h3></div></div></div><p>This has to be performed in exactly the same manner as described in <a class="xref" href="#step1" title="4.1. Step 1: Patch the Kernel">Section 4.1, &#8220;Step 1: Patch the Kernel&#8221;</a> and <a class="xref" href="#step2" title="4.2. Step 2: Compile the Kernel">Section 4.2, &#8220;Step 2: Compile the Kernel&#8221;</a>.</p><p>Also add an entry for the new kernel in <code class="filename">/boot/grub/menu.lst</code> as described in <a class="xref" href="#step4" title="4.4. Step 4: Reboot with the new kernel">Section 4.4, &#8220;Step 4: Reboot with the new kernel&#8221;</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="nodes"></a>5.4. Step 4: Create nodes</h3></div></div></div><p>This is done using the ame procedure as described in <a class="xref" href="#step3" title="4.3. Step 3: Create Nodes">Section 4.3, &#8220;Step 3: Create Nodes&#8221;</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="modconf"></a>5.5. Step 5: Modify the /etc/module.conf file</h3></div></div></div><p>The file <code class="filename">/etc/modules.conf</code> has to be modified, adding this line at the end of the file:</p><pre class="screen">
options doc major=62
</pre><p>This is required since our nodes use a major number of 62, while the doc driver module uses a major number of 100. When creating the <code class="filename">initrd</code> image, the driver will be loaded with major number value of 100 (instead of 62) if you do not edit the module configuration file.  This will make it impossible for the nodes to use the driver. The reason for using the initrd image will be explained in the next step.</p><p>The <span class="command"><strong>mkinitrd_doc</strong></span> script from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver</code> reads the <code class="filename">/etc/modules.conf</code> file and looks for anything that has been mentioned for the DOC driver regarding the major number. By default, <span class="command"><strong>mkinitrd_doc</strong></span> will create an <code class="filename">initrd</code> image that loads the DOC module with a major number of 100. However, with the modifications we have made to the <code class="filename">/etc/modules.conf</code> file, the <code class="filename">initrd</code> image will load the module with a major number of 62.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="initrd"></a>5.6. Step 6: Create the initrd image</h3></div></div></div><p>Run the <span class="command"><strong>mkinitrd_doc</strong></span> script from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver/</code>:</p><div class="cmdsynopsis"><p><code class="command">./mkinitrd_doc</code> </p></div><p>This may give warning messages similar to the following, which can be safely ignored:</p><pre class="screen">
  cp: cannot stat ./sbin/insmod.static.: No such file or directory
  cp: cannot stat ./dev/systty.: No such file or directory
</pre><p>Check for the newly created <code class="filename">initrd</code> image, <code class="filename">initrd-2.4.18.img</code>, in the <code class="filename">/boot</code> directory. </p><p>Running the <span class="command"><strong>mkinitrd_doc</strong></span> script produces this image. The reason for making an <code class="filename">initrd</code> image is that the provided M-Systems driver cannot be added as a built-in support in the kernel, which leaves no other option than adding it as a loadable module. If we want to boot from DOC, the kernel should know how to access the DOC at the time of booting to search for <span class="command"><strong>/sbin/init</strong></span> in the root filesystem on the DOC (the root filesystem is necessary to get the Linux system up).</p><p>In the booting sequence of the Linux, <span class="command"><strong>/sbin/init</strong></span> is the file (a command actually) that the kernel looks for in order to start various services and, finally, give the login shell to the user.  The figure below illustrates the problem:</p><div class="figure"><a name="idm479"></a><p class="title"><b>Figure 1. Why we need an initrd image</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/initrd.png" alt="Through the initrd image, the kernel kan read /sbin/init on the root system om the DOC."></div></div></div><br class="figure-break"></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="insert_driver"></a>5.7. Step 7: Insert the DOC driver into the new kernel</h3></div></div></div><p>Reboot the system and boot into the newly created kernel.</p><p>Now insert the doc module:</p><div class="cmdsynopsis"><p><code class="command">modprobe <em class="parameter"><code>doc</code></em></code> </p></div><p>This will give the following messages:</p><pre class="screen">
fl : Flash disk driver for DiskOnChip
fl: DOC devices(s) found: 1
fl: _init:registed device at major 62
.
.
.
.
</pre><p>To access the DOC, ensure that the major number assigned to the nodes is 62.</p><p>In case of a major number of 100 is assigned, check if the <code class="filename">/etc/modules.conf</code> was successfully modified. If it was not, then repeat <a class="xref" href="#modconf" title="5.5. Step 5: Modify the /etc/module.conf file">Section 5.5, &#8220;Step 5: Modify the /etc/module.conf file&#8221;</a>. You must then also repeat <a class="xref" href="#initrd" title="5.6. Step 6: Create the initrd image">Section 5.6, &#8220;Step 6: Create the initrd image&#8221;</a> because the <code class="filename">initrd</code> image depends on <code class="filename">/etc/modules.conf</code>.   If the DOC entry were incorrect in this file, the <code class="filename">initrd</code> image will be useless.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="createfs"></a>5.8. Step 8:  Create a filesystem on the DiskOnChip</h3></div></div></div><p>Perform <a class="xref" href="#step6" title="4.6. Step 6: Create a filesystem on the DiskOnChip">Section 4.6, &#8220;Step 6: Create a filesystem on the DiskOnChip&#8221;</a>.  This is required to create partitions on the DOC.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="rootfs"></a>5.9. Step 9:  Build Root Filesystem on the DiskOnChip</h3></div></div></div><p>Before starting with this step make sure that you have not mounted <code class="filename">/dev/msys/fla1</code> on any of the mount points, as this step will involve reformatting the DiskOnChip.</p><p>Also, in order to understand the details of Root File system refer to <a class="ulink" href="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html" target="_top">The Linux Bootdisk How To</a> available at <a class="ulink" href="http://www.tldp.org" target="_top">http://www.tldp.org</a>.</p><p>We will use the <span class="command"><strong>mkdocimg</strong></span> script located in <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/build</code>.</p><p>We will also use the <code class="filename">redhat-7.1.files</code> directory, located in the same directory (i.e. <code class="filename">build</code>), which contains the list of the files that will be copied in the root filesystem that will be created on the DOC.</p><div class="cmdsynopsis"><p><code class="command">./mkdocimg <code class="filename">redhat-7.1.files</code></code> </p></div><p>This step will take a few minutes to complete.</p><p>Now mount the <code class="filename">/dev/msys/fla1</code> partition on the mount point <code class="filename">/mnt/doc</code> and check the files that have been created:</p><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-t</code> <em class="parameter"><code>auto</code></em> <code class="filename">/dev/msys/fla1 /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/mnt/doc</code></code> </p></div><p>The following directories are created on the DOC as a result of running the script:</p><p><code class="filename">bin dev sbin etc lib usr home mnt tmp var boot</code></p><p>The most important is the boot directory. This contains the <code class="filename">vmlinuz-2.4.18</code> and <code class="filename">initrd-2.4.18.img</code> which gets copied from the <code class="filename">/boot</code> directory. This directory is required when booting from DiskOnChip.</p><p>Apart from these files there are some other files which must be deleted:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">System.map-2.4.18</code></p></li><li class="listitem"><p><code class="filename">boot.3E00</code></p></li></ul></div><p>These two files are created later by LILO.</p><p>The <code class="filename">redhat-7.1.files</code> directory contains a list of files and directories that will be created when we use the <span class="command"><strong>mkdocimg</strong></span> script.</p><p>This script does not create all the files that are necessary for creating the root filesystem on the DOC. So replace the directories created by the <span class="command"><strong>mkdocimg</strong></span> script, with the directories of the <code class="filename">/</code> filesystem (root filesystem that is currently running).</p><p>The directories under <code class="filename">/</code>, such as <code class="filename">etc</code>, <code class="filename">sbin</code>, <code class="filename">bin</code> and so on contain lot of files that are not useful and ideally should not be copied while building the root filesystem for DOC. But since we have not discussed the files that are essential and the files that can be removed, we therefore suggest that one should copy the entire contents of the directories. We know that it is a clumsy way of building the root filesystem and will unnecessarily take lot of memory; bear with us as in the next section we will explain how to put the development tools on the DOC.  We will then remove the useless files from the root filesystem of DOC.</p><p>If you are aware of how to build the root filesystem we would encourage you to copy only the essential files.</p><p>The following is the set of commands we used to modify the root filesystem:</p><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/sbin</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/etc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/lib</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/dev</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/sbin /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/etc /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/dev /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/lib /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/lib/modules</code></code> </p></div><p>Now our filesystem is ready.</p><p>The total size occupied by this filesystem will be about 35Mb.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="rdev"></a>5.10. Step 10: Use rdev to specify the DOC root filesystem location to kernel image</h3></div></div></div><p>This step is required to specify the location of the DOC root filesystem to the kernel we compiled in the step 3. The step can be avoided by giving the details of the root filesystem location in the Boot Loader configuration file, but we had some problems in making the kernel locate the root filesystem at the time of booting so we recommend executing this command:</p><div class="cmdsynopsis"><p><code class="command">rdev <code class="filename">/boot/vmlinuz-2.4.18 /dev/msys/fla1</code></code> </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="lilo"></a>5.11. Step 11: Compile lilo-22.3.2</h3></div></div></div><p>We are going to use LILO as the boot loader since this is the only BootLoader that can read an INFTL device without many changes to be done to the BootLoader source code.</p><p>For more information on how LILO and other boot loaders operate, refer to <a class="xref" href="#refs" title="7. References">Section 7, &#8220;References&#8221;</a>.</p><p>We need to compile the lilo-22-3.2 source code to get the executable file for LILO.</p><p>We will use the source code from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2</code>.</p><p>Before starting the build we need to do the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create a <span class="emphasis"><em>soft link</em></span> for the kernel-2.4.18 source code with the name <code class="filename">linux</code>.</p><p>When you untar the file <code class="filename">linux-2.4.18.tar.gz</code> it will create a directory <code class="filename">linux</code>. So we need to rename the directory <code class="filename">linux</code> to <code class="filename">linux-2.4.18</code> before creating a soft link with the same name:</p><div class="cmdsynopsis"><p><code class="command">mv <code class="filename">linux linux-2.4.18</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename">linux-2.4.18 linux</code></code> </p></div><p>If the above steps are not done the build might fail.</p></li><li class="listitem"><p>Patch file: <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/common.h</code>:</p><p>The lilo-22.3.2 source code that comes with the M-Systems <code class="filename">linux_binary.5_1_4.tgz</code> is buggy as one of the variables <code class="varname">PAGE_SIZE</code> is not defined. We need to patch the LILO source code as follows:</p><p>Add the following lines in the <code class="filename">common.h</code> after the line <span class="quote">&#8220;<span class="quote">#include .lilo.h.</span>&#8221;</span>:</p><pre class="screen">
+ #ifndef PAGE_SIZE
+ #define PAGE_SIZE 4096U
+ #endif
#define 0_NACCESS 3
</pre><p>Where <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> indicates the lines to be added.</p></li><li class="listitem"><p>Make sure that the <span class="command"><strong>gcc</strong></span> version is 2.95.3 by using <span class="command"><strong>gcc <code class="option">--version</code></strong></span>.</p></li></ol></div><p>Now we can start the build process. Run</p><div class="cmdsynopsis"><p><code class="command">make <em class="parameter"><code>clean</code></em> &amp;&amp; make</code> </p></div><p>This will create a new LILO executable, <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo</code>.  Copy this LILO executable into <code class="filename">/sbin/lilo</code> and <code class="filename">/mnt/doc/sbin/lilo</code>:</p><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /sbin/lilo</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /mnt/doc/sbin/lilo</code></code> </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="boot.b"></a>5.12. Step 12: Copy the boot.b file into boot directory of DOC</h3></div></div></div><p>We need to copy the file <code class="filename">boot.b</code> from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/</code> to <code class="filename">/mnt/doc/boot</code>.</p><p>The file contains the essential <span class="emphasis"><em>stage1</em></span> and <span class="emphasis"><em>stage2</em></span> of the LILO boot loader.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="liloconf"></a>5.13. Step 13:  Modify the /etc/lilo.conf file</h3></div></div></div><p>First, remove the existing <code class="filename">/etc/lilo.conf</code>:</p><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/etc/lilo.conf</code></code> </p></div><p>Now create a new <code class="filename">/etc/lilo.conf</code>, using a text editor, and add the following lines to it:</p><pre class="screen">
boot=/dev/msys/fla
compact
install=/boot/boot.b
map=/boot/System.map
disk=/dev/msys/fla
bios=0x80
prompt
delay=50
timeout=50
image=/boot/vmlinuz
label=linux
root=/dev/msys/fla1
initrd=/boot/initrd.img
read-only
</pre><p>According to the above lines added to <code class="filename">/etc/lilo.conf</code>, one needs to create soft links for <code class="filename">vmlinuz-2.4.18</code> and <code class="filename">initrd-2.4.18.img</code> in <code class="filename">/mnt/doc/boot</code>:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/mnt/doc/boot</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename">vmlinuz-2.4.18 vmlinuz</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename"> initrd-2.4.18.img initrd.img</code></code> </p></div><p>Copy the newly created <code class="filename">/etc/lilo.conf</code> to <code class="filename">mnt/doc/etc/lilo.conf</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="bootable"></a>5.14. Step 14: Store the new LILO configuration on the DiskOnChip</h3></div></div></div><p>This step will configure LILO in the MBR of the DiskOnChip and hence make the DiskOnChip bootable.</p><p>Ensure that <code class="filename">/dev/msys/fla1</code> (root filesystem partition for the DOC) is mounted on the mount point <code class="filename">/mnt/doc</code>.</p><p>Execute the following command to store the LILO configuration on the DOC:</p><div class="cmdsynopsis"><p><code class="command">lilo<code class="option">-v -C</code> <code class="filename">/etc/lilo.conf</code> <code class="option">-r</code> <code class="filename">/mnt/doc</code></code> </p></div><p><code class="filename">/mnt/doc</code> denotes the location where the BootLoader will be installed, so it is installed on the DiskOnChip, as <code class="filename">/mnt/doc</code> is the mount point for the primary partition of DOC where LILO was configured.</p><p>It will create the following two files in the boot directory of DOC (i.e. <code class="filename">/mnt/doc/boot</code>):</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">System.map-2.4.18</code></p></li><li class="listitem"><p><code class="filename">boot.3E00</code></p></li></ol></div><p>Now you should make a backup of the entire DiskOnChip to allow for easy restore of the files damaged by possible fatal errors:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/home</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-cvzf</code> <code class="filename">docimg.tgz /mnt/doc</code></code> </p></div><p>This will create a compressed copy of all the contents of DiskOnChip with the name <code class="filename">docimg.tgz</code> in <code class="filename">/home</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fstab"></a>5.15. Step 15: Modify etc/fstab of DiskOnChip root file system</h3></div></div></div><p>Open the <code class="filename">/mnt/doc/etc/fstab</code> file and edit the line where the mount point is <code class="filename">/</code>.  Change that line to:</p><pre class="screen">
/dev/msys/fla1  /  ext2  rw.noauto 0 1
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="firmware"></a>5.16. Step16:  Update Firmware</h3></div></div></div><p>This step is required to update the firmware of the DiskOnChip. We will use the <span class="command"><strong>dformat</strong></span> utility from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37</code>:</p><div class="cmdsynopsis"><p><code class="command">./dformat <code class="option">-W:D000 -S:doc514.exb -Y -NOFORMAT</code></code> </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Don't format!</h3><p>The <code class="option">NOFORMAT</code> flag is important otherwise it will reformat the DiskOnChip device, and the contents will be lost.</p></div><p>The above command will cause the DiskOnChip to boot in the absence of any other bootable device. So we need to remove the Hard Disk in order to allow the DOC to boot.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="boot"></a>5.17. Step17: BOOT from DiskOnChip</h3></div></div></div><p>Check your BIOS manual for enabling booting from a BIOS extension device i.e. DiskOnChip. On our system we had to disable the Hard Disk and CDROM and set the first bootable device as HDD-0.</p><p>Reboot the system after making the necessary changes in the BIOS.</p><p>You will get the LILO menu and on pressing enter Linux gets booted from DiskOnChip.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="devtools"></a>6. Install Development ToolChain on DiskOnChip</h2></div></div></div><p>This section may be left out if the requirement is not to have a development environment on the DiskOnChip. The following steps will install the necessary libraries and tools that are required for developing and executing programs on DiskOnChip.  This will completely eliminate the concept of having a host system and target system since now the complete application development can be done on the target system itself. For this purpose we will use uClibc which is a C library that has been developed primarily for embedded systems. Also since our root filesystem that was created in the previous section is bulky (35 MB) we will remove the unnecessary files and make it smaller, approximately 11MB.</p><p>We will use the Buildroot package from www.uclibc.org to replace the existing bulky root filesystem of DOC with a tiny filesystem and to install the necessary development ToolChain which includes uClibc library, gcc, g++, make, ncurses, busybox, GNU tar, GNU grep and the GNU coreutils . For more details on Buildroot refer to <a class="ulink" href="http://buildroot.uclinux.org/buildroot.html" target="_top">http://buildroot.uclinux.org/buildroot.html</a>. The <a class="ulink" href="http://www.uclibc.org" target="_top">http://www.uclibc.org</a> website provides a precompiled package containing all the tools, which can be downloaded and used. We will use the precompiled package, which is available as <code class="filename">root_fs</code> image. Refer to the <a class="ulink" href="http://www.uclibc.org/FAQ.html" target="_top">uClibc FAQ</a> for more details.</p><p>Follow these steps in order to get the software working on your DOS:</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="getimage"></a>6.1. Step1: Obtain the latest copy of root_fs_i386.ext2</h3></div></div></div><p>Download <code class="filename">root_fs_i386.ext2.tar.gz</code> from <a class="ulink" href="www.uclibc.org/downloads/root_fs_i386.ext2.tar.gz" target="_top">www.uclibc.org/downloads/root_fs_i386.ext2.tar.gz</a>.</p><p>It is around 22MB in size. This actually gets decompressed to a 100MB size file.</p><p>Untar the file in <code class="filename">/usr/src</code>:</p><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-xvzf</code> <code class="filename">root_fs_i386.ext2.tar.gz</code></code> </p></div><p>This will create a file <code class="filename">root_fs_i386.ext2</code>.</p><p>We need to mount this file using a loopback device. Do the following steps:</p><div class="cmdsynopsis"><p><code class="command">mkdir <code class="filename">root_fs</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-o</code> <em class="parameter"><code>loop</code></em> <code class="filename">root_fs_i386.ext2 root_fs</code></code> </p></div><p>Now you can access the content of the file <code class="filename">root_fs_i386.ext2</code> through the <code class="filename">root_fs</code> directory. <code class="filename">The root_fs</code> directory contains a number of directories which makes the root filesystem, like <code class="filename">bin</code>, <code class="filename">var</code>, <code class="filename">sbin</code>, <code class="filename">opt</code>, <code class="filename">root</code>, <code class="filename">home</code>, <code class="filename">etc</code>, <code class="filename">usr</code>, <code class="filename">lib</code>, <code class="filename">tmp</code>, <code class="filename">dev</code>, and <code class="filename">proc</code>.</p><p>The <code class="filename">usr</code> and <code class="filename">lib</code> directories contain the development tools like <span class="command"><strong>gcc</strong></span> and <span class="command"><strong>g++</strong></span>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fs_swap"></a>6.2. Step2: Replace the root filesystem of the DiskOnChip</h3></div></div></div><p>Replace the <code class="filename">bin</code>, <code class="filename">var</code>, <code class="filename">sbin</code>, <code class="filename">etc</code>, <code class="filename">lib</code>, <code class="filename">usr</code>, <code class="filename">proc</code>, <code class="filename">mnt</code>, <code class="filename">home</code> and <code class="filename">opt</code> directories of the DiskOnChip with the ones of the <code class="filename">root_fs</code> image.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Do not replace boot and dev!</h3><p>The <code class="filename">boot</code> directory of the DiskOnChip has to be kept intact since it contains the kernel image, <code class="filename">initrd</code> image and Map file that is used by LILO to load the kernel into memory.</p><p>The <code class="filename">dev</code> directory should also not be replaced since it contains the device nodes for DOC (The replacement task will take 5-10 minutes.)</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="DOS_fstab"></a>6.3. Step3: Modify etc/fstab of DiskOnChip root file system</h3></div></div></div><p>Open the newly replaced <code class="filename">/mnt/doc/etc/fstab</code> and edit the line where the mount point is <code class="filename">/</code>.  Change that line to:</p><pre class="screen">
/dev/msys/fla1  /  ext2  rw.noauto 0 1
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="reboot"></a>6.4. Step4: Reboot</h3></div></div></div><p>Reboot from DiskOnChip and enjoy the uClibc development environment.</p><p>You will get the message</p><pre class="screen">
Welcome to the Erik.s uClibc development environment.
</pre><p>The entire root filesystem + boot directory + development tools take 84Mb of space.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="refs"></a>7. References</h2></div></div></div><p>Apart from the web sites referenced, here are some books and documents we found to be useful:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Application Note: Using DiskOnChip Under Linux With M-Systems Driver,RTD Embedded Technologies Inc.,SWM-640000016A</p></li><li class="listitem"><p>Installation Manual for DiskOnChip TrueFFS driver for Linux ,M-Systems</p></li><li class="listitem"><p>Building Embedded Linux Systems, Karim Yaghmour.O.reilly,First Edition, April 2003</p></li><li class="listitem"><p>Installation Manual IM-DOC-021,Using the DiskOnChip with Linux OS,Ron Dick, Esther Spanjer, Vadim Khmelnitsky, M-Systems</p></li><li class="listitem"><p>Installation Guide available with M-Systems TrueFFS Linux driver version 5.1.4</p></li><li class="listitem"><p>Understanding the Linux Kernel, Daniel P. Bovet &amp; Marco Cesati, O.reilly, Second Edition, March 2002.</p></li><li class="listitem"><p>Booting Linux: The History and the Future, Werner Almesberger, June 25,2000</p></li></ul></div></div><div class="appendix"><h2 class="title" style="clear: both"><a name="idm871"></a>A. Output of dinfo</h2><p>The following are the details of the internals of a Linux Bootable DiskOnChip 2000 TSOP 256MB (MD2202-D256) produced by the <span class="command"><strong>dinfo</strong></span> utility:</p><div class="figure"><a name="idm875"></a><p class="title"><b>Figure A.1. Output of dinfo</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/dinfo.png" alt="Gneeral info about the DOS device."></div></div></div><br class="figure-break"><p>According to the screenshot our DOC uses an INFTL translation layer.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="idm885"></a>B. License</h2><p>This document is copyrighted (c) 2006 by Rohit Agarwal &amp; Vishnu Swaminathan.</p><p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is available at <a class="ulink" href="http://www.gnu.org/copyleft/fdl.html" target="_top">http://www.gnu.org/copyleft/fdl.html</a>.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="idm890"></a>C. About Authors</h2><p>Rohit Agarwal has obtained his Masters in Information Technology from IIIT-Bangalore,India and Bachelors degree in Computer Science from I.E.T. Lucknow,India.He has co-authored another HowTo "Libdc1394 Library support for IEEE1394 camera HowTo" published by TLDP in January,2006. Visit his <a class="ulink" href="htpp://geocities.com/vickys_box/rohit_agarwal.htm" target="_top">homepage</a> for more details.</p><p>Visnu Swaminathan is a PhD and MS from Duke University,North Carolina,USA. He is currently working in Siemens Corporate Technology,India</p><p>authors can be contacted at </p><p> rohdimp_24@rediffmail.com (rohit) </p><p> vishnu.swaminathan@siemens.com (vishnu) </p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="idm898"></a>D. Dedications</h2><p>I am grateful to all my friends for extending their support to carry out this work. I will specially thank Vikram and Chinmaya for their valuable advices.</p><p>Finally I will like to dedicate this document to Mr. S.Nagarajan my professor who inspired me to contribute to Open Source Community</p><p> Rohit Agarwal</p></div></div></body></html>
