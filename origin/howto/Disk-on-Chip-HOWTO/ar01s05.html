<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>5. Install Linux and LILO on DiskOnChip</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Booting Linux from DiskOnChip HOWTO"><link rel="up" href="index.html" title="Booting Linux from DiskOnChip HOWTO"><link rel="prev" href="ar01s04.html" title="4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux"><link rel="next" href="ar01s06.html" title="6. Install Development ToolChain on DiskOnChip"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Install Linux and LILO on DiskOnChip</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s06.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="install"></a>5. Install Linux and LILO on DiskOnChip</h2></div></div></div><p>In this section we will learn how to install Linux operating system on an unformatted DOC and boot from it using LILO as the boot loader.</p><p>In order to get to this state, a procedure will be discussed.  Some steps in this procedure resemble the steps discussed previously in this document.  Even so, this should be considered a separate procedure, rather than a continuation of the steps in <a class="xref" href="ar01s04.html" title="4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux">Section 4, &#8220;Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux&#8221;</a>.</p><p>In general, to make a device to boot into Linux, it should have the following components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Kernel Image</p></li><li class="listitem"><p>Root Filesystem</p></li><li class="listitem"><p>Boot loader to load the kernel Image into memory</p></li></ul></div><p>This section will basically try to fulfill the above three requirements.</p><p>The following steps should be followed for achieving the goal of this section.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="copy_firmware"></a>5.1. Step 1: Copying the DOC firmware onto DiskOnChip</h3></div></div></div><p>We will use the <span class="command"><strong>dformat</strong></span> utility from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37</code>.</p><p>M-Systems does not provide the firmware for using the DOC on Linux platforms. We address this problem by making a copy of the firmware shipped with the M-Systems dos utilities into this directory (<span class="quote">&#8220;<span class="quote">dos utilities</span>&#8221;</span> is the term used by the M-Systems people so we have also used this name).  On our system we copied it by mounting the windows partition and extracting it from there:</p><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-t</code> <em class="parameter"><code>auto</code></em><code class="filename">/dev/hda5 /mnt/d</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">/mnt/d/dos\ utilities/doc514.exb linux_binary.5_1_4/dformat_5_1_4_37/</code></code> </p></div><p>Now format the drive, using the <span class="command"><strong>dtformat</strong></span> from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37/</code>:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37/</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">./dformat <code class="option">-WIN:D000 -S:doc514.exb</code></code> </p></div><p><em class="parameter"><code>D000</code></em> specifies the address of the DiskOnChip in the BIOS.</p><p>The following is the BIOS (RTD Enhanced Phoenix - AwardBIOS CMOS Setup Utility (v6.00.04.1601)) setting on our system.</p><p>The Integrated peripherals of the BIOS menu should have:</p><pre class="screen">
SSD Socket #1 to Bios Extension
Bios Ext. Window size 8k
Bios Ext. window [D000:0000]
Fail safe Boot ROM [Disabled]
</pre><p>The Bios Ext. Window denotes the address for your DiskOnChip.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">BIOSes</h3><p>The setting may be different depending upon your BIOS version.</p></div><p>Now shutdown the system and boot into Windows XP.</p><p>From now on you will notice the TrueFFS message and some time delay before the Grub Menu appears.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="format"></a>5.2. Step 2: Format DiskOnChip using Dos Utilities</h3></div></div></div><p>Boot into Windows XP. We will use the M-Systems Dos Utilities for formatting the DiskOnChip. The Dos utility <span class="command"><strong>dformat</strong></span> will copy the firmware to the DOC, and then format it as a <span class="emphasis"><em>fat16</em></span> device.</p><p>Using the command prompt, run the following command from the DOS utilities folder (assuming that you have already downloaded the DOS utilities):</p><div class="cmdsynopsis"><p><code class="command">dformat <code class="option">/WIN:D000 /S:doc514.exb</code></code> </p></div><p>Check the DOC partition using another utility called <span class="command"><strong>dinfo</strong></span>. A sample <span class="command"><strong>dinfo</strong></span> output is given in the appendix.</p><p>Again shutdown the system and now boot into Linux.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Always shutdown</h3><p>After formatting you should always do a full shutdown (power off) and not just a reboot.</p></div><p>Even though Step 1 and Step 2 seem to be the same, the only difference being that Step 1 is done from Linux and Step 2 from Windows XP, they both have to be done.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="patch-compile"></a>5.3. Step 3: Patch and Compile the kernel 2.4.18</h3></div></div></div><p>This has to be performed in exactly the same manner as described in <a class="xref" href="ar01s04.html#step1" title="4.1. Step 1: Patch the Kernel">Section 4.1, &#8220;Step 1: Patch the Kernel&#8221;</a> and <a class="xref" href="ar01s04.html#step2" title="4.2. Step 2: Compile the Kernel">Section 4.2, &#8220;Step 2: Compile the Kernel&#8221;</a>.</p><p>Also add an entry for the new kernel in <code class="filename">/boot/grub/menu.lst</code> as described in <a class="xref" href="ar01s04.html#step4" title="4.4. Step 4: Reboot with the new kernel">Section 4.4, &#8220;Step 4: Reboot with the new kernel&#8221;</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="nodes"></a>5.4. Step 4: Create nodes</h3></div></div></div><p>This is done using the ame procedure as described in <a class="xref" href="ar01s04.html#step3" title="4.3. Step 3: Create Nodes">Section 4.3, &#8220;Step 3: Create Nodes&#8221;</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="modconf"></a>5.5. Step 5: Modify the /etc/module.conf file</h3></div></div></div><p>The file <code class="filename">/etc/modules.conf</code> has to be modified, adding this line at the end of the file:</p><pre class="screen">
options doc major=62
</pre><p>This is required since our nodes use a major number of 62, while the doc driver module uses a major number of 100. When creating the <code class="filename">initrd</code> image, the driver will be loaded with major number value of 100 (instead of 62) if you do not edit the module configuration file.  This will make it impossible for the nodes to use the driver. The reason for using the initrd image will be explained in the next step.</p><p>The <span class="command"><strong>mkinitrd_doc</strong></span> script from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver</code> reads the <code class="filename">/etc/modules.conf</code> file and looks for anything that has been mentioned for the DOC driver regarding the major number. By default, <span class="command"><strong>mkinitrd_doc</strong></span> will create an <code class="filename">initrd</code> image that loads the DOC module with a major number of 100. However, with the modifications we have made to the <code class="filename">/etc/modules.conf</code> file, the <code class="filename">initrd</code> image will load the module with a major number of 62.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="initrd"></a>5.6. Step 6: Create the initrd image</h3></div></div></div><p>Run the <span class="command"><strong>mkinitrd_doc</strong></span> script from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/driver/</code>:</p><div class="cmdsynopsis"><p><code class="command">./mkinitrd_doc</code> </p></div><p>This may give warning messages similar to the following, which can be safely ignored:</p><pre class="screen">
  cp: cannot stat ./sbin/insmod.static.: No such file or directory
  cp: cannot stat ./dev/systty.: No such file or directory
</pre><p>Check for the newly created <code class="filename">initrd</code> image, <code class="filename">initrd-2.4.18.img</code>, in the <code class="filename">/boot</code> directory. </p><p>Running the <span class="command"><strong>mkinitrd_doc</strong></span> script produces this image. The reason for making an <code class="filename">initrd</code> image is that the provided M-Systems driver cannot be added as a built-in support in the kernel, which leaves no other option than adding it as a loadable module. If we want to boot from DOC, the kernel should know how to access the DOC at the time of booting to search for <span class="command"><strong>/sbin/init</strong></span> in the root filesystem on the DOC (the root filesystem is necessary to get the Linux system up).</p><p>In the booting sequence of the Linux, <span class="command"><strong>/sbin/init</strong></span> is the file (a command actually) that the kernel looks for in order to start various services and, finally, give the login shell to the user.  The figure below illustrates the problem:</p><div class="figure"><a name="idm479"></a><p class="title"><b>Figure 1. Why we need an initrd image</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/initrd.png" alt="Through the initrd image, the kernel kan read /sbin/init on the root system om the DOC."></div></div></div><br class="figure-break"></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="insert_driver"></a>5.7. Step 7: Insert the DOC driver into the new kernel</h3></div></div></div><p>Reboot the system and boot into the newly created kernel.</p><p>Now insert the doc module:</p><div class="cmdsynopsis"><p><code class="command">modprobe <em class="parameter"><code>doc</code></em></code> </p></div><p>This will give the following messages:</p><pre class="screen">
fl : Flash disk driver for DiskOnChip
fl: DOC devices(s) found: 1
fl: _init:registed device at major 62
.
.
.
.
</pre><p>To access the DOC, ensure that the major number assigned to the nodes is 62.</p><p>In case of a major number of 100 is assigned, check if the <code class="filename">/etc/modules.conf</code> was successfully modified. If it was not, then repeat <a class="xref" href="ar01s05.html#modconf" title="5.5. Step 5: Modify the /etc/module.conf file">Section 5.5, &#8220;Step 5: Modify the /etc/module.conf file&#8221;</a>. You must then also repeat <a class="xref" href="ar01s05.html#initrd" title="5.6. Step 6: Create the initrd image">Section 5.6, &#8220;Step 6: Create the initrd image&#8221;</a> because the <code class="filename">initrd</code> image depends on <code class="filename">/etc/modules.conf</code>.   If the DOC entry were incorrect in this file, the <code class="filename">initrd</code> image will be useless.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="createfs"></a>5.8. Step 8:  Create a filesystem on the DiskOnChip</h3></div></div></div><p>Perform <a class="xref" href="ar01s04.html#step6" title="4.6. Step 6: Create a filesystem on the DiskOnChip">Section 4.6, &#8220;Step 6: Create a filesystem on the DiskOnChip&#8221;</a>.  This is required to create partitions on the DOC.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="rootfs"></a>5.9. Step 9:  Build Root Filesystem on the DiskOnChip</h3></div></div></div><p>Before starting with this step make sure that you have not mounted <code class="filename">/dev/msys/fla1</code> on any of the mount points, as this step will involve reformatting the DiskOnChip.</p><p>Also, in order to understand the details of Root File system refer to <a class="ulink" href="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html" target="_top">The Linux Bootdisk How To</a> available at <a class="ulink" href="http://www.tldp.org" target="_top">http://www.tldp.org</a>.</p><p>We will use the <span class="command"><strong>mkdocimg</strong></span> script located in <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/build</code>.</p><p>We will also use the <code class="filename">redhat-7.1.files</code> directory, located in the same directory (i.e. <code class="filename">build</code>), which contains the list of the files that will be copied in the root filesystem that will be created on the DOC.</p><div class="cmdsynopsis"><p><code class="command">./mkdocimg <code class="filename">redhat-7.1.files</code></code> </p></div><p>This step will take a few minutes to complete.</p><p>Now mount the <code class="filename">/dev/msys/fla1</code> partition on the mount point <code class="filename">/mnt/doc</code> and check the files that have been created:</p><div class="cmdsynopsis"><p><code class="command">mount <code class="option">-t</code> <em class="parameter"><code>auto</code></em> <code class="filename">/dev/msys/fla1 /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/mnt/doc</code></code> </p></div><p>The following directories are created on the DOC as a result of running the script:</p><p><code class="filename">bin dev sbin etc lib usr home mnt tmp var boot</code></p><p>The most important is the boot directory. This contains the <code class="filename">vmlinuz-2.4.18</code> and <code class="filename">initrd-2.4.18.img</code> which gets copied from the <code class="filename">/boot</code> directory. This directory is required when booting from DiskOnChip.</p><p>Apart from these files there are some other files which must be deleted:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">System.map-2.4.18</code></p></li><li class="listitem"><p><code class="filename">boot.3E00</code></p></li></ul></div><p>These two files are created later by LILO.</p><p>The <code class="filename">redhat-7.1.files</code> directory contains a list of files and directories that will be created when we use the <span class="command"><strong>mkdocimg</strong></span> script.</p><p>This script does not create all the files that are necessary for creating the root filesystem on the DOC. So replace the directories created by the <span class="command"><strong>mkdocimg</strong></span> script, with the directories of the <code class="filename">/</code> filesystem (root filesystem that is currently running).</p><p>The directories under <code class="filename">/</code>, such as <code class="filename">etc</code>, <code class="filename">sbin</code>, <code class="filename">bin</code> and so on contain lot of files that are not useful and ideally should not be copied while building the root filesystem for DOC. But since we have not discussed the files that are essential and the files that can be removed, we therefore suggest that one should copy the entire contents of the directories. We know that it is a clumsy way of building the root filesystem and will unnecessarily take lot of memory; bear with us as in the next section we will explain how to put the development tools on the DOC.  We will then remove the useless files from the root filesystem of DOC.</p><p>If you are aware of how to build the root filesystem we would encourage you to copy only the essential files.</p><p>The following is the set of commands we used to modify the root filesystem:</p><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/sbin</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/etc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/lib</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/dev</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/sbin /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/etc /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/dev /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="option">-rf</code> <code class="filename">/lib /mnt/doc</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/mnt/doc/lib/modules</code></code> </p></div><p>Now our filesystem is ready.</p><p>The total size occupied by this filesystem will be about 35Mb.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="rdev"></a>5.10. Step 10: Use rdev to specify the DOC root filesystem location to kernel image</h3></div></div></div><p>This step is required to specify the location of the DOC root filesystem to the kernel we compiled in the step 3. The step can be avoided by giving the details of the root filesystem location in the Boot Loader configuration file, but we had some problems in making the kernel locate the root filesystem at the time of booting so we recommend executing this command:</p><div class="cmdsynopsis"><p><code class="command">rdev <code class="filename">/boot/vmlinuz-2.4.18 /dev/msys/fla1</code></code> </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="lilo"></a>5.11. Step 11: Compile lilo-22.3.2</h3></div></div></div><p>We are going to use LILO as the boot loader since this is the only BootLoader that can read an INFTL device without many changes to be done to the BootLoader source code.</p><p>For more information on how LILO and other boot loaders operate, refer to <a class="xref" href="ar01s07.html" title="7. References">Section 7, &#8220;References&#8221;</a>.</p><p>We need to compile the lilo-22-3.2 source code to get the executable file for LILO.</p><p>We will use the source code from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2</code>.</p><p>Before starting the build we need to do the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create a <span class="emphasis"><em>soft link</em></span> for the kernel-2.4.18 source code with the name <code class="filename">linux</code>.</p><p>When you untar the file <code class="filename">linux-2.4.18.tar.gz</code> it will create a directory <code class="filename">linux</code>. So we need to rename the directory <code class="filename">linux</code> to <code class="filename">linux-2.4.18</code> before creating a soft link with the same name:</p><div class="cmdsynopsis"><p><code class="command">mv <code class="filename">linux linux-2.4.18</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename">linux-2.4.18 linux</code></code> </p></div><p>If the above steps are not done the build might fail.</p></li><li class="listitem"><p>Patch file: <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/common.h</code>:</p><p>The lilo-22.3.2 source code that comes with the M-Systems <code class="filename">linux_binary.5_1_4.tgz</code> is buggy as one of the variables <code class="varname">PAGE_SIZE</code> is not defined. We need to patch the LILO source code as follows:</p><p>Add the following lines in the <code class="filename">common.h</code> after the line <span class="quote">&#8220;<span class="quote">#include .lilo.h.</span>&#8221;</span>:</p><pre class="screen">
+ #ifndef PAGE_SIZE
+ #define PAGE_SIZE 4096U
+ #endif
#define 0_NACCESS 3
</pre><p>Where <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> indicates the lines to be added.</p></li><li class="listitem"><p>Make sure that the <span class="command"><strong>gcc</strong></span> version is 2.95.3 by using <span class="command"><strong>gcc <code class="option">--version</code></strong></span>.</p></li></ol></div><p>Now we can start the build process. Run</p><div class="cmdsynopsis"><p><code class="command">make <em class="parameter"><code>clean</code></em> &amp;&amp; make</code> </p></div><p>This will create a new LILO executable, <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo</code>.  Copy this LILO executable into <code class="filename">/sbin/lilo</code> and <code class="filename">/mnt/doc/sbin/lilo</code>:</p><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /sbin/lilo</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">cp <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /mnt/doc/sbin/lilo</code></code> </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="boot.b"></a>5.12. Step 12: Copy the boot.b file into boot directory of DOC</h3></div></div></div><p>We need to copy the file <code class="filename">boot.b</code> from <code class="filename">linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/</code> to <code class="filename">/mnt/doc/boot</code>.</p><p>The file contains the essential <span class="emphasis"><em>stage1</em></span> and <span class="emphasis"><em>stage2</em></span> of the LILO boot loader.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="liloconf"></a>5.13. Step 13:  Modify the /etc/lilo.conf file</h3></div></div></div><p>First, remove the existing <code class="filename">/etc/lilo.conf</code>:</p><div class="cmdsynopsis"><p><code class="command">rm <code class="option">-rf</code> <code class="filename">/etc/lilo.conf</code></code> </p></div><p>Now create a new <code class="filename">/etc/lilo.conf</code>, using a text editor, and add the following lines to it:</p><pre class="screen">
boot=/dev/msys/fla
compact
install=/boot/boot.b
map=/boot/System.map
disk=/dev/msys/fla
bios=0x80
prompt
delay=50
timeout=50
image=/boot/vmlinuz
label=linux
root=/dev/msys/fla1
initrd=/boot/initrd.img
read-only
</pre><p>According to the above lines added to <code class="filename">/etc/lilo.conf</code>, one needs to create soft links for <code class="filename">vmlinuz-2.4.18</code> and <code class="filename">initrd-2.4.18.img</code> in <code class="filename">/mnt/doc/boot</code>:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/mnt/doc/boot</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename">vmlinuz-2.4.18 vmlinuz</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">ln <code class="option">-s</code> <code class="filename"> initrd-2.4.18.img initrd.img</code></code> </p></div><p>Copy the newly created <code class="filename">/etc/lilo.conf</code> to <code class="filename">mnt/doc/etc/lilo.conf</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="bootable"></a>5.14. Step 14: Store the new LILO configuration on the DiskOnChip</h3></div></div></div><p>This step will configure LILO in the MBR of the DiskOnChip and hence make the DiskOnChip bootable.</p><p>Ensure that <code class="filename">/dev/msys/fla1</code> (root filesystem partition for the DOC) is mounted on the mount point <code class="filename">/mnt/doc</code>.</p><p>Execute the following command to store the LILO configuration on the DOC:</p><div class="cmdsynopsis"><p><code class="command">lilo<code class="option">-v -C</code> <code class="filename">/etc/lilo.conf</code> <code class="option">-r</code> <code class="filename">/mnt/doc</code></code> </p></div><p><code class="filename">/mnt/doc</code> denotes the location where the BootLoader will be installed, so it is installed on the DiskOnChip, as <code class="filename">/mnt/doc</code> is the mount point for the primary partition of DOC where LILO was configured.</p><p>It will create the following two files in the boot directory of DOC (i.e. <code class="filename">/mnt/doc/boot</code>):</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">System.map-2.4.18</code></p></li><li class="listitem"><p><code class="filename">boot.3E00</code></p></li></ol></div><p>Now you should make a backup of the entire DiskOnChip to allow for easy restore of the files damaged by possible fatal errors:</p><div class="cmdsynopsis"><p><code class="command">cd <code class="filename">/home</code></code> </p></div><div class="cmdsynopsis"><p><code class="command">tar <code class="option">-cvzf</code> <code class="filename">docimg.tgz /mnt/doc</code></code> </p></div><p>This will create a compressed copy of all the contents of DiskOnChip with the name <code class="filename">docimg.tgz</code> in <code class="filename">/home</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fstab"></a>5.15. Step 15: Modify etc/fstab of DiskOnChip root file system</h3></div></div></div><p>Open the <code class="filename">/mnt/doc/etc/fstab</code> file and edit the line where the mount point is <code class="filename">/</code>.  Change that line to:</p><pre class="screen">
/dev/msys/fla1  /  ext2  rw.noauto 0 1
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="firmware"></a>5.16. Step16:  Update Firmware</h3></div></div></div><p>This step is required to update the firmware of the DiskOnChip. We will use the <span class="command"><strong>dformat</strong></span> utility from <code class="filename">linux_binary.5_1_4/dformat_5_1_4_37</code>:</p><div class="cmdsynopsis"><p><code class="command">./dformat <code class="option">-W:D000 -S:doc514.exb -Y -NOFORMAT</code></code> </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Don't format!</h3><p>The <code class="option">NOFORMAT</code> flag is important otherwise it will reformat the DiskOnChip device, and the contents will be lost.</p></div><p>The above command will cause the DiskOnChip to boot in the absence of any other bootable device. So we need to remove the Hard Disk in order to allow the DOC to boot.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="boot"></a>5.17. Step17: BOOT from DiskOnChip</h3></div></div></div><p>Check your BIOS manual for enabling booting from a BIOS extension device i.e. DiskOnChip. On our system we had to disable the Hard Disk and CDROM and set the first bootable device as HDD-0.</p><p>Reboot the system after making the necessary changes in the BIOS.</p><p>You will get the LILO menu and on pressing enter Linux gets booted from DiskOnChip.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. Install Development ToolChain on DiskOnChip</td></tr></table></div></body></html>
