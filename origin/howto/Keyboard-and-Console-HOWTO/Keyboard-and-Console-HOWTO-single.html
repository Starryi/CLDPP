<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>The Linux keyboard and console HOWTO</TITLE>
</HEAD>
<BODY>
<H1>The Linux keyboard and console HOWTO</H1>

<H2>Andries Brouwer, <CODE>aeb@cwi.nl</CODE></H2>v2.13, 2002-10-12
<HR>
<EM>This note contains some information about the Linux keyboard
and console, and the use of non-ASCII characters.
It describes Linux 2.0.
<!--
HOWTOs!keyboard and console
-->

<!--
HOWTOs!console and keyboard
-->
</EM>
<HR>
<H2><A NAME="s1">1. Useful programs</A></H2>

<P>
<!--
programs!keyboard-related
-->

<!--
programs!console-related
-->

<!--
keyboard!programs related to
-->

<!--
console!programs related to
-->
</P>
<P>The following packages contain keyboard or console related programs.</P>
<P><CODE>kbd-1.06.tar.gz</CODE> contains <CODE>loadkeys</CODE>, <CODE>dumpkeys</CODE>, <CODE>showkey</CODE>,
<CODE>setmetamode</CODE>, <CODE>setleds</CODE>, <CODE>setfont</CODE>, <CODE>showconsolefont</CODE>,
<CODE>mapscrn</CODE>, <CODE>kbd_mode</CODE>, <CODE>kbdrate</CODE>, <CODE>loadunimap</CODE>, <CODE>chvt</CODE>,
<CODE>resizecons</CODE>, <CODE>deallocvt</CODE>, <CODE>getkeycodes</CODE>, <CODE>setkeycodes</CODE>.
It also contains <CODE>openvt</CODE>, formerly called <CODE>open</CODE>.</P>
<P>There exists a clone of the kbd package, namely <CODE>console-tools</CODE>,
that contains more or less the same stuff. The latest version,
<CODE>console-tools-0.3.3</CODE> is roughly up-to-date with <CODE>kbd-0.99</CODE>.</P>
<P><CODE>SVGATextMode-1.10</CODE> contains <CODE>SVGATextMode</CODE>, a program that
obsoletes <CODE>resizecons</CODE>.</P>
<P><CODE>util-linux-2.11</CODE> contains <CODE>setterm</CODE>.</P>
<P><CODE>sh-utils-1.12</CODE> contains <CODE>stty</CODE>.</P>
<P>See also <CODE>dynamic-vc-1.2.tar.gz</CODE> and <CODE>consd-1.3.tgz</CODE> for
programs that exploit the `Keyboard Signal' key. Very primitive
versions are <CODE>spawn_login</CODE> or <CODE>spawn_console</CODE> found in the kbd package.</P>
<P>See 
<A HREF="http://www.cix.co.uk/~mayday/font.tgz">font.tgz</A>
for a package that handles console fonts.</P>
<P>Packages like <CODE>recode</CODE> and <CODE>konwert-1.8</CODE> allow one to convert
between different character encodings.</P>

<P>The X distribution contains <CODE>xmodmap</CODE>, <CODE>xset</CODE>, <CODE>kbd_mode</CODE>.
(See also X386keybd(1) for the situation under XFree86 1.3,
and Xserver(1) for the XKEYBOARD extension under X11R6.)
A handy interface to <CODE>xmodmap</CODE> is <CODE>xkeycaps</CODE>, see
<A HREF="www.jwz.org/xkeycaps/">http://www.jwz.org/xkeycaps/</A>.</P>
<P><CODE>termcap-2.0.8.tar.gz</CODE> contains <CODE>termcap</CODE>, an old terminal
capabilities data base. <CODE>ncurses-1.9.9e.tar.gz</CODE> contains the
<CODE>termlib</CODE> data base which obsoletes <CODE>termcap</CODE>. (However,
there are still many programs using <CODE>termcap</CODE>.)</P>
<P>See loadkeys(1), setleds(1) and setmetamode(1) for the codes generated by the
various keys and the setting of leds when not under X. Under X, see xmodmap(1)
and xset(1).</P>
<P>See setfont(8) for loading console fonts. Many people will want to
load a font like <CODE>iso01.f16</CODE> because the default font is the
hardware font of the video card, and often is a `Code Page 437' font
missing accented characters and other Latin-1 symbols.</P>
<P>See setterm(1) and kbdrate(8) for properties such as foreground and background
colors, screen blanking and character repeat rate when not under X.
Under X, see xset(1), also for key click and bell volume.</P>
<P>The file <CODE>/etc/termcap</CODE> defines the escape sequences
used by many programs addressing the console (or any other terminal).
See termcap(5).
A more modern version is found in <CODE>/usr/lib/terminfo</CODE>.
See terminfo(5). Terminfo files are compiled
by the terminfo compiler <CODE>/usr/lib/terminfo/tic</CODE>, see tic(1).
Their contents can be examined using the program <CODE>infocmp</CODE>,
see infocmp(1).</P>
<P>The Linux console sequences are documented in console_codes(4).</P>
<P>The package <CODE>funkey</CODE> by Rick van Rein provides support
for all these new keys modern keyboards have. See
<A HREF="http://rick.vanrein.org/linux/funkey">rick.vanrein.org/linux/funkey</A>.</P>

<H2><A NAME="s2">2. Keyboard generalities</A></H2>

<P>
<!--
keyboard!theory of operation
-->
</P>
<P>You press a key, and the keyboard controller sends
<A HREF="http://www.win.tue.nl/~aeb/linux/kbd/scancodes.html">scancodes</A>
to the kernel keyboard driver. Some keyboards can be programmed,
but usually the scancodes corresponding to your keys are fixed.
The kernel keyboard driver just transmits whatever it receives
to the application program when it is in <EM>scancode mode</EM>,
like when <CODE>X</CODE> is running. Otherwise, it parses the stream of scancodes
into keycodes, corresponding to key press or key release events.
(A single key press can generate up to 6 scancodes.)
These keycodes are transmitted to the application program when it is
in <EM>keycode mode</EM> (as used, for example, by <CODE>showkey</CODE>
and some X servers).
Otherwise, these keycodes are looked up in the keymap, and the character
or string found there is transmitted to the application, or the action
described there is performed.
(For example, if one presses and releases the <CODE>a</CODE> key, then the keyboard
produces scancodes 0x1e and 0x9e, this is converted to keycodes 30 and 158,
and then transmitted as 0141, the ASCII or latin-1 code for `a';
if one presses and releases <CODE>Delete</CODE>, then the keyboard produces scancodes
0xe0 0x53 0xe0 0xd3, these are converted to keycodes 111 and 239, and then
transmitted as the 4-symbol sequence ESC [ 3 ~, all assuming
a US keyboard and a default keymap. An example of a key combination to which
an action is assigned is Ctrl-Alt-Del.)</P>
<P>The translation between unusual scancodes and keycodes can be set using the
utility <CODE>setkeycodes</CODE> - only few people will need it.
The translation between keycodes and characters or strings or actions, that is,
the keymap, is set using the utilities <CODE>loadkeys</CODE> and <CODE>setmetamode</CODE>.
For details, see getkeycodes(8), setkeycodes(8), dumpkeys(1), loadkeys(1),
setmetamode(1). The format of the files output by <CODE>dumpkeys</CODE> and read
by <CODE>loadkeys</CODE> is described in keymaps(5).</P>
<P>Where it says `transmitted to the application' in the above description,
this really means `transmitted to the terminal driver'. That is, further
processing is just like that of text that comes in over a serial line.
The details of this processing are set by the program <CODE>stty</CODE>.</P>

<H2><A NAME="s3">3. Console generalities</A></H2>

<P>
<!--
console!theory of operation
-->
</P>
<P>Conversely, when you output something to the console, it first undergoes
the standard tty processing, and then is fed to the console driver.
The console driver emulates a VT100, and parses the input in order to
recognize VT100 escape sequences (for cursor movement, clear screen, etc.).
The characters that are not part of an escape sequence are first converted
into Unicode, using one of four mapping tables if the console was not
in UTF-8 mode to start with, then looked up in the table describing
the correspondence between Unicode values and font positions,
and the obtained 8- or 9-bit font indices are then written to video memory,
where they cause the display of character shapes found in the video card's
character ROM.
One can load one's own fonts into character ROM using <CODE>setfont</CODE>.
The obsolete programs <CODE>loadunimap</CODE> and <CODE>mapscrn</CODE> can be used
to manipulate the Unicode map belonging to the font, or the mapping
table of the console. More details will be given below.</P>
<P>There are many consoles (called <I>Virtual Consoles</I> or
<I>Virtual Terminals</I>, abbreviated VCs or VTs) that share the same
screen. You can use them as independent devices, either to run
indendent login sessions, or just to send some output to, perhaps
from <CODE>top</CODE>, or the tail of the system log or so.
See below (`Console switching') on how to set them up and
switch between them.</P>


<H2><A NAME="s4">4. Resetting your terminal</A></H2>

<P>
<!--
terminal!resetting
-->

<!--
screen!clearing
-->

<!--
console!clearing
-->
</P>
<P>There is garbage on the screen, or all your keystrokes are echoed
as line drawing characters. What to do?</P>
<P>Many programs will redraw the screen when Ctrl-L is typed. This might
help when there is some modem noise or broadcast message on your screen.
The command <CODE>clear</CODE> will clear the screen.</P>
<P>The command <CODE>reset</CODE> will reset the console driver. This helps when
the screen is full of funny graphic characters, and also if it is
reduced to the bottom line. If you don't have this command, or if it
does something else, make your own by putting the following two lines
in an executable file <CODE>reset</CODE> in your PATH:
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/sh
        echo -e \\033c
</PRE>
</CODE></BLOCKQUOTE>

that is, you want to send the two characters ESC c to the console.</P>
<P>Why is it that the display sometimes gets confused and gives you
a 24-line or 1-line screen, instead of the usual 25 lines?
Well, the main culprit is the use of <CODE>TERM=vt100</CODE> (or some other
entry with 24 lines) instead of <CODE>TERM=linux</CODE> when logged in remotely.
If this happens on <CODE>/dev/tty2</CODE> then typing
<BLOCKQUOTE><CODE>
<PRE>
        % cat > /dev/tty2
        ^[c
        ^D
</PRE>
</CODE></BLOCKQUOTE>

on some other VT (where 4 symbols are typed to <CODE>cat</CODE>: ESC, c, ENTER,
Ctrl-D) and refreshing the screen on <CODE>/dev/tty2</CODE>
(perhaps using Ctrl-L) will fix things. Of course the permanent fix
is to use the right termcap or terminfo entry.
A command that only changes the number of lines is
<BLOCKQUOTE><CODE>
<PRE>
        % echo -e "\033[1;25r"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Why is it that you sometimes get a lot of line-drawing characters,
e.g., after catting a binary to the screen?
Well, there are various character set changing escape sequences,
and by accident your binary might contain some of these.
The ESC c is a general reset, a cure for all, but if you know
precisely what went wrong you can repair it without resetting
other console attributes. For example, after
<BLOCKQUOTE><CODE>
<PRE>
        % cat
        ^N
        ^D
</PRE>
</CODE></BLOCKQUOTE>

your shell prompt will be all line-drawing characters.
Now do (typing blindly)
<BLOCKQUOTE><CODE>
<PRE>
        % cat
        ^O
        ^D
</PRE>
</CODE></BLOCKQUOTE>

and all is well again. (Three symbols typed to each <CODE>cat</CODE>:
Ctrl-N (or Ctrl-O), ENTER, Ctrl-D.) To understand what is happening,
see `The console character sets' below.</P>
<P>If you loaded some strange font, and want to return to the default,
<BLOCKQUOTE><CODE>
<PRE>
        % setfont
</PRE>
</CODE></BLOCKQUOTE>

will do (provided you stored the default font in the default place).
If this default font does not contain an embedded Unicode map (and
gives the wrong symbols for accented characters), then say
<BLOCKQUOTE><CODE>
<PRE>
        % loadunimap
</PRE>
</CODE></BLOCKQUOTE>

For example, if I do
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys de-latin1
</PRE>
</CODE></BLOCKQUOTE>

then I have a German keyboard, and the key left of the Enter key
gives me a-umlaut. This works, because the a-umlaut occurs
on the CP437 code page and the kernel Unicode map is initialized
to CP437, and my video card has a CP437 font built-in.
If I now load an ISO 8859-1 font with
<BLOCKQUOTE><CODE>
<PRE>
        % setfont iso01.f16
</PRE>
</CODE></BLOCKQUOTE>

then everything still works, because <CODE>setfont</CODE> invalidates the kernel
Unicode map (if there is no Unicode map attached to the font), and without
map the kernel goes directly to the font, and that is precisely correct
for an ISO 8859-1 system with <CODE>iso01.f16</CODE> font.
But going back to the previous font with
<BLOCKQUOTE><CODE>
<PRE>
        % setfont
</PRE>
</CODE></BLOCKQUOTE>

gives capital Sigma's instead of a-umlaut - all accented letters
are mixed up because also this font has no embedded Unicode map. After
<BLOCKQUOTE><CODE>
<PRE>
        % loadunimap
</PRE>
</CODE></BLOCKQUOTE>

which loads the default Unicode map (which is right for the default
font) all works correctly again. Usually <CODE>loadunimap</CODE> is not
invoked directly, but via <CODE>setfont</CODE>. Thus, the previous two
commands may be replaced by
<BLOCKQUOTE><CODE>
<PRE>
        % setfont -u def
</PRE>
</CODE></BLOCKQUOTE>

These days most fonts have embedded Unicode maps (often this is
indicated by the extension <CODE>.psfu</CODE>), and none of this nonsense
is needed anymore.</P>
<P>On very old terminals output involving tabs may require a delay,
and you have to say
<BLOCKQUOTE><CODE>
<PRE>
        % stty tab3
</PRE>
</CODE></BLOCKQUOTE>

(see stty(1)).</P>
<P>You can change the video mode using <CODE>resizecons</CODE> or
<CODE>SVGATextMode</CODE>. Or by rebooting and having "vga=ask"
in the LILO configuration file.</P>
<P>This usually settles the output side.</P>
<P>On the input side there are many things that might be wrong. If <CODE>X</CODE> or
<CODE>DOOM</CODE> or some other program using raw mode crashed, your keyboard may
still be in raw (or mediumraw) mode, and it is difficult to give commands.
(See "How to get out of raw mode" below.)
If you loaded a bad keymap, then
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys -d
</PRE>
</CODE></BLOCKQUOTE>

loads the default map again, but it may well be difficult to type `-'!
An alternative is
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys defkeymap
</PRE>
</CODE></BLOCKQUOTE>

Sometimes even the letters are garbled. It is useful to know that there
are four main types of keyboards: QWERTY, QWERTZ, AZERTY and DVORAK.
The first three are named after the first six letter keys, and roughly
represent the English, German and French speaking countries.
Compared to QWERTY, the QWERTZ map interchanges Y and Z.
Compared to QWERTY, the AZERTY map interchanges Q and A, W and Z, and has
its M right of the L, at the semicolon position.
DVORAK has an entirely different letter ordering.
There are two types of Turkish keyboard. The so-called `Q'-keyboard
has a QWERTY layout, while the `F'-keyboard has an entirely
different layout, let us say fgGIod, where G stands for Gbreve
and I for dotlessi.</P>

<H2><A NAME="ss4.1">4.1 Keyboard hardware reset</A>
</H2>

<P>
<!--
keyboard!resetting
-->
</P>
<P>Things may be wrong on a lower level than Linux knows about.
There are at least two distinct lower levels (keyboard and keyboard controller)
where one can give the command "keyboard disable" to the keyboard hardware.
Keyboards can often be programmed to use one out of three
different sets of scancodes.</P>
<P>However, I do not know of cases where this turned out to be
a problem.</P>
<P>Some keyboards have a remapping capability built in.
Stormy Henderson (<CODE>stormy@Ghost.Net</CODE>) writes:
`If it's your keyboard accidently being reprogrammed, you can
(on a Gateway AnyKey keyboard) press control-alt-suspend_macro
to reset the keys to normal.'</P>

<H2><A NAME="s5">5. Delete and Backspace</A></H2>

<P>
<!--
delete key!problems with
-->

<!--
backspace key!problems with
-->
</P>
<P>Getting Delete and Backspace to work just right is nontrivial,
especially in a mixed environment, where you talk to console,
to <CODE>X</CODE>, to <CODE>bash</CODE>, to <CODE>emacs</CODE>, login remotely, etc.
You may have to edit several configuration files to tell all
of the programs involved precisely what you want.
On the one hand, there is the matter of which keys generate
which codes (and how these codes are remapped by e.g. <CODE>kermit</CODE>
or <CODE>emacs</CODE>), and on the other hand the question of what functions
are bound to what codes.</P>
<P>People often complain `my backspace key does not work', as if this
key had a built-in function `delete previous character'.
Unfortunately, all this key, or any key, does is producing a code,
and one only can hope that the kernel tty driver and
all application programs can be configured such that
the backspace key indeed does function as a `delete previous character'
key.</P>
<P>Most Unix programs get their tty input via the kernel tty driver
in `cooked' mode, and a simple <CODE>stty</CODE> command determines the
erase character. However, programs like <CODE>bash</CODE> and <CODE>emacs</CODE>
and <CODE>X</CODE> do their own input handling, and have to be convinced
one-by-one to do the right thing.</P>

<H2><A NAME="ss5.1">5.1 How to tell Unix what character you want to use to delete the last typed character</A>
</H2>

<P>
<!--
stty!using to set erase character
-->
</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        % stty erase ^?
</PRE>
</CODE></BLOCKQUOTE>

If the character is erased, but in a funny way, then something is
wrong with your tty settings. If <CODE>echoprt</CODE> is set, then erased characters
are enclosed between <CODE>\</CODE> and <CODE>/</CODE>.
If <CODE>echoe</CODE> is not set, then the erase char is echoed
(which is reasonable when it is a printing character, like #).
Most people will want <CODE>stty echoe -echoprt</CODE>. Saying <CODE>stty sane</CODE>
will do this and more. Saying <CODE>stty -a</CODE> shows your current settings.
How come this is not right by default? It is, if you use the right
<CODE>getty</CODE>.</P>
<P>Note that many programs (like <CODE>bash</CODE>, <CODE>emacs</CODE> etc.) have their own
keybindings (defined in <CODE>~/.inputrc</CODE>,
<CODE>~/.emacs</CODE> etc.) and are unaffected by the setting
of the erase character.</P>
<P>The standard Unix tty driver does not recognize a cursor, or keys
(like the arrow keys) to move the current position, and hence does not
have a command `delete current character' either. But for example
you can get <CODE>bash</CODE> on the console to recognize the Delete key by putting
<BLOCKQUOTE><CODE>
<PRE>
        set editing-mode emacs
        "\e[3~":delete-char
</PRE>
</CODE></BLOCKQUOTE>

into <CODE>~/.inputrc</CODE>.</P>

<H3>`Getty used to do the right thing with DEL and BS but is broken now?'</H3>

<P>
<!--
getty!problems with BS and DEL
-->
</P>
<P>Earlier, the console driver would do BS Space BS
(<CODE>\010\040\010</CODE>)
when it got a DEL (<CODE>\177</CODE>).
Nowadays, DEL's are ignored (as they should be,
since the driver emulates a vt100). Get a better getty, i.e.,
one that does not output DEL.</P>

<H3>`Login behaves differently at the first and second login attempts?'</H3>

<P>
<!--
login!problems with BS and DEL
-->
</P>
<P>At the first attempt, you are talking to <CODE>getty</CODE>. At the second attempt,
you are talking to <CODE>login</CODE>, a different program.</P>

<H2><A NAME="ss5.2">5.2 How to tell Linux what code to generate when a key is pressed</A>
</H2>

<P>
<!--
keyboard!keycode remapping
-->

<!--
keycode remapping
-->
</P>
<P>On the console, or, more precisely, when not in (MEDIUM)RAW mode, use
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys mykeys.map
</PRE>
</CODE></BLOCKQUOTE>

and under X use
<BLOCKQUOTE><CODE>
<PRE>
        % xmodmap mykeys.xmap
</PRE>
</CODE></BLOCKQUOTE>

Note that (since XFree86-2.1) X reads the Linux settings of the keymaps
when initialising the X keymap. Although the two systems are not
100% compatible, this should mean that in many cases the use of
<CODE>xmodmap</CODE> has become superfluous.</P>
<P>For example, suppose that you would like the Backspace key
to send a BackSpace (Ctrl-H, octal 010) and the grey Delete key
a DEL (octal 0177). Add the following to <CODE>/etc/rc.local</CODE>
(or wherever you keep your local boot-time stuff):
<BLOCKQUOTE><CODE>
<PRE>
        /usr/bin/loadkeys &lt;&lt; EOF
        keycode 14 = BackSpace
        keycode 111 = Delete
        EOF
</PRE>
</CODE></BLOCKQUOTE>

Note that this will only change the function of these keys
when no modifiers are used. (You need to specify a keymaps line
to tell which keymaps should be affected if you want to change
bindings on more keymaps.)
The Linux kernel default lets
Ctrl-Backspace generate BackSpace - this is sometimes useful
as emergency escape, when you find you can only generate DELs.</P>
<P>The left Alt key is sometimes called the Meta key, and by
default the combinations AltL-X are bound to the symbol MetaX.
But what character sequence is MetaX?
That is determined (per-tty) by the Meta flag, set by the command
<CODE>setmetamode</CODE>. The two choices are: ESC X or X or-ed with 0200.</P>
<P>Many distributions have a <CODE>loadkeys</CODE> command somewhere in the
bootup sequence. For example, one may have the name of the desired
keymap in <CODE>/etc/sysconfig/keyboard</CODE> and the <CODE>loadkeys</CODE>
command that loads it in <CODE>/etc/rc.d/init.d/keytable</CODE>.
Or one may have the actual default keymap in <CODE>/etc/default.keytab</CODE>
and the loadkeys command that loads it in <CODE>/etc/rc.d/boot</CODE>.
Etc. Instead of adding a local modification to the default, one can
of course change the default by editing the default keymap or changing
the name of the keymap to be loaded at boot time. Note that <CODE>loadkeys</CODE>
itself has default keymap <CODE>defkeymap.map</CODE> located somewhere under
<CODE>/usr/lib/kbd</CODE> or <CODE>/usr/share/kbd</CODE> (just like all other
keymaps) and this may not yet be available in single user boot before
<CODE>/usr</CODE> has been mounted.</P>

<H3>`How do I get a dvorak keyboard?'</H3>

<P>
<!--
dvorak keyboard
-->

The command
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys dvorak
</PRE>
</CODE></BLOCKQUOTE>

will give you a dvorak layout, probably by loading
something like <CODE>/usr/lib/kbd/keymaps/i386/dvorak/dvorak.map.gz</CODE>.
Under <CODE>X</CODE>, put
<BLOCKQUOTE><CODE>
<PRE>
        XkbLayout       "dvorak"
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>XF86Config</CODE>.</P>

<H3>`Why doesn't the Backspace key generate BackSpace by default?'</H3>

<P>
<!--
backspace key!not generating correct keycode
-->
</P>
<P>(i) Because the VT100 had a Delete key above the Enter key.</P>
<P>(ii) Because Linus decided so.</P>

<H2><A NAME="ss5.3">5.3 How to tell X to interchange Delete and Backspace</A>
</H2>

<P>
<!--
X!swapping DEL, BS
-->

<!--
xmodmap!using to swap DEL, BS
-->
</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        % xmodmap -e "keysym BackSpace = Delete" -e "keysym Delete = BackSpace"
</PRE>
</CODE></BLOCKQUOTE>

Or, if you just want the Backspace key to generate a BackSpace:
<BLOCKQUOTE><CODE>
<PRE>
        % xmodmap -e "keycode 22 = BackSpace"
</PRE>
</CODE></BLOCKQUOTE>

Or, if you just want the Delete key to generate a Delete:
<BLOCKQUOTE><CODE>
<PRE>
        % xmodmap -e "keycode 107 = Delete"
</PRE>
</CODE></BLOCKQUOTE>

(but usually this is the default binding already).</P>

<H2><A NAME="ss5.4">5.4 How to tell emacs what to do when it receives a Delete or Backspace</A>
</H2>

<P>
<!--
emacs!binding DEL, BS
-->
</P>
<P>Put in your <CODE>.emacs</CODE> file lines like
<BLOCKQUOTE><CODE>
<PRE>
        (global-set-key "\?" 'help-command)
        (global-set-key "\C-h" 'delete-backward-char)
</PRE>
</CODE></BLOCKQUOTE>

Of course you can bind other commands to other keys in the same way.
Note that various major and minor modes redefine keybindings.
For example, in incremental search mode one finds the code
<BLOCKQUOTE><CODE>
<PRE>
        (define-key map "\177" 'isearch-delete-char)
        (define-key map "\C-h" 'isearch-mode-help)
</PRE>
</CODE></BLOCKQUOTE>

This means that it may be a bad idea to use the above two
global-set-key commands. There are too many places where
there are built-in assumptions about Ctrl-H = help and DEL = delete.
That doesn't mean that you have to setup keys so that Backspace
generates DEL. But if it doesn't then it is easiest to remap
them at the lowest possible level in emacs.</P>

<H2><A NAME="ss5.5">5.5 How to tell emacs to interchange Delete and Backspace</A>
</H2>

<P>
<!--
emacs!swapping DEL, BS
-->
</P>
<P>Put in your <CODE>.emacs</CODE> file lines
<BLOCKQUOTE><CODE>
<PRE>
        (setq keyboard-translate-table (make-string 128 0))
        (let ((i 0))
          (while (&lt; i 128)
            (aset keyboard-translate-table i i)
            (setq i (1+ i))))
        (aset keyboard-translate-table ?\b ?\^?)
        (aset keyboard-translate-table ?\^? ?\b)
</PRE>
</CODE></BLOCKQUOTE>

Recent versions of emacs have a function <CODE>keyboard-translate</CODE>
and one may simplify the above to
<BLOCKQUOTE><CODE>
<PRE>
        (keyboard-translate ?\C-h ?\C-?)
        (keyboard-translate ?\C-? ?\C-h)
</PRE>
</CODE></BLOCKQUOTE>

Note that under X emacs can distinguish between Ctrl-h and the
Backspace key (regardless of what codes these produce on the console),
and by default emacs will view the Backspace key as DEL
(and do deletion things, as bound to that character, rather than
help things, bound to Ctrl-H). One can distinguish Backspace and Delete,
e.g. by
<BLOCKQUOTE><CODE>
<PRE>
        (global-unset-key [backspace] )
        (global-set-key [backspace] 'delete-backward-char)
        (global-unset-key [delete] )
        (global-set-key [delete] 'delete-char)
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.6">5.6 How to tell kermit to interchange Delete and Backspace</A>
</H2>

<P>
<!--
kermit!swapping DEL, BS
-->
</P>
<P>Put in your <CODE>.kermrc</CODE> file the lines
<BLOCKQUOTE><CODE>
<PRE>
        set key \127 \8
        set key \8 \127
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.7">5.7 How to tell xterm to interchange Delete and Backspace</A>
</H2>

<P>
<!--
xterm!swapping DEL, BS
-->

<BLOCKQUOTE><CODE>
<PRE>
XTerm*VT100.Translations:       #override\n\
        &lt;KeyPress> BackSpace : string(0x7f)\n\
        &lt;KeyPress> Delete : string(0x08)\n
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.8">5.8 How to tell xterm about your favourite tty modes</A>
</H2>

<P>
<!--
xterm!setting tty modes for
-->
</P>
<P>Normally xterm will inherit the tty modes from its invoker.
Under <CODE>xdm</CODE>, the default erase and kill characters are <CODE>#</CODE> and <CODE>@</CODE>,
as in good old Unix Version 6.
If you don't like that, you might put something like
<BLOCKQUOTE><CODE>
<PRE>
        XTerm*ttymodes: erase ^? kill ^U intr ^C quit ^\ eof ^D \ 
                        susp ^Z start ^Q stop ^S eol ^@
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>/usr/lib/X11/app-defaults/XTerm</CODE> or in
<CODE>$HOME/.Xresources</CODE>, assuming that you have a line
<BLOCKQUOTE><CODE>
<PRE>
        xrdb -merge $HOME/.Xresources
</PRE>
</CODE></BLOCKQUOTE>

in your <CODE>$HOME/.xinitrc</CODE> or <CODE>$HOME/.xsession</CODE>.</P>

<H2><A NAME="ss5.9">5.9 How to tell non-Motif X applications that the Del key deletes forward</A>
</H2>

<P>Put
<BLOCKQUOTE><CODE>
<PRE>
*Text.translations:    #override \
        ~Shift ~Meta &lt;Key>Delete: delete-next-character()
</PRE>
</CODE></BLOCKQUOTE>

into <CODE>.Xresources</CODE> to make non-Motif X applications such as
<CODE>xfig</CODE>, <CODE>xedit</CODE>, etc., work correctly. (Daniel T. Cobra)</P>

<H2><A NAME="ss5.10">5.10 How to tell xmosaic that the Backspace key generates a DEL</A>
</H2>

<P>
<!--
xmosaic!remapping BS key
-->

<!--
Netscape!remapping BS
-->
</P>
<P>Putting
<BLOCKQUOTE><CODE>
<PRE>
        *XmText.translations: #override\n\
           &lt;Key>osfDelete: delete-previous-character()
        *XmTextField.translations: #override\n\
           &lt;Key>osfDelete: delete-previous-character()
</PRE>
</CODE></BLOCKQUOTE>

in your <CODE>$HOME/.Xdefaults</CODE> or
<CODE>$HOME/.Xresources</CODE> helps.
(What file? The file that is fed to <CODE>xrdb</CODE>, for example
in <CODE>.xinitrc</CODE>.)</P>
<P>The netscape FAQ, however, says:
<PRE>
        Why doesn't my Backspace key work in text fields? 
        By default, Linux and XFree86 come with the Backspace and Delete keys
        misconfigured. All Motif programs (including, of course, Netscape
        Navigator) will malfunction in the same way.

        The Motif spec says that Backspace is supposed to delete the previous
        character and Delete is supposed to delete the following character.
        Linux and XFree86 come configured with both the Backspace and Delete
        keys generating Delete.

        You can fix this by using any one of the xmodmap, xkeycaps, or
        loadkeys programs to make the key in question generate the BackSpace
        keysym instead of Delete.

        You can also fix it by having a .motifbind file; see the man page
        for VirtualBindings(3).

        Note: Don't use the *XmText.translations or *XmTextField.translations
        resources to attempt to fix this problem. If you do, you will blow
        away Netscape Navigator's other text-field key bindings.
</PRE>
</P>

<H2><A NAME="ss5.11">5.11 A better solution for Motif-using programs, like netscape</A>
</H2>

<P>
<!--
Netscape!remapping BS
-->

<!--
Motif!remapping BS
-->
</P>
<P>Ted Kandell (<CODE>ted@tcg.net</CODE>) suggests the following:</P>
<P>Somewhere in your .profile add the following:
<BLOCKQUOTE><CODE>
<PRE>
stty erase ^H
</PRE>
</CODE></BLOCKQUOTE>

If you are using <CODE>bash</CODE>, add the following lines to your <CODE>.inputrc</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
"\C-?": delete-char
"\C-h": backward-delete-char
</PRE>
</CODE></BLOCKQUOTE>

Add the following lines to your .xinitrc file:
<BLOCKQUOTE><CODE>
<PRE>
xmodmap &lt;&lt;-EOF
keycode 22  =  BackSpace osfBackSpace
keycode 107 =  Delete
EOF

# start your window manager here,  for example:
#(fvwm) 2>&amp;1 | tee /dev/tty /dev/console

stty sane
stty erase ^H
loadmap &lt;&lt;-EOF
keycode 14  = BackSpace
keycode 111 = Delete
EOF
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This will definitely work for a PC 101 or 102 key keyboard
with any Linux/XFree86 layout.</P>
<P>The important part to making Motif apps like Netscape work properly
is adding osfBackSpace to keycode 22 in addition to BackSpace.</P>
<P>Note that there must be spaces on either side of the = sign.</P>


<H2><A NAME="ss5.12">5.12 What about termcap and terminfo?</A>
</H2>

<P>
<!--
termcap!remapping BS with
-->

<!--
terminfo!remapping BS with
-->
</P>
<P>When people have problems with backspace, they tend to look at their termcap
(or terminfo) entry for the terminal, and indeed, there does exist a kb
(or kbs) capability describing the code generated by the Backspace key.
However, not many programs use it, so unless you are having problems with one
particular program only, probably the fault is elsewhere.
Of course it is a good idea anyway to correct your termcap (terminfo) entry.
See also below under "The TERM variable".</P>

<H2><A NAME="ss5.13">5.13 A complete solution</A>
</H2>

<P>There are many possibilities to get a functioning system.
Can't you give one complete set of settings that works?
<!--
delete key!a solution
-->

<!--
backspace key!a solution
-->
</P>
<P>One way of getting a setup that works in all contexts
is to have the Backspace key generate DEL when on the
console (or xterm), and BackSpace when under X.
Maybe that is most convenient - there are too many X utilities
that expect BackSpace, and emacs on the console or xterm
expects DEL, while emacs under X can distinguish [BackSpace]
from Ctrl-H and does the right thing.</P>
<P>What is needed?
No loadkeys changes, since the Backspace key already generates
DEL by default.  No stty settings, they are OK by default.
No X settings, they are OK by default.
One just has to tell xterm that the Backspace key should generate DEL:
put 
<BLOCKQUOTE><CODE>
<PRE>
XTerm*VT100.Translations:       #override\n\
        &lt;KeyPress> BackSpace : string(0x7f)\n\
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>.Xresources</CODE>, and
<BLOCKQUOTE><CODE>
<PRE>
xrdb -merge .Xresources
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>.xinitrc</CODE>, and you are settled.</P>
<P>For a much more extensive discussion of these things, and
alternative solutions, see
<A HREF="http://www.ibb.net/~anne/keyboard.html">Anne Baretta's page</A>.</P>

<H2><A NAME="s6">6. The console character sets</A></H2>

<P>
<!--
console character sets
-->

<!--
character sets, console
-->
</P>
<P>The kernel first tries to figure out what symbol is meant by any given
user byte, and next where this symbol is located in the current font.</P>
<P>The kernel knows about 5 translations of bytes into console-screen symbols.
In Unicode (UTF-8) mode, the UTF-8 code is just converted directly into
Unicode. The assumption is that almost all symbols one needs are present
in Unicode, and for the cases where this does not hold the codes
0xf000-0xf1ff are reserved for direct font access.
When not in Unicode mode, one of four translation tables is used.
The four tables are: a) Latin1 -&gt; Unicode,  b) VT100 graphics -&gt; Unicode,
c) PC -&gt; Unicode, d) user-defined.</P>
<P>There are two character sets, called G0 and G1, and one of them
is the current character set. (Initially G0.)
Typing Ctrl-N causes G1 to become current, Ctrl-O causes G0 to become current.</P>
<P>These variables G0 and G1 point at a translation table, and can be changed
by the user. Initially they point at tables a) and b), respectively.
The sequences ESC ( B and ESC ( 0 and ESC ( U and ESC ( K cause G0 to point
at translation table a), b), c) and d), respectively.
The sequences ESC ) B and ESC ) 0 and ESC ) U and ESC ) K cause G1 to point
at translation table a), b), c) and d), respectively.</P>
<P>The sequence ESC c causes a terminal reset, which is what you want if the
screen is all garbled. The oft-advised <CODE>echo ^V^O</CODE> will only
make G0 current, but there is no guarantee that G0 points at table a).
In some distributions there is a program reset(1) that just does
<CODE>echo ^[c</CODE>.
If your termcap entry for the console is correct (and has an entry
<CODE>:rs=\Ec:</CODE>), then also <CODE>setterm -reset</CODE> will work.</P>
<P>The user-defined mapping table can be set using mapscrn(8).
The result of the mapping is that if a symbol c is printed, the symbol
<CODE>s = map[c]</CODE> is sent to the video memory. The bitmap that corresponds to
<CODE>s</CODE> is found in the character ROM, and can be changed using setfont(8).</P>

<H2><A NAME="s7">7. Console switching</A></H2>

<P>
<!--
console!switching
-->
</P>
<P>By default, console switching is done using Alt-Fn or Ctrl-Alt-Fn.
Under <CODE>X</CODE> (or recent versions of <CODE>dosemu</CODE>), only Ctrl-Alt-Fn works.
Many keymaps will allow cyclic walks through all allocated consoles
using Alt-RightArrow and Alt-LeftArrow.</P>
<P>XFree86 1.3 does not know that Alt is down when you switch to the X
window. Thus, you cannot switch immediately to some other VT again
but have to release Alt first.
In the other direction this should work: the kernel always keeps
track of the up/down status of all keys. (As far as possible: on some
keyboards some keys do not emit a scancode when pressed (e.g.: the PFn
keys of a FOCUS 9000) or released (e.g.: the Pause key of many keyboards).)</P>
<P>XFree86 1.3 saves the fonts loaded in the character ROMs when started,
and restores it on a console switch. Thus, the result of <CODE>setfont</CODE> on
a VT is wiped out when you go to X and back.
Using <CODE>setfont</CODE> under X will lead to funny results.</P>
<P>One can change VT under program control using the <CODE>chvt</CODE> command.</P>

<H2><A NAME="ss7.1">7.1 Changing the number of Virtual Consoles</A>
</H2>

<P>
<!--
console!changing number of
-->
</P>
<P>This question still comes up from time to time, but the answer is:
you already have enough of them.
Since kernel version 1.1.54, there are between 1 and 63 virtual
consoles. A new one is created as soon as it is opened. It is
removed by the utility <CODE>deallocvt</CODE> (but it can be removed only when
no processes are associated to it anymore, and no text on it has been
selected by programs like <CODE>selection</CODE> or <CODE>gpm</CODE>).</P>
<P>For older kernels, change the line
<BLOCKQUOTE><CODE>
<PRE>
        #define NR_CONSOLES     8
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>include/linux/tty.h</CODE> (don't increase this number beyond 63),
and recompile the kernel.</P>
<P>If they do not exist yet, create the tty devices with <CODE>MAKEDEV</CODE>
or <CODE>mknod tty</CODE>N <CODE>c 4</CODE> N where N denotes the tty number. For example,
<BLOCKQUOTE><CODE>
<PRE>
        for i in 9 10 11 12; do mknod /dev/tty$i c 4 $i; done
</PRE>
</CODE></BLOCKQUOTE>

or, better (since it also takes care of owner and permissions),
<BLOCKQUOTE><CODE>
<PRE>
        for i in 9 10 11 12; do /dev/MAKEDEV tty$i; done
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>If you want the new VCs to run <CODE>getty</CODE>, add lines in <CODE>/etc/inittab</CODE>.
(But it is much better to have only two <CODE>getty</CODE>'s running,
and to create more consoles dynamically as the need arises.
That way you'll have more memory when you don't use all these consoles,
and also more consoles, in case you really need them.
Edit <CODE>/etc/inittab</CODE> and comment out all <CODE>getty</CODE>'s except
for the first two.)</P>
<P>When the consoles are allocated dynamically, it is usually easiest
to have only one or two running <CODE>getty</CODE>. More are opened by
<CODE>open -l -s bash</CODE>. Unused consoles (without associated processes)
are deallocated using <CODE>deallocvt</CODE> (formerly <CODE>disalloc</CODE>).
But, you say, I am involved in activities when I suddenly need more
consoles, and do not have a bash prompt available to give the <CODE>open</CODE>
command.
Fortunately it is possible to create a new console upon a single
keystroke, regardless of what is happening at the current console.</P>
<P>If you have <CODE>spawn_login</CODE> from <CODE>kbd-1.04.tar.gz</CODE> and you put
<BLOCKQUOTE><CODE>
<PRE>
        loadkeys &lt;&lt; EOF
        alt keycode 103 = Spawn_Console
        EOF
        spawn_login &amp;
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>/etc/rc.local</CODE>, then typing Alt-UpArrow will create a fresh VC
running <CODE>login</CODE> (and switch to it). With <CODE>spawn_console &amp;</CODE> instead of
<CODE>spawn_login &amp;</CODE> you'll have bash running there.
See also <CODE>open-1.4.tgz</CODE> and <CODE>dynamic-vc-1.1.tar.gz</CODE>.</P>
<P>What action should be taken upon this Spawn_Console keypress
can also be set in <CODE>/etc/inittab</CODE> under <CODE>kbrequest</CODE>,
if you have a recent <CODE>init</CODE>. See inittab(5).</P>
<P>(This action can be something entirely different - I just called
the key Spawn_Console because that is what I used it for.
When used for other purposes it is less confusing to use
its synonym KeyboardSignal.
For example, some people like to put the lines
<BLOCKQUOTE><CODE>
<PRE>
        kb::kbrequest:/sbin/shutdown -h now
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>/etc/inittab</CODE>, and
<BLOCKQUOTE><CODE>
<PRE>
        control alt keycode 79 = KeyboardSignal
        control alt keycode 107 = KeyboardSignal
</PRE>
</CODE></BLOCKQUOTE>

in their keymap. Now Ctrl-Alt-End will do a system shutdown.)</P>
<P>You can only login as "root" on terminals listed in <CODE>/etc/securetty</CODE>.
There exist programs that read terminal settings from files
<CODE>/etc/ttys</CODE> and <CODE>/etc/ttytype</CODE>. If you have such
files, and create additional consoles, then it might be a good idea
to also add entries for them in these files.</P>

<H2><A NAME="s8">8. Ctrl-Alt-Del and other special key combinations</A></H2>



<H2><A NAME="ss8.1">8.1 Ctrl-Alt-Del (Boot)</A>
</H2>

<P>
<!--
ctrl-alt-del!action taken by
-->
</P>
<P>If you press Ctrl-Alt-Del (or whatever key was assigned the keysym Boot by
loadkeys) then either the machine reboots immediately (without sync), or
<CODE>init</CODE> is sent a SIGINT. The former behaviour is the default. The default
can be changed by root, using the system call reboot(), see ctrlaltdel(8).
Some <CODE>init</CODE>'s change the default. What happens when <CODE>init</CODE> gets SIGINT depends
on the version of <CODE>init</CODE> used - often it will be determined by the pf entry in
<CODE>/etc/inittab</CODE> (which means that you can run an arbitrary program
in this case).
In the current kernel Ctrl-AltGr-Del is no longer by default assigned to Boot.</P>

<H2><A NAME="ss8.2">8.2 Other combinations</A>
</H2>

<P>
<!--
keyboard!special key combinations
-->

<!--
key combinations, special
-->
</P>
<P>
<PRE>
Name            Default binding
-------------------------------
Show_Memory     Shift-Scrollock
Show_Registers  AltGr-ScrollLock
Show_State      Ctrl-ScrollLock
Console_n       Alt-Fn and Ctrl-Alt-Fn  (1 &lt;= n &lt;= 12)
Console_{n+12}  AltGr-Fn                (1 &lt;= n &lt;= 12)
Incr_Console    Alt-RightArrow
Decr_Console    Alt-LeftArrow
Last_Console    Alt[Gr]-PrintScreen
Scroll_Backward Shift-PageUp
Scroll_Forward  Shift-PageDown
Caps_On                                 (CapsLock is a toggle; this key sets)
Compose         Ctrl-.
</PRE>
</P>

<H2><A NAME="ss8.3">8.3 X Combinations</A>
</H2>

<P>
<!--
keyboard!key combinations for X
-->

<!--
key combinations, X
-->

<!--
X!key combinations for
-->
</P>
<P>
<PRE>
Ctrl-Alt-Fn     Switch to VT n
Ctrl-Alt-KP+    Next mode
Ctrl-Alt-KP-    Previous mode
Ctrl-Alt-Backspace      Kill X
</PRE>

On some motherboards, Ctrl-Alt-KP- and Ctrl-Alt-KP+ will be equivalent to
pressing the Turbo button. That is, both will produce the scancodes
1d 38 4a ca b8 9d and 1d 38 4e ce b8 9d, and both will switch between
Turbo (&gt;= 25MHz) and non-Turbo (8 or 12 MHz).
(Often these key combinations only function this way when enabled
by jumpers on the motherboard.)</P>
<P>Perry F Nguyen (<CODE>pfnguyen@netcom22.netcom.com</CODE>) writes:
AMI BIOS has a feature that locks up the keyboard and flashes the LED's
if the Ctrl-Alt-Backspace combination is pressed while a BIOS password
is enabled, until the CMOS/BIOS password is typed in.</P>
<P>On some SiS based motherboards the combination Ctrl-Alt-Backspace
will cause a power off, or puts the machine in power save mode.
(Reported for SiS 630 and for SiS645DX.)</P>

<H2><A NAME="ss8.4">8.4 Dosemu Combinations</A>
</H2>

<P>
<!--
key combinations!dosemu
-->

<!--
dosemu!key combinations for
-->
</P>
<P>
<PRE>
Ctrl-Alt-Fn     Switch to VT n (from version 0.50; earlier Alt-Fn)
Ctrl-Alt-PgDn   Kill dosemu (when in RAW keyboard mode)
(and many other combinations - see the dosemu documentation)
</PRE>
</P>

<H2><A NAME="ss8.5">8.5 Composing symbols</A>
</H2>

<P>
<!--
keyboard!composing symbols with
-->

<!--
symbols!composing with keyboard
-->
</P>
<P>One symbol may be constructed using several keystrokes.
<UL>
<LI>LeftAlt-press, followed by a decimal number typed on the keypad, followed
by LeftAlt-release, yields the symbol with code given by this number.
(In Unicode mode this same mechanism, but then with 4 hexadecimal digits,
may be used to define a Unicode symbol.)</LI>
<LI>A dead diacritic followed by a symbol, yields that symbol adorned with
that diacritic. If the combination is undefined, both keys are taken
separately.
Which keys are dead diacritics is user-settable; none is by default.
Five (since 2.0.25 six) dead diacritics can be defined (using loadkeys(1)):
dead_grave, dead_acute, dead_circumflex, dead_tilde, dead_diaeresis
(and dead_cedilla).
Precisely what this adorning means is also user-settable:
dead-diacritic, symbol is equivalent to Compose + diacritic + symbol.</LI>
<LI>Compose followed by two symbols yields a combination symbol. These
combinations are user-settable. Today there are 68 combinations
defined by default; you can see them by saying "dumpkeys | grep compose".</LI>
<LI>Then there are `Sticky' modifier keys (since 1.3.33). For example,
one can type Ctrl-C as SControl, C and Ctrl-Alt-BackSpace as SControl,
SAlt, BackSpace.</LI>
</UL>
</P>
<P>Note that there are at least four such composition mechanisms:
<OL>
<LI>The Linux keyboard driver mechanism, used in conjunction with loadkeys.</LI>
<LI>The X mechanism - see X386keybd(1), later XFree86kbd(1).
Under X11R6: edit <CODE>/usr/X11R6/lib/X11/locale/iso8859-1/Compose</CODE>.
<P>See also Andrew D. Balsa's comments at
<A HREF="http://wauug.erols.com/~balsa/linux/deadkeys/index.html">http://wauug.erols.com/~balsa/linux/deadkeys/index.html</A>.</P>
</LI>
<LI>The emacs mechanism obtained by loading "iso-insert.el" or
calling `iso-accents-mode'.</LI>
<LI>The vim mechanism: insert a composed symbol by pressing Ctrl-K
followed by two symbols. A list of the possible combinations is
obtained by the command <CODE>:digraphs</CODE>.</LI>
</OL>

For X the order of the two symbols is arbitrary: both Compose-,-c and
Compose-c-, yield a c-cedilla; for Linux and emacs only the former sequence
works by default. For X and vim the list of compose combinations is fixed.
Linux and emacs are flexible.
The default lists are somewhat similar, but the details are different.</P>

<H2><A NAME="ss8.6">8.6 The SysRq key</A>
</H2>

<P>
<!--
SysRq key
-->

In case your kernel was compiled with CONFIG_MAGIC_SYSRQ enabled
(a feature that is present since Linux 2.1.43)
there is a single key (defined in <CODE>&lt;linux/keyboard.h&gt;</CODE>)
to which special system functions are attached, regardless of the
current keyboard mode. For the PC architecture this special key is,
naturally, the Alt+SysRq key, and any of the two Alt keys will work.
(Note that if CONFIG_MAGIC_SYSRQ was not enabled, the default action
of this key is to return to the previous console.)</P>
<P>If you press this key, do not release it, and hit another key,
a corresponding action is performed. The action is performed whether
anybody is logged in or not, is root or not. For the details, see
<CODE>drivers/char/sysrq.c</CODE>. Since this feature is meant only
for kernel hackers, that should suffice. Still, let me add a few
remarks.</P>
<P>For the key r the keyboard mode is reset to K_XLATE.
For the key k a SAK and console reset is done.
For the key b the machine is rebooted immediately.
(See, not something you want to have enabled on a production machine.)
For the key o the power is turned off (when the machine is capable of that).
For the key s an emergency sync is scheduled.
For the key u an emergency read-only remount is scheduled.
For the keys p,t,m various information is shown
(namely the same information also shown for RAlt,RCtrl,RShift+ScrollLock).
For the keys e,i,l all processes get a SIG_TERM or SIG_KILL, respectively;
for l even the init process is killed.
Digits set the log level. Anything else prints a short summary:
<CODE>SysRq: unRaw saK Boot Off Sync Unmount showPc showTasks showMem
loglevel0-8 tErm kIll killalL</CODE>.</P>
<P>Note: These are very dangerous actions! And they do not use your
keymap - indeed, are meant for emergency cases where the state
of your keymap, or even of the entire kernel, is uncertain.
If you use a dvorak keyboard - bad luck! Most other people will
be able to survive: the dangerous letters A,M,Q,W,Y,Z that are
differently placed on English, French and German keyboards, are
not used for actions. (But if your finger slips and you hit L
instead of K - bye bye to your system.)</P>
<P>In Linux 2.3.13 the possibility to enable/disable SysRq was added.
<BLOCKQUOTE><CODE>
<PRE>
        echo 0 > /proc/sys/kernel/sysrq
</PRE>
</CODE></BLOCKQUOTE>

will disable it (if the kernel was compiled with CONFIG_MAGIC_SYSRQ).</P>

<H2><A NAME="ss8.7">8.7 Problems</A>
</H2>

<P>A good keyboard accurately reports multiple key presses.
Especially for people using a keyboard as Braille input device,
where they have to be able to press up to six keys simultaneously,
this is important. Many modern keyboards fail here due to sloppy
design and testing - they misreport or fail in other ways when
four or more keys are pressed simultaneously, sometimes already
when two non-modifier keys are pressed simultaneously.
This affects Linux users a bit: the SysRq key is not a modifier key,
and people report problems using Alt-SysRq-<I>X</I> for various
letters or digits <I>X</I>.</P>
<P>Long ago a similar problem (`ghosting') was caused by the design
of the scan matrix: when three keys were pressed a fourth was
also seen. That problem was solved by the use of diodes.
Today it is the interface logic that is deficient.</P>

<H2><A NAME="s9">9. How to get out of raw mode</A></H2>

<P>
<!--
raw mode, exiting
-->
</P>
<P>If some program using K_RAW keyboard mode exits without restoring the keyboard
mode to K_XLATE, then it is difficult to do anything - not even Ctrl-Alt-Del
works. However, it is sometimes possible to avoid hitting the reset button.
(And desirable as well: your users may get angry if you kill their Hack game
by rebooting; you might also damage your file system.)
Easy solutions involve logging in from another terminal or another machine
and doing <CODE>kbd_mode -a</CODE>.
The procedure below assumes that no X is running, that the display is in
text mode, and that you are at your bash prompt, that you are using a US
keyboard layout, and that your interrupt character is Ctrl-C.</P>
<P>Step 1. Start X.
As follows: press 2 (and don't release), press F12 (and don't release)
and immediately afterwards press = . This starts X.
(Explanation: if a key press produces keycode K, then the key release
produces keycode K+128. Probably your shell does not like these high
characters, so we avoid generating them by not releasing any key.
However, we have to be quick, otherwise key repeat starts. The digit 2
produces a Ctrl-C that discards previous junk, the F12 produces an X
and the = a Return.)
Probably your screen will be grey now, since no <CODE>.xinitrc</CODE> was specified.
However, Ctrl-Alt-Fn will work and you can go to another VT.
(Ctrl-Alt-Backspace also works, but that exits X, and gets you back into
the previous state, which is not what you want.)</P>
<P>Step 2. Setup to change the keyboard mode.
(For example, by <CODE>sleep 5; kbd_mode -a</CODE>.)</P>
<P>Step 3. Leave X again.
Alt-Fx (often Alt-F7) brings you back to X, and then Ctrl-Alt-Backspace
exits X. Within 5 seconds your keyboard will be usable again.</P>
<P>If you want to prepare for the occasion, then make
<CODE>\215A\301</CODE> (3 symbols) an alias for <CODE>kbd_mode -a</CODE>.
Now just hitting = F7 = (3 symbols) will return you to sanity.</P>

<H2><A NAME="s10">10. The keyboard LEDs</A></H2>

<P>
<!--
LEDs, keyboard
-->

<!--
keyboard!LEDs on
-->
</P>
<P>1. There are per-tty keyboard flags:
each VC has its own NumLock, CapsLock, ScrollLock.
By default these keyboard flags are shown in the LEDs.
The usual way to change them is by pressing the corresponding key.
(Side remark: pressing the NumLock key when in application key mode
will not change the NumLock status, but produce an escape sequence.
If you want the NumLock key to always change the Numlock status,
bind it to Bare_Num_Lock.)</P>
<P>2. Next, there are per-tty default keyboard flags,
to initialize the keyboard flags when a reset occurs.
Thus if you want NumLock on all the time, that is possible.
The usual way to change them is by `<CODE>setleds -D</CODE> ...'.</P>
<P>3. There is the possibility that the leds do not reflect
the keyboard flags, but something else.</P>
<P>3A. This something else can be three bits somewhere in the kernel -
which can be used if you want to monitor some hardware or software
status bit(s). If you want this, edit the kernel source to call
<CODE>register_leds()</CODE> somewhere.</P>
<P>3B. This something else can also be whatever some user program wants
to show in the LEDs. Thus, people who like such things can make
nice patterns of lights. If you want this, use the KDSETLED ioctl.</P>
<P>This latter use is not per-tty, but the choice between former
and latter use is per-tty.</P>
<P>Summarizing: Each tty has a flag <CODE>kbd->ledmode</CODE>.
If this has the value LED_SHOW_FLAGS then the keyboard flags
(NumLock etc.) of that tty are shown.
If this has the value LED_SHOW_MEM then three selected memory
addresses are shown.
If this has the value LED_SHOW_IOCTL then the leds show whatever
value was last assigned to them using the KDSETLED ioctl.</P>
<P>One may add that X uses ioctl's to set the LEDs, but fails
to reset its VT when it exits, so after using X there may
be one VT that is not in the default LED_SHOW_FLAGS state.
This can be fixed by doing `<CODE>setleds -L</CODE>' on that VT.
See setleds(1).</P>

<H2><A NAME="s11">11. The TERM variable</A></H2>

<P>
<!--
TERM environment variable
-->

<!--
environment variables!TERM
-->
</P>
<P>Many programs use the <CODE>TERM</CODE> variable and the database
<CODE>/etc/termcap</CODE> or <CODE>/usr/lib/terminfo/*</CODE> to decide
which strings to send for clear screen, move cursor, etc.,
and sometimes also to decide which string is sent
by the users backspace key, function keys etc.
This value is first set by the kernel (for the console).
Usually, this variable is re-set by <CODE>getty</CODE>, using <CODE>/etc/ttytype</CODE> or
the argument specified in <CODE>/etc/inittab</CODE>.
Sometimes, it is also set in <CODE>/etc/profile</CODE>.</P>
<P>Older systems use <CODE>TERM=console</CODE> or <CODE>TERM=con80x25</CODE>. Newer systems (with
ncurses 1.8.6) use the more specific <CODE>TERM=linux</CODE> or <CODE>TERM=linux-80x25</CODE>.
However, old versions of <CODE>setterm</CODE> test for <CODE>TERM=con*</CODE> and hence fail
to work with <CODE>TERM=linux</CODE>.</P>
<P>Since kernel version 1.3.2, the kernel default for the console is
<CODE>TERM=linux</CODE>.</P>
<P>If you have a termcap without entry for linux, add the word linux
to the entry for the console:
<BLOCKQUOTE><CODE>
<PRE>
        console|con80x25|linux:\
</PRE>
</CODE></BLOCKQUOTE>

and make <CODE>/usr/lib/terminfo/l/linux</CODE> a copy of or symbolic link to
<CODE>/usr/lib/terminfo/c/console</CODE>.</P>

<H2><A NAME="ss11.1">11.1 Terminfo</A>
</H2>

<P>
<!--
terminfo
-->
</P>
<P>The terminfo entry for the linux console from ncurses 1.8.6 misses the
entry <CODE>kich1=\E[2~</CODE>, needed by some programs.
Edit the file and <CODE>tic</CODE> it.</P>

<H2><A NAME="s12">12. How to make other programs work with non-ASCII chars</A></H2>

<P>
<!--
non-ASCII characters, using
-->
</P>
<P>In the bad old days this used to be quite a hassle. Every separate
program had to be convinced individually to leave your bits alone.
Not that all is easy now, but recently a lot of gnu utilities have
learned to react to <CODE>LC_CTYPE=iso_8859_1</CODE> or <CODE>LC_CTYPE=iso-8859-1</CODE>.
Try this first, and if it doesn't help look at the hints below.
Note that in recent versions of libc the routine setlocale() only
works if you have installed the locale files (e.g. in
<CODE>/usr/lib/locale</CODE>).</P>
<P>First of all, the 8-th bit should survive the kernel input processing,
so make sure to have <CODE>stty cs8 -istrip -parenb</CODE> set.</P>
<P>A. For <CODE>emacs</CODE> the details strongly depend on the version.
The information below is for version 19.34. Put lines
<BLOCKQUOTE><CODE>
<PRE>
        (set-input-mode nil nil 1)
        (standard-display-european t)
        (require 'iso-syntax)
</PRE>
</CODE></BLOCKQUOTE>

into your <CODE>$HOME/.emacs</CODE>.
The first line (to be precise: the final 1)
tells <CODE>emacs</CODE> not to discard the 8-th bit from input characters.
The second line tells <CODE>emacs</CODE> not to display non-ASCII characters
as octal escapes.
The third line specifies the syntactic properties
and case conversion table for the Latin-1 character set
These last two lines are superfluous if you have something like
<CODE>LC_CTYPE=ISO-8859-1</CODE> in your environment.
(The variable may also be <CODE>LC_ALL</CODE> or even <CODE>LANG</CODE>.
The value may be anything with a substring `88591' or `8859-1'
or `8859_1'.)</P>
<P>This is a good start.
On a terminal that cannot display non-ASCII ISO 8859-1 symbols,
the command
<BLOCKQUOTE><CODE>
<PRE>
        (load-library "iso-ascii")
</PRE>
</CODE></BLOCKQUOTE>

will cause accented characters to be displayed comme {,c}a.
If your keymap does not make it easy to produce non-ASCII characters, 
then
<BLOCKQUOTE><CODE>
<PRE>
        (load-library "iso-transl")
</PRE>
</CODE></BLOCKQUOTE>

will make the 2-character sequence Ctrl-X 8 a compose character,
so that the 4-character sequence Ctrl-X 8 , c produces c-cedilla.
Very inconvenient.</P>
<P>The command
<BLOCKQUOTE><CODE>
<PRE>
        (iso-accents-mode)
</PRE>
</CODE></BLOCKQUOTE>

will toggle ISO-8859-1 accent mode, in which the six
characters ', `, ", ^, ~, / are dead keys
modifying the following symbol.
Special combinations: ~c gives a c with cedilla,
~d gives an Icelandic eth, ~t gives an Icelandic thorn,
"s gives German sharp s, /a gives a with ring,
/e gives an a-e ligature, ~&lt; and ~&gt; give guillemots,
~! gives an inverted exclamation mark,
~? gives an inverted question mark, and '' gives an acute accent.
This is the default mapping of accents.
The variable <CODE>iso-languages</CODE> is a list of pairs (language name,
accent mapping), and a non-default mapping can be selected using
<BLOCKQUOTE><CODE>
<PRE>
        (iso-accents-customize LANGUAGE)
</PRE>
</CODE></BLOCKQUOTE>

Here LANGUAGE can be one of <CODE>"portuguese"</CODE>, <CODE>"irish"</CODE>,
<CODE>"french"</CODE>, <CODE>"latin-2"</CODE>, <CODE>"latin-1"</CODE>.</P>
<P>Since the Linux default compose character is Ctrl-.
it might be convenient to use that everywhere. Try
<BLOCKQUOTE><CODE>
<PRE>
        (load-library "iso-insert.el")
        (define-key global-map [?\C-.] 8859-1-map)
</PRE>
</CODE></BLOCKQUOTE>

The latter line will not work under <CODE>xterm</CODE>, if you use <CODE>emacs -nw</CODE>,
but in that case you can put
<BLOCKQUOTE><CODE>
<PRE>
        XTerm*VT100.Translations:       #override\n\
              Ctrl &lt;KeyPress> . : string("\0308")
</PRE>
</CODE></BLOCKQUOTE>

in your <CODE>.Xresources</CODE>.)</P>
<P>B. For <CODE>less</CODE>, put <CODE>LESSCHARSET=latin1</CODE> in the environment.
This is also what you need if you see <CODE>\255</CODE> or <CODE>&lt;AD&gt;</CODE>
in <CODE>man</CODE> output: some versions of <CODE>less</CODE> will render the soft hyphen
(octal 0255, hex 0xAD) this way when not given permission to output Latin-1.</P>
<P>C. For <CODE>ls</CODE>, give the option <CODE>-N</CODE>. (Probably you want to make an alias.)</P>
<P>D. For <CODE>bash</CODE> (version 1.13.*), put
<BLOCKQUOTE><CODE>
<PRE>
        set meta-flag on
        set convert-meta off
        set output-meta on
</PRE>
</CODE></BLOCKQUOTE>

into your <CODE>$HOME/.inputrc</CODE>.</P>
<P>E. For <CODE>tcsh</CODE>, use
<BLOCKQUOTE><CODE>
<PRE>
        setenv LANG     US_en
        setenv LC_CTYPE iso_8859_1
</PRE>
</CODE></BLOCKQUOTE>

If you have nls on your system, then the corresponding routines are used.
Otherwise <CODE>tcsh</CODE> will assume iso_8859_1, regardless of the values given to
LANG and LC_CTYPE. See the section NATIVE LANGUAGE SYSTEM in tcsh(1).
(The Danish HOWTO says: <CODE>setenv LC_CTYPE ISO-8859-1; stty pass8</CODE>)</P>
<P>F. For <CODE>flex</CODE>, give the option <CODE>-8</CODE> if the parser it generates must be
able to handle 8-bit input. (Of course it must.)</P>
<P>G. For <CODE>elm</CODE>, set <CODE>displaycharset</CODE> to <CODE>ISO-8859-1</CODE>.
(Danish HOWTO: <CODE>LANG=C</CODE> and <CODE>LC_CTYPE=ISO-8859-1</CODE>)</P>
<P>H. For programs using curses (such as <CODE>lynx</CODE>) David Sibley reports:
The regular curses package uses the high-order bit for reverse video mode
(see flag _STANDOUT defined in <CODE>/usr/include/curses.h</CODE>).  However,
<CODE>ncurses</CODE> seems to be 8-bit clean and does display iso-latin-8859-1
correctly.</P>
<P>I. For programs using <CODE>groff</CODE> (such as <CODE>man</CODE>), make sure to use
<CODE>-Tlatin1</CODE> instead of <CODE>-Tascii</CODE>. Old versions of the program <CODE>man</CODE>
also use <CODE>col</CODE>, and the next point also applies.</P>
<P>J. For <CODE>col</CODE>, make sure 1) that it is fixed so as to do
<CODE>setlocale(LC_CTYPE,"");</CODE> and 2) put
<CODE>LC_CTYPE=ISO-8859-1</CODE> in the environment.</P>
<P>K. For <CODE>rlogin</CODE>, use option <CODE>-8</CODE>.</P>
<P>L. For <CODE>joe</CODE>,
<CODE>metalab.unc.edu:/pub/Linux/apps/editors/joe-1.0.8-linux.tar.gz</CODE>
is said to work after editing the configuration file. Someone else said:
<CODE>joe</CODE>: Put the <CODE>-asis</CODE> option in <CODE>/isr/lib/joerc</CODE> in the
first column.</P>
<P>M. For LaTeX: <CODE>\documentstyle[isolatin]{article}</CODE>.
For LaTeX2e: <CODE>\documentclass{article}\usepackage{isolatin}</CODE>
where <CODE>isolatin.sty</CODE> is available from
<A HREF="ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit">ftp.vlsivie.tuwien.ac.at/pub/8bit</A>.</P>
<P>A nice discussion on the topic of ISO-8859-1 and how to manage 8-bit
characters is contained in the file <CODE>grasp.insa-lyon.fr:/pub/faq/fr/accents</CODE>
(in French). Another fine discussion (in English) can be found in
<A HREF="ftp://rtfm.mit.edu/pub/usenet-by-group/comp.answers/internationalization/iso-8859-1-charset">rtfm.mit.edu:pub/usenet-by-group/comp.answers/internationalization/iso-8859-1-charset</A>.</P>
<P>If you need to fix a program that behaves badly with 8-bit characters,
one thing to keep in mind is that if you have a signed char type then
characters may be negative, and using them as an array index will fail.
Several programs can be fixed by judiciously adding (unsigned char) casts.</P>

<H2><A NAME="s13">13. X</A></H2>


<P>This FAQ/HOWTO is about the Linux keyboard and console, not about X,
which substitutes its own handling. However, it seems useful to
document some of the Linux keyboard and console related properties
of X.</P>
<P>First of all, when X is started (say using <CODE>startx</CODE> or <CODE>xinit</CODE>)
it opens the first unused console, unless the desired console has been
indicated explicitly, as in <CODE>xinit -- vt12</CODE>.
Note that this will fail when there is no device file <CODE>/dev/tty12</CODE>,
but that it will not fail when the indicated console was in use already.
When X finishes, it will return to the original console.
While it is running one can use Ctrl-Alt-Fn to switch to VTn.</P>
<P>The XFree86 keymap mechanism is much poorer than the Linux mechanism.
For each keycode there are at most 4 symbols defined, namely for the
4 keymaps plain, shift, mod, mod+shift. What is the modifier mod?
It is the one designated by the symbol <CODE>Mode_switch</CODE>.
For example, the command <CODE>xmodmap keys.dk</CODE>, where the file
<CODE>keys.dk</CODE> contains
<BLOCKQUOTE><CODE>
<PRE>
keycode 64 = Mode_switch
keycode 113 = Mode_switch
keycode 38 = a A aring Aring
keycode 26 = e E ae AE
keycode 32 = o O oslash Ooblique
</PRE>
</CODE></BLOCKQUOTE>

will make both Alt keys into mod keys, so that Alt+a gives  (a-ring), etc.
(Note the illogical naming of oslash and Ooblique.)
Such an <CODE>xmodmap</CODE> command can be placed in the <CODE>.xinitrc</CODE>
shell script that is executed by default when X is started.</P>

<H2><A NAME="ss13.1">13.1 What precisely does XFree86-2.1 do when it initializes its keymap?</A>
</H2>

<P>
<!--
keymap!initialization by XFree86
-->

<!--
XFree86!keymap initialization
-->
</P>
<P>Since version 2.1, XFree86 will initialize its keymap from the Linux keymap,
as far as possible. However, Linux had 16 entries per key (one for each
combination of the Shift, AltGr, Ctrl, Alt modifiers) and presently has
256 entries per key, while X has 4 entries per key (one for each combination
of Shift, Mod), so some information is necessarily lost.</P>
<P>First <CODE>X</CODE> reads the <CODE>Xconfig</CODE> file, where definitions of the LeftAlt, RightAlt,
RightCtl, ScrollLock keys as Meta, ModeShift, Compose, ModeLock or ScrollLock
might be found - see X386keybd(1), later XFree86kbd(1).</P>
<P>For Mod the LeftAlt key is taken, unless RightCtl was defined as ModeShift or
ModeLock, in which case RightCtl is taken, or RightAlt was so defined, in which
case RightAlt is taken.
This determines how the 4 XFree86 meanings of a key are selected from the 16
Linux meanings.
Note that Linux today does not distinguish by default between the two Ctrl keys
or between the two Shift keys. <CODE>X</CODE> does distinguish.</P>
<P>Now the kernel keymap is read and the usually obvious corresponding X
bindings are made. The bindings for the "action keys" Show_Memory, Show_State,
Show_Registers, Last_Console, Console_n, Scroll_Backward, Scroll_Forward,
Caps_On and Boot are ignored, as are the dead diacriticals, and the locks
(except for ShiftLock), and the "ASCII-x" keys.</P>
<P>Next, the definitions in the <CODE>Xconfig</CODE> file are used. (Thus, a definition
of Compose in <CODE>Xconfig</CODE> will override its value as found in the Linux
keymap.)</P>
<P>What happens to the strings associated with the function keys? Nothing,
X does not have such a concept. (But it is possible to define strings
for function keys in <CODE>xterm</CODE> - note however that the window manager gets the
keys first.)</P>
<P>I don't know how to convince <CODE>xterm</CODE> that it should use the X keymap
when Alt is pressed; it seems just to look at its resource <CODE>eightBitInput</CODE>,
and depending on whether that is true or false either set the high order bit
of the character, or generate an additional Escape character
(just like setmetamode(1) does for the console).</P>

<H2><A NAME="s14">14. Unusual keys and keyboards</A></H2>

<P>
<!--
keyboard!unusual versions of
-->

<!--
keyboard!non-standard keys on
-->
</P>
<P>The two keys PrintScrn/SysRq and Pause/Break are special in that they
have two keycodes: the former has keycode 84 when Alt is pressed
simultaneously, and keycode 99 otherwise; the latter has keycode
101 when Ctrl is pressed simultaneously, and keycode 119 otherwise.
(Thus, it makes no sense to bind functions to Alt keycode 99 or
Ctrl keycode 119.) The Pause/Break key is also special in another way:
it does not generate key-up scancodes, but generates the entire
6-scancode sequence on key-down.</P>
<P>If you have strange keys, that do not generate any code under Linux
(or generate messages like "unrecognized scancode"), and your kernel
is 1.1.63 or later, then you can use setkeycodes(1) to tell the kernel
about them. Once they have gotten a keycode from <CODE>setkeycodes</CODE>,
they can be assigned a function by <CODE>loadkeys</CODE>.</P>
<P>For example, using <CODE>showkey -s</CODE> one sees that Microsoft keyboards
use the scancode sequences (in hexadecimal) e0 5b (left Windows key),
e0 5c (right Windows key), e0 5d (Menu key).
Microsoft Internet keyboard also uses e0 6a (Back), e0 69 (Forward),
e0 68 (Stop), e0 6c (Mail), e0 65 (Search), e0 66 (Favorites),
e0 32 (Web/Home), e0 6b (My Computer), e0 21 (Calculator), e0 5f (Sleep).
Use <CODE>dumpkeys</CODE> to see what keycodes are still unused.
Typically values like 89-95 and 112-118 and 120-127 are free.
Now
<BLOCKQUOTE><CODE>
<PRE>
        % setkeycodes e05b 125
        % setkeycodes e05c 126
        % setkeycodes e05d 127
</PRE>
</CODE></BLOCKQUOTE>

assigns keycodes to these scancode sequences, and
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys
        keycode 125 = Decr_Console
        keycode 126 = Incr_Console
        keycode 127 = KeyboardSignal
        %
</PRE>
</CODE></BLOCKQUOTE>

would make these Windows keys go to the previous or next virtual console,
and let the Menu key create a fresh virtual console (in case you have
something like <CODE>spawn_console</CODE> running).</P>

<H2><A NAME="ss14.1">14.1 Funkeys</A>
</H2>

<P>Many modern keyboards have buttons or keys with labels like
"Vol Up", "Eject" etc. that suggest actions rather than strings.
Of course one can bind shell commands to them, but then they'll
work only when you are at a shell prompt.
Rick van Rein wrote a package funkey consisting of a kernel patch
and a daemon. The kernel patch creates a new character device,
and adds a new key type to indicate which keystrokes should be
sent to this new character device. A daemon can now listen to
the character device, somewhat like <CODE>gpm</CODE> listens to the
mouse device, and perform the actions indicated in its config file.
See 
<A HREF="http://rick.vanrein.org/linux/funkey">rick.vanrein.org/linux/funkey</A>.</P>

<H2><A NAME="s15">15. Examples of use of loadkeys and xmodmap</A></H2>

<P>
<!--
loadkeys!example using
-->

<!--
xmodmap!example using
-->
</P>
<P>Switching Caps Lock and Control on the keyboard (assuming you use
keymaps 0-15; check with <CODE>dumpkeys | head -1</CODE>)
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys
        keymaps 0-15
        keycode 58 = Control
        keycode 29 = Caps_Lock
        %
</PRE>
</CODE></BLOCKQUOTE>

Switching them under X only:
<BLOCKQUOTE><CODE>
<PRE>
        % xmodmap .xmodmaprc
</PRE>
</CODE></BLOCKQUOTE>

where <CODE>.xmodmaprc</CODE> contains lines
<BLOCKQUOTE><CODE>
<PRE>
        remove Lock = Caps_Lock
        remove Control = Control_L
        keysym Control_L = Caps_Lock
        keysym Caps_Lock = Control_L
        add Lock = Caps_Lock
        add Control = Control_L
</PRE>
</CODE></BLOCKQUOTE>

What is this about the key numbering? Backspace is 14 under Linux,
22 under X?  Well, the numbering can best be regarded as arbitrary;
the Linux number of a key can be found using showkey(1), and the
X number using xev(1). Often the X number will be 8 more than the
Linux number.</P>
<P>Something else people like to change are the bindings of the function keys.
Suppose that you want to make F12 produce the string "emacs ".
Then
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys
        keycode 88 = F12
        string F12 = "emacs "
        %
</PRE>
</CODE></BLOCKQUOTE>

will do this. More explicitly, the procedure is like this:
(i) find the keycodes of the keys to be remapped, using showkey(1).
(ii) save the current keymap, make a copy and edit that:
<BLOCKQUOTE><CODE>
<PRE>
        % dumpkeys > my_keymap
        % cp my_keymap trial_keymap
        % emacs trial_keymap
        % loadkeys trial_keymap
        %
</PRE>
</CODE></BLOCKQUOTE>

The format of the table can be guessed by looking at the output
of <CODE>dumpkeys</CODE>, and is documented in keymaps(5).
When the new keymap functions as desired, you can put an invocation
<BLOCKQUOTE><CODE>
<PRE>
        loadkeys my_new_keymap
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>/etc/rc.local</CODE> or so, to execute it automatically at boot-up.
Note that changing modifier keys is tricky, and a newbie can easily
get into a situation only an expert can get out of.</P>
<P>The default directory for keymaps is <CODE>/usr/lib/kbd/keymaps</CODE>.
The default extension for keymaps is <CODE>.map</CODE>.
For example, <CODE>loadkeys uk</CODE> would probably load
<CODE>/usr/lib/kbd/keymaps/i386/qwerty/uk.map</CODE>.
(With kbd-0.95 and older this would be <CODE>/usr/lib/kbd/keytables</CODE>
and <CODE>/usr/lib/kbd/keytables/uk.map</CODE>.)</P>

<P>(On my machine) <CODE>/dev/console</CODE> is a symbolic link to <CODE>/dev/tty0</CODE>,
and the kernel regards <CODE>/dev/tty0</CODE> as a synonym for the current VT.
XFree86 1.3 changes the owner of <CODE>/dev/tty0</CODE>, but does not reset this
after finishing. Thus, <CODE>loadkeys</CODE> or <CODE>dumpkeys</CODE> might fail because
someone else owns <CODE>/dev/tty0</CODE>;
in such a case you might run X first.
Note that you cannot change keyboard mappings when not at the console
(and not superuser).</P>

<H2><A NAME="ss15.1">15.1 `I can use only one finger to type with'</A>
</H2>

<P>
<!--
keyboard!making modifier keys toggle
-->
</P>
<P>"Can the Shift, Ctrl and Alt keys be made to behave as toggles?"</P>
<P>Yes, after saying
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys
        keymaps 0-15
        keycode 29 = Control_Lock
        keycode 42 = Shift_Lock
        keycode 56 = Alt_Lock
        %
</PRE>
</CODE></BLOCKQUOTE>

the left Control, Shift and Alt keys will act as toggles.
The numbers involved are revealed by showkey
(and usually are 29, 97, 42, 54, 56, 100 for left and right control,
shift and alt, respectively), and the functions are
Control_Lock, Shift_Lock, Alt_Lock, ALtGr_Lock.</P>
<P>"What about `sticky' modifier keys?"</P>
<P>Since version 1.3.33, the kernel knows about `sticky' modifier keys.
These act on the next key pressed. So, where one earlier needed
the 3-symbol sequence Shift_Lock a Shift_Lock to type `A', one
can now use the 2-symbol sequence SShift_Lock a.
You can say
<BLOCKQUOTE><CODE>
<PRE>
        % loadkeys
        keymaps 0-15
        keycode 54 = SShift
        keycode 97 = SCtrl
        keycode 100 = SAlt
        %
</PRE>
</CODE></BLOCKQUOTE>

to make the right Shift, Ctrl, Alt sticky versions of the left ones.
This will allow you to type Ctrl-Alt-Del in three keystrokes with one hand.</P>
<P>The keymaps line in these examples should cover all keymaps you have in use.
You find what keymaps you have in use by
<BLOCKQUOTE><CODE>
<PRE>
        % dumpkeys | head -1
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss15.2">15.2 Sticky keys under <CODE>X</CODE></A>
</H2>

<P>The following text was contributed by Piotr Mitros.</P>
<P>XFree86 supports an accessibility option which allows disabled users
to type single-handed. With sticky keys enabled, the user can hit a
modifier key (ctrl, alt, shift) followed by another key, rather than
having to hold the modifier key while hitting the letter. </P>
<P>To enable sticky keys, first make sure the xkb extension is enabled
(this is done during initial <CODE>X</CODE> server configuration and is usually
enabled by default). Next, run the <CODE>X</CODE> server with the <CODE>+accessx</CODE>
option. If you use <CODE>startx</CODE>, either run <CODE>startx -- +accessx</CODE> or
add <CODE>+accessx</CODE> to the serverargs line in the <CODE>startx</CODE> script.
If you use <CODE>xdm</CODE>, add <CODE>+accessx</CODE> to the appropriate server line
in <CODE>/etc/X11/xdm/Xservers</CODE>.</P>
<P>It is also possible to enable <CODE>X</CODE> accessibility with some end-user
utilities with a running <CODE>X</CODE> server.</P>
<P>Once <CODE>X</CODE> accessibility is enabled, press the shift key five times in a
row to enable sticky keys. To disable sticky keys, either press the
shift key five times again, or press a key while holding a modifier
key.</P>
<P>XFree86 also supports Slow Keys, Repeat Keys, Bounce Keys and an
audible bell. <CODE>xkbcomp</CODE> can be used to generate a <CODE>.xkm</CODE> file
to enable these. The appropriate <CODE>xkbcomp</CODE> commands are listed in
<CODE>/usr/X11R6/lib/X11/xkb/compat/accessx</CODE>.
Unfortunately, the exact process is still undocumented.</P>

<H2><A NAME="s16">16. Changing the video mode</A></H2>

<P>
<!--
console!changing video modes
-->

<!--
video modes, changing
-->

<!--
resolution, changing
-->
</P>
<P>As far as I know there are 6 ways to change resolution:</P>
<P>1. At compile time: change the line
<BLOCKQUOTE><CODE>
<PRE>
        SVGA_MODE=      -DSVGA_MODE=NORMAL_VGA
</PRE>
</CODE></BLOCKQUOTE>

in <CODE>/usr/src/linux/Makefile</CODE>.</P>
<P>1A. After compilation: use <CODE>rdev -v</CODE> - a terrible hack, but it exists.</P>
<P>2. At boot time: put <CODE>vga=ask</CODE> in the lilo config file, and lilo will
ask you what video mode you want. Once you know, put <CODE>vga=</CODE>mypreference.</P>
<P>3. At run time:
A. Use the <CODE>resizecons</CODE> command. (This is a very primitive wrapper around
the VT_RESIZE ioctl.)
B. Use the <CODE>SVGATextMode</CODE> command. (This is a less primitive wrapper around
the VT_RESIZE ioctl.)</P>
<P>4. Not "on the console":
Under <CODE>dosemu</CODE>, or with svgalib etc. you can change the hardware video mode
without the console driver being aware of it. Sometimes this is useful in
getting <CODE>resizecons</CODE> or <CODE>SVGATextMode</CODE> set up: use <CODE>dosemu</CODE> and some
DOS program to get into the desired videomode, dump (say from another VT) the
contents of all video hardware registers, and use that in the initialization
that <CODE>resizecons</CODE> and <CODE>SVGATextMode</CODE> require.
In some cases where the video mode has gotten into some unusable state,
starting <CODE>dosemu</CODE>, relying on the BIOS to set up the video mode, and then
killing <CODE>dosemu</CODE> (with <CODE>kill -9</CODE>), is the easiest way to get into shape
again.</P>

<H2><A NAME="ss16.1">16.1 Instructions for the use of resizecons</A>
</H2>

<P>
<!--
resizecons program
-->
</P>
<P>Get svgalib and compile the program <CODE>restoretextmode</CODE>.
Boot up your machine in all possible video modes
(using <CODE>vga=ask</CODE> in the lilo config file), and write
the video hardware register contents to files CxR
(C=cols, R=rows), e.g., 80x25, 132x44, etc.
Put these files in <CODE>/usr/lib/kbd/videomodes</CODE>.
Now <CODE>resizecons 132x44</CODE> will change videomode for you
(and send SIGWINCH to all processes that need to know
about this, and load another font if necessary).</P>
<P>At present, <CODE>resizecons</CODE> only succeeds when there is memory enough
for both the old and the new consoles at the same time.</P>

<H2><A NAME="s17">17. Changing the keyboard repeat rate</A></H2>

<P>
<!--
keyboard!repeat rate, setting
-->
</P>
<P>At startup, the Linux kernel sets the repeat rate to its maximal value.
For most keyboards this is reasonable, but for some it means that you
can hardly touch a key without getting three copies of the corresponding
symbol. Use the program kbdrate(8) to change the repeat rate, or, if
that doesn't help, edit or remove the section
<HR>
<PRE>
     ! set the keyboard repeat rate to the max

         mov     ax,#0x0305
         xor     bx,bx           ! clear bx
         int     0x16
</PRE>
<HR>

of <CODE>/usr/src/linux/[arch/i386/]boot/setup.S</CODE>.</P>
<P>Scott Johnston (<CODE>sj@zule.com</CODE>) reports: `To program the
repeat rate of a Gateway AnyKey keyboard all one has to do
is press the "Repeat Rate" key, then a function key
F1-F8, then "Repeat Rate" again.  F1 is the slowest possible repeat rate,
and F8 is really fast.  If you somehow manage to mess up your AnyKey
keyboard doing this, simply press Ctrl-Alt-SuspndMacro to reset
your keyboard to factory default settings.'</P>

<H2><A NAME="s18">18. Scrolling</A></H2>

<P>
<!--
console!scrolling
-->

<!--
scrolling, console
-->
</P>
<P>There are two ways to get a screen to scroll.
The first, called `hard scrolling', is to leave the text in
video memory as it is, but change the viewing origin. This is
very fast.
The second, called `soft scrolling', involves moving all screen text
up or down. This is much slower.
The kernel console driver will write text starting at the top of
the video memory, continuing to the bottom, then copy the bottom
part to the top again, and continue, all the time using hard scrolling
to show the right part on the screen.
You can scroll back until the top op the video memory by using
Shift-PageUp (the grey PageUp) and scroll down again using
Shift-PageDown (the grey PageDown), assuming a default keymap.
The amount of scrollback is thus limited to the amount of video memory
you happen to have and you cannot increase this amount.
If you need more scrollback, use some program that
buffers the text, like <CODE>less</CODE> or <CODE>screen</CODE> - by using
a buffer on disk you can go back to what you did last week.
(One can set the amount of scrollback for <CODE>xterm</CODE> by
adding a line like <CODE>XTerm*saveLines: 2500</CODE> in <CODE>.Xresources</CODE>.)</P>
<P>Upon changing virtual consoles, the screen content of the old VT
is copied to kernel memory, and the screen content of the new VT
is copied from kernel memory to video memory. Only the visible screen
is copied, not all of video memory, so switching consoles means
losing the scrollback information.</P>
<P>Sometimes, hard scrolling is undesirable, for example when the hardware
does not have the possibility to change viewing origin. The first
example was a Braille machine that would render the top of video
memory in Braille. There is a kernel boot-time option <CODE>no-scroll</CODE>
to tell the console driver not to use hard scrolling.
See bootparam(7).</P>

<H2><A NAME="s19">19. Screensaving</A></H2>

<P>
<!--
screensaving!controlling
-->

<!--
screen blanking
-->
</P>
<P><CODE>setterm -blank</CODE> <I>nn</I> will tell the console driver to blank the
screen after <I>nn</I> minutes of inactivity. (With <I>nn</I> = 0, screensaving
is turned off. In some old kernels this first took effect after the next
keyboard interrupt.)</P>
<P>The <CODE>s</CODE> option of xset(1) will set the X screensaving parameters:
<CODE>xset s off</CODE> turns off the screensaver,
<CODE>xset s 10</CODE> blanks the screen after 10 minutes.</P>
<P>The video hardware powersaving modes can be enabled/disabled
using the <CODE>setvesablank</CODE> program given in the starting comment of
<CODE>/usr/src/linux/drivers/char/vesa_blank.c</CODE>.</P>

<H2><A NAME="s20">20. Screen dumps</A></H2>

<P>
<!--
console!screenshots, obtaining
-->

<!--
screenshots!obtaining from console
-->
</P>
<P><CODE>setterm -dump</CODE> <I>N</I> will dump the contents of the
screen of <CODE>/dev/tty</CODE><I>N</I> to a file <CODE>screen.dump</CODE>
in the current directory. See setterm(1).</P>
<P>The current contents of the screen of <CODE>/dev/tty</CODE><I>N</I>
can be accessed using the device <CODE>/dev/vcs</CODE><I>N</I>
(where `vcs' stands for `virtual console screen').
For example, you could have a clock program that displays the
current time in the upper right hand corner of the console screen
(see the program <CODE>vcstime</CODE> in <CODE>kbd-1.04.tar.gz</CODE>).
Just dumping the contents goes with <CODE>cat /dev/vcs</CODE><I>N</I>.
These device files <CODE>/dev/vcs</CODE><I>N</I> do not contain
newlines, and do not contain attributes, like colors. From a program
it is usually better to use <CODE>/dev/vcsa</CODE><I>N</I>
(`virtual console screen with attributes') instead - it starts with
a header giving the number of rows and columns and the location
of the cursor.
See vcs(4).</P>

<H2><A NAME="s21">21. Some properties of the VT100 - application key mode</A></H2>

<P>
<!--
keyboard!VT100 application key mode
-->

<!--
VT100 application key mode
-->
</P>
<P>: Sometimes my cursor keys or keypad keys produce strange codes?</P>
<P>When the terminal is in application cursor key mode the cursor keys
produce  Esc O x  and otherwise  Esc [ x  where x is one of A,B,C,D.
Certain programs put the terminal in application cursor key mode;
if you kill them with <CODE>kill -9</CODE>, or if they crash, then the mode will
not be reset.
<PRE>
        % echo -e '\033c'  
</PRE>

resets all properties of the current VC. Just changing the cursor
application key mode is done by
<PRE>
        % echo -e '\033[?1h' 
</PRE>

(set) and
<PRE>
        % echo -e '\033[?1l' 
</PRE>

(clear).</P>
<P>When the terminal is in application keypad key mode the keypad keys
produce  Esc O y  and otherwise  Esc [ z ~  for
certain y and z. Setting application keypad key mode is done by
<PRE>
        % echo -e '\033=' 
</PRE>

and
<PRE>
        % echo -e '\033&gt;' 
</PRE>

clears it again.</P>

<H2><A NAME="s22">22. Hardware incompatibility</A></H2>

<P>
<!--
keyboard!hardware incompatibilities
-->

<!--
incompatibility!keyboard-related
-->
</P>
<P>Several people have noticed that they lose typed characters when
a floppy disk is active. It seems that this might be a problem with
Uni-486WB motherboards.</P>
<P>Tjalling Tjalkens (<CODE>tjalling@ei.ele.tue.nl</CODE>) reports very similar problems
with "a no-brand GMB-486 UNP Vesa motherboard with AMD 486DX2-66 CPU" -
during floppy activity some keystrokes are lost, during floppy tape streamer
(Conner C 250 MQ) activity many keystrokes are lost.</P>
<P>Some people experience sporadic lockups - sometimes associated to
hard disk activity or other I/O.</P>
<P>Ulf Tietz (<CODE>ulf@rio70.bln.sni.de</CODE>) wrote:
`I have had the same problems, when I had my motherboard tuned too fast.
So I reset all the timings ( CLK, wait statements etc ) to more 
conventional values, and the problems are gone.'</P>
<P>Bill Hogan (<CODE>bhogan@crl.com</CODE>) wrote:
`If you have an AMI BIOS, you might try setting the Gate A20 emulation
parameter to "chipset" (if you have that option). Whenever I have had
that parameter set to any of the other options on my machine
("fast", "both", "disabled") I have had frequent keyboard lockups.'</P>
<P>There may be a relation between keyboard problems and the video card in use.</P>
<P>Shawn K. Quinn (<CODE>skquinn@wt.net</CODE>) wrote:
`I have a Zeos Pantera Pentium-90 that originally came with a Diamond Stealth
64 S3-based video card. Under X I frequently got q's inserted into my text
(how annoying) especially if I typed very fast (during Netrek for instance,
even more annoying because guess what that does :-( ).
Switching to a Creative Labs Graphics Blaster MA202 solved the problem.
I'm assuming the Stealth 64 did something funny with the timings.'</P>

<H2><A NAME="s23">23. Copyright</A></H2>

<P>Copyright (c) 1993-2001 by Andries Brouwer.  This document may be
distributed under the terms set forth in the LDP license 
at 
<A HREF="http://metalab.unc.edu/LDP/COPYRIGHT.html">http://metalab.unc.edu/LDP/COPYRIGHT.html</A> or
<A HREF="ftp://www.win.tue.nl/pub/linux/LDP/COPYRIGHT.txt">ftp://www.win.tue.nl/pub/linux/LDP/COPYRIGHT.txt</A>.</P>
<P>Additions and corrections are welcome.
Andries Brouwer - <CODE>aeb@cwi.nl</CODE></P>

</BODY>
</HTML>
