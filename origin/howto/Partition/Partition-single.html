<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Linux Partition HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="This Linux Mini-HOWTO teaches you how to plan and create partitions on IDE and SCSI hard drives. It discusses partitioning terminology and considers size and location issues. Use of the fdisk partitioning utility for creating and recovering of partition tables is covered. The most recent version of this document is here. The Turkish translation is here."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="index"></a>Linux Partition HOWTO</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Anthony</span> <span class="surname">Lissot</span></h3></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 3.5</td><td align="left">26 Dec 2005</td></tr><tr><td align="left" colspan="2">    
      		reorganized document page ordering.
			added page on setting up swap space.
			added page of partition labels.
			updated max swap size values in section 4.
			added instructions on making ext2/3 file systems.
			broken links identified by Richard Calmbach are fixed.
			created an XML version.
        </td></tr><tr><td align="left">Revision 3.4.4</td><td align="left">08 March 2004</td></tr><tr><td align="left" colspan="2">
				synchronized SGML version with HTML version. 
				Updated lilo placement and swap size discussion.
        </td></tr><tr><td align="left">Revision 3.3</td><td align="left">04 April 2003</td></tr><tr><td align="left" colspan="2">synchronized SGML and HTML versions
        </td></tr><tr><td align="left">Revision 3.3</td><td align="left">10 July 2001</td></tr><tr><td align="left" colspan="2">Corrected Section 6, calculation of cylinder numbers
        </td></tr><tr><td align="left">Revision 3.2</td><td align="left">1 September 2000</td></tr><tr><td align="left" colspan="2">Dan Scott provides sgml conversion 2 Oct. 2000.
			Rewrote Introduction.
			Rewrote discussion on device names in Logical Devices.
			Reorganized Partition Types.
			Edited Partition Requirements.
			Added Recovering a deleted partition table.
        </td></tr><tr><td align="left">Revision 3.1</td><td align="left">12 June 2000</td></tr><tr><td align="left" colspan="2">Corrected swap size limitation in Partition
        Requirements, updated various links in Introduction, added
        submitted example in How to Partition with fdisk, added file
        system discussion in Partition Requirements. </td></tr><tr><td align="left">Revision 3.0</td><td align="left">1 May 2000</td></tr><tr><td align="left" colspan="2">
        First revision by 
        Anthony Lissot based on Linux Partition HOWTO by Kristian Koehntopp.
        </td></tr><tr><td align="left">Revision 2.4</td><td align="left">3 November 1997</td></tr><tr><td align="left" colspan="2">Last revision by Kristian Koehntopp.
        </td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
	This Linux Mini-HOWTO teaches you how to plan and create partitions
	on IDE and SCSI hard drives. It discusses partitioning terminology
	and considers size and location issues. Use of the fdisk
	partitioning utility for creating and recovering of partition tables
	is covered. The most recent version of this document is <a class="ulink" href="http://lissot.net/partition" target="_top">here</a>. The Turkish
	translation is <a class="ulink" href="http://belgeler.org/howto/partition-howto.html" target="_top">here</a>.
</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#explanation">1.1. What is a partition?</a></span></dt><dt><span class="sect2"><a href="#idm57">1.2. Other Partitioning Software:</a></span></dt><dt><span class="sect2"><a href="#howtos">1.3. Related HOWTOs</a></span></dt><dt><span class="sect2"><a href="#idm141">1.4. Additional information on your system:</a></span></dt></dl></dd><dt><span class="sect1"><a href="#devices">2. Devices</a></span></dt><dd><dl><dt><span class="sect2"><a href="#names">2.1. Device names</a></span></dt><dt><span class="sect2"><a href="#numbers">2.2. Device numbers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#partition-types">3. Partition Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#types">3.1. Partition Types</a></span></dt><dt><span class="sect2"><a href="#idm429">3.2. Foreign Partition Types</a></span></dt><dt><span class="sect2"><a href="#primary">3.3. Primary Partitions</a></span></dt><dt><span class="sect2"><a href="#logical">3.4. Logical Partitions</a></span></dt><dt><span class="sect2"><a href="#swap-partitions">3.5. Swap Partitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#requirements">4. Partitioning requirements</a></span></dt><dd><dl><dt><span class="sect2"><a href="#number">4.1. What Partitions do I need?</a></span></dt><dt><span class="sect2"><a href="#idm467">4.2. Discussion:</a></span></dt><dt><span class="sect2"><a href="#idm493">4.3. File Systems</a></span></dt><dt><span class="sect2"><a href="#SwapSize">4.4. Swap Partitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#fdisk_partitioning">5. Partitioning with fdisk</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fdisk">5.1. fdisk usage</a></span></dt><dt><span class="sect2"><a href="#primary-example">5.2. Four primary partitions</a></span></dt><dt><span class="sect2"><a href="#mixed">5.3. Mixed primary and logical partitions</a></span></dt><dt><span class="sect2"><a href="#submitted">5.4. Submitted Examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="#labels">6. Labels</a></span></dt><dd><dl><dt><span class="sect2"><a href="#volumelabels">6.1. Volume Labels</a></span></dt><dt><span class="sect2"><a href="#devicelabels">6.2. Device Labels</a></span></dt></dl></dd><dt><span class="sect1"><a href="#formatting">7. Formatting an ext2/3 partition</a></span></dt><dd><dl><dt><span class="sect2"><a href="#formatting-invocation">7.1. Simple Invocation</a></span></dt><dt><span class="sect2"><a href="#reservedblocks">7.2. Reserved blocks</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recovering">8. Recovering a Deleted Partition Table</a></span></dt><dt><span class="sect1"><a href="#setting_up_swap">9. Setting Up Swap Space</a></span></dt><dd><dl><dt><span class="sect2"><a href="#swap_partitions">9.1. Swap Files</a></span></dt><dt><span class="sect2"><a href="#swapfiles">9.2. Swap Files</a></span></dt><dt><span class="sect2"><a href="#multiple_swap_areas">9.3. Multiple Swap Areas</a></span></dt></dl></dd><dt><span class="sect1"><a href="#appendix">10. Appendix</a></span></dt><dd><dl><dt><span class="sect2"><a href="#formating">10.1. Formating Partitions</a></span></dt><dt><span class="sect2"><a href="#swap">10.2. Activating Swap Space</a></span></dt><dt><span class="sect2"><a href="#mounting">10.3. Mounting Partitions</a></span></dt><dt><span class="sect2"><a href="#fragmentation">10.4. Some facts about file systems and fragmentation</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>1. Introduction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="explanation"></a>1.1. What is a partition?</h3></div></div></div><p>
	Partitioning is a means to divide a single hard drive into many
	logical drives. A partition is a contiguous set of blocks on a drive
	that are treated as an independant disk. A partition table (the
	creation of which is the topic of this HOWTO) is
	an index that relates sections of the hard drive to partitions.
</p><p>
Why have multiple partitions? 
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
		Encapsulate your data. Since file system corruption is local to
		a partition, you stand to lose only some of your data if an
		accident occurs.
	</p></li><li class="listitem"><p>
		Increase disk space efficiency. You can format partitions with
		varying block sizes, depending on your usage. If your data is in
		a large number of small files (less than 1k) and your partition
		uses 4k sized blocks, you are wasting 3k for every file. In
		general, you waste on average one half of a block for every
		file, so matching block size to the average size of your files
		is important if you have many files.
	</p></li><li class="listitem"><p>
		Limit data growth. Runaway processes or maniacal users can
		consume so much disk space that the operating system no longer
		has room on the hard drive for its bookkeeping operations. This
		will lead to disaster. By segregating space, you ensure that
		things other than the operating system die when allocated disk
		space is exhausted.
	</p></li></ul></div><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm57"></a>1.2. Other Partitioning Software:</h3></div></div></div><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>sfdisk</strong></span>: a command-line version of fdisk</p></li><li class="listitem"><p><span class="command"><strong>cfdisk</strong></span>: a curses-based version of fdisk</p></li><li class="listitem"><p><a class="ulink" href="http://www.gnu.org/software/parted/parted.html" target="_top"><span class="command"><strong>parted</strong></span></a>: Gnu partition editor</p></li><li class="listitem"><p><a class="ulink" href="http://www.powerquest.com/partitionmagic/index.html" target="_top"><span class="productname">Partition Magic</span>&#8482;</a>:
 a commercial utility to create, resize, merge and convert partitions, without destroying data.
</p></li><li class="listitem"><p><a class="ulink" href="http://www.linux-mandrake.com/diskdrake" target="_top"><span class="productname">Disk Drake</span>&#8482;</a>: a Perl/Gtk program to create, rsize, and delete partitions</p></li></ul></div><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="howtos"></a>1.3. Related HOWTOs</h3></div></div></div><p>
</p><div class="table"><a name="idm82"></a><p class="title"><b>Table 1. Related HOWTOs</b></p><div class="table-contents"><table class="table" summary="Related HOWTOs" border="1"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th>Title</th><th>Author</th><th>Description</th></tr></thead><tbody><tr><td><a class="ulink" href="http://www.tldp.org/HOWTO/Install-Strategies" target="_top">
   			Dual boot install strategies</a>
   </td><td>
   		<a class="ulink" href="mailto:tobbyb@usa.net" target="_top">Gjoen Stein</a>
   	</td><td>
   		How to estimate the various size and speed requirements for
   		different parts of the filesystem.
   	</td></tr><tr><td><a class="ulink" href="http://www.nyx.net/~sgjoen/disk.html" target="_top">Linux Multiple
   Disk System Tuning</a></td><td><a class="ulink" href="mailto:sgjoen@mail.nyx.net" target="_top">Gjoen Stein</a></td><td>How to estimate the various size and speed requirements for
   different parts of the filesystem.</td></tr><tr><td>
   		<a class="ulink" href="http://www.tldp.org/HOWTO/Large-Disk-HOWTO.html" target="_top">
   			Linux Large Disk
   		</a>
   	</td><td>
   		<a class="ulink" href="mailto:aeb@cwi.nl" target="_top">
   			Andries Brouwer
   		</a>
   </td><td>
   		Instructions and considerations regarding disks with more than 1024 cylinders
   	</td></tr><tr><td>
	   <a class="ulink" href="http://metalab.unc.edu/mdw/HOWTO/mini/Quota.html" target="_top">
			 Linux Quota
	   </a>
   </td><td>
   		<a class="ulink" href="mailto:mailto:r.vdooren@snow.nl" target="_top">
   			Ralf van Dooren
   		</a>
   </td><td>
   		Instructions on limiting disk space usage per user (quotas)
   </td></tr><tr><td>
	   <a class="ulink" href="http://www.linuxdocs.org/HOWTOs/mini/Partition-Rescue.html" target="_top">
		   Partition-Rescue mini-HOWTO
	   </a>
   </td><td>
	   <a class="ulink" href="mailto:jdanield@dodin.net" target="_top">
		   Jean-Daniel Dodin
	   </a>
   </td><td>
	   How to restore linux partitions after they have been deleted by a
	   Windows install. Does not appear to preserve data.
   </td></tr><tr><td>
	   <a class="ulink" href="http://www.tldp.org/HOWTO/ADSM-Backup.html" target="_top">
		   Linux ADSM Backup
	   </a>
   </td><td>
	   <a class="ulink" href="mailto:Thomas.Koenig@ciw.uni-karlsruhe.de" target="_top">
		   Thomas Koenig
	   </a>
   </td><td>
	   Instructions on integrating Linux into an IBM ADSM backup
	   environment.
   </td></tr><tr><td>
	   <a class="ulink" href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/Backup-With-MSDOS.html" target="_top">
		   Linux Backup with MSDOS
	   </a>
   </td><td>
	   <a class="ulink" href="mailto:neufeld@physics.utoronto.ca" target="_top">
		   Christopher Neufeld
	   </a>
   </td><td>
		   Information about MS-DOS driven Linux backups.
   </td></tr><tr><td> Linux HOWTO Index</td><td><a class="ulink" href="mailto:linux-howto@sunsite.unc.edu" target="_top">Tim Bynum</a></td><td>Instructions on writing and submitting a HOWTO document</td></tr></tbody></table></div></div><p><br class="table-break">
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm141"></a>1.4. Additional information on your system:</h3></div></div></div><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  <a class="ulink" href="file:/usr/src/linux/Documentation" target="_top"><code class="filename">/usr/src/linux/Documentation</code></a>
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
    <a class="ulink" href="file:/usr/src/linux/Documentation/ide.txt" target="_top">
    <code class="filename">ide.txt</code></a>:
    Info about your IDE drivers
    </p></li><li class="listitem"><p>
    <a class="ulink" href="file:/usr/src/linux/Documentation/scsi.txt" target="_top"><code class="filename">scsi.txt</code></a>:
    Info about your SCSI drivers
    </p></li></ul></div><p>
  </p></li></ul></div><p>

</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="devices"></a>2. Devices</h2></div></div></div><p>
There is a special nomenclature that linux uses to refer to hard drive
partitions that must be understood in order to follow the discussion
on the following pages.
</p><p>
In Linux, partitions are represented by device files. These are phoney
files located in <code class="filename">/dev</code>. Here are a few entries:

</p><pre class="programlisting">
brw-rw----    1 root     disk       3,   0 May  5  1998 hda
brw-rw----    1 root     disk       8,   0 May  5  1998 sda
crw-------    1 root     tty        4,  64 May  5  1998 ttyS0
</pre><p>

A device file is a file with type c ( for "character" devices, devices
that do not use the buffer cache) or b (for "block" devices, which go
through the buffer cache). In Linux, all disks are represented as
block devices only.  
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="names"></a>2.1. Device names</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="NamingConvention"></a>2.1.1. Naming Convention</h4></div></div></div><p>
By convention, IDE drives will be given device
names <code class="literal">/dev/hda</code> to <code class="literal">/dev/hdd</code>.
<span class="emphasis"><em>H</em></span>ard <span class="emphasis"><em>D</em></span>rive
<span class="emphasis"><em>A</em></span> (<code class="literal">/dev/hda</code>) is the first drive and
<span class="emphasis"><em>H</em></span>ard <span class="emphasis"><em>D</em></span>rive
<span class="emphasis"><em>C</em></span> (<code class="literal">/dev/hdc</code>) is the third.


</p><div class="table"><a name="idm179"></a><p class="title"><b>Table 2. IDE controller naming convention</b></p><div class="table-contents"><table class="table" summary="IDE controller naming convention" border="1"><colgroup><col align="center" class="drive name"><col align="center" class="drive controller"><col align="center" class="drive number"></colgroup><tbody><tr><td align="center">drive name</td><td align="center">drive controller</td><td align="center">drive number</td></tr><tr><td align="center">/dev/hda</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">/dev/hdb</td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">/dev/hdc</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center">/dev/hdd</td><td align="center">2</td><td align="center">2</td></tr></tbody></table></div></div><p><br class="table-break">
</p><p>
A typical PC has two IDE
controllers, each of which can have two drives connected to it. For
example, <code class="filename">/dev/hda</code> is the first drive (master) on the
first IDE controller and <code class="filename">/dev/hdd</code> is
the second (slave) drive on the second controller (the fourth IDE
drive in the computer). 
</p><p>
You can write to these devices directly (using <span class="command"><strong>cat</strong></span> or 
<span class="command"><strong>dd</strong></span>). However,
since these devices represent the entire disk, starting at the first
block, you can mistakenly overwrite the master boot record and the
partition table, which will render the drive unusable.
</p><p>
</p><div class="table"><a name="idm213"></a><p class="title"><b>Table 3. partition names</b></p><div class="table-contents"><table class="table" summary="partition names" border="1"><colgroup><col align="center" class="drive name"><col align="center" class="drive controller"><col align="center" class="drive number"><col align="center" class="partition type"><col align="center" class="partition number"></colgroup><tbody><tr><td align="center">drive name</td><td align="center">drive controller</td><td align="center">drive number</td><td align="center">partition type</td><td align="center">partition number</td></tr><tr><td align="center">/dev/hda1</td><td align="center">1</td><td align="center">1</td><td align="center">primary</td><td align="center">1</td></tr><tr><td align="center">/dev/hda2</td><td align="center">1</td><td align="center">1</td><td align="center">primary</td><td align="center">2</td></tr><tr><td align="center">/dev/hda3</td><td align="center">1</td><td align="center">1</td><td align="center">primary</td><td align="center">3</td></tr><tr><td align="center">/dev/hda4</td><td align="center">1</td><td align="center">1</td><td align="center">swap</td><td align="center">NA</td></tr><tr><td align="center">/dev/hdb1</td><td align="center">1</td><td align="center">2</td><td align="center">primary</td><td align="center">1</td></tr><tr><td align="center">/dev/hdb2</td><td align="center">1</td><td align="center">2</td><td align="center">primary</td><td align="center">2</td></tr><tr><td align="center">/dev/hdb3</td><td align="center">1</td><td align="center">2</td><td align="center">primary</td><td align="center">3</td></tr><tr><td align="center">/dev/hdb4</td><td align="center">1</td><td align="center">2</td><td align="center">primary</td><td align="center">4</td></tr></tbody></table></div></div><p><br class="table-break">
</p><p>
	Once a drive has been partitioned, the partitions will represented
	as numbers on the end of the names. For example, the second
	partition on the second drive will be
	<code class="filename">/dev/hdb2</code>. The partition type (primary) is
	listed in the table above for clarity, although the concept is not
	explained until <a class="xref" href="#primary" title="3.3. Primary Partitions">Section 3.3, &#8220;Primary Partitions&#8221;</a>.
</p><p>
</p><div class="table"><a name="idm280"></a><p class="title"><b>Table 4. SCSI Drives</b></p><div class="table-contents"><table class="table" summary="SCSI Drives" border="1"><colgroup><col align="center" class="drive name"><col align="center" class="drive controller"><col align="center" class="drive number"><col align="center" class="partition type"><col align="center" class="partition number"></colgroup><tbody><tr><td align="center">drive name</td><td align="center">drive controller</td><td align="center">drive number</td><td align="center">partition type</td><td align="center">partition number</td></tr><tr><td align="center">/dev/sda1</td><td align="center">1</td><td align="center">6</td><td align="center">primary</td><td align="center">1</td></tr><tr><td align="center">/dev/sda2</td><td align="center">1</td><td align="center">6</td><td align="center">primary</td><td align="center">2</td></tr><tr><td align="center">/dev/sda3</td><td align="center">1</td><td align="center">6</td><td align="center">primary</td><td align="center">3</td></tr></tbody></table></div></div><p><br class="table-break">

</p><p>
	SCSI drives follow a similar pattern; They are represented by 'sd'
	instead of 'hd'. The first partition of the second SCSI drive would
	therefore be <code class="filename">/dev/sdb1</code>. In
	the table above, the drive number is arbitraily chosen to be 6 to
	introduce the idea that SCSI ID numbers do not map onto device names
	under linux.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm315"></a>2.1.2. Name Assignment</h4></div></div></div><p>
		Under (Sun) Solaris and (SGI) IRIX, the device name given to a
		SCSI drive has some relationship to where you plug it in. Under
		linux, there is only wailing and gnashing of teeth.
</p><p>
<span class="emphasis"><em>Before</em></span>
</p><pre class="programlisting">
SCSI ID #2        SCSI ID #5       SCSI ID #7        SCSI ID #8
 /dev/sda          /dev/sdb         /dev/sdc          /dev/sdd
</pre><p>
</p><p>
<span class="emphasis"><em>After</em></span>
</p><pre class="programlisting">
SCSI ID #2                         SCSI ID #7        SCSI ID #8
 /dev/sda                           /dev/sdb          /dev/sdc
</pre><p>
</p><p>
	SCSI drives have ID numbers which go from 1 through 15. Lower SCSI
	ID numbers are assigned lower-order letters. For example, if you
	have two drives numbered 2 and 5, then #2 will be
	<code class="filename">/dev/sda</code> and #5 will be
	<code class="filename">/dev/sdb</code>. If you remove either, all the higher
	numbered drives will be renamed the next time you boot up.
</p><p>
	If you have two SCSI controllers in your linux box, you will need to
	examine the output of <span class="command"><strong>/bin/dmesg</strong></span> in order to
	see what name each drive was assigned. If you remove one of two
	controllers, the remaining controller might have all its drives
	renamed. Grrr...
</p><p>
	There are two work-arounds; both involve using a program to put a
	label on each partition (see <a class="xref" href="#labels" title="6. Labels">Section 6, &#8220;Labels&#8221;</a>). The label is
	persistent even when the device is physically moved. You then refer
	to the partition directly or indirectly by label.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm331"></a>2.1.3. Logical Partitions</h4></div></div></div><p>

</p><div class="table"><a name="idm334"></a><p class="title"><b>Table 5. Logical Partitions</b></p><div class="table-contents"><table class="table" summary="Logical Partitions" border="1"><colgroup><col align="center" class="drive name"><col align="center" class="drive controller"><col align="center" class="drive number"><col align="center" class="partition type"><col align="center" class="partition number"></colgroup><tbody><tr><td align="center">drive name</td><td align="center">drive controller</td><td align="center">drive number</td><td align="center">partition type</td><td align="center">partition number</td></tr><tr><td align="center">/dev/hdb1</td><td align="center">1</td><td align="center">2</td><td align="center">primary</td><td align="center">1</td></tr><tr><td align="center">/dev/hdb2</td><td align="center">1</td><td align="center">2</td><td align="center">extended</td><td align="center">NA</td></tr><tr><td align="center">/dev/hda5</td><td align="center">1</td><td align="center">2</td><td align="center">logical</td><td align="center">2</td></tr><tr><td align="center">/dev/hdb6</td><td align="center">1</td><td align="center">2</td><td align="center">logical</td><td align="center">3</td></tr></tbody></table></div></div><p><br class="table-break">

</p><p>
	The table above illustrates a mysterious jump in the name
	assignments. This is due to the use of logical  partitions (see <a class="xref" href="#logical" title="3.4. Logical Partitions">Section 3.4, &#8220;Logical Partitions&#8221;</a>, which always start with 5, for
	reasons explained later.
</p><p>
	This is all you have to know to deal with linux disk devices. For
	the sake of completeness, see Kristian's discussion of device
	numbers below.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="numbers"></a>2.2. Device numbers</h3></div></div></div><p>
	The only important thing with a device file are its major and minor
	device numbers, which are shown instead of the file size:
</p><pre class="programlisting">
$ ls -l /dev/hda
</pre><p>
</p><div class="table"><a name="idm380"></a><p class="title"><b>Table 6. Device file attributes</b></p><div class="table-contents"><table class="table" summary="Device file attributes" border="1"><colgroup><col align="center" class="c1"><col align="center" class="c2"><col align="center" class="c3"><col align="center" class="c4"><col align="center" class="c5"><col align="center" class="c6"><col align="center" class="c7"><col align="center" class="c8"></colgroup><tbody><tr><td align="center">brw-rw----</td><td align="center">1</td><td align="center">root</td><td align="center">disk</td><td align="center">3,</td><td align="center">0</td><td align="center">Jul 18  1994</td><td align="center">/dev/hda</td></tr><tr><td align="center">permissions</td><td align="center"> </td><td align="center">owner</td><td align="center">group</td><td align="center">major device number</td><td align="center">minor device number</td><td align="center">date</td><td align="center">device name</td></tr></tbody></table></div></div><p><br class="table-break">
</p><p>When accessing a device file, the major number
selects which device driver is being called to perform the
input/output operation. This call is being done with the minor number
as a parameter and it is entirely up to the driver how the minor
number is being interpreted. The driver documentation usually
describes how the driver uses minor numbers. For IDE disks, this
documentation is in 
<a class="ulink" href="file:/usr/src/linux/Documentation/ide.txt" target="_top">
<code class="filename">/usr/src/linux/Documentation/ide.txt</code></a>.
For SCSI disks, one would expect such documentation in 
<a class="ulink" href="file:/usr/src/linux/Documentation/scsi.txt" target="_top">
<code class="filename">/usr/src/linux/Documentation/scsi.txt</code></a>,
but it isn't there. One has to look at the driver source to be sure
(<a class="ulink" href="file:/usr/src/linux/driver/scsi/sd.c" target="_top">
<code class="filename">/usr/src/linux/driver/scsi/sd.c</code></a>:184-196). 
Fortunately,
there is Peter Anvin's list of device numbers and names in 
<a class="ulink" href="file:/usr/src/linux/Documentation/devices.txt" target="_top">
<code class="filename">/usr/src/linux/Documentation/devices.txt</code></a>;
see the entries for block devices, major 3, 22, 33, 34 for IDE and
major 8 for SCSI disks. The major and minor numbers are a byte each
and that is why the number of partitions per disk is limited.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partition-types"></a>3. Partition Types</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="types"></a>3.1. Partition Types</h3></div></div></div><p>
	A partition is labeled to host a certain kind of file system (not to
	be confused with a volume label (see <a class="xref" href="#labels" title="6. Labels">Section 6, &#8220;Labels&#8221;</a>)).
	Such a file system could be the linux standard ext2 file system or
	linux swap space, or even foreign file systems like (Microsoft) NTFS
	or (Sun) UFS. There is a numerical code associated with each
	partition type. For example, the code for ext2 is
	<code class="literal">0x83</code> and linux swap is <code class="literal">0x82</code>.
	To see a list of partition types and their codes, execute
	<strong class="userinput"><code><span class="command"><strong>/sbin/sfdisk</strong></span> -T </code></strong>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm429"></a>3.2. Foreign Partition Types</h3></div></div></div><p>
	The partition type codes have been arbitrarily chosen (you can't
	figure out what they should be) and they are particular to a given
	operating system. Therefore, it is theoretically possible that if
	you use two operating systems with the same hard drive, the same
	code might be used to designate two different partition types. OS/2
	marks its partitions with a 0x07 type and so does Windows NT's NTFS.
	MS-DOS allocates several type codes for its various flavors of FAT
	file systems: 0x01, 0x04 and 0x06 are known. DR-DOS used 0x81 to
	indicate protected FAT partitions, creating a type clash with
	Linux/Minix at that time, but neither Linux/Minix nor DR-DOS are
	widely used any more.
</p><p>

	 OS/2 marks its partitions with a <code class="literal">0x07</code> type and
	 so does Windows NT's NTFS. MS-DOS allocates several type codes for
	 its various flavors of FAT file systems: 0x01,
	 <code class="literal">0x04</code> and <code class="literal">0x06</code> are known.
	 DR-DOS used <code class="literal">0x81</code> to indicate protected FAT
	 partitions, creating a type clash with Linux/Minix at that time,
	 but neither Linux/Minix nor DR-DOS are widely used any more.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="primary"></a>3.3. Primary Partitions</h3></div></div></div><p>
	The number of partitions on an Intel-based system was limited from
	the very beginning: The original partition table was installed as
	part of the boot sector and held space for only four partition
	entries.  These partitions are now called primary partitions.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="logical"></a>3.4. Logical Partitions</h3></div></div></div><p>
	One primary partition of a hard drive may be subpartitioned. These
	are logical partitions. This effectively allows us to skirt the
	historical four partition limitation.
</p><p>
	The primary partition used to house the logical partitions is called
	an extended partition and it has its own file system type (0x05).
	Unlike primary partitions, logical partitions must be contiguous.
	Each logical partition contains a pointer to the next logical
	partition, which implies that the number of logical partitions is
	unlimited. However, linux imposes limits on the total number of any
	type of partition on a drive, so this effectively limits the number
	of logical partitions. This is at most 15 partitions total on an
	SCSI disk and 63 total on an IDE disk.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="swap-partitions"></a>3.5. Swap Partitions</h3></div></div></div><p>
	Every process running on your computer is allocated a number of
	blocks of RAM. These blocks are called pages. The set of in-memory
	pages which will be referenced by the processor in the very near
	future is called a "working set." Linux tries to predict these
	memory accesses (assuming that recently used pages will be used
	again in the near future) and keeps these pages in RAM if possible.
</p><p>
	If you have too many processes running on a machine, the kernel will
	try to free up RAM by writing pages to disk. This is what swap space
	is for. It effectively increases the amount of memory you have
	available. However, disk I/O is about a hundred times slower than
	reading from and writing to RAM. Consider this emergency memory and
	not extra memory.
</p><p>
	If memory becomes so scarce that the kernel pages out from the
	working set of one process in order to page in for another, the
	machine is said to be thrashing. Some readers might have
	inadvertenly experienced this: the hard drive is grinding away like
	crazy, but the computer is slow to the point of being unusable. Swap
	space is something you need to have, but it is no substitute for
	sufficient RAM.  See the discussion in  <a class="xref" href="#SwapSize" title="4.4. Swap Partitions">Section 4.4, &#8220;Swap Partitions&#8221;</a> for tips on determining the size of swap space
	you need.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="requirements"></a>4. Partitioning requirements</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="number"></a>4.1. What Partitions do I need?</h3></div></div></div><p>
For the Boot Drive:
If you want to boot your operating system from the drive you are about
to partition, you will need:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A primary partition</p></li><li class="listitem"><p>One or more swap partitions</p></li><li class="listitem"><p>Zero or more primary/logical partitions</p></li></ul></div><p>
For any other drive:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>One or more primary/logical partitions</p></li><li class="listitem"><p>Zero or more swap partitions</p></li></ul></div><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm467"></a>4.2. Discussion:</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><a name="boot"></a><span class="term">Boot Partition:</span></dt><dd><p>
	Your boot partition ought to be a primary partition, not a logical
	partition. This will ease recovery in case of disaster, but it is
	not technically necessary. It must be of type
	<code class="literal">0x83</code> "Linux native". If you are using a version
	of <a class="ulink" href="http://tldp.org/HOWTO/LILO.html" target="_top"><span class="command"><strong>lilo</strong></span></a> before 21-3 (ie, from the 1990s), your boot partition must be
	contained within the first 1024 cylinders of the drive. (Typically,
	the boot partition need only contain the kernel image.)
</p><p>
	If you have more than one boot partition (from other OSs, for
	example,) keep them all in the first 1024 cylinders
	(<span class="emphasis"><em>All</em></span> DOS partitions must be within the first
	1024).  If you are using a modern version of lilo, or a means other
	than lilo to load your kernel (for example, a boot disk or the
	<span class="command"><strong>LOADLIN.EXE</strong></span> MS-DOS based Linux loader), the
	partition can be anywhere. See the <a class="ulink" href="http://www.tldp.org/HOWTO/Large-Disk-HOWTO.html" target="_top">Large-disk</a> 
	HOWTO for details.
</p></dd><dt><a name="swap-definition"></a><span class="term">Swap Partition:</span></dt><dd><p>
Unless you swap to files (see <a class="xref" href="#swapfiles" title="9.2. Swap Files">Section 9.2, &#8220;Swap Files&#8221;</a>) you will
need a dedicated swap partition. It must be of type
<code class="literal">0x82</code> "Linux swap". It may be positioned anywhere on
the disk (but see <a class="xref" href="#SwapPlacement" title="4.4.3. Where should I put my swap space?">Section 4.4.3, &#8220;Where should I put my swap space?&#8221;</a>). Either a primary or
logical partition can be used for swap. More than one swap partition can
exist on a drive. 8 total (across drives) are permitted. See notes on
swap size below (<a class="xref" href="#SwapSize" title="4.4. Swap Partitions">Section 4.4, &#8220;Swap Partitions&#8221;</a>).
</p></dd><dt><a name="logical-definition"></a><span class="term">Logical Partition:</span></dt><dd><p>
A single primary partition must be used as a container (extended
partition) for the logical partitions. The extended partition can go
anywhere on the disk. The logical partitions must be contiguous, but
needn't fill the extended partition.
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm493"></a>4.3. File Systems</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="filesystems"></a>4.3.1. Which file systems need their own partitions?</h4></div></div></div><p>
Everything in your linux file system can go in the same (single)
partition. However, there are circumstances when you may want to
restrict the growth of certain file systems. For example, if your mail
spool was in the same partition as your root fs and it filled the
remaining space in the partition, your computer would basically
hang.
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">/var</code></span></dt><dd><p>This fs contains spool directories such as those for mail and 
	  printing. In addition, it contains the error log
	  directory. If your machine is a server and develops a
	  chronic error, those msgs can fill the partition. Server
	  computers ought to have /var in a different partition than
	  /.
      </p></dd><dt><span class="term"><code class="filename">/usr</code></span></dt><dd><p>This is where most executable binaries go. In addition, the
	  kernel source tree goes here, and much documentation. 
     </p></dd><dt><span class="term"><code class="filename">/tmp</code></span></dt><dd><p>Some programs write temporary data files here. Usually, they
	  are quite small. However, if you run computationally
	  intensive jobs, like science or engineering applications,
	  hundreds of megabytes could be required for brief periods of 
	  time. In this case, keep /tmp in a different partition than
	  /.
     </p></dd><dt><span class="term"><code class="filename">/home</code></span></dt><dd><p>This is where users home directories go. If you do not impose 
	  quotas on your users, this ought to be in its own partition.
     </p></dd><dt><span class="term"><code class="filename">/boot</code></span></dt><dd><p>This is where your kernel images go. See discussion above
          for placement on old systems.
     </p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="backups"></a>4.3.2. File lifetimes and backup cycles as partitioning criteria</h4></div></div></div><p>With ext2, partitioning decisions should be governed by backup
considerations and to avoid external fragmentation <a class="xref" href="#fragmentation" title="10.4. Some facts about file systems and fragmentation">Section 10.4, &#8220;Some facts about file systems and fragmentation&#8221;</a>
from different file lifetimes.
</p><p>Files have lifetimes. After a file has been created, it will
remain some time on the system and then be removed. File
lifetime varies greatly throughout the system and is partly
dependent on the pathname of the file. For example, files in
<code class="filename">/bin</code>, <code class="filename">/sbin</code>, <code class="filename">/usr/sbin</code>, <code class="filename">/usr/bin</code> and similar directories are
likely to have a very long lifetime: many months and above.
Files in <code class="filename">/home</code> are likely to have a medium lifetime: several
weeks or so. File in <code class="filename">/var</code> are usually short lived: Almost no
file in <code class="filename">/var/spool/news</code> will remain longer than a few days,
files in <code class="filename">/var/spool/lpd</code> measure their lifetime in minutes or
less.
</p><p>
	For backup it is useful if the amount of daily backup is smaller
	than the capacity of a single backup medium. A daily backup can be a
	complete backup or an incremental backup.
</p><p>
	You can decide to keep your partition sizes small enough that they
	fit completely onto one backup medium (choose daily full backups).
	In any case a partition should be small enough that its daily delta
	(all modified files) fits onto one backup medium (choose incremental
	backup and expect to change backup media for the weekly/monthly full
	dump - no unattended operation possible).
</p><p>
	Your backup strategy depends on that decision.
</p><p>
	When planning and buying disk space, remember to set aside a
	sufficient amount of money for backup! Unbackuped data is worthless!
	Data reproduction costs are much higher than backup costs for
	virtually everyone!
</p><p>
	For performance it is useful to keep files of different lifetimes on
	different partitions. This way the short lived files on the news
	partition may be fragmented very heavily. This has no impact on the
	performance of the <code class="filename">/</code> or
	<code class="filename">/home</code> partition.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="SwapSize"></a>4.4. Swap Partitions</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm546"></a>4.4.1. How large should my swap space be?</h4></div></div></div><p>
Conventional wisdom creates swap space equal to the amount of RAM. </p><p>
	But keep in mind that this is just a rule of thumb. It is easily
	possible to create scenarios where programs have extremely large or
	extremely small working sets (see <a class="xref" href="#swap-partitions" title="3.5. Swap Partitions">Section 3.5, &#8220;Swap Partitions&#8221;</a>). 
	For example, a simulation program with
	a large data set that is accessed in a very random fashion would
	have almost no noticeable locality of reference in its data segment,
	so its working set would be quite large.
</p><p>
	On the other hand, a graphics program with many simultaneously
	opened JPEGs, all but one iconified, would have a very large data
	segment. But image transformations are all done on one single image,
	most of the memory occupied by the program is not accessed. The same
	is true for an editor with many editor windows where only one window
	is being modified at a time. These programs have - if they are
	designed properly - a very high locality of reference and large
	parts of them can be kept swapped out without too severe performance
	impact. A user who never quits programs once launched would
	want a lot of swap space for the same reason.
</p><p>
	Servers typically are configured with more swap space than their
	desktop counterparts. Even though a given amount of swap is
	sufficient for its operations, the server might come under transient
	heavy loads which cause it to page out at a high rate. Some
	administrators prefer this to the server crashing altogether. In
	these cases, swap might be several times the size of ram.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="max_swap_size"></a>4.4.2. How large <span class="emphasis"><em>can</em></span> my swap space be?</h4></div></div></div><p>
		Currently, the maximum size of a swap partition is
		architecture-dependent. For i386, m68k, ARM and PowerPC, it is
		"officially" 2Gb. It is 128Gb on alpha, 1Gb on sparc, and 3Tb on
		sparc64. An opteron on the 2.6 kernel can write to a 16 Tb swap
		partition. For linux kernels 2.1 and earlier, the limit is
		128Mb. The partition may be larger than 128 MB, but excess space
		is never used. If you want more than 128 MB of swap for a 2.1
		and earlier kernel, you have to create multiple swap partitions
		(8 max). After 2.4, 32 swap areas are "officially" possible. See
		setting up swap for details.
</p><p><span class="emphasis"><em>footnote:</em></span> 
	"official" max swap size: With kernel 2.4, the limit is 64 swap spaces at a
	maximum of 64Gb each, although this is not reflected in the man page
	for <span class="command"><strong>mkswap</strong></span>. With the 64 bit opteron on the 2.6 kernel, 128 swap
	areas are permitted, each a whopping 16 Tb! (thanks to Peter Chubb
	for the calculation)
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="SwapPlacement"></a>4.4.3. Where should I put my swap space?</h4></div></div></div><p>
The short answer is anywhere is fine. However, if you are
interested in extracting as much speed as possible, there are
two basic strategies (other than buying more RAM).
</p><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Split the swap space across multiple drives, or at least on the
			    drive you write to least.
           </p></li><li class="listitem"><p>Put each swap partition on the outer tracks.
           </p></li></ul></div><p>
</p><p> 
	Here are the considerations:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
		If you have a disk with many heads and one with less heads and
		both are identical in other parameters, the disk with many heads
		will be faster. Reading data from different heads is fast, since
		it is purely electronic. Reading data from different tracks is
		slow, since it involves physically moving the head.
	</p><p>
		It follows then that writing swap on a separate drive will be
		faster than moving the head back and forth on a single drive.
	</p></li><li class="listitem"><p><span class="emphasis"><em>Placement</em></span>: 
		Older disks have the same number of sectors on all tracks. With
		these disks it will be fastest to put your swap in the middle of
		the disks, assuming that your disk head will move from a random
		track towards the swap area.
	</p></li><li class="listitem"><p> 
		Newer disks use ZBR (zone bit recording). They have more sectors
		on the outer tracks. With a constant number of rpms, this yields
		a far greater performance on the outer tracks than on the inner
		ones. Put your swap on the fast tracks. (In general,
		low-numbered cylinders are associated low partition numbers.
		However, see Kristian's more recent <a class="ulink" href="http://lissot.net/partition/mapping.html" target="_top">comments</a>
		on this issue. -Tony)
	</p></li><li class="listitem"><p> <span class="emphasis"><em>Usage</em></span>: 
		Of course your disk head will not move randomly. If you have swap
		space in the middle of a disk between a constantly busy home
		partition and an almost unused archive partition, you would be
		better of if your swap were near the home partition for
		even shorter head movements. You would be even better off, if you
		had your swap on another otherwise unused disk, though.
	</p></li><li class="listitem"><p> <span class="emphasis"><em>Striping</em></span>: 
		Speed can be increased by writing to multiple swap areas
		simultaneously. Swap spaces with the same priority will be
		written to like a RAID. See <a class="xref" href="#multiple_swap_areas" title="9.3. Multiple Swap Areas">Section 9.3, &#8220;Multiple Swap Areas&#8221;</a>.
</p></li></ul></div><p><span class="emphasis"><em>Summary:</em></span> 
	Put your swap on a fast disk with many heads that is not busy doing
	other things. If you have multiple disks: Split swap and scatter it
	over all your disks or even different controllers.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fdisk_partitioning"></a>5. Partitioning with fdisk</h2></div></div></div><p>
This section shows you how to actually partition your hard drive with
the <span class="command"><strong>fdisk</strong></span> utility. Linux allows only 4 primary
partitions. You can have a much larger number of logical partitions by
sub-dividing one of the primary partitions. Only one of the primary
partitions can be sub-divided.
</p><p>
<span class="emphasis"><em>Examples:</em></span>
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	   		Four primary partitions (see <a class="xref" href="#primary-example" title="5.2. Four primary partitions">Section 5.2, &#8220;Four primary partitions&#8221;</a>)
	   </p></li><li class="listitem"><p>
	  		 Mixed primary and logical partitions (see <a class="xref" href="#mixed" title="5.3. Mixed primary and logical partitions">Section 5.3, &#8220;Mixed primary and logical partitions&#8221;</a>)
	   </p></li></ol></div><p>
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fdisk"></a>5.1. fdisk usage</h3></div></div></div><p>
	<span class="command"><strong>fdisk</strong></span> is started by typing (as root)
	<strong class="userinput"><code><span class="command"><strong>fdisk</strong></span>
	<em class="replaceable"><code>device</code></em></code></strong> at the command prompt.
	<em class="replaceable"><code>device</code></em> might be something like <code class="filename">/dev/hda</code> or <code class="filename">/dev/sda</code> (see <a class="xref" href="#NamingConvention" title="2.1.1. Naming Convention">Section 2.1.1, &#8220;Naming Convention&#8221;</a>). The basic
	<span class="command"><strong>fdisk</strong></span> commands you need are:
</p><p>
	<strong class="userinput"><code>p</code></strong>
	print the partition table
</p><p>
	<strong class="userinput"><code>n</code></strong>
	create a new partition
</p><p>
        <strong class="userinput"><code>d</code></strong>
        delete a partition
</p><p>
	<strong class="userinput"><code>q</code></strong>
	quit without saving changes
</p><p>
	<strong class="userinput"><code>w</code></strong>
	write the new partition table and exit
</p><p>
Changes you make to the partition table do not take effect until you issue the write (w) command.
Here is a sample partition table:
</p><pre class="programlisting">
Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
 
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       184    370912+  83  Linux
/dev/hdb2           185       368    370944   83  Linux
/dev/hdb3           369       552    370944   83  Linux
/dev/hdb4           553       621    139104   82  Linux swap
</pre><p>

The first line shows the geometry of your hard drive. It may not be
physically accurate, but you can accept it as though it were. The hard
drive in this example is made of 32 double-sided platters with one
head on each side (probably not true). Each platter has 621 concentric
tracks. A 3-dimensional track (the same track on all disks) is called
a cylinder. Each track is divided into 63 sectors. Each sector
contains 512 bytes of data. Therefore the block size in the partition
table is 64 heads * 63 sectors * 512 bytes er...divided by 1024. (See
<a class="xref" href="#BlockSize">4</a> for discussion on
problems with this calculation.) The start and end values are cylinders.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="primary-example"></a>5.2. Four primary partitions</h3></div></div></div><p>
	<span class="emphasis"><em>The overview:</em></span> 
</p><p>
	Decide on the size of your swap space (see <a class="xref" href="#SwapSize" title="4.4. Swap Partitions">Section 4.4, &#8220;Swap Partitions&#8221;</a>) and where it ought to go (see <a class="xref" href="#SwapPlacement" title="4.4.3. Where should I put my swap space?">Section 4.4.3, &#8220;Where should I put my swap space?&#8221;</a>).
	Divide up the remaining space for the three other partitions.
</p><p>
Example:
</p><p>
I start fdisk from the shell prompt:
</p><pre class="programlisting">
# <strong class="userinput"><code><span class="command"><strong>fdisk</strong></span> <code class="filename">/dev/hdb</code></code></strong> 
</pre><p>

which indicates that I am using the second drive on my IDE controller.
(See <a class="xref" href="#names" title="2.1. Device names">Section 2.1, &#8220;Device names&#8221;</a>.) When I print the (empty) partition table,
I just get configuration information.

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>p</code></strong>

Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
</pre><p>
I knew that I had a 1.2Gb drive, but now I really know: 64 * 63 * 512
* 621 = 1281982464 bytes. I decide to reserve 128Mb of that space for
swap, leaving 1153982464. If I use one of my primary partitions for
swap, that means I have three left for ext2 partitions. Divided
equally, that makes for 384Mb per partition. Now I get to work.

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>1</code></strong>
First cylinder (1-621, default 1):<strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-621, default 621): <strong class="userinput"><code>+384M</code></strong>
</pre><p>

Next, I set up the partition I want to use for swap:

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): <strong class="userinput"><code>2</code></strong>
First cylinder (197-621, default 197):<strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 197
Last cylinder or +size or +sizeM or +sizeK (197-621, default 621): <strong class="userinput"><code>+128M</code></strong>
</pre><p>

Now the partition table looks like this:

</p><pre class="programlisting">
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1             1       196    395104   83  Linux
/dev/hdb2           197       262    133056   83  Linux
</pre><p>

I set up the remaining two partitions the same way I did the first.
Finally, I make the first partition bootable:

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>a</code></strong>
Partition number (1-4): <strong class="userinput"><code>1</code></strong>
</pre><p>

And I make the second partition of type swap:

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>t</code></strong>
Partition number (1-4): <strong class="userinput"><code>2</code></strong>
Hex code (type L to list codes): <strong class="userinput"><code>82</code></strong>
Changed system type of partition 2 to 82 (Linux swap)      
Command (m for help): <strong class="userinput"><code>p</code></strong>
</pre><p>

The end result:

</p><pre class="programlisting">
Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
 
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       196    395104+  83  Linux
/dev/hdb2           197       262    133056   82  Linux swap
/dev/hdb3           263       458    395136   83  Linux
/dev/hdb4           459       621    328608   83  Linux          
</pre><p>

Finally, I issue the write command (w) to write the table on the disk.
</p><p>
Side topics:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="#swap" title="10.2. Activating Swap Space">Section 10.2, &#8220;Activating Swap Space&#8221;</a></p></li><li class="listitem"><p><a class="xref" href="#formating" title="10.1. Formating Partitions">Section 10.1, &#8220;Formating Partitions&#8221;</a></p></li><li class="listitem"><p><a class="xref" href="#mounting" title="10.3. Mounting Partitions">Section 10.3, &#8220;Mounting Partitions&#8221;</a></p></li></ul></div><p>

</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mixed"></a>5.3. Mixed primary and logical partitions</h3></div></div></div><p>
<span class="emphasis"><em>The overview:</em></span> create one use one of the primary
partitions to house all the extra partitions. Then create logical
partitions within it. Create the other primary partitions before or
after creating the logical partitions.
</p><p>
Example:
</p><p>
I start fdisk from the shell prompt:

</p><pre class="programlisting">
# fdisk /dev/sda
</pre><p>

which indicates that I am using the first drive on my SCSI chain. 
(See <a class="xref" href="#names" title="2.1. Device names">Section 2.1, &#8220;Device names&#8221;</a>.)
</p><p>
First I figure out how many partitions I want. I know my drive has a
183Gb capacity and I want 26Gb partitions (because I happen to have
back-up tapes that are about that size).
</p><p>
	<code class="literal">183Gb / 26Gb = ~7</code>
</p><p>
so I will need 7 partitions. Even though fdisk accepts partition sizes
expressed in Mb and Kb, I decide to calculate the number of cylinders
that will end up in each partition because fdisk reports start and
stop points in cylinders.  I see when I enter fdisk that I have 22800
cylinders.

</p><pre class="programlisting">
&gt; The number of cylinders for this disk is set to 22800.  There is
&gt; nothing wrong with that, but this is larger than 1024, and could in
&gt; certain setups cause problems with: 1) software that runs at boot
&gt; time (e.g., LILO) 2) booting and partitioning software from other
&gt; OSs  (e.g., DOS FDISK, OS/2 FDISK)
</pre><p>

So, 22800 total cylinders divided by seven partitions is 3258
cylinders. Each partition will be about 3258 cylinders long. I ignore
the warning msg because this is not my boot drive (<a class="xref" href="#requirements" title="4. Partitioning requirements">Section 4, &#8220;Partitioning requirements&#8221;</a>).
</p><p>
 Since I have 4 primary partitions, 3 of them can be 3258
long. The extended partition will have to be (4 * 3258), or 13032,
cylinders long in order to contain the 4 logical partitions.
</p><p>
I enter the following commands to set up the first of the 3 primary
partitions (stuff I type is bold ):

</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>1</code></strong>
First cylinder (1-22800, default 1): <strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <strong class="userinput"><code>3258</code></strong>
</pre><p>

The last partition is the extended partition:

</p><pre class="programlisting">
Partition number (1-4): <strong class="userinput"><code>4</code></strong>
First cylinder (9775-22800, default 9775): <strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): <strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 22800
</pre><p>

 The result, when I issue the print table command is:

</p><pre class="programlisting">
/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
</pre><p>

Next I segment the extended partition into 4 logical partitions,
starting with the first logical partition, into 3258-cylinder
segments.  The logical partitions automatically start from /dev/sda5.

</p><pre class="programlisting">
Command (m for help):  <strong class="userinput"><code>n</code></strong>
First cylinder (9775-22800, default 9775): <strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): 13032
</pre><p>

The end result is:

</p><pre class="programlisting">
   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
/dev/sda5          9775     13032  26169853+  83  Linux
/dev/sda6         13033     16290  26169853+  83  Linux
/dev/sda7         16291     19584  26459023+  83  Linux
/dev/sda8         19585     22800  25832488+  83  Linux
</pre><p>

Finally, I issue the write command (w) to write the table on the disk.
To make the partitions usable, I will have to format (<a class="xref" href="#formating" title="10.1. Formating Partitions">Section 10.1, &#8220;Formating Partitions&#8221;</a>)
each partition and then mount (<a class="xref" href="#mounting" title="10.3. Mounting Partitions">Section 10.3, &#8220;Mounting Partitions&#8221;</a>) it.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="submitted"></a>5.4. Submitted Examples</h3></div></div></div><p>
 I'd like to submit my partition layout, because it works well with
any distribution of Linux (even big RPM based ones).

I have one hard drive that ... is 10 gigs, exactly. Windows 
can't see above 9.3 gigs of it, but Linux can see it all, and use it 
all. It also has much more than 1024 cylenders.

</p><div class="table"><a name="idm711"></a><p class="title"><b>Table 7. Partition layout example</b></p><div class="table-contents"><table class="table" summary="Partition layout example" border="1"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th>Partition</th><th>Mount point</th><th>Size</th></tr></thead><tbody><tr><td>/dev/hda1</td><td>/boot</td><td>(15 megs)</td></tr><tr><td>/dev/hda2</td><td>windows 98 partition</td><td>(2 gigs)</td></tr><tr><td>/dev/hda3</td><td>extended</td><td>(N/A)</td></tr><tr><td>/dev/hda5</td><td>swap space</td><td>(64 megs)</td></tr><tr><td>/dev/hda6</td><td>/tmp</td><td>(50 megs)</td></tr><tr><td>/dev/hda7</td><td>/</td><td>(150 megs)</td></tr><tr><td>/dev/hda8</td><td>/usr</td><td>(1.5 gigs)</td></tr><tr><td>/dev/hda9</td><td>/home</td><td>(rest of drive)</td></tr></tbody></table></div></div><p><br class="table-break">

I test new kernels for the USB mass storage, so that explains the large 
/boot partition.  I install LILO into the MBR, and by default I boot 
windows (I'm not the only one to use this computer).
</p><p>
I also noticed that you don't have any REAL examples of partition 
tables, and for newbies I HIGHLY suggest putting quite a few up. I'm 
freshly out of the newbie stage, and partitioning was what messed me up 
the most.
</p><p>
 <a class="ulink" href="mailto:valkor@qx.net" target="_top">Valkor</a>
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="labels"></a>6. Labels</h2></div></div></div><p>
	In linux, hard drives are referred to as devices, and devices are
	pseudo files in <code class="filename">/dev</code>. For
	example, the first partition of the second lowest numbered SCSI
	drive is <code class="filename">/dev/sdb1</code>. If the drive referred to as
	<code class="filename">/dev/sda</code> is removed from the chain, then the
	latter partition is automatically renamed
	<code class="filename">/dev/sda1</code> at reboot.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="volumelabels"></a>6.1. Volume Labels</h3></div></div></div><p>
	Volume labels make it possible for partitions to retain a consistent
	name regardless of where they are connected, and regardless of
	whatever else is connected. Labels are not mandatory for a linux
	volume. Each can be a maximum of 16 characters long.
</p><p>
	There are three tools to make volume labels: mke2fs, tune2fs and e2label.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="labelinvocation"></a>6.1.1. Simple Invocation</h4></div></div></div><p>
	<span class="command"><strong>e2label</strong></span> <code class="filename">/dev/hdb1</code> <code class="filename">pubsw</code>
</p><p>
	<span class="command"><strong>tune2fs</strong></span> -L <code class="filename">pubsw</code> <code class="filename">/dev/hdb1</code> 
</p><p>
	Either of thse two commands will label the first partition of the
	second drive "pubsw". That label stays with that particular
	partition, even if the drive is moved to another controller or even
	another computer.
</p><p>
	<span class="command"><strong>mke2fs</strong></span>	<code class="filename">pubsw</code> 
			<code class="filename">/dev/hdb1</code> 
</p><p>
	<span class="command"><strong>mke2fs</strong></span> -L	<code class="filename">pubsw</code> 
				<code class="filename">/dev/hdb1</code> 
</p><p>
	will do the same thing as the first two commands - after they make
	the file system. This means that either of these last two commands
	will delete any existing data in the partition.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="howtousevolumelabels"></a>6.1.2. How to Use</h4></div></div></div><p>
	Here is a sample fstab. This is a text file located in /etc, which
	is usually set up during the installation of the operating system.
	it describes where each partition wil be mounted, and how it will be
	mounted. It can be modified by you, either through a utility or
	manually, when you add/remove devices.
</p><p>
</p><pre class="programlisting">
LABEL=/        /                    ext3    defaults        1 1
LABEL=/boot    /boot                ext2    defaults        1 2
none           /dev/pts             devpts  gid=5,mode=620  0 0
none           /dev/shm             tmpfs   defaults        0 0
LABEL=HOME     /home                ext3    defaults        1 2
none           /proc                proc    defaults        0 0
none           /sys                 sysfs   defaults        0 0
LABEL=/usr     /usr                 ext3    defaults        1 2
/dev/hdc1      /k-space             ext3    defaults        1 2
/dev/hda6      swap                 swap    defaults        0 0
/dev/hdd       /media/cdrecorder    auto    pamconsole,ro,exec,noauto,managed 0 0
/dev/fd0       /media/floppy        auto    pamconsole,exec,noauto,managed 0 0
</pre><p>
</p><p>
	The leftmost column lists devices and the second column lists mount
	points. This example contains a mixture of devices and labels. The
	master drive of the second controller is always mounted on <code class="filename">/k-space</code>.
	The partition labeled "HOME" is always mounted on <code class="filename">/home</code>, regardless
	of which drive it is on or which partition number it has. Notice
	that it is permissible to use mount points as labels, such as "/usr"
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="devicelabels"></a>6.2. Device Labels</h3></div></div></div><p>
	<span class="command"><strong>devlabel</strong></span> is a script which creates symbolic links to devices. For
	example,
</p><p>
	<span class="command"><strong>devlabel</strong></span> -d <code class="filename">/dev/hdb1</code>
			 -s <code class="filename">/dev/home</code>
</p><p>
	will create a link from <code class="filename">/dev/hdb1</code> to <code class="filename">/dev/home</code>. Crucially, it stores a
	unique identifier for the hardware that was on <code class="filename">/dev/hdb1</code> and stores that identifier along with
	the link name that you specified in /etc/sysconfig/devlabel. If the
	hardware is later moved to <code class="filename">/dev/hdc1</code>,
	its unique identifier will be queried (using
	/usr/bin/partition_uuid), matched to its entry in
	/etc/sysconfig/devlabel, and again linked to <code class="filename">/dev/home</code>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="formatting"></a>7. Formatting an ext2/3 partition</h2></div></div></div><p>
	When a hard drive is partitioned, it is mapped into sections, but
	the sections are empty. It is like a newly constructed library;
	shelves, signs, and a card catalogue system must be put in place
	before the books are put away.</p><p>
	The organizational structure inside a partition is called a file
	system. With Linux, the standard file system is ext2 and ext3. The
	ext3 file system is ext2, plus a log of disk writes called a
	journal. The journal allows the system to recover quickly from
	accidental power outages, among other things.
</p><p>
	The principal tool for making an ext2/3 file system in a partition
	is <span class="command"><strong>mke2fs</strong></span>. It is usually found in <code class="filename">/sbin</code>. <span class="command"><strong>mkfs.ext2</strong></span> and
	<span class="command"><strong>mkfs.ext3</strong></span> are frontends which pass specific
	options to <span class="command"><strong>mke2fs</strong></span>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="formatting-invocation"></a>7.1. Simple Invocation</h3></div></div></div><p>
	<span class="command"><strong>mke2fs</strong></span> <code class="filename">/dev/hdb1</code> 
</p><p>
	<span class="command"><strong>mkfs.ext2</strong></span> <code class="filename">/dev/hdb1</code> 
</p><p>
	both of which make an ext2 file system on the first partition of the second drive, and
</p><p>
	<span class="command"><strong>mke2fs</strong></span>	-j <code class="filename">/dev/hdb1</code> 
</p><p>
	<span class="command"><strong>mkfs.ext3</strong></span> <code class="filename">/dev/hdb1</code> 
</p><p>
	make an ext3 file system.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="reservedblocks"></a>7.2. Reserved blocks</h3></div></div></div><p>
	The -m option is probably the one of most use to non-experts. If the
	file system becomes filled and there is no more space to write, it
	is basically unusable because the operating system is constantly
	writing to disk. By default, five percent of the partition is
	reserved for use by the root user. This allows root to conduct
	administrative activities on the partition and perhaps move some
	data off. However, this is most critical when the partition contains
	/ or home directories. For pure data partitions, this is just lost
	space. Five percent of a 250Gb partition is 12.5 Gb. Especially in
	the case of large partitions, it is safe to set the reserved space
	to the minimum, which is one percent.
</p><p>
	<span class="command"><strong>mkfs.ext3</strong></span> -m 1<code class="filename">/dev/hdb1</code> 
</p><p>
	creates a file system with only 1% of its space reserved for the
	root user. tune2fs -m can be used to adjust the reserved blocks
	after data is loaded on the partition.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recovering"></a>8. Recovering a Deleted Partition Table</h2></div></div></div><p>
	Below are instructions for manually recovering a deleted partition
	table. There are utilities such as <a class="ulink" href="http://www.stud.uni-hannover.de/user/76201/gpart" target="_top">gpart</a>
	or <a class="ulink" href="http://www.cgsecurity.org/index.html?testdisk.html" target="_top">TestDisk
	</a> which can make this task considerably easier. If you are
	reading this, however, because you have run out of luck, this is
	what you will have to do:
</p><p>     
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Make a partition that is at least as big as your first partition
  was. You can make it larger than the original partition by any
  amount. If you underestimate, there will be much wailing and
  gnashing of teeth.
</p><pre class="programlisting">
Command (m for help): <strong class="userinput"><code>n</code></strong>
Command action
   e   extended
   p   primary partition (1-4)
<strong class="userinput"><code>p</code></strong>
Partition number (1-4): <strong class="userinput"><code>1</code></strong>
First cylinder (1-23361, default 1): <strong class="userinput"><code>&lt;RETURN&gt;</code></strong>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <strong class="userinput"><code>13032</code></strong>

Command (m for help): <strong class="userinput"><code>w</code></strong>
</pre><p>
  </p></li><li class="listitem"><p>
  Run <span class="command"><strong>dumpe2fs</strong></span> on the first partition and grep out the block count.
  </p><p>
  Example:
      </p><pre class="programlisting">
           % dumpe2fs /dev/sda1 | grep "Block count:"
           Block count:              41270953
      </pre><p>
      If you are uncertain about this value, repeat Step 1 with a
      bigger partition size. If the block count changes, then you
      underestimated the size of the original partition. Repeat Step
      1 until you get a stable block count.
  </p></li><li class="listitem"><p>
  Remove the partition you just created
      </p><pre class="programlisting">
         Command (m for help): <strong class="userinput"><code>d</code></strong>
         Partition number (1-4): <strong class="userinput"><code>1</code></strong>
      </pre><p>
  </p></li><li class="listitem"><p><a name="BlockSize"></a>Make a new partition with the exact size you got from the block
  count. Since you cannot enter block size in fdisk, you need to
  figure out how many cylinders to request. Here is the formula:
</p><p>
</p><pre class="programlisting">
  (number of needed cylinders) = (number of blocks) / (block size)

  (block size) = (unit size) / 1024

  (unit size) = (number of heads) * (number of sectors/cylinder) * (number of bytes/sector)
</pre><p>

</p><p>
    Consider the following example, where a hard drive has been partitioned into four primary
       partitions of 1, 2, 4, and 8 cylinders.

</p><pre class="programlisting">
disk /dev/sda: 16 heads, 63 sectors, 23361 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1         2       976+  83  Linux
/dev/sda2             3         5      1512   83  Linux
/dev/sda3             6        10      2520   83  Linux
/dev/sda4            11        19      4536   83  Linux
</pre><p>

<span class="command"><strong>fdisk</strong></span> provides the configuration information I need in the head of the output.

       The unit size is <strong class="userinput"><code>516096</code></strong> ( <strong class="userinput"><code>16</code></strong> heads * <strong class="userinput"><code>63</code></strong> sectors/cyl * <strong class="userinput"><code>512</code></strong> bytes/sector ). 

       The block size is <strong class="userinput"><code>504</code></strong> ( <strong class="userinput"><code>516096 / 1024</code></strong> ). 

       The number of needed cylinders for the second partition is therefore <strong class="userinput"><code>3</code></strong> ( <strong class="userinput"><code>1512</code></strong> blocks <strong class="userinput"><code>/
       504</code></strong> ). 

       The partition table shows that this is indeed the case: the first cylinder is <strong class="userinput"><code>3</code></strong>, the second <strong class="userinput"><code>4</code></strong>, and
       the last is <strong class="userinput"><code>5</code></strong>, for a total of three cylinders. 

       The number of needed cylinders for the third partition is calculated similarly: <strong class="userinput"><code>2520</code></strong> blocks
       <strong class="userinput"><code>/ 504 = 5</code></strong>, which corresponds to blocks <strong class="userinput"><code>6,7,8,9,10</code></strong> 
       . 

       Notice that this calculation does not work for the first partition because the block count is
       wrong ( <strong class="userinput"><code>976</code></strong> instead of <strong class="userinput"><code>1008</code></strong> ). The plus sign indicates that not all the blocks are included in
       the fdisk value. When you try the calculation ( <strong class="userinput"><code>976 / 504</code></strong> ) you get <strong class="userinput"><code>1.937</code></strong>. Knowing that
       the number of cylinders must be an integer, you can simply round up. 
  </p></li><li class="listitem"><p>Run <span class="command"><strong>e2fsck</strong></span> on it to verify that you can read the new partition.
  </p></li><li class="listitem"><p>
  Repeat Steps 1-5 on remaining partitions.
  </p></li></ol></div><p>

Remount your partitions. Amazingly, all of your data will be there.
</p><p>
Credit goes to: Mike Vevea, jedi sys admin, for providing the basic strategy.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="setting_up_swap"></a>9. Setting Up Swap Space</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="swap_partitions"></a>9.1. Swap Files</h3></div></div></div><p>
	Normally, there are only two steps to setting up swap space,
	creating the partition and adding it to /etc/fstab. A typical fstab
	entry for a swap partition at /dev/hda6 would look like this:
</p><pre class="programlisting">
/dev/hda6	swap	swap	defaults	0	0
</pre><p>
	The next time you reboot, the initialization scripts will activate
	it automatically and there's nothing more to be done.
</p><p>
	However, if you want to make use of it right away, you'll need to
	activate it maually. As root, type:
</p><pre class="programlisting">
<strong class="userinput"><code><span class="command"><strong>mkswap</strong></span> -f <code class="filename">/dev/hda6</code></code></strong>
<strong class="userinput"><code><span class="command"><strong>swapon</strong></span> <code class="filename">/dev/hda6</code></code></strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="swapfiles"></a>9.2. Swap Files</h3></div></div></div><p>
	There might be times when you've run out of swap space and it is not
	practical to repartition a drive or add a new one. In this case, you
	can use a regular file in an ordinary partition. All you have to do
	is create a file of the size you want
</p><p>

<strong class="userinput"><code><span class="command"><strong>dd</strong></span> if=/dev/zero of=/var/my_swap bs=1024 count=131072</code></strong>
</p><p>
	and activate it
</p><pre class="programlisting">
	<strong class="userinput"><code><span class="command"><strong>mkswap</strong></span> -f /var/my_swap</code></strong>
	<strong class="userinput"><code><span class="command"><strong>swapon</strong></span> /var/my_swap</code></strong>
</pre><p>
	This invocation creates a file called <code class="filename">my_swap</code>
	in <code class="filename">/var</code>. It is 128 Mb long
	(128 x 1024 = 131072). Initially, it is filled with zeros. However,
	<span class="command"><strong>mkswap</strong></span> marks it as swap space and <span class="command"><strong>swapon</strong></span> tells
	the kernel to start using it as swap space. When you are done with
	it,
</p><pre class="programlisting">
<strong class="userinput"><code><span class="command"><strong>swapoff</strong></span> /var/my_swap</code></strong>
<strong class="userinput"><code><span class="command"><strong>rm</strong></span> /var/my_swap</code></strong>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="multiple_swap_areas"></a>9.3. Multiple Swap Areas</h3></div></div></div><p>
	More than one swap partition can be used on the same system.
	Consider an example fstab where there is a single swap partition:
</p><pre class="programlisting">
/dev/hda5   /        ext3   defaults        1	1
/dev/hda1   /boot    ext2   defaults        1	2
none        /dev/pts devpts gid=5,mode=620  0	0
none        /proc    proc   defaults        0	0
/dev/hda7   /usr     ext3   defaults        1	2
/dev/hda6   swap     swap   defaults        0	0
</pre><p>
	Imagine replacing the entry for the swap partition with these three lines:
</p><pre class="programlisting">
/dev/hda6   none    swap    sw,pri=3    0	0
/dev/hdb2   none    swap    sw,pri=2    0	0
/dev/hdc2   none    swap    sw,pri=1    0	0
</pre><p>
	This configuration would cause the kernel to use /dev/hda6 first. it
	has the highest priority assigned to it (pri=3). The maximum
	priority can be 32767 and the lowest 0. If that space were to max
	out, the kernel would start using /dev/hdb2, and on to /dev/hdc2
	after that. Why such a configuration? Imagine that the newest
	(fastest) drives are given the highest priority. This will minimize
	speed loss as swap space usage grows.
</p><p>
	It is possible to write to all three simulataneously. If each has
	the same priority, the kernel will write to them much like a RAID,
	with commensurate speed increases.
</p><pre class="programlisting">
/dev/hda6   none   swap   sw,pri=3   0   0
/dev/hdb2   none   swap   sw,pri=3   0   0
/dev/hdc2   none   swap   sw,pri=3   0   0
</pre><p>
	Notice that these three partitions are on separate drives, which is
	ideal in terms of speed enhancement.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix"></a>10. Appendix</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="formating"></a>10.1. Formating Partitions</h3></div></div></div><p>
At the shell prompt, I begin making the file systems on my
partitions.  Continuing with the example in (see <a class="xref" href="#mixed" title="5.3. Mixed primary and logical partitions">Section 5.3, &#8220;Mixed primary and logical partitions&#8221;</a>),
this is:

</p><pre class="programlisting">
# mke2fs /dev/sda1
</pre><p>
</p><p>
I need to do this for each of my partitions, but not for <code class="filename">/dev/sda4</code> (my extended partition).

Linux supports types of file systems other than ext2. You can find out
what kinds your kernel supports by looking in: 
<code class="filename">/usr/src/linux/include/linux/fs.h</code>
</p><p>
	The most common file systems can be made with programs in <code class="filename">/sbin</code> that start with "mk" like
	<span class="command"><strong>mkfs.msdos</strong></span> and <span class="command"><strong>mke2fs</strong></span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="swap"></a>10.2. Activating Swap Space</h3></div></div></div><p>

To set up a swap partition:

</p><pre class="programlisting">
# mkswap -f /dev/hda5
</pre><p>

To activate the swap area:

</p><pre class="programlisting">
# swapon  /dev/hda5
</pre><p>

Normally, the swap area is activated by the initialization scripts at 
boot time.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mounting"></a>10.3. Mounting Partitions</h3></div></div></div><p>

Mounting a partition means attaching it to the linux file system. To
mount a linux partition:

</p><pre class="programlisting">
# mount -t ext2 /dev/sda1 /opt
</pre><p>

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-t ext2</span></dt><dd><p>
    File system type. Other types you are likely to use are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ext3 (journaling sile system based on ext2)</p></li><li class="listitem"><p>msdos (DOS)</p></li><li class="listitem"><p>hfs (mac)</p></li><li class="listitem"><p>iso9660 (CDROM)</p></li><li class="listitem"><p>nfs (network file system)</p></li></ul></div><p>
    </p></dd><dt><span class="term">/dev/sda1</span></dt><dd><p>
    Device name. Other device names you are likely to use:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">/dev/hdb2</code> (second partition in second IDE drive)</p></li><li class="listitem"><p><code class="filename">/dev/fd0</code>  (floppy drive A)</p></li><li class="listitem"><p><code class="filename">/dev/cdrom</code>  (CDROM)</p></li></ul></div><p>
    </p></dd><dt><span class="term">/opt</span></dt><dd><p>
		mount point. This is where you want to "see" your partition.
		When you type <strong class="userinput"><code>ls /opt</code></strong>, you can see what
		is in <code class="filename">/dev/sda1</code>. If there
		are already some directories and/or files under <code class="filename">/opt</code>, they will be invisible after
		this mount command.
    </p></dd></dl></div><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fragmentation"></a>10.4. Some facts about file systems and fragmentation</h3></div></div></div><p>
Disk space is administered by the operating system in units of
blocks and fragments of blocks. In ext2, fragments and blocks
have to be of the same size, so we can limit our discussion to
blocks.
</p><p>
Files come in any size. They don't end on block boundaries.  So
with every file a part of the last block of every file is
wasted. Assuming that file sizes are random, there is
approximately a half block of waste for each file on your disk.
Tanenbaum calls this "internal fragmentation" in his book
"Operating Systems".
</p><p>
You can guess the number of files on your disk by the number of
allocated inodes on a disk. On my disk
</p><pre class="programlisting">
# df -i
Filesystem           Inodes   IUsed   IFree  %IUsed Mounted on
/dev/hda3              64256   12234   52022    19%  /
/dev/hda5              96000   43058   52942    45%  /var
</pre><p>

	there are about 12000 files on <code class="filename">/</code> and about 44000 files on <code class="filename">/var</code>.  At a block size of 1 KB, about
	6+22 = 28 MB of disk space are lost in the tail blocks of files. Had
	I chosen a block size of 4 KB, I had lost 4 times this space.
</p><p>
	Data transfer is faster for large contiguous chunks of data, though.
	That's why ext2 tries to preallocate space in units of 8 contigous
	blocks for growing files. Unused preallocation is released when the
	file is closed, so no space is wasted.
</p><p>
	Noncontiguous placement of blocks in a file is bad for performance,
	since files are often accessed in a sequential manner. It forces the
	operating system to split a disk access and the disk to move the
	head. This is called "external fragmentation" or simply
	"fragmentation" and is a common problem with MS-DOS file systems. In
	conjunction with the abysmal buffer cache used by MS-DOS, the
	effects of file fragmentation on performance are very noticeable.
	DOS users are accustomed to defragging their disks every few weeks
	and some have even developed some ritualistic beliefs regarding
	defragmentation.
</p><p>
	None of these habits should be carried over to Linux and ext2. Linux
	native file systems do not need defragmentation under normal use and
	this includes any condition with at least 5% of free space on a
	disk. There is a defragmentation tool for ext2 called defrag, but
	users are cautioned against casual use. A power outage during such
	an operation can trash your file system. Since you need to back up
	your data anyway, simply writing back from your copy will do the
	job.
</p><p>
	The MS-DOS file system is also known to lose large amounts of disk
	space due to internal fragmentation. For partitions larger than 256
	MB, DOS block sizes grow so large that they are no longer useful
	(This has been corrected to some extent with FAT32). Ext2 does not
	force you to choose large blocks for large file systems, except for
	very large file systems in the 0.5 TB range (that's terabytes with 1
	TB equaling 1024 GB) and above, where small block sizes become
	inefficient. So unlike DOS there is no need to split up large disks
	into multiple partitions to keep block size down.
</p><p>
	Use a 1Kb block size if you have many small files. For large
	partitions, 4Kb blocks are fine.
</p></div></div></div></body></html>
