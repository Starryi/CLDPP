<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>From Power Up To Bash Prompt</TITLE>
</HEAD>
<BODY>
<H1>From Power Up To Bash Prompt</H1>

<H2>Greg O'Keefe, <CODE>gcokeefe@postoffice.utas.edu.au</CODE></H2>v0.9, November 2000
<HR>
<EM>This is a brief description of what happens in a Linux system, from the time
that you turn on the power, to the time that you log in and get a bash prompt.
Understanding this will be helpful when you need to
solve problems or configure your system.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>I find it frustrating that many things happen inside my Linux machine that I do
not understand. If, like me, you want to really understand your system rather
than just knowing how to use it, this document should be a good place to start.
This kind of background knowledge is also needed if you want to be a top notch
Linux problem solver.</P>

<P>I assume that you have a working Linux box, and understand some basic things
about Unix and PC hardware. If not, an excellent place to start learning is
Eric S. Raymond's 
<A HREF="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A>
It is short, very readable and covers all the basics.</P>

<P>The main thread in this document is how Linux starts itself up. 
But it also tries to be a more comprehensive learning resource.
I have included exercises in each section. If you actually do some of these,
you will learn much more than you could by just reading.</P>

<P>I hope some readers will undertake the best Linux learning exercise that I
know of, which is building a system from source code. 
Giambattista Vico, an Italian philosopher (1668-1744) said 
``verum ipsum factum'', which means ``understanding arises through making''.
Thanks to Alex (see 
<A HREF="#acknowledge">Acknowledgements</A>) 
for this quote.</P>

<P>If you want to ``roll your own'', you should also see Gerard Beekmans' 
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A> (LFS).
LFS has detailed instructions on building a complete useable system from
source code. On the LFS website, you will also find a mailing list for people 
building systems this way. 
The instructions that used to be part of this document 
are now in a separate document ``Building a Minimal Linux System from Source Code'', 
and can be found at
<A HREF="http://www.netspace.net.au/~gok/power2bash/">From PowerUp to Bash Prompt home page</A>.
They explain how to
``toy'' system, purely as a learning exercise. </P>

<P>Packages are presented in the order in which they appear in the system
startup process. This means that if you install the packages in this order
you can reboot after each installation, and see the system get a little closer
to giving you a bash prompt each time. There is a reassuring sense of
progress in this.</P>

<P>I recommend that you first read the main text of each section, skipping the
exercises and references. Then decide how deep an understanding you want to
develop, and how much effort you are prepared to put in. Then start at the 
beginning again, doing the exercises and additional reading as you go.</P>



<H2><A NAME="s2">2. Hardware</A></H2>

<P>When you first turn on your computer it tests itself to make sure everything is
in working order. This is called the ``Power on self test''. Then a program
called the bootstrap loader, located in the ROM BIOS, looks for
a boot sector. A boot sector is the first sector of a disk and has a small 
program that can load an operating system. Boot sectors are marked with a magic 
number 0xAA55 = 43603 at byte 0x1FE = 510. That's the last two bytes of the
sector. This is how the hardware can tell
whether the sector is a boot sector or not. </P>

<P>The bootstrap loader has a list of places to look for a boot sector. My old 
machine looks in the primary floppy drive, then the primary hard drive. 
More modern machines can also look for a boot sector on a CD-ROM.
If it finds a boot sector, it loads it into memory and passes control to the
program that loads the operating system.
On a typical Linux system, this program will be LILO's first stage
boot loader. There are many different ways of setting your system up to boot
though. See the <EM>LILO User's Guide</EM> for details. See section 
<A HREF="#lilo-links">LILO</A> for a URL.</P>

<P>Obviously there is a lot more to say about what PC hardware does. But this is
not the place to say it. See one of the many good books about PC hardware.</P>

<H2><A NAME="ss2.1">2.1 Configuration</A>
</H2>

<P>The machine stores some information about itself in its CMOS. This
includes what disks and RAM are in the system. The machine's BIOS contains a
program to let you modify these settings. Check the messages on your screen as
the machine is turned on to see how to access it. On my machine, you press the
delete key before it begins loading its operating system.</P>

<H2><A NAME="hardware-ex"></A> <A NAME="ss2.2">2.2 Exercises </A>
</H2>

<P>A good way to learn about PC hardware is to build a machine out of second hand
parts. Get at least a 386 so you can easily run Linux on it. It won't cost much.
Ask around, someone might give you some of the parts you need. </P>

<P>Check out, download compile and make a boot disk for 
<A HREF="http://www.netspace.net.au/~gok/resources">Unios</A>.
(They used to have a home page at 
<A HREF="http://www.unios.org">http://www.unios.org</A>,
but it disappeared)
This is just a bootable ``Hello World!'' program, consisting of just over 100 
lines of assembler code. It would be good to see it converted to a format
that the GNU assembler <CODE>as</CODE> can understand.</P>

<P>Open the boot disk image for unios with a hex editor. This image is 512 bytes
long, exactly one sector. Find the magic number 0xAA55. Do the same for
the boot sector from a bootable floppy disk or your own computer. You can
use the <CODE>dd</CODE> command to copy it to a file: <CODE>dd if=/dev/fd0 of=boot.sector</CODE>.
Be <EM>very</EM> careful to get <CODE>if</CODE> (input file)  and <CODE>of</CODE> 
(output file) the right way round!</P>
<P>Check out the source code for LILO's boot loader.</P>

<H2><A NAME="ss2.3">2.3 More Information</A>
</H2>

<P>
<UL>
<LI>
<A HREF="http://www.linuxdoc.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A>
by Eric S. Raymond,
especially section 3, <EM>What happens when you switch on a computer?</EM>
</LI>
<LI>The first chapter of <EM>The LILO User's Guide</EM> gives an excellent
explanation of PC disk partitions and booting.
See section 
<A HREF="#lilo-links">LILO</A> for a URL.
</LI>
<LI><EM>The NEW Peter Norton Programmer's Guide to the IBM PC &amp; PS/2</EM>, 
by Peter Norton and Richard Wilton, Microsoft Press 1988 
There is a newer Norton book, which looks good, but I can't afford it right now!
</LI>
<LI>One of the many books available on upgrading PC's</LI>
</UL>
</P>



<H2><A NAME="s3">3. Lilo</A></H2>

<P>When the computer loads a boot sector on a normal Linux system, what it loads is actually a part of lilo, called the ``first stage boot loader''. This is a tiny program who's only job in life is to load and run the ``second stage boot loader''.</P>

<P>The second stage loader gives you a prompt (if it was installed that way) and loads the operating system you choose. </P>

<P>When your system is up and running, and you run <CODE>lilo</CODE>, what you are actually running is the ``map installer''. This reads the configuration file <CODE>/etc/lilo.conf</CODE> and writes the boot loaders, and information about the operating systems it can load, to the hard disk.</P>

<P>There are lots of different ways to set your system up to boot. What I have just explained is the most obvious and ``normal'' way, at least for a system who's main operating system is Linux. The Lilo Users' Guide explains several examples of ``boot concepts''. It is worth reading these, and trying some of them out. </P>

<H2><A NAME="ss3.1">3.1 Configuration</A>
</H2>

<P>The configuration file for lilo is <CODE>/etc/lilo.conf</CODE>. There is a manual
page for it: type <CODE>man lilo.conf</CODE> into a shell to see it. The main thing
in <CODE>lilo.conf</CODE> is one entry for each thing that lilo is set up to boot. For a
Linux entry, this includes where the kernel is, and what disk partition to
mount as the root filesystem. For other operating systems, the main piece of
information is which partition to boot from.</P>

<H2><A NAME="ss3.2">3.2 Exercises</A>
</H2>

<P><EM>DANGER:</EM> take care with these exercises. It is easy enough to get
something wrong and screw up your master boot record and make your system
unuseable. Make sure you have a working rescue disk, and know how to use it to
fix things up again. See below for a link to tomsrtbt, the rescue disk I use
and recommend. The best precaution is to use a machine that doesn't matter. </P>

<P>Set up lilo on a floppy disk. It doesn't matter if there is nothing other than
a kernel on the floppy - you will get a ``kernel panic'' when the kernel is
ready to load init, but at least you will know that lilo is working. </P>

<P>If you like you can press on and see how much of a system you can get going on
the floppy. This is probably the second best Linux learning activity around.
See the Bootdisk HOWTO (url below), and tomsrtbt (url below) for clues.</P>

<P>Get lilo to boot unios (see section 
<A HREF="#hardware-ex">hardware exercises</A> for a URL). As an extra challenge, see if you can do this on a
floppy disk.</P>

<P>Make a boot-loop. Get lilo in the master boot record to boot lilo in one of the
primary partition boot sectors, and have that boot lilo in the master boot
record... Or perhaps use the master boot record and all four primary partitions
to make a five point loop. Fun!</P>

<H2><A NAME="ss3.3">3.3 More Information</A>
</H2>

<P>
<A NAME="lilo-links"></A> 
<UL>
<LI>The lilo man page. </LI>
<LI>The Lilo package 
(
<A HREF="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/">lilo</A>),
contains the ``LILO User's Guide'' 
<CODE>lilo-u-21.ps.gz</CODE> (or a later version).
You may already have this document though. 
Check <CODE>/usr/doc/lilo</CODE> or there abouts. 
The postscript version is better than the plain text, 
since it contains diagrams and tables.</LI>
<LI>
<A HREF="http://www.toms.net/rb">tomsrtbt</A> the coolest single
floppy linux. Makes a great rescue disk.</LI>
<LI>
<A HREF="http://www.linuxdoc.org/HOWTO/Bootdisk-HOWTO/">The Bootdisk HOWTO</A> </LI>
</UL>
</P>



<H2><A NAME="s4">4. The Linux Kernel</A></H2>


<P>The kernel does quite a lot really. I think a fair way of summing it up is that it makes the hardware do what the programs want, fairly and efficiently.</P>

<P>The processor can only execute one instruction at a time, but Linux systems
appear to be running lots of things simultaneously. The kernel acheives this by
switching from task to task really quickly. It makes the best use of the processor
by keeping track of which processes are ready to go, and which ones are waiting
for something like a record from a hard disk file, or some keyboard input.
This kernel task is called scheduling.</P>

<P>If a program isn't doing anything, then it doesn't need to be in RAM. Even a
program that is doing something, might have parts that aren't doing anything.
The address space of each process is divided into pages. The Kernel keeps track of
which pages of which processes are being used the most. The pages that aren't
used so much can be moved out to the swap partition. When they are needed again,
another unused page can be paged out to make way for it. This is virtual memory
management. </P>

<P>If you have ever compiled your own Kernel, you will have noticed that there are
many many options for specific devices. The kernel contains a lot of specific
code to talk to diverse kinds of hardware, and present it all in a nice uniform
way to the application programs.</P>

<P>The Kernel also manages the filesystem, interprocess communication, and a lot
of networking stuff.</P>

<P>Once the kernel is loaded, the first thing it does is look for an <CODE>init</CODE> program to run.</P>

<H2><A NAME="ss4.1">4.1 Configuration</A>
</H2>

<P>Most of the configuration of the kernel is done when you build it, using
<CODE>make menuconfig</CODE>, or <CODE>make xconfig</CODE> in <CODE>/usr/src/linux/</CODE>
(or wherever your Linux kernel source is). You can reset the default video
mode, root filesystem, swap device and RAM disk size using <CODE>rdev</CODE>. These
parameters and more can also be passed to the kernel from lilo. You can give lilo
parameters to pass to the kernel either in lilo.conf, or at the lilo prompt.
For example if you wanted to use hda3 as your root file system instead of hda2,
you might type</P>
<P>
<PRE>
        LILO: linux root=/dev/hda3
</PRE>
</P>

<P>If you are building a system from source, you can make life a lot simpler by
creating a ``monolithic'' kernel. That is one with no modules. Then you don't
have to copy kernel modules to the target system.</P>

<P>NOTE: The <CODE>System.map</CODE> file is used by the kernel logger to determine
the module names generating messages. The program <CODE>top</CODE> also uses this
information. When you copy the kernel to the target system, copy
<CODE>System.map</CODE> too.</P>

<H2><A NAME="ss4.2">4.2 Exercises</A>
</H2>

<P>Think about this: <CODE>/dev/hda3</CODE> is a special type of file that
describes a hard disk partition. But it lives on a file system just like all
other files. The kernel wants to know which partition to mount as the root
filesystem - it doesn't have a file system yet. So how can it read 
<CODE>/dev/hda3</CODE> to find out which partition to mount? </P>

<P>If you haven't already: build your own kernel. Read all the help information
for each option.</P>

<P>See how small a kernel you can make that still works. You can learn a lot by leaving the wrong things out! </P>

<P>Read ``The Linux Kernel'' (URL below) and as you do, find the parts of the source code that it refers to. The book (as I write) refers to kernel version 2.0.33, which is pretty out of date. It might be easier to follow if you download this old version and read the source there.  Its amazing to find bits of C code called ``process'' and ``page''.</P>

<P>Hack! See if you can make it spit out some extra messages or something.</P>


<H2><A NAME="Kernel"></A> <A NAME="ss4.3">4.3 More Information </A>
</H2>

<P>
<UL>
<LI><CODE>/usr/src/linux/README</CODE> and the contents of 
<CODE>/usr/src/linux/Documentation/</CODE> 
(These may be in some other place on your system)</LI>
<LI> 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Kernel-HOWTO.html">The Kernel HOWTO</A> </LI>
<LI>The help available when you configure a kernel using 
<CODE>make menuconfig</CODE> or <CODE>make xconfig</CODE> </LI>
<LI> 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">The Linux Kernel (and other LDP Guides)</A></LI>
<LI>  source code, see 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> 
for urls</LI>
</UL>
</P>


<H2><A NAME="s5">5. The GNU C Library</A></H2>

<P>The next thing that happens as your computer starts up is that init is loaded
and run. However, init, like almost all programs, uses functions from libraries.  </P>

<P>You may have seen an example C program like this:</P>

<P>
<PRE>
        main() {
                printf("Hello World!\n");
        }
</PRE>
</P>
<P>The program contains no definition of <CODE>printf</CODE>, so where does it come from?
It comes from the standard C libraries, on a GNU/Linux system, glibc.
If you compile it under Visual C++, then it comes from a Microsoft
implementation of the same standard functions. There are zillions of
these standard functions, for math, string, dates/times memory allocation
and so on. Everything in Unix (including Linux) is either written in C
or has to try hard to pretend it is, so everything uses these functions.</P>

<P>     
If you look in <CODE>/lib</CODE> on your linux system you will see lots of files called
<CODE>libsomething.so</CODE> or <CODE>libsomething.a</CODE> etc. They are libraries of these functions.
Glibc is just the GNU implementation of these functions.</P>

<P>There are two ways programs can use these library functions. If you <EM>statically</EM>
link a program, these library functions are copied into the executable that gets
created. This is what the <CODE>libsomething.a</CODE> libraries are for. If you 
<EM>dynamically</EM> link a program (and this is the default), then when the program
is running and needs the library code, it is called from the <CODE>libsomething.so</CODE>
file.</P>

<P>The command <CODE>ldd</CODE> is your friend when you want to work out which
libraries are needed by a particular program.  For example, here are the
libraries that <CODE>bash</CODE> uses:</P>

<P>
<PRE>
        [greg@Curry power2bash]$ ldd /bin/bash
                libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
                libc.so.6 => /lib/libc.so.6 (0x4001d000)
                /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</PRE>
</P>

<H2><A NAME="ss5.1">5.1 Configuration</A>
</H2>

<P>Some of the functions in the libraries depend on where you are. For example, in Australia we write dates as dd/mm/yy, but Americans write mm/dd/yy. There is a program that comes with the <CODE>glibc</CODE> distribution called <CODE>localedef</CODE> which enables you to set this up.</P>

<H2><A NAME="ss5.2">5.2 Exercises</A>
</H2>

<P>Use <CODE>ldd</CODE> to find out what libraries your favourite applications use.</P>

<P>Use <CODE>ldd</CODE> to find out what libraries <CODE>init</CODE> uses.</P>

<P>Make a toy library, with just one or two functions in it. The program
<CODE>ar</CODE> is used to create them, the man page for <CODE>ar</CODE> might be a
good place to start investigating how this is done. Write, compile and link
a program that uses this library.</P>


<H2><A NAME="ss5.3">5.3 More Information</A>
</H2>

<P>
<UL>
<LI>  source code, see 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> 
for urls</LI>
</UL>
</P>



<H2><A NAME="s6">6. Init</A></H2>

<P>I will only talk about the ``System V'' style of init that Linux systems mostly
use. There are alternatives. In fact, you can put any program you like in
<CODE>/sbin/init</CODE>, and the kernel will run it when it has finished loading.</P>

<P>It is <CODE>init</CODE>'s job to get everthing running the way it should be. 
It checks that
the file systems are ok and mounts them. It starts up ``daemons'' to log system
messages, do networking, serve web pages, listen to your mouse and so on. It
also starts the getty processes that put the login prompts on your virtual
terminals. </P>

<P>There is a whole complicated story about switching ``run-levels'', but I'm
going to mostly skip that, and just talk about system start up.</P>

<P>Init reads the file <CODE>/etc/inittab</CODE>, which tells it what to do.
Typically, the first thing it is told to do is to run an initialisation script.
The program that executes (or interprets) this script is <CODE>bash</CODE>,
the same program that gives you a command prompt. 
In Debian systems, the initialisation script is <CODE>/etc/init.d/rcS</CODE>, on Red Hat,
<CODE>/etc/rc.d/rc.sysinit</CODE>. This is where the filesystems get checked and
mounted, the clock set, swap space enabled, hostname gets set etc. </P>

<P>Next, another script is called to take us into the default run-level. This just
means a set of subsystems to start up. There is a set of directories
<CODE>/etc/rc.d/rc0.d</CODE>, 
<CODE>/etc/rc.d/rc1.d</CODE>, ..., <CODE>/etc/rc.d/rc6.d</CODE> in Red Hat, or
<CODE>/etc/rc0.d</CODE>,
<CODE>/etc/rc1.d</CODE>, ..., <CODE>/etc/rc6.d</CODE> in Debian, which correspond to the
run-levels. If we are going into runlevel 3 on a Debian system, then the script
runs all the scripts in <CODE>/etc/rc3.d</CODE> that start with `S' (for start).
These scripts are really just links to scripts in another directory usually
called <CODE>init.d</CODE>. </P>

<P>So our run-level script was called by <CODE>init</CODE>, and it is looking in a directory for scripts starting with `S'. It might find <CODE>S10syslog</CODE> first. The numbers tell the run-level script which order to run them in. So in this case <CODE>S10syslog</CODE> gets run first, since there were no scripts starting with S00 ... S09. But <CODE>S10syslog</CODE> is really a link to <CODE>/etc/init.d/syslog</CODE> which is a script to start and stop the system logger. Because the link starts with an `S', the run-level script knows to execute the <CODE>syslog</CODE> script with a ``start'' parameter. There are corresponding links starting with `K' (for kill), which specify what to shut down and in what order when leaving the run-level.</P>

<P>To change what subsystems start up by default, you must set up these links in
the <CODE>rcN.d</CODE> directory, where N is the default runlevel set in your
<CODE>inittab</CODE>.</P>

<P>The last important thing that init does is to start some <CODE>getty</CODE>'s.
These are ``respawned'' which means that if they stop, <CODE>init</CODE> just
starts them again. Most distributions come with six virtual terminals. You may
want less than this to save memory, or more so you can leave lots of 
things running and
quickly flick to them as you need them. You may also want to run a 
<CODE>getty</CODE> for a
text terminal or a dial in modem. In this case you will need to edit the
<CODE>inittab</CODE> file.</P>


<H2><A NAME="ss6.1">6.1 Configuration</A>
</H2>

<P><CODE>/etc/inittab</CODE> is the top level configuration file for init.</P>

<P>The <CODE>rcN.d</CODE> directories, where N = 0, 1, ..., 6 determine what
subsystems are started.</P>

<P>Somewhere in one of the scripts invoked by init, the <CODE>mount -a</CODE> command
will be issued. This means mount all the file systems that are supposed to be
mounted. The file <CODE>/etc/fstab</CODE> defines what is supposed to be mounted.
If you want to change what gets mounted where when your system starts up, this 
is the file you will need to edit. There is a man page for <CODE>fstab</CODE>.</P>

<H2><A NAME="ss6.2">6.2 Exercises</A>
</H2>

<P>Find the <CODE>rcN.d</CODE> directory for the default run-level of your system and do a <CODE>ls -l</CODE> to see what the files are links to.</P>

<P>Change the number of gettys that run on your system.</P>

<P>Remove any subsystems that you don't need from your default run-level.</P>

<P>See how little you can get away with starting.</P>

<P>Set up a floppy disk with lilo, a kernel and a statically linked "hello world" program called <CODE>/sbin/init</CODE> and watch it boot up and say hello.</P>

<P>Watch carefully as your system starts up, and take notes about what it tells you is happening. Or print a section of your system log <CODE>/var/log/messages</CODE> from start up time. Then starting at <CODE>inittab</CODE>, walk through all the scripts and see what code does what. You can also put extra start up messages in, such as</P>
<P>
<PRE>
        echo "Hello, I am rc.sysinit"
</PRE>
</P>
<P>This is a good exercise in learning Bash shell scripting too, some of the scripts are quite complicated. Have a good Bash reference handy.</P>

<H2><A NAME="ss6.3">6.3 More Information</A>
</H2>

<P>
<UL>
<LI>There are man pages for the <CODE>inittab</CODE> and <CODE>fstab</CODE> files. 
Type (eg) <CODE>man inittab</CODE> into a shell to see it.</LI>
<LI>The Linux System Administrators Guide has a good 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">section</A> on init.</LI>
<LI>  source code, see 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> 
for urls</LI>
</UL>
</P>


<H2><A NAME="s7">7. The Filesystem</A></H2>

<P>In this section, I will be using the word ``filesystem'' in two different ways.
There are filesystems on disk partitions and other devices, 
and there is the filesystem as it is
presented to you by a running Linux system. In Linux, you ``mount'' a disk
filesystem onto the system's filesystem.</P>

<P>In the previous section I mentioned that init scripts check and mount the
filesystems. The commands that do this are <CODE>fsck</CODE> and <CODE>mount</CODE>
respectively.</P>

<P>A hard disk is just a big space that you can write ones and zeros on. A
filesystem imposes some structure on this, and makes it look like files within
directories within directories... Each file is represented by an inode, which
says who's file it is, when it was created and where to find its contents.
Directories are also represented by inodes, but these say where to find the
inodes of the files that are in the directory. If the system wants to read
<CODE>/home/greg/bigboobs.jpeg</CODE>, it first finds the inode for the root
directory <CODE>/</CODE> in the ``superblock'', then finds the inode for the
directory <CODE>home</CODE> in the contents of <CODE>/</CODE>, then finds the inode for
the directory <CODE>greg</CODE> in the contents of <CODE>/home</CODE>, 
then the inode for <CODE>bigboobs.jpeg</CODE> which
will tell it which disk blocks to read.</P>


<P>If we add some data to the end of a file, it could happen that the data is
written before the inode is updated to say that the new blocks belong to the
file, or vice versa. If the power cuts out at this point, the filesystem will
be broken. It is this kind of thing that <CODE>fsck</CODE> attempts to detect and
repair.</P>

<P>The mount command takes a filesystem on a device, and adds it to the heirarchy
that you see when you use your system. Usually, the kernel mounts its root file
system read-only. The mount command is used to remount it read-write after
<CODE>fsck</CODE> has checked that it is ok.</P>

<P>Linux supports other kinds of filesystem too: msdos, vfat, minix and so on. The
details of the specific kind of filesystem are abstracted away by the virtual
file system (VFS). I won't go into any detail on this though. There is a
discussion of it in ``The Linux Kernel'' 
(see section 
<A HREF="#Kernel">The Linux Kernel</A> for a url)</P>

<P>A completely different kind of filesystem gets mounted on <CODE>/proc</CODE>.
It is really a representation of things in the kernel. There is a 
directory there for each process running on the system, with the process
number as the directory name. There are also files such as <CODE>interrupts</CODE>,
and <CODE>meminfo</CODE> which tell you about how the hardware is being used.
You can learn a lot by exploring <CODE>/proc</CODE>.</P>

<H2><A NAME="ss7.1">7.1 Configuration</A>
</H2>

<P>There are parameters to the command <CODE>mke2fs</CODE> which creates ext2
filesystems. These control the size of blocks, the number of inodes and so on.
Check the <CODE>mke2fs</CODE> man page for details.</P>

<P>What gets mounted where on your filesystem is controlled by the <CODE>/etc/fstab</CODE>
file. It also has a man page. </P>

<H2><A NAME="ss7.2">7.2 Exercises</A>
</H2>

<P>Make a very small filesystem, and view it with a hex viewer. Identify inodes,
superblocks and file contents.</P>

<P>I believe there are tools that give you a graphical view of a filesystem.
Find one, try it out, and email me the url and a review!</P>

<P>Check out the ext2 filesystem code in the Kernel.</P>

<H2><A NAME="ss7.3">7.3 More Information</A>
</H2>

<P>
<UL>
<LI>Chapter 9 of the LDP book ``The Linux Kernel'' is an excellent description
of filesystems. You can find it at the Australian LDP
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">mirror</A></LI>
<LI>The <CODE>mount</CODE> command is part of the util-linux package, there is a link 
to it in 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> </LI>
<LI>man pages for <CODE>mount</CODE>, <CODE>fstab</CODE>, <CODE>fsck</CODE>, <CODE>mke2fs</CODE>
and <CODE>proc</CODE></LI>
<LI>The file <CODE>Documentation/proc.txt</CODE> in the Linux source code explains
the <CODE>/proc</CODE> filesystem.</LI>
<LI>EXT2 File System Utilities
<A HREF="http://web.mit.edu/tytso/www/linux/e2fsprogs.html">ext2fsprogs</A> home page
<A HREF="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/">ext2fsprogs</A> Australian mirror. There is also a Ext2fs-overview
document here, although it is out of date, and not as readable as chapter 9
of ``The Linux Kernel''</LI>
<LI>  
<A NAME="FHS"></A> 
<A HREF="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/">Unix File System Standard</A> 
Another 
<A HREF="http://www.pathname.com/fhs/">link</A> to the Unix File System Standard.
This describes what should go where
in a Unix file system, and why. It also has minimum requirements for
the contents of <CODE>/bin</CODE>, <CODE>/sbin</CODE> and so on. This is a 
good reference if your goal is to make a minimal yet complete system.</LI>
</UL>
</P>



<H2><A NAME="s8">8. Kernel Daemons</A></H2>

<P>If you issue the <CODE>ps aux</CODE> command, you will see something like the following:</P>

<P>
<PRE>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2] 
root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)
root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)
root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)
root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)
root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0 
root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd 
root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash 
root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt
root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1
root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux 
</PRE>
</P>

<P>This is a list of the processes running on the system. The information comes
from the <CODE>/proc</CODE> filesystem that I mentioned in the previous section.
Note that <CODE>init</CODE>
is process number one. Processes 2, 3, 4 and 5 are kflushd, kupdate, kpiod and
kswapd. There is something strange here though: notice that in both the virtual
storage size (SIZE) and the Real Storage Size (RSS) columns, these processes
have zeroes. How can a process use no memory? </P>

<P>These processes are the kernel daemons. Most of the kernel 
does not show up on process lists at all, and you can
only work out what memory it is using by subtracting the memory available from
the amount on your system. The kernel daemons are started after init,
so they get process numbers like normal processes do. But their code and
data lives in the kernel's part of the memory. </P>

<P>There are brackets around the entries in the command column
because the <CODE>/proc</CODE> filesystem does not contain command line information
for these processes.</P>

<P>So what are these kernel daemons for?
Previous versions of this document had a plea for help,
as I didn't know much about the kernel daemons.
The following partial story has been patched together
from various replies to that plea, for which I am most grateful. 
Further clues, references and corrections are most welcome!</P>

<P>Input and output is done via <EM>buffers</EM> in memory. 
This allows things to run faster. What
programs write can be kept in memory, in a buffer, then written to disk in
larger more efficient chunks. The daemons <CODE>kflushd</CODE> and <CODE>kupdate</CODE>
handle this work:
<CODE>kupdate</CODE> runs periodically (5 seconds?) 
to check whether there are any dirty buffers. If there are, it gets
<CODE>kflushd</CODE> to flush them to disk.</P>

<P>Processes often have nothing to do, and ones that are running often
don't need all of their code and data in memory. This means we can
make better use of our memory, by shifting unused parts of running programs
out to the swap partition(s) of the hard disk.
Moving this data in and out of memory as needed is done by
<CODE>kpiod</CODE> and <CODE>kswapd</CODE>. Every second or so, <CODE>kswapd</CODE>
wakes up to check out the memory situation, and if something out on
the disk is needed in memory, or there is not enough free memory,
<CODE>kpiod</CODE> is called in.</P>

<P>There might also be a <CODE>kapmd</CODE> daemon running on your system if you
have configured automatic power management into your kernel.</P>


<H2><A NAME="ss8.1">8.1 Configuration</A>
</H2>

<P>The program <CODE>update</CODE> allows you to configure <CODE>kflushd</CODE> and <CODE>kswapd</CODE>.
Try <CODE>update -h</CODE> for some information. </P>

<P>Swap space is turned on by <CODE>swapon</CODE> and off by <CODE>swapoff</CODE>.
The init script (<CODE>/etc/rc.sysinit</CODE> or <CODE>/etc/rc.d/rc.sysinit</CODE>)
usually calls <CODE>swapon</CODE> as the system is coming up.
I'm told that <CODE>swapoff</CODE> is handy for saving power on laptops.</P>

<H2><A NAME="ss8.2">8.2 Exercises</A>
</H2>

<P>Do an <CODE>update -d</CODE>, note the blatherings on the
last line about ``threshold for buffer fratricide''.
Now there's an intriguing concept, go investigate!</P>

<P>Change directory to <CODE>/proc/sys/vm</CODE> and <CODE>cat</CODE> the
files there. See what you can work out.</P>

<H2><A NAME="ss8.3">8.3 More Information</A>
</H2>

<P>The Linux Documentation Project's ``The Linux Kernel'' 
(see section 
<A HREF="#Kernel">The Linux Kernel</A> for a url) </P>

<P>The Linux kernel source code, if you are brave enough!
The <CODE>kswapd</CODE> code is in <CODE>linux/mm/vmscan.c</CODE>, 
and <CODE>kflushd</CODE> and <CODE>kupdate</CODE>
are in <CODE>linux/fs/buffer.c</CODE>.</P>



<H2><A NAME="s9">9. System Logger</A></H2>

<P>Init starts the <CODE>syslogd</CODE> and <CODE>klogd</CODE> daemons. They write
messages to logs. The kernel's messages are handled by <CODE>klogd</CODE>, while
<CODE>syslogd</CODE> handles log messages from other processes. The main log is
<CODE>/var/log/messages</CODE>. This is a good place to look if something is going
wrong with your system. Often there will be a valuable clue in there.</P>


<H2><A NAME="ss9.1">9.1 Configuration</A>
</H2>

<P>The file <CODE>/etc/syslog.conf</CODE> tells the loggers what messages to put where. Messages are identified by which service they come from, and what priority level they are. This configuration file consists of lines that say messages from service x with priority y go to z, where z is a file, tty, printer, remote host or whatever.</P>

<P>NOTE: Syslog requires the <CODE>/etc/services</CODE> file to be present. The services file allocates ports. I am not sure whether syslog needs a port allocated so that it can do remote logging, or whether even local logging is done through a port,
or whether it just uses <CODE>/etc/services</CODE> to convert the service names 
you type <CODE>/etc/syslog.conf</CODE> into port numbers.</P>

<H2><A NAME="ss9.2">9.2 Exercises</A>
</H2>

<P>Have a look at your system log. Find a message you don't understand, and find out what it means.</P>

<P>Send all your log messages to a tty. (set it back to normal once done)</P>


<H2><A NAME="ss9.3">9.3 More Information</A>
</H2>

<P>Australian sysklogd 
<A HREF="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/">Mirror</A></P>



<H2><A NAME="s10">10. Getty and Login</A></H2>

<P>Getty is the program that enables you to log in through a serial device such as a virtual terminal, a text terminal, or a modem. It displays the login prompt. Once you enter your username, getty hands this over to <CODE>login</CODE> which asks for a password, checks it out and gives you a shell.</P>


<P>There are many getty's available. Some distributions, including Red Hat use
a very small one called <CODE>mingetty</CODE> that only works with virtual terminals.</P>

<P>The <CODE>login</CODE> program is part of the util-linux package, which also
contains a getty called <CODE>agetty</CODE>, which works fine. This package also
contains  <CODE>mkswap</CODE>, <CODE>fdisk</CODE>,
<CODE>passwd</CODE>, <CODE>kill</CODE>, <CODE>setterm</CODE>, <CODE>mount</CODE>,
<CODE>swapon</CODE>, <CODE>rdev</CODE>, <CODE>renice</CODE>, 
<CODE>more</CODE> (the program) and more (ie more programs).</P>

<H2><A NAME="ss10.1">10.1 Configuration</A>
</H2>

<P>The message that comes on the top of your screen with your login prompt comes
from <CODE>/etc/issue</CODE>. Gettys are usually started in <CODE>/etc/inittab</CODE>.
Login checks user details in <CODE>/etc/passwd</CODE>, and if you have password
shadowing, <CODE>/etc/shadow</CODE>.</P>

<H2><A NAME="ss10.2">10.2 Exercises</A>
</H2>

<P>Create a <CODE>/etc/passwd</CODE> by hand. Passwords can be set to null, and
changed with the program <CODE>passwd</CODE> once you log on. See the man page for
this file Use <CODE>man 5 passwd</CODE> to get the man page for the file rather
than the man page for the program.</P>



<H2><A NAME="s11">11. Bash</A></H2>

<P>If you give <CODE>login</CODE> a valid username and password combination, it will
check in <CODE>/etc/passwd</CODE> to see which shell to give you. In most cases on
a Linux system this will be <CODE>bash</CODE>. It is <CODE>bash</CODE>'s job to read
your commands and see that they are acted on. It is simultaneously a user
interface, and a programming language interpreter.  </P>

<P>As a user interface it reads your commands, and executes them itself if they
are ``internal'' commands like <CODE>cd</CODE>, or finds and executes a program if
they are ``external'' commands like <CODE>cp</CODE> or <CODE>startx</CODE>. It also
does groovy stuff like keeping a command history, and completing filenames.</P>

<P>We have already seen <CODE>bash</CODE> in action as a programming language
interpreter. The scripts that <CODE>init</CODE> runs to start the system up are
usually shell scripts, and are executed by <CODE>bash</CODE>. Having a proper
programming language, along with the usual system utilities available at the
command line makes a very powerful combination, if you know what you are doing.
For example (smug mode on) I needed to apply a whole stack of ``patches'' to a
directory of source code the other day. I was able to do this with the
following single command:</P>
<P>
<PRE>
for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 &lt; $f; done;
</PRE>
</P>

<P>This looks at all the files in my home directory whose names start with
<CODE>sh-utils-1.16</CODE> and end with <CODE>.patch</CODE>. It then takes each of
these in turn, and sets the variable <CODE>f</CODE> to it and executes the commands
between <CODE>do</CODE> and <CODE>done</CODE>. In this case there were 11 patch files,
but there could just as easily have been 3000.</P>

<H2><A NAME="ss11.1">11.1 Configuration</A>
</H2>

<P>The file <CODE>/etc/profile</CODE> controls the system-wide behaviour of bash. What
you put in here will affect everybody who uses bash on your system. It will do
things like add directories to the <CODE>PATH</CODE>, set your <CODE>MAIL</CODE>
directory variable.</P>

<P>The default behaviour of the keyboard often leaves a lot to be desired. It is
actually readline that handles this. Readline is a separate package that
handles command line interfaces, providing the command history and filename
completion, as well as some advanced line editing features. It is compiled into
bash. By default, readline is configured using the file <CODE>.inputrc</CODE> in
your home directory. The bash variable INPUTRC can be used to override this for
bash. For example in Red Hat 6, <CODE>INPUTRC</CODE> is set to
<CODE>/etc/inputrc</CODE> in <CODE>/etc/profile</CODE>. This means that backspace,
delete, home and end keys work nicely for everyone. </P>

<P>Once bash has read the system-wide configuration file, it looks for your
personal configuration file. It checks in your home directory for
<CODE>.bash_profile</CODE>, <CODE>.bash_login</CODE> and <CODE>.profile</CODE>. It runs the
first one of these it finds. If you want to change the way bash behaves for
you, without changing the way it works for others, do it here. For example,
many applications use environment variables to control how they work. I have
the variable <CODE>EDITOR</CODE> set to <CODE>vi</CODE> so that I can use vi in
Midnight Commander (an excellent console based file manager) instead of its
editor. </P>


<H2><A NAME="ss11.2">11.2 Exercises</A>
</H2>

<P>The basics of bash are easy to learn. But don't stop there: there is an
incredible depth to it. Get into the habit of looking for better ways to do
things. </P>

<P>Read shell scripts, look up stuff you don't understand.</P>

<H2><A NAME="ss11.3">11.3 More Information</A>
</H2>

<P>
<UL>
<LI>There is a ``Bash Reference Manual'' with this, which is comprehensive, but heavy going. </LI>
<LI>There is an O'Rielly book on Bash, not sure if it's good.</LI>
<LI>I don't know of any good free up to date bash tutorials. If you do, please
email me a url.</LI>
<LI>  source code, see 
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> 
for urls</LI>
</UL>
</P>


<H2><A NAME="s12">12. Commands</A></H2>

<P>You do most things in bash by issuing commands like <CODE>cp</CODE>. Most of these commands are
small programs, though some, like <CODE>cd</CODE> are built into the shell.  </P>

<P>The commands come in packages, most of them from the Free Software Foundation (or GNU).
Rather than list the packages here, I'll direct you to the 
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A>. 
It has a full and up to date list of the packages that go into a Linux system
as well as instructions on how to build them.</P>


<H2><A NAME="s13">13. Conclusion</A></H2>

<P>One of the best things about Linux, in my humble opinion, is that you can get
inside it and really find out how it all works. I hope that you enjoy this as
much as I do. And I hope that this little note has helped you do it.</P>

<H2><A NAME="s14">14. Administrivia</A></H2>

<H2><A NAME="ss14.1">14.1 Copyright</A>
</H2>

<P>This document is copyright (c) 1999, 2000 Greg O'Keefe. You are welcome
to use, copy, distribute or modify it, without charge, under the terms of the 
<A HREF="http://www.gnu.org/copyleft/gpl.html">GNU General Public Licence</A>.
Please acknowledge me if you use all or part of this in another document.</P>

<H2><A NAME="ss14.2">14.2 Homepage</A>
</H2>

<P>The lastest version of this document lives at 
<A HREF="http://www.netspace.net.au/~gok/power2bash">From Powerup To Bash Prompt</A> 
as does its companion ``Building a Minimal Linux System from Source Code''.</P>

<P>There is a French translation at
<A HREF="http://www.freenix.fr/unix/linux/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">From Powerup To Bash Prompt</A> thanks to Dominique van den Broeck.
A Japanese by Yuji Senda is coming soon, if it's not at 
<A HREF="http://www.linux.or.jp/JF">Japanese Documentation and FAQ Project</A>
already.</P>




<H2><A NAME="ss14.3">14.3 Feedback</A>
</H2>

<P>I would like to hear any comments, criticisms and suggestions for improvement
that you have. Please send them to me  
<A HREF="mailto:gcokeefe@postoffice.utas.edu.au">Greg O'Keefe</A></P>


<H2><A NAME="acknowledge"></A> <A NAME="ss14.4">14.4 Acknowledgements </A>
</H2>

<P>Product names are trademarks of the respective holders, and are hereby
considered properly acknowledged.</P>

<P>There are some people I want to say thanks to, for helping to make this happen.</P>

<P>
<DL>

<DT><B>Michael Emery</B><DD>
<P>For reminding me about Unios.</P>
<DT><B>Tim Little</B><DD>
<P>For some good clues about <CODE>/etc/passwd</CODE></P>
<DT><B>sPaKr on #linux in efnet</B><DD>
<P>Who sussed out that syslogd needs <CODE>/etc/services</CODE>, 
and introduced me to the phrase ``rolling your own'' to 
describe building a system from source code.</P>
<DT><B>Alex Aitkin</B><DD>
<P>For bringing Vico and his ``verum ipsum factum'' 
(understanding arises through making) to my attention.</P>
<DT><B>Dennis Scott</B><DD>
<P>For correcting my hexidecimal arithmetic.</P>
<DT><B>jdd</B><DD>
<P>For pointing out some typos.</P>
<DT><B>David Leadbeater</B><DD>
<P>For contributing some ``ramblings'' about the kernel deamons.</P>
<DT><B>Dominique van den Broeck </B><DD>
<P>For translating this doc into French.</P>
<DT><B>Matthieu Peeters </B><DD>
<P>For some good information about kernel deamons.</P>
<DT><B>John Fremlin</B><DD>
<P>For some good information about kernel deamons.</P>
<DT><B>Yuji Senda</B><DD>
<P>For the Japanese translation.</P>
<DT><B>Antonius de Rozari</B><DD>
<P>For contributing a GNU assembler version of UNIOS
(see resources section on the home page) </P>
</DL>
</P>

<H2><A NAME="ss14.5">14.5 Change History</A>
</H2>

<H3>0.8 -> 0.9 (November 2000)</H3>

<P>
<UL>
<LI>Incorporated some information from Matthieu Peeters
and John Fremlin on
kernel deamons and the <CODE>/proc</CODE> filesystem.</LI>
</UL>
</P>

<H3>0.7 -> 0.8 (September 2000)</H3>

<P>
<UL>
<LI> Removed instructions on how to build a system, placing them in a 
separate document. Adjusted a few links accordingly.</LI>
<LI> Changed homepage from 
<A HREF="http://learning.taslug.org.au/power2bash">learning@TasLUG</A>
to 
<A HREF="http://www.netspace.net.au/~gok/power2bash">my own webspace</A>.</LI>
<LI> Completely failed to incorporate a lot of good material 
contributed by various people. Maybe next time :(</LI>
</UL>
</P>

<H3>0.6 -> 0.7</H3>

<P>
<UL>
<LI>more emphasis on explanation, less on how to build a system, 
building info gathered together in a separate section
and the system built is trimmed down,
direct readers to Gerard Beekmans' ``Linux From Scratch'' doc 
for serious building</LI>
<LI>added some ramblings contributed by David Leadbeater</LI>
<LI>fixed a couple of url's, added link to unios download at 
learning.taslug.org.au/resources</LI>
<LI>tested and fixed url's</LI>
<LI>generally rewrite, tidy up</LI>
</UL>
</P>

<H3>0.5 -> 0.6</H3>

<P>
<UL>
<LI>added change history</LI>
<LI>added some todos</LI>
</UL>
</P>

<H2><A NAME="ss14.6">14.6 TODO</A>
</H2>

<P>
<UL>
<LI>explain kernel modules, depmod, modprobe, insmod and all that
(I'll have to find out first!)</LI>
<LI>mention the /proc filesystem, potential for exercises here</LI>
<LI>convert to docbook sgml</LI>
<LI>add more exercises, perhaps a whole section on larger exercises,
like creating a minimal system file by file from a distro
install.</LI>
<LI>add makefile hack to bash build instructions - see easter notes.</LI>
</UL>
</P>

</BODY>
</HTML>
