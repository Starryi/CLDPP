<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Designing Integrated High Quality Linux Applications</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="HighQuality-Apps-HOWTO"></a>Designing Integrated High Quality Linux Applications</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Avi</span> <span class="surname">Alkalay</span></h3><div class="affiliation"><span class="orgname">IBM Linux Impact Team :: <a class="ulink" href="http://ibm.com/linux" target="_top">ibm.com/linux</a><br></span> <span class="orgdiv">Senior IT and Software Architect :: Linux Market Developer<br></span><div class="address"><p><br>
				<code class="email">&lt;<a class="email" href="mailto:avi%20at%20br.ibm.com">avi at br.ibm.com</a>&gt;</code><br>
				<code class="email">&lt;<a class="email" href="mailto:avi%20at%20unix.sh">avi at unix.sh</a>&gt;</code><br>
			</p></div></div></div></div></div><div><p class="copyright">Copyright © 2002 Avi Alkalay</p></div><div><p class="pubdate">v2.1, 2002-08-24</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 2.1</td><td align="left">24 Aug 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">
		  <em><span class="remark">Rewrite of the /opt /usr/local section.</span></em>
		  <em><span class="remark">Cosmetics on graphical user interface and plugins sections.</span></em>
		  <em><span class="remark">Fixed screens and programlistings width.</span></em>
                </td></tr><tr><td align="left">Revision 2.0</td><td align="left">07 May 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Final XML conversion. Files reorganization.</td></tr><tr><td align="left">Revision 1.9.9</td><td align="left">20 Apr 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Included other document locations.</td></tr><tr><td align="left">Revision 1.98</td><td align="left">14 Apr 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Title changed from "Creating" to "Designing".</td></tr><tr><td align="left">Revision 1.97</td><td align="left">09 Apr 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Converted to XML 4.1.2, and started to use real XSLT. Spell checked the english version.</td></tr><tr><td align="left">Revision 1.96</td><td align="left">23 Mar 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Better HTML style sheets.</td></tr><tr><td align="left">Revision 1.95</td><td align="left">17 Mar 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Last chapter: One Body, Many Souls. Created appendix. Still have to translate some words here and there.</td></tr><tr><td align="left">Revision 1.9</td><td align="left">16 Mar 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Added universal software table with FHS.</td></tr><tr><td align="left">Revision 1.7</td><td align="left">16 Mar 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Everything is now translated except some words.</td></tr><tr><td align="left">Revision 1.3</td><td align="left">27 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Translated and reviewed the most important section of the article: The /opt and /usr/local section.</td></tr><tr><td align="left">Revision 1.2</td><td align="left">23 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">English translation at 65%. Doing some corrections to potuguese version also.</td></tr><tr><td align="left">Revision 1.1</td><td align="left">17 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Started english translation.</td></tr><tr><td align="left">Revision 1.0</td><td align="left">16 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">First final version of proposed skeleton.</td></tr><tr><td align="left">Revision 0.9.6</td><td align="left">16 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Finished Plugin chapter.</td></tr><tr><td align="left">Revision 0.9.5</td><td align="left">15 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Finished chapter about boot and subsystems.</td></tr><tr><td align="left">Revision 0.9.4</td><td align="left">14 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Finished chapter describing the boot process.</td></tr><tr><td align="left">Revision 0.9.3</td><td align="left">08 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Text and style updates.</td></tr><tr><td align="left">Revision 0.9.2</td><td align="left">07 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">Text updates.</td></tr><tr><td align="left">Revision 0.9</td><td align="left">06 Feb 2002</td><td align="left">avi</td></tr><tr><td align="left" colspan="3">First translation to DocBook.</td></tr></table></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#intro">1. Introduction</a></span></dt><dt><span class="section"><a href="#userFriendly">2. User Friendly: Guaranteed Success</a></span></dt><dd><dl><dt><span class="section"><a href="#installAndUse">2.1. Embrace the <span class="emphasis"><em>Install-and-Use</em></span> Paradigm</a></span></dt></dl></dd><dt><span class="section"><a href="#software">3. The Four Universal Parts of Any Software</a></span></dt><dd><dl><dt><span class="section"><a href="#software.example">3.1. Practical Examples</a></span></dt><dt><span class="section"><a href="#separe">3.2. The Importance of Clear Separation Between Four Parts</a></span></dt><dt><span class="section"><a href="#bodysouls">3.3. One Body, Many Souls</a></span></dt></dl></dd><dt><span class="section"><a href="#fhs">4. Linux Directory Hierarchy: Oriented to the Software Parts</a></span></dt><dd><dl><dt><span class="section"><a href="#fhs.fhs">4.1. <acronym class="acronym">FHS</acronym> Summary</a></span></dt><dt><span class="section"><a href="#newtable">4.2. Examples Using the <acronym class="acronym">FHS</acronym></a></span></dt><dt><span class="section"><a href="#noopt">4.3. Developer, Do Not Install in <code class="filename">/opt</code> or <code class="filename">/usr/local</code> !</a></span></dt></dl></dd><dt><span class="section"><a href="#plugin">5. Provide Architecture for Extensions and Plugins</a></span></dt><dd><dl><dt><span class="section"><a href="#plugin.concept">5.1. Abstracting About Plugins</a></span></dt></dl></dd><dt><span class="section"><a href="#rpm">6. Allways Provide RPM Packages of Your Softwares</a></span></dt><dd><dl><dt><span class="section"><a href="#module">6.1. Software Package Modularization</a></span></dt></dl></dd><dt><span class="section"><a href="#security">7. Security: The Omnipresent Concept</a></span></dt><dt><span class="section"><a href="#gui">8. Graphical User Interface</a></span></dt><dd><dl><dt><span class="section"><a href="#kdegnome">8.1. KDE, GNOME, Java or Motif?</a></span></dt><dt><span class="section"><a href="#webgui">8.2. Web Interface: Access from Anywhere</a></span></dt><dt><span class="section"><a href="#wizard">8.3. Wizards and Graphical Installers</a></span></dt></dl></dd><dt><span class="section"><a href="#boot">9. Starting Your Software Automatically on Boot</a></span></dt><dd><dl><dt><span class="section"><a href="#boot.init">9.1. From <acronym class="acronym">BIOS</acronym> to Subsystems</a></span></dt><dt><span class="section"><a href="#boot.runlevel">9.2. Runlevels</a></span></dt><dt><span class="section"><a href="#boot.subs">9.3. The Subsystems</a></span></dt><dt><span class="section"><a href="#boot.script">9.4. Turning Your Software Into a Subsystem</a></span></dt><dt><span class="section"><a href="#boot.install">9.5. Packaging Your Boot Script</a></span></dt></dl></dd><dt><span class="appendix"><a href="#redhat">A. Red Hat, About the Filesystem Structure</a></span></dt><dt><span class="appendix"><a href="#about">B. About this Document</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>1. Introduction</h2></div></div></div><p>Linux is becoming more and more popular, and many Software vendors are porting their products from other platformas. This document (article) tries to clarify some issues and give tips on how to create Linux applications highly integrated to the Operating System, security and easy of use.</p><p>The examples run on <a class="ulink" href="http://www.redhat.com/" target="_top">Red Hat</a> Linux, and should be compatible with other distributions based on Red Hat (<a class="ulink" href="http://www.conectiva.com.br/" target="_top">Conectiva</a>, <a class="ulink" href="http://www.turbolinux.com/" target="_top">Turbolinux</a>, <a class="ulink" href="http://www.calderasys.com/" target="_top">Caldera</a>, <a class="ulink" href="http://www.pld.org.pl/" target="_top">PLD</a>, <a class="ulink" href="http://www.mandrakelinux.com/" target="_top">Mandrake</a>, etc).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="userFriendly"></a>2. User Friendly: Guaranteed Success</h2></div></div></div><p>The <span class="emphasis"><em>user-friendly</em></span> concept is missassociated with a good <acronym class="acronym">GUI</acronym> (graphical user interface). In fact, it is much more than that. In systems like Linux (with more server-like characteristics), the user measures how easy a Software is, mainly in the installation and initial configuration. He can even forget how easy were to install and use a certain product, but it will never forget that a Software package has a complex configuration and installation process. A migration or new installation allways will be a nightmare, making the user avoid it.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="installAndUse"></a>2.1. Embrace the <span class="emphasis"><em>Install-and-Use</em></span> Paradigm</h3></div></div></div><p>Imagine you'll install that expansive product your company bought from ACME, and realized you'll have to do the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>To have a manual that shows the installation process step-by-step. We know that a manual is the last thing the user reads</p></li><li class="listitem"><p>Read some README files</p></li><li class="listitem"><p>Uncompress huge files in your disk (after downloading them from net our CD), to create the installation environment</p></li><li class="listitem"><p>Read more README files that appeared in the installation environment</p></li><li class="listitem"><p>Comprehend that the installation requires you to execute in a special way some provided script (the inconvenient <code class="filename">./install.sh</code>)</p></li><li class="listitem"><p>Uncomfortably answer some questions that the script does, like target directory, user for the installation, etc. To make it worse, it frequently happens in a terminal that has a missconfigured backspace</p></li><li class="listitem"><p>After the installation, configure some environment variables in your profile, like <code class="envar">$PATH</code>, <code class="envar">$LIBPATH</code>, <code class="envar">$ACMEPROGRAM_DATA_DIR</code>, <code class="envar">$ACMEPROGRAM_BIN_DIR</code>, etc</p></li><li class="listitem"><p>Edit OS files to include the presence of the new product (e.g. <code class="filename">/etc/inetd.conf</code>, <code class="filename">/etc/inittab</code>)</p></li><li class="listitem"><p>And the worse: Change security permissions of OS directories and files to let the product run OK</p></li></ol></div><p>Sounds familiar? Who never faced this sad situation, that inducts the user to make mistakes? If your products' installation process sound like <span class="emphasis"><em>Uncompress-Copy-Configure-ConfigureMore-Use</em></span>, like this one, you have a problem, and the user won't like it.</p><p>Users like to feel that your Product integrates well with the OS. You should not demand that the OS adapt himself to your Product (changing environment variables, etc). It must let the user <span class="strong"><strong>Install-and-Use</strong></span>.</p><p>The <span class="emphasis"><em>Install-And-Use</em></span> glory is easily achieved using a 3 ingredients receipt:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Understanding the Four Universal Parts of Any Software</p></li><li class="listitem"><p>Understanding how they are related to Linux's directory hierarchy</p></li><li class="listitem"><p>Aggressively use a package system, for process automation and leverage first items. In our case is RPM.</p></li></ol></div><p>We'll discuss here what are these ingredients and how to implement them.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="software"></a>3. The Four Universal Parts of Any Software</h2></div></div></div><p>The file set of any Application Software, graphical, server-side, commercial, open/free, monolithic etc, has allways four universal parts:</p><a name="software.body"></a><h3><a name="idm181"></a>1<sup>st</sup> :: The Software on its own: the body</h3><p>The executables, libraries, static-data files, examples, manuals and documentation, etc. Regular users must have read-only access to these files. They are changed only when the system administrator makes an upgrade in this Software.</p><a name="software.soul"></a><h3><a name="idm185"></a>2<sup>nd</sup> :: Configuration Files: the soul</h3><p>These are files that define how the Software will run, how to use the <a class="link" href="#software.content">Content</a>, <a class="link" href="#security" title="7. Security: The Omnipresent Concept">security</a>, performance etc. Without them, the <a class="link" href="#software.body">Software on its own</a> is usually useless.</p><p>Depending on your Software, specific privileged users may change these files, to make the Software behave as they want.</p><p>It is important to provide documentation about the configuration files.</p><a name="software.content"></a><h3><a name="idm194"></a>3<sup>rd</sup> :: Content</h3><p>Is what receives all the user attention. Is what the user delegated to be managed by your Product. Is what makes a user throw away your product and use the competitors', if it gets damaged.</p><p>Are the tables of a database system, the documents for a text editor, the images and HTML pages of a web-server, the servlets and EJBs of an Application Server, etc.</p><a name="software.logs"></a><h3><a name="idm199"></a>4<sup>th</sup> :: Logs, Dumps etc</h3><p>Server Software use to generate access logs, trace files problem determination, temporary files etc. Other types of softwares also use this files, but it is less common.</p><p>It is the last class of file, but many times they are the most problem generator for a system administrator, because their volume can surpass even the content size. Due this fact, it is important for you to think in some methodology or facility for this issue, while you are in design time.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="software.example"></a>3.1. Practical Examples</h3></div></div></div><p>Let's see how universal is this concept analyzing some types of softwares:</p><div class="table"><a name="partstable"></a><p class="title"><b>Table 1. Universality of 4 Parts</b></p><div class="table-contents"><table class="table" summary="Universality of 4 Parts" width="100%" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th> </th><th><a class="link" href="#software.body">Software on its Own</a></th><th><a class="link" href="#software.soul">Configurations</a></th><th><a class="link" href="#software.content">Content</a></th><th><a class="link" href="#software.logs">Logs, Dumps etc</a></th></tr></thead><tbody><tr><td><span class="strong"><strong>Data Base Server</strong></span></td><td>Binaries, libraries, documentations.</td><td>Files that define the directory of the data files. For this type of Software, the remaining configurations usually are in special tables inside the database.</td><td>Table files, index files, etc. This software use to have whole trees under the same directory. And many times they need several filesystems to guarantee performance. Their local in the system is defined by they <a class="link" href="#software.soul">Configurations</a>.</td><td>For DBs, there are the backup, generated in a daily basis. And the logs are used by the <acronym class="acronym">DBA</acronym> to define indexing strategy. His local on the system is also defined by the <a class="link" href="#software.soul">Configurations</a>.</td></tr><tr><td><span class="strong"><strong>Text Processor</strong></span></td><td>The same, templates, modular file format filters, etc</td><td>As a user-oriented Software, its configurations must be put in each user's <code class="envar">$HOME</code> directory, and are files that defines standard fonts and tabulation, etc.</td><td>The documents generated by the user, and they go some place in his <code class="envar">$HOME</code></td><td>They show as temporary files that can be huge. User can define their location with a user-friendly dialog (that saves it in some <a class="link" href="#software.soul">Configuration</a> file)</td></tr><tr><td><span class="strong"><strong>MP3 generator</strong></span></td><td>Same, audio modular filters</td><td>Each user has a configuration file in his <code class="envar">$HOME</code>, and contains bitrate preferences etc</td><td>Similar to Text Editor</td><td>Similar to Text Editor</td></tr><tr><td><span class="strong"><strong>Web Server</strong></span></td><td>Similar to Data Base</td><td>Files that define the <a class="link" href="#software.content">Content</a> directory, network and performance parameters, <a class="link" href="#security" title="7. Security: The Omnipresent Concept">security</a>, etc</td><td>Directories where the webmaster deposits his creativity. Again defined by the <a class="link" href="#software.soul">Configurations</a></td><td>Preciouses access logs, vital for Marketing Intelligence, that are generated in a location and format defined by <a class="link" href="#software.soul">Configurations</a></td></tr><tr><td><span class="strong"><strong>e-Mail Server</strong></span></td><td>Similar to Database and Web-Server</td><td>Files that define how to access user database, mail routing rules, etc</td><td>The preciouses users mail boxes. Again defined by the <a class="link" href="#software.soul">Configurations</a></td><td>Mail transfer log, virus detection log, etc. Again defined by the <a class="link" href="#software.soul">Configurations</a></td></tr></tbody></table></div></div><br class="table-break"><p>Pay attention that the <a class="link" href="#software.body">Software on its Own</a> contains all your product <span class="emphasis"><em>business logic</em></span>, which could be useless if you hadn't a <a class="link" href="#software.soul">Configuration</a> to define how to work with a <a class="link" href="#software.content">data bundle</a>, provided by the user. So, <a class="link" href="#software.soul">Configurations</a> are what connects your product to the user.</p><p>We can use a metaphor about a Sculptor (<a class="link" href="#software.body">business logic</a>), that needs Bronze (<a class="link" href="#software.content">content</a>) and a Theme or Inspiration (<a class="link" href="#software.soul">configuration</a>) from a Mecenas (<a class="link" href="#userFriendly" title="2. User Friendly: Guaranteed Success">user</a>), to produce a beautiful work (<a class="link" href="#software.content">content</a>). He make annotations in his Journal (<a class="link" href="#software.logs">logs</a>) about his day-by-day activities, to report to his Mecenas (<a class="link" href="#userFriendly" title="2. User Friendly: Guaranteed Success">user</a>).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="separe"></a>3.2. The Importance of Clear Separation Between Four Parts</h3></div></div></div><p>OK, so let's be more practical. The fact is, if we correctly use the <a class="link" href="#software" title="3. The Four Universal Parts of Any Software">universal parts concept</a>, we greatly improve the quality of our Product. We'll do that simply separating, encapsulating, each one of these parts in different system directories (having only different files for each part is not sufficient). There is a standard called <a class="ulink" href="http://www.pathname.com/fhs/" target="_top">FHS</a> that defines the Linux directories for each part, and we'll discuss it later in <a class="xref" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts">Section 4, &#8220;Linux Directory Hierarchy: Oriented to the Software Parts&#8221;</a>.</p><p>By now let's see the value of this separation to the user:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>He gains a clear vision about where is each part, specially his <a class="link" href="#software.soul">Configurations</a> and <a class="link" href="#software.content">Content</a>, and he feels your Product as something completely under control. The clareza brings ease of use, security and confidence in your Product. And in practice it permits him manipulate each part independently</p></li><li class="listitem"><p>It is clear now that, for instance, when backing up, user action is needed only for <a class="link" href="#software.soul">Configurations</a> and <a class="link" href="#software.content">Content</a> (the puritans will also backup some <a class="link" href="#software.logs">logs</a>). The user don't have to care about <a class="link" href="#software.body">Software on its Own</a>, because it is safe, original, on the product CD, in his shelf.</p></li><li class="listitem"><p>For upgrades, the new package will overwrite only the <a class="link" href="#software.body">business logic</a>, leaving intact the user's precious <a class="link" href="#software.soul">Configurations</a> and <a class="link" href="#software.content">Content</a>. Here is very important to keep old content and configuration compatible, or to provide some tools help migration of data</p></li><li class="listitem"><p>The logs being kept in a separate filesystem (obviously suggested in your documentation), avoids that their exaggerated growth interfere with the <a class="link" href="#software.content">Content</a>, or with the stability of the whole system</p></li><li class="listitem"><p>If your Software follows some directory standards, the user don't have to reconfigure his system or environment to use it. He will simply <span class="strong"><strong>Install-and-Use</strong></span>.</p></li></ol></div><p>Let's make some exercise with separation using as example a system called <acronym class="acronym">MySoftware</acronym>, in which the <a class="link" href="#software.body">business logic</a> is in <a class="xref" href="#example.body" title="Example 1. A Shell program referring an external configuration file">Example 1, &#8220;A Shell program referring an external configuration file&#8221;</a> and the configuration is in <a class="xref" href="#example.soul" title="Example 2. File containing only the configurations for MySoftware">Example 2, &#8220;File containing only the configurations for <acronym class="acronym">MySoftware</acronym>&#8221;</a>.</p><div class="example"><a name="example.body"></a><p class="title"><b>Example 1. A Shell program referring an external configuration file</b></p><div class="example-contents"><pre class="programlisting">
#!/bin/sh

#############################################################################
##
## /usr/bin/MySoftware
##
## Business logic of MyProgram system.
## Do not change nothing in this file. All configuration can be
## made on /etc/MySoftware.conf
##
## We'll not support any modifications made here.
##

# Default configuration file
CONF=/etc/MySoftware.conf	<a name="ex.body.const.c1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

# Minimal content directories
MIN_CONTENT_PATH=/var/www:/var/MySoftware/www	<a name="ex.body.const.c2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

if [ -r "$CONF"]; then
        . "$CONF"	<a name="ex.body.conf"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
fi

# All the content I'll serve are the "minimal" plus the ones provided
# by the user in the configuration file $CONF
CONTENT_PATH=$MIN_CONTENT_PATH:$CONF_CONTENT_PATH	<a name="ex.body.merge"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>

.
.
.
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex.body.const.c1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left"><p>Definition of the configuration file name.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.body.const.c2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>Definition of some static parameters.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.body.conf"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>The configuration is readed from an external file, if exists.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.body.merge"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> </p></td><td valign="top" align="left"><p>After reading the configuration file, all content directories -- user's + product's -- goes together in the <code class="envar">$CONTENT_PATH</code>, that will be used from now on.</p></td></tr></table></div></div></div><br class="example-break"><div class="example"><a name="example.soul"></a><p class="title"><b>Example 2. File containing only the configurations for <acronym class="acronym">MySoftware</acronym></b></p><div class="example-contents"><pre class="programlisting">
#############################################################################
##
## /etc/MySoftware.conf
##
## Configuration parameters for MySoftware.
## Change as much as you want.
##

# Content directory.
# A ':' separated list of directories for your content.
# The directories /var/www and /var/MySofware are already there, so
# include here your special directories, if any.
CONF_CONTENT_PATH=/var/NewInstance:/var/NewInstance2	<a name="ex.soul.c1"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>

# Your e-mail address, for notifications.
EMAIL=john@mycompany.com	<a name="ex.soul.c2"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

# Logs directory
LOG_DIR=/var/log/myInstance	<a name="ex.soul.c3"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex.soul.c1"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> <a href="#ex.soul.c2"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> <a href="#ex.soul.c3"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>These are user defined parameters.</p></td></tr></table></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bodysouls"></a>3.3. One Body, Many Souls</h3></div></div></div><p>When I was a system administrator for IBM e-business Hosting Services, I was fascinated by <a class="ulink" href="http://httpd.apache.org/" target="_top">Apache</a>'s flexibility letting us do things like this:</p><pre class="screen">
<code class="prompt">bash# </code><span class="command"><strong>/usr/sbin/httpd &amp;</strong></span>
<code class="prompt">bash# </code><span class="command"><strong>/usr/sbin/httpd -f /etc/httpd/dom1.com.br.conf &amp;</strong></span>
<code class="prompt">bash# </code><span class="command"><strong>/usr/sbin/httpd -f /etc/httpd/dom2.com.br.conf &amp;</strong></span>
<code class="prompt">bash# </code><span class="command"><strong>/usr/sbin/httpd -f /etc/httpd/dom3.com.br.conf &amp;</strong></span></pre><p>If we don't pass any parameter (like the first example), Apache loads its default, hardcoded configuration file from <code class="filename">/etc/httpd/conf/httpd.conf</code>. We built other configs, one for each customer, with a completely different structure, IP address, loaded modules, content directory, passwords, domains, log strategy etc.</p><p>This same concept is used by a text editor of a multiuser desktop (like Linux). When the code is loaded, it looks for a configuration file on the user's <code class="envar">$HOME</code>, and depending who invoked him (user A or B), it will appear differently because each user has its own personal configuration.</p><p>The obvious conclusion is that the Software's body (<a class="link" href="#software.body">business logic</a>) is pure e completely oriented by his manipulator's spirit (<a class="link" href="#software.soul">configuration</a>). But the competitive advantage lays on how easy we switch from one <a class="link" href="#software.soul">spirit</a> to another, like in Apache's example. It is very healthy to promote it to your user. You'll be letting him create intimacy, reliability, confort with your Product.</p><p>We used this approach with many different Softwares in that e-business Hosting time, and it was extremely usefull for maintenance etc. In a version migration we had total control over where were <a class="link" href="#software" title="3. The Four Universal Parts of Any Software">each of its parts</a>, and upgraded and downgraded Software with no waste of time, with obvious success.</p><p>But there were some Products that refused to work this way. They had so many hardcoded parameters, that we couldn't see what divided the <a class="link" href="#software.body">body</a> from their <a class="link" href="#software.soul">spirit</a> (or other parts). These Softwares were marked as <span class="emphasis"><em>bad guys</em></span> and discarded/replaced as soon as possible.</p><p>We concluded that the <span class="emphasis"><em>good guys</em></span> Softwares were intuitively blessed by their developer's <a class="link" href="#software" title="3. The Four Universal Parts of Any Software">four parts vision</a>. And they made our life easyer. In fact, in that time we formulated this <a class="link" href="#software" title="3. The Four Universal Parts of Any Software">theory</a>, that continues to prove itself.</p><p>Do you want to deploy <span class="emphasis"><em>bad guy</em></span> or <span class="emphasis"><em>good guy</em></span> Software?</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fhs"></a>4. Linux Directory Hierarchy: Oriented to the Software Parts</h2></div></div></div><p>By now, all discussion are OS independent. On Linux, the <a class="link" href="#software" title="3. The Four Universal Parts of Any Software">Four Software Parts</a> theory is expressed in his directory structure, which is classified and documented in the <a class="ulink" href="http://www.pathname.com/fhs/" target="_top">Filesystem Hierarchy Standard</a>. The <acronym class="acronym">FHS</acronym> is part of the <a class="ulink" href="http://www.linuxbase.org/" target="_top"><acronym class="acronym">LSB</acronym> (Linux Standard Base)</a>, which makes him a good thing because all the industry is moving thowards it, and is a constant preoccupation to all distributions. <acronym class="acronym">FHS</acronym> defines in which directories each peace of Apache, Samba, Mozilla, KDE <span class="emphasis"><em>and your Software</em></span> must go, and you don't have any other reason to not use it while thinking in developing your Software, but I'll give you some more:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><acronym class="acronym">FHS</acronym> is a standard, and we can't live without standards</p></li><li class="listitem"><p>This is the most basic OS organization, that are related to access levels and <a class="link" href="#security" title="7. Security: The Omnipresent Concept"><span class="strong"><strong>security</strong></span></a>, where users intuitively find each type of file, etc</p></li><li class="listitem"><p><span class="emphasis"><em>Makes user's life easyer</em></span></p></li></ol></div><p>This last reason already justifies FHS adoption, so <span class="strong">allways use the <acronym class="acronym">FHS</acronym></span> !!!</p><p>More about <acronym class="acronym">FHS</acronym> importance and sharing the same directory structure can be found in <a class="ulink" href="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-filesystem.html" target="_top">Red Hat website.</a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="fhs.fhs"></a>4.1. <acronym class="acronym">FHS</acronym> Summary</h3></div></div></div><p>So let's summarize what the <acronym class="acronym">FHS</acronym> has to say about Linux directories:</p><div class="variablelist"><p class="title"><b>Linux system directories</b></p><dl class="variablelist"><dt><span class="term"><code class="filename">/usr/bin</code></span></dt><dd><p>Directory for the executables that are accessed by all users (everybody have this directory in their <code class="varname">$PATH</code>). The main files of your Software will probably be here. You should never create a subdirectory under this folder.</p></dd><dt><span class="term"><code class="filename">/bin</code></span></dt><dd><p>Like <code class="filename">/usr/bin</code>, but here you'll find only boot process vital executables, that are simple and small. Your Software (being high-level) probably doesn't have nothing to install here.</p></dd><dt><span class="term"><code class="filename">/usr/sbin</code></span></dt><dd><p>Like <code class="filename">/usr/bin</code>, but contains only the executables that must be accessed by the administrator (root user). Regular users should never have this directory in their <code class="varname">$PATH</code>. If your Software is a daemon, This is the directory for some of executables.</p></dd><dt><span class="term"><code class="filename">/sbin</code></span></dt><dd><p>Like <code class="filename">/usr/sbin</code>, but only for the boot process vital executables, and that will be accessed by sysadmin for some system maintaining. Commands like <span class="command"><strong>fsck</strong></span> (filesystem check), <span class="command"><strong>init</strong></span> (father of all processes), <span class="command"><strong>ifconfig</strong></span> (network configuration), <span class="command"><strong>mount</strong></span>, etc can be found here. It is the system's most vital directory.</p></dd><dt><span class="term"><code class="filename">/usr/lib</code></span></dt><dd><p>Contains dynamic libraries and support static files for the executables at <code class="filename">/usr/bin</code> and <code class="filename">/usr/sbin</code>. You can create a subdirectory like <code class="filename">/usr/lib/myproduct</code> to contain your helper files, or dynamic libraries that will be accessed only by your Software, without user intervention. A subdirectory here can be used as a container for <a class="link" href="#plugin" title="5. Provide Architecture for Extensions and Plugins">plugins and extensions</a>.</p></dd><dt><span class="term"><code class="filename">/lib</code></span></dt><dd><p>Like <code class="filename">/usr/lib</code> but contains dynamic libraries and support static files needed in the boot process. You'll never find an executable at <code class="filename">/bin</code> or <code class="filename">/sbin</code> that needs a library that is outside this directory. Kernel modules (device drivers) are under <code class="filename">/lib</code>.</p></dd><dt><span class="term"><code class="filename">/etc</code></span></dt><dd><p>Contains configuration files. If your Software uses several files, put them under a subfolder like <code class="filename">/etc/myproduct/</code></p></dd><dt><span class="term"><code class="filename">/var</code></span></dt><dd><p>The name comes from "<span class="emphasis"><em>variable</em></span>", because everything that is under this directory changes frequently, and the package system (RPM) doesn't keep control of. Usually <code class="filename">/var</code> is mounted over a separate high-performance partition. In <code class="filename">/var/log</code> logfiles grow up. For web content we use <code class="filename">/var/www</code>, and so on.</p></dd><dt><span class="term"><code class="filename">/home</code></span></dt><dd><p>Contains the user's (real human beings) <span class="emphasis"><em>home</em></span> directories. Your Software package should <span class="emphasis"><em>never</em></span> install files here (in installation time). If <span class="emphasis"><em>your</em></span> business logic requires a special <acronym class="acronym">UNIX</acronym> user (not a human being) to be created, you should assign him a home directory under <code class="filename">/var</code> or other place <span class="emphasis"><em>outside</em></span> <code class="filename">/home</code>. Please, never forget that.</p></dd><dt><span class="term"><code class="filename">/usr/share/doc</code>, </span><span class="term"><code class="filename">/usr/share/man</code></span></dt><dd><p>The "share" word is used because what is under <code class="filename">/usr/share</code> is platform independent, and can be shared among several machines across a network filesystem. Therefore this is the place for manuals, documentations, examples etc.</p></dd><dt><span class="term"><code class="filename">/usr/local</code>, </span><span class="term"><code class="filename">/opt</code></span></dt><dd><p>These are obsolete folders. When <acronym class="acronym">UNIX</acronym> didn't have a package system (like RPM), sysadmins needed to separate an <span class="emphasis"><em>optional</em></span> (or <span class="emphasis"><em>local</em></span>) Software from the main OS. These were the directories used for that.</p></dd></dl></div><p>You may think is a bad idea to break your Software (as a whole) in many pieces, instead of keeping it all under a self-contained directory. But a <a class="link" href="#rpm" title="6. Allways Provide RPM Packages of Your Softwares">package system (RPM)</a> has a database that manages it all for you in a very professional way, taking care of configuration files, directories etc. And if you spread your Software using the <acronym class="acronym">FHS</acronym>, beyond the user friendliness, you'll bring an intuitive way to the sysadmin configure it, and work better with performance and security.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="newtable"></a>4.2. Examples Using the <acronym class="acronym">FHS</acronym></h3></div></div></div><p>Now that we know where each part of our software must be installed, lets review the <a class="link" href="#partstable" title="Table 1. Universality of 4 Parts">Universal Parts Table</a> applied to the <acronym class="acronym">FHS</acronym>.</p><div class="table"><a name="idm513"></a><p class="title"><b>Table 2. Same Software, applying <acronym class="acronym">FHS</acronym></b></p><div class="table-contents"><table class="table" summary="Same Software, applying FHS" width="100%" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th> </th><th><a class="link" href="#software.body">Software on its Own</a></th><th><a class="link" href="#software.soul">Configurations</a></th><th><a class="link" href="#software.content">Content</a></th><th><a class="link" href="#software.logs">Logs, Dumps etc</a></th></tr></thead><tbody><tr><td><span class="strong"><strong>Data Base Server</strong></span></td><td><code class="filename">/usr/bin/</code>, <code class="filename">/usr/lib/</code>, <code class="filename">/usr/share/doc/mydb/</code>, <code class="filename">/usr/share/doc/mydb/examples/</code></td><td><code class="filename">/etc/mydb/</code></td><td><code class="filename">/var/db/instance1/</code>, <code class="filename">/var/db/instance2/</code>, etc</td><td><code class="filename">/var/db/instance1/transactions/</code>, <code class="filename">/var/log/db/access-instance1.log</code>, <code class="filename">/var/log/db/access-instance2.log</code></td></tr><tr><td><span class="strong"><strong>Text Editor</strong></span></td><td><code class="filename">/usr/bin/</code>, <code class="filename">/usr/lib/</code>, <code class="filename">/usr/lib/myeditor/plugins/</code>, <code class="filename">/usr/share/myeditor/templates/</code>, <code class="filename">/usr/share/doc/myeditor/</code></td><td><code class="filename">$HOME/.myeditor.conf</code></td><td><code class="filename">$HOME/Docs/</code></td><td><code class="filename">$HOME/.myeditor-tmp/</code></td></tr><tr><td><span class="strong"><strong>MP3 Generator</strong></span></td><td><code class="filename">/usr/bin/</code>, <code class="filename">/usr/lib/</code>, <code class="filename">/usr/lib/mymp3/plugins/</code>, <code class="filename">/usr/share/doc/mymp3/</code></td><td><code class="filename">$HOME/.mymp3.conf</code></td><td><code class="filename">$HOME/Music/</code></td><td><code class="filename">$HOME/.mymp3-tmp/</code></td></tr><tr><td><span class="strong"><strong>Web Server</strong></span></td><td><code class="filename">/usr/sbin/</code>, <code class="filename">/usr/bin/</code>, <code class="filename">/usr/lib/httpd-modules/</code>, <code class="filename">/usr/share/doc/httpd/</code>, <code class="filename">/usr/share/doc/httpd/examples/</code></td><td><code class="filename">/etc/httpd/</code>, <code class="filename">/etc/httpd/instance1/</code>, <code class="filename">/etc/httpd/instance2/</code></td><td><code class="filename">/var/www/</code>, <code class="filename">/var/www/instance1/</code>, <code class="filename">/var/www/instance2/</code></td><td><code class="filename">/var/logs/httpd/</code>, <code class="filename">/var/logs/httpd/instance1/</code>, <code class="filename">/var/logs/httpd/instance2/</code></td></tr><tr><td><span class="strong"><strong>E-Mail Server</strong></span></td><td><code class="filename">/usr/sbin/</code>, <code class="filename">/usr/bin/</code>, <code class="filename">/usr/lib/</code>, <code class="filename">/usr/share/doc/mymail/</code></td><td><code class="filename">/etc/mail/</code>, <code class="filename">/etc/mailserver.cf</code></td><td><code class="filename">/var/mail/</code></td><td><code class="filename">/var/spool/mailqueue/</code>, <code class="filename">/var/logs/mail.log</code></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="noopt"></a>4.3. Developer, Do Not Install in <code class="filename">/opt</code> or <code class="filename">/usr/local</code> !</h3></div></div></div><p>If you are a systems administrator, this section is not for you. This is a subject for developers and packagers, to make sysadmin's life easyer.</p><p>The <code class="filename">/opt</code> and <code class="filename">/usr/local</code> directories are used by sysadmins to manualy non-packaged files (without RPM) of a software, precisely to not loose control over those files. Notice how separated this folder are from the rest of the system.</p><p>A manual installation process (without RPM, or based on simple file copy) is documented in forgoten document inside a drawer (if it was documented), and inside the head of who made installation. If he moves to another job, that installations becomes obscure to the rest of the team, and is a time bomb.</p><p>With <a class="link" href="#rpm" title="6. Allways Provide RPM Packages of Your Softwares">RPM</a> is different. RPM (or any other package system) is an installation "process" by itself. It is self-documented in his database and pre and post-install actions, which permits total control. Turns installations independent from who did it, turning installtions in a <span class="emphasis"><em>business process</em></span>.</p><p>Installations based on coping files into <code class="filename">/opt</code> or <code class="filename">/usr/local</code> are far from providing the organization, system visibility and control that RPM provides. I can say <code class="filename">/opt</code> and <code class="filename">/usr/local</code> would be obsoleted when all softwares become RPMized.</p><p>It is very important to Linux evolution and popularization (especially in the desktop battlefield), that developers stop using this hell directories, and start using the <acronym class="acronym">FHS</acronym>. After reading this section, if you still think this folders are good business, please drop me an e-mail.</p><p>Products that are <span class="emphasis"><em>entirely</em></span> installed under <span class="emphasis"><em>one</em></span> directory, use the <span class="emphasis"><em>self-contained</em></span> approach, that has several problems:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Forces the user to change environment variables like <code class="varname">$PATH</code> and <code class="varname">$LD_LIBRARY_PATH</code> to use your product easily.</p></li><li class="listitem"><p>Puts files in non-standard places, complicating system integration, and future installation of extensions to your product.</p></li><li class="listitem"><p>The sysadmin probably didn't prepared disk space in these partitions, generating problems in installation time.</p></li><li class="listitem"><p>It is an accepted approach only for pure graphical application, without the command line concept. This is why it were well accepted in Windows. But...</p></li><li class="listitem"><p>...even using this approach, you can't avoid installing or changing files in standard locations to, for instance, make your icons appear in the user desktop.</p></li></ol></div><p>Many developers believe that the "self-contained" approach let them work with several versions of the same product, for testing purposes, or whatever. Yes, agree, with this or any good reason in the planet. But remember that a High Quality Software (or Commercial Grade Software) objective is to be practical for the final user, and not to be easy to their developers and testers. Invite yourself to visit an unexperienced user (but potential customer) and watch him installing your product.</p><p>Developer, don't be afraid of spreading your files according to <a class="link" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts"><acronym class="acronym">FHS</acronym></a> because RPM will keep an eye on them.</p><p>If you have a business reason to let the user work with several versions of your Product simultaneously (or any other reason), make a <a class="ulink" href="http://www.rpm.org/max-rpm/ch-rpm-reloc.html" target="_top">relocatable package</a>, which is described in the <a class="ulink" href="http://www.rpm.org/max-rpm/" target="_top">Maximum RPM</a> book. Be also aware about the implications of using this feature, <a class="ulink" href="http://www.rpm.org/max-rpm/s1-rpm-reloc-wrinkles.html" target="_top">described in the same book</a>.</p><p>Red Hat and derivated distributions allways use the directory standard, instead of <code class="filename">/opt</code> or <code class="filename">/usr/local</code>. <a class="link" href="#redhat" title="A. Red Hat, About the Filesystem Structure">Read what Red Hat says about this subject</a>, and think about it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The Makefiles of an OpenSource Software that is portable to other <acronym class="acronym">UNICES</acronym> must have the standard installation in <code class="filename">/usr/local</code> for compatibility reasons. But must also give the option, and induct the packager, to create the package using <a class="link" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts"><acronym class="acronym">FHS</acronym></a> specifications.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="plugin"></a>5. Provide Architecture for Extensions and Plugins</h2></div></div></div><p>You'll probably let other Software vendors plug extensions to your product. Since you are the author of the initial Software, is your responsability to organize it in such a way that the user can simply install the extension RPM and use it, without forcing him modify any configuration file. It is again the famous <a class="link" href="#installAndUse" title="2.1. Embrace the Install-and-Use Paradigm"><span class="emphasis"><em>Install-and-Use</em></span></a> that guarantees ease-of-use.</p><p>Well, and extension is nothing more that some files in a <span class="strong"><strong>right format</strong></span> (DLLs that implements the API your Software defined), put in the <span class="strong"><strong>right folders</strong></span> (directories your Software looks for extensions).</p><p>We can see many applications requesting the user to change configuration files to "declare" the presence of a new plugin. This is a bad approach that must be avoided because makes user's or plugin provider's life harder.</p><p>The most important thing to consider in your plugin architecture is <span class="emphasis"><em>to not share files between plugins and your Software</em></span>. You should provide an architecture where plugins will be able to fully install and uninstall themselves by simply putting and removing files in specific directories, documented in you Software. Good candidates are <code class="filename">/usr/lib/myproduct/plugins</code> as the plugins directory, and <code class="filename">/etc/myproduct/plugins</code> as the plugins configuration files directory. Your Software and plugins must be sufficient intelligent to know how to find files, specially configurations, in these directories.</p><p>Using this approach, no post-install procedures is required from the user, and from the plugin provider.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="plugin.concept"></a>5.1. Abstracting About Plugins</h3></div></div></div><p>I would like to close this subject inviting the reader a se abstratir and think about any Software can be treated as an extension to the lower level Software. In the same way a third party plugin is an extension to your Software, your Software is also an extension to the OS (lower level). This is where all the Integration (from the title of this document) magic lives. So we can apply all the ease-of-use concepts we discussed before to the plugin architecture design of your Software.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rpm"></a>6. Allways Provide RPM Packages of Your Softwares</h2></div></div></div><p>This is extremely important for many reasons:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ease-of-use. This is allways the primordial motivation.</p></li><li class="listitem"><p>Automates some tasks that must be made before and after the installation of your Software. Again bringing ease-of-use.</p></li><li class="listitem"><p>Intelligently manages configuration files, documentation etc, providing more control in an upgrade</p></li><li class="listitem"><p>Manages interdependencies with other packages and versions, guaranteeing good functionality.</p></li><li class="listitem"><p>Lets you distribute Software with your company's digital signature, and makes integrity checks (<acronym class="acronym">MD5</acronym>) in each file, guaranteeing precedence, and reporting unwanted file modification.</p></li><li class="listitem"><p>Provides tools to let interact with your graphic installer.</p></li></ol></div><p>But a good package is not only put together your files in a RPM. <acronym class="acronym">FHS</acronym> must be followed, configuration and documentation files must be marked as is, and pre- and post-install scripts must be robust, to not let them damage the system (remember that installation processes is done by root).</p><p>Know well RPM because it can bring much power and facilities to you and your user. There are a lot of documentation available about RPM on the Internet:</p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>The book <a class="ulink" href="http://www.redhat.com/docs/books/max-rpm/" target="_top">Maximum RPM</a>, also available <a class="ulink" href="http://www.rpm.org/max-rpm/" target="_top">on-line</a> and in printable <a class="ulink" href="http://www.rpm.org/local/maximum-rpm.ps.gz" target="_top">PostScript</a> format.</p></li><li class="listitem"><p><a class="ulink" href="http://www.rpm.org/RPM-HOWTO/" target="_top">RPM-HOWTO</a> which is smaller and more straight-forward.</p></li><li class="listitem"><p><a class="ulink" href="http://www.rpm.org/" target="_top">www.rpm.org</a></p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="module"></a>6.1. Software Package Modularization</h3></div></div></div><p>You should give user the option to install only the part of your Software he wants. Imagine your Software has a client part and a server part, and both use files and libraries in common. You should break them in 3 RPMs. For instance, lets say the name of your product is <span class="emphasis"><em>MyDB</em></span>, so you'll provide the packages:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">MyDB-common-1.0-3.i386.rpm</code></p></li><li class="listitem"><p><code class="filename">MyDB-server-1.0-3.i386.rpm</code></p></li><li class="listitem"><p><code class="filename">MyDB-client-1.0-3.i386.rpm</code></p></li></ol></div><p>and last 2 packages depends on the first. If the user is installing a client profile, he will use:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">MyDB-common-1.0-3.i386.rpm</code></p></li><li class="listitem"><p><code class="filename">MyDB-client-1.0-3.i386.rpm</code></p></li></ol></div><p>If he is installing a server profile:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="filename">MyDB-common-1.0-3.i386.rpm</code></p></li><li class="listitem"><p><code class="filename">MyDB-server-1.0-3.i386.rpm</code></p></li></ol></div><p>This approach will help the user save disk space, and be aware of how your Software is organized.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security"></a>7. Security: The Omnipresent Concept</h2></div></div></div><p>From a very general perspective, security is synonym of order, conscience. And insecure is everything that makes a system stop without the user wish. So besides open network ports, or weak cryptography (that are beyond the scope of this document), applications that inducts the user to use it only as root, or make him change files in inappropriate places, is considered insecure. We can say the same for the apps that fills a filesystem that is vital to the OS.</p><p>Many standards appeared from good practices discussed and developed in conjunction for a long time. So you should know and use them when you'll package your software, because they are key for you to achieve a good organization (security) level.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gui"></a>8. Graphical User Interface</h2></div></div></div><p>Everybody loves graphical interfaces. Many times they make our life easyer, and this way helps to popularize a Software, because the learning curve get smaller. But for the everyday use, a command with many options and a good manual becomes much more practical, making scripts easy, remote access, etc. So the suggestion is, whenever is possible, to provide both interfaces: graphical for the beginners, and the powerfull command line for the expert.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="kdegnome"></a>8.1. KDE, GNOME, Java or Motif?</h3></div></div></div><p>Better then a simple graphical interface is a <span class="emphasis"><em>consistent integrated desktop</em></span>. So developer, please do not reinvent the wheel using proprietary libraries. Today's Linux desktop is full-featured, complete <acronym class="acronym">API</acronym>s that makes your life easier.</p><p>The desktops today in Linuxland are <acronym class="acronym">KDE</acronym> and <acronym class="acronym">GNOME</acronym>. Try to allways use one of them, or both.</p><p><a class="ulink" href="http://www.kde.org/" target="_top">KDE</a> is the most outstanding, offering a true consistent desktop, flexible, with an extremely elegant architecture, using components (like Microsoft's COM and COM+), intercommunication, performance etc. It is constantly evolving, and is developed in C++. Its applications have an familiar integrated look-and-feel, is light and mature. People say that KDE 3 is shiny diamond, ready to be used, and is my first suggestion to you.</p><p><a class="ulink" href="http://www.gnome.org/" target="_top">GNOME</a> also brings the integrated desktop proposal, but it is far from the maturity and ease-of-use of KDE. From the other side, is very well supported by the comunity, and good improvements are appearing.</p><p>Motif isn't an integrated desktop. It is a widgets library (button, scrollbar etc), plus a window-manager. It was born commercial, is mature and popular in commercial applications. But is considered obsolete in front of KDE and GNOME, that integrates the desktop. Motif source code was opened by the <a class="ulink" href="http://www.opengroup.org/" target="_top">OpenGroup</a> and because that was renamed to <a class="ulink" href="http://www.openmotif.org/" target="_top">OpenMotif</a>.</p><p><a class="ulink" href="http://java.sun.com/" target="_top">Java</a> is being used more and more for graphical interfaces, specially in server Software, where the graphics are only helpers to configuration and administration. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="webgui"></a>8.2. Web Interface: Access from Anywhere</h3></div></div></div><p>Nowadays every desktop has a browser, and if your Product is a server application, the Web Interface is the right choice, because it lets a user administer it from anywhere. But keep in mind the security and organization of your CGIs, because they use to be front doors for crackers. Web interface (CGI) is completely different programming paradigm. Try to understand it conceptually first, starting from "how a web-server works", "what is a URL", etc, to get on this without compromising your Product's security.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="wizard"></a>8.3. Wizards and Graphical Installers</h3></div></div></div><p>Specially for a commercial Product, your Software must provide a graphical installer. Believe me, they are impressive in a demonstration, and CIOs love them.</p><p>More then just installation, a wizard helps in the initial configuration of your Product, collects info like activation key etc, and shows the developer license.</p><p>A wizard should not do more than this:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ask which modules to install, experienced by the user as checkboxes.</p></li><li class="listitem"><p>Get the necessary info to build an initial <a class="link" href="#software.soul">configuration (the soul)</a> for the Software.</p></li><li class="listitem"><p>Install the selected modules, that are in fact RPM files. Each checkbox must represent one or more RPMs, because each RPM is a indivisible (atomic) portion of a Software.</p></li><li class="listitem"><p>After RPMs installation, change the <a class="link" href="#software.soul">configuration (soul)</a> files (marked this way in the RPMs), or create some <a class="link" href="#software.content">content</a>, based on the data the user gave to the wizard.</p></li></ol></div><p>So the wizard hides the RPM installation and writes initial personalization. RPM is still responsable for putting all your software files in the correct places. This role should never be of your installer. Think that an experienced user (there are a lot of them in the Linux world) should be able to reproduce your Product installation without the graphical help, using only RPM commands. In fact, in big data centers, where people make mass installations, a graphical installer only disturbs.</p><p>RPM provides tools that help your graphical installer interact with them, like installation percentage viewer. Documentation for use are allways in the RPM manual (<span class="command"><strong>man rpm</strong></span>) and in the <a class="ulink" href="http://www.rpm.org/max-rpm/" target="_top">Maximum RPM</a> book.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="boot"></a>9. Starting Your Software Automatically on Boot</h2></div></div></div><p>The way Linux starts (and stops) all its subsystems is very simple and modular. Lets you define initialization order, <a class="link" href="#boot.runlevel" title="9.2. Runlevels">runlevels</a> etc</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot.init"></a>9.1. From <acronym class="acronym">BIOS</acronym> to Subsystems</h3></div></div></div><p>Lets review what happens when we boot Linux:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <acronym class="acronym">BIOS</acronym> or a bootloader (<span class="application">lilo</span>, <span class="application">zlilo</span>, <span class="application">grub</span>, etc) loads Linux Kernel from disk to memory, with some parameters defined in the bootloader configuration. We can see this process watching the dots that appear in the screen. Kernel file stays in the <code class="filename">/boot</code> directory, and is accessed only at this moment.</p></li><li class="listitem"><p>In memory, Kernel code starts to run, detecting a series of vital devices, disk partitions etc.</p></li><li class="listitem"><p>On of the last things Kernel does is to mount the <code class="filename">/</code> (root) filesystem, that obrigatoriamente must contain the <code class="filename">/etc</code>, <code class="filename">/sbin</code>, <code class="filename">/bin</code> and <code class="filename">/lib</code> directories.</p></li><li class="listitem"><p>Immediately behind, calls the program called <span class="command"><strong>init</strong></span> (<code class="filename">/sbin/init</code>) and passes the control to him.</p></li><li class="listitem"><p>The <span class="command"><strong>init</strong></span> command will read his configuration file (<code class="filename">/etc/inittab</code>) which defines the system <span class="strong"><strong>runlevel</strong></span>, and some Shell scripts to be run.</p></li><li class="listitem"><p>These scripts will continue the setup of system's minimal infrastructure, mounting other filesystems (according to <code class="filename">/etc/fstab</code>), activating swap space (virtual memory), etc.</p></li><li class="listitem"><p>The last step, and most interesting for you, is the execution of the special script called <code class="filename">/etc/rc.d/rc</code>, which initializes the subsystems according to a directory structure under <code class="filename">/etc/rc.d</code>. The name <span class="emphasis"><em>rc</em></span> comes from <span class="emphasis"><em>run commands</em></span>.</p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot.runlevel"></a>9.2. Runlevels</h3></div></div></div><p>The runlevels mechanism lets Linux initialize itself in different ways. And also lets us change from one profile (runlevel) to another without rebooting.</p><p>The default runlevel is defined in <code class="filename">/etc/inittab</code> with a line like this:</p><div class="example"><a name="idm842"></a><p class="title"><b>Example 3. Default runlevel (3, in this case) line in <code class="filename">/etc/inittab</code></b></p><div class="example-contents"><pre class="programlisting">id:3:initdefault:</pre></div></div><br class="example-break"><p>Runlevels are numbers from 0 to 6 and each one of them is used following this standard:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">0</span></dt><dd><p>Halts the system. Turning to this runlevel, all subsystems are softly deactivated before the shutdown. Don't use it in the <span class="command"><strong>initdefault</strong></span> line of <code class="filename">/etc/inittab</code>.</p></dd><dt><span class="term">1</span></dt><dd><p>Mono-user mode. Only vital subsystems are initialized because it is used for system maintenance. No user authentication (login) is required in this runlevel. A command line is directly returned to the user.</p></dd><dt><span class="term">3, </span><span class="term">2</span></dt><dd><p>3 is used when a system is in full production. Take it as the runlevel your software will run. 2 is historical and is like 3, but without NFS.</p></dd><dt><span class="term">4</span></dt><dd><p>Not used. You can define it as you want, but is uncommon.</p></dd><dt><span class="term">5</span></dt><dd><p>Like 3 plus a graphical login. It is ideal for a desktop workstation. Use 3 if the machine will be used as a server, for security and performance reasons.</p></dd><dt><span class="term">6</span></dt><dd><p>Like runlevel 0, but after complete stop, the machine is rebooted. Don't use it in the <span class="command"><strong>initdefault</strong></span> line of <code class="filename">/etc/inittab</code>.</p></dd></dl></div><p>You can switch from one runlevel to another using the <span class="command"><strong>telinit</strong></span> command. And you can see the current runlevel and the last one with the <span class="command"><strong>runlevel</strong></span> command. See bellow how we switched from runlevel 3 to 5.</p><pre class="screen">
<code class="prompt">bash# </code><span class="command"><strong>runlevel</strong></span>
N 3
<code class="prompt">bash# </code><span class="command"><strong>telinit 5</strong></span>
<code class="prompt">bash# </code><span class="command"><strong>runlevel</strong></span>
3 5
<code class="prompt">bash# </code></pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot.subs"></a>9.3. The Subsystems</h3></div></div></div><p>Subsystems examples are a web-server, data base server, OS network layer etc. We'll not consider a user oriented application (like a text editor) as a subsystem.</p><p>Linux provides an elegant and modular way to organize the subsystems initialization. An important fact to think is about subsystems interdependencies. For instance, it makes no sense to start a web-server before basic networking subsystem is active.</p><p>Subsystems are organized under the <code class="filename">/etc/init.d</code> and <code class="filename">/etc/rc.d/rc<em class="replaceable"><code>N</code></em>.d</code> directories: </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">/etc/init.d</code></span></dt><dd><p>All installed Subsystems put in this directory a control program, which is a script that follows a <a class="link" href="#boot.script" title="9.4. Turning Your Software Into a Subsystem">simple standard described bellow</a>. This is a simplified listing of this directory:</p><div class="example"><a name="idm903"></a><p class="title"><b>Example 4. Subsystems installed in <code class="filename">/etc/init.d</code></b></p><div class="example-contents"><pre class="screen">
<code class="prompt">bash:/etc/init.d# </code><span class="command"><strong>ls -l</strong></span>
-rwxr-xr-x  1 root  root   9284 Aug 13  2001 functions
-rwxr-xr-x  1 root  root   4984 Sep  5 00:18 halt
-rwxr-xr-x  1 root  root   5528 Nov  5 09:44 firewall
-rwxr-xr-x  1 root  root   1277 Sep  5 21:09 keytable
-rwxr-xr-x  1 root  root    487 Jan 30  2001 killall
-rwxr-xr-x  1 root  root   7958 Aug 15 17:20 network
-rwxr-xr-x  1 root  root   1490 Sep  5 07:54 ntpd
-rwxr-xr-x  1 root  root   2295 Jan 30  2001 rawdevices
-rwxr-xr-x  1 root  root   1830 Aug 31 09:29 httpd
-rwxr-xr-x  1 root  root   1311 Aug 15 14:18 syslog</pre></div></div><br class="example-break"></dd><dt><span class="term"><code class="filename">/etc/rc.d/rc<em class="replaceable"><code>N</code></em>.d</code> (<em class="replaceable"><code>N</code></em> is the runlevel indicator)</span></dt><dd><p>These directories must contain only special symbolic links to the scripts in <code class="filename">/etc/init.d</code>. This is how it looks:</p><div class="example"><a name="idm917"></a><p class="title"><b>Example 5. <code class="filename">/etc/rc3.d</code> listing</b></p><div class="example-contents"><pre class="screen">
<code class="prompt">bash:/etc/rc3.d# </code><span class="command"><strong>ls -l</strong></span>
lrwxrwxrwx  1 root  root     18 Jan 14 11:59 K92firewall -&gt; ../init.d/firewall
lrwxrwxrwx  1 root  root     17 Jan 14 11:59 <span class="strong"><strong>S10network -&gt; ../init.d/network</strong></span>
lrwxrwxrwx  1 root  root     16 Jan 14 11:59 S12syslog -&gt; ../init.d/syslog
lrwxrwxrwx  1 root  root     18 Jan 14 11:59 S17keytable -&gt; ../init.d/keytable
lrwxrwxrwx  1 root  root     20 Jan 14 11:59 S56rawdevices -&gt; ../init.d/rawdevices
lrwxrwxrwx  1 root  root     16 Jan 14 11:59 S56xinetd -&gt; ../init.d/xinetd
lrwxrwxrwx  1 root  root     18 Jan 14 11:59 <span class="strong"><strong>S75httpd -&gt; ../init.d/httpd</strong></span>
lrwxrwxrwx  1 root  root     11 Jan 13 21:45 S99local -&gt; ../rc.local</pre></div></div><br class="example-break"><p>Pay attention that all link names has a prefix starting with letter <span class="strong"><strong>K</strong></span> (from Kill, to deactivate) or <span class="strong"><strong>S</strong></span> (from Start, to activate), and a 2 digit number that defines the boot activation priority. In our example we have HTTPd (priority 75) starting after the Network (priority 10) subsystem. And the Firewalling subsystem will be deactivated (<span class="strong"><strong>K</strong></span>) in this runlevel.</p></dd></dl></div><p>So <span class="strong"><strong>to make your Software start automatically in the boot process, it must be a subsystem</strong></span>, and we'll see how to do it in the following section.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot.script"></a>9.4. Turning Your Software Into a Subsystem</h3></div></div></div><p>Your Software's files will spread across the filesystems, but you'll want to provide a simple and consistent interface to let the user at least start and stop it. Subsystems architecture promotes this ease-of-use, also providing a way (non obrigatoria) to be automatically started on system initialization. You just have to create your <code class="filename">/etc/init.d</code> script following a standard to make it functional.</p><div class="example"><a name="idm935"></a><p class="title"><b>Example 6. Skeleton of a Subsystem control program in <code class="filename">/etc/init.d</code></b></p><div class="example-contents"><pre class="programlisting">
#!/bin/sh
#
# /etc/init.d/mysystem
# Subsystem file for "MySystem" server
#
# chkconfig: 2345 95 05	<a name="ex.init.chkconfig"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
# description: MySystem server daemon
#
# processname: MySystem
# config: /etc/MySystem/mySystem.conf
# config: /etc/sysconfig/mySystem
# pidfile: /var/run/MySystem.pid

# source function library
. /etc/rc.d/init.d/functions

# pull in sysconfig settings
[ -f /etc/sysconfig/mySystem ] &amp;&amp; . /etc/sysconfig/mySystem	<a name="ex.init.sysconfig"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>

RETVAL=0
prog="MySystem"
.
.	<a name="ex.init.any.begin"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
.

start() {	<a name="ex.init.start"></a><span><img src="images/callouts/4.png" alt="4" border="0"></span>
	echo -n $"Starting $prog:"
	.
	.	<a name="ex.init.any.start"></a><span><img src="images/callouts/5.png" alt="5" border="0"></span>
	.
	RETVAL=$?
	[ "$RETVAL" = 0 ] &amp;&amp; touch /var/lock/subsys/$prog
	echo
}

stop() {	<a name="ex.init.stop"></a><span><img src="images/callouts/6.png" alt="6" border="0"></span>
	echo -n $"Stopping $prog:"
	.
	.	<a name="ex.init.any.stop"></a><span><img src="images/callouts/7.png" alt="7" border="0"></span>
	.
	killproc $prog -TERM
	RETVAL=$?
	[ "$RETVAL" = 0 ] &amp;&amp; rm -f /var/lock/subsys/$prog
	echo
}

reload() {	<a name="ex.init.reload"></a><span><img src="images/callouts/8.png" alt="8" border="0"></span>
	echo -n $"Reloading $prog:"
	killproc $prog -HUP
	RETVAL=$?
	echo
}

case "$1" in	<a name="ex.init.call"></a><span><img src="images/callouts/9.png" alt="9" border="0"></span>
	start)
		start
		;;
	stop)
		stop
		;;
	restart)
		stop
		start
		;;
	reload)
		reload
		;;
	condrestart)
		if [ -f /var/lock/subsys/$prog ] ; then
			stop
			# avoid race
			sleep 3
			start
		fi
		;;
	status)
		status $prog
		RETVAL=$?
		;;
	*)	<a name="ex.init.default"></a><span><img src="images/callouts/10.png" alt="10" border="0"></span>
		echo $"Usage: $0 {start|stop|restart|reload|condrestart|status}"
		RETVAL=1
esac
exit $RETVAL
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.chkconfig"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left"><p>Although these are comments, they are used by <span class="command"><strong>chkconfig</strong></span> command and must be present. This particular line defines that on runlevels 2,3,4 and 5, this subsystem will be activated with priority 95 (one of the lasts), and deactivated with priority 05 (one of the firsts).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.sysconfig"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>Besides your <a class="link" href="#software.soul">Software's own configuration</a>, this script can also have a configuration file. The standard place for it is under <code class="filename">/etc/sysconfig</code> directory, and in our case we call it <code class="filename">mySystem</code>. This code line reads this configuration file.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.start"><span><img src="images/callouts/4.png" alt="4" border="0"></span></a> <a href="#ex.init.stop"><span><img src="images/callouts/6.png" alt="6" border="0"></span></a> <a href="#ex.init.reload"><span><img src="images/callouts/8.png" alt="8" border="0"></span></a> </p></td><td valign="top" align="left"><p>Your script can have many functions, but it is obrigatorios the implementation of <span class="command"><strong>start</strong></span> and <span class="command"><strong>stop</strong></span> methods, because they are responsible for (de)activation of your Subsystem on boot. Other methods can be called from the command line, and you can define as much as you want.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.call"><span><img src="images/callouts/9.png" alt="9" border="0"></span></a> </p></td><td valign="top" align="left"><p>After defining the script actions, the command line is analyzed and the requested method (action) is called.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.default"><span><img src="images/callouts/10.png" alt="10" border="0"></span></a> </p></td><td valign="top" align="left"><p>If this script is executed without any parameter, it will return a help message like this:</p><pre class="screen">
<code class="prompt">bash# </code><span class="command"><strong>/etc/init.d/mysystem</strong></span>
Usage: mysystem {start|stop|restart|reload|condrestart|status}</pre></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#ex.init.any.begin"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> <a href="#ex.init.any.start"><span><img src="images/callouts/5.png" alt="5" border="0"></span></a> <a href="#ex.init.any.stop"><span><img src="images/callouts/7.png" alt="7" border="0"></span></a> </p></td><td valign="top" align="left"><p>Here you put your Software's specific command.</p></td></tr></table></div></div></div><br class="example-break"><p>The <span class="command"><strong>mysystem</strong></span> subsystem methods you implemented will be called by users with the <span class="command"><strong>service</strong></span> command like this example:</p><div class="example"><a name="idm974"></a><p class="title"><b>Example 7. <span class="command">service</span> command usage</b></p><div class="example-contents"><pre class="screen">
<code class="prompt">bash# </code><span class="command"><strong>service mysystem start</strong></span>
Starting MySystem:			[ OK ]
<code class="prompt">bash# </code><span class="command"><strong>service mysystem status</strong></span>
Subsysten MySystem is active with pid 1234
<code class="prompt">bash# </code><span class="command"><strong>service mysystem reload</strong></span>
Reloading MySystem:			[ OK ]
<code class="prompt">bash# </code><span class="command"><strong>service mysystem stop</strong></span>
Stopping MySystem:			[ OK ]
<code class="prompt">bash# </code></pre></div></div><br class="example-break"><p>You don't have to worry about managing the symbolic links in <code class="filename">/etc/rc.d/rc<em class="replaceable"><code>N</code></em>.d</code>. The <span class="command"><strong>chkconfig</strong></span> command makes it for you, based on the control comments defined in the beginning of your script.</p><div class="example"><a name="idm991"></a><p class="title"><b>Example 8. Using the <span class="command">chkconfig</span> command</b></p><div class="example-contents"><pre class="screen">
<code class="prompt">bash# </code><span class="command"><strong>chkconfig --add mysystem</strong></span>
<code class="prompt">bash# </code><span class="command"><strong>chkconfig --del mysystem</strong></span></pre></div></div><br class="example-break"><p>Read the <span class="command"><strong>chkconfig</strong></span> manual page to see what more it can do for you.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="boot.install"></a>9.5. Packaging Your Boot Script</h3></div></div></div><p>When you'll create the RPM, put your Subsystem script in <code class="filename">/etc/init.d</code> and <span class="strong"><strong>do not include</strong></span> any <code class="filename">/etc/rc.d/rc<em class="replaceable"><code>N</code></em>.d</code> link, because it is a user decision to make your subsystem automatic or not. If you include them and the user makes any change, the RPM file inventory will become inconsistent.</p><p>The symbolic links must be created and removed dynamically by the post-installation and pre-uninstallation process of your package, using the <span class="command"><strong>chkconfig</strong></span> command. This approach guarantees 100% package and filesystem consistency.</p></div></div><div class="appendix"><h2 class="title" style="clear: both"><a name="redhat"></a>A. Red Hat, About the Filesystem Structure</h2><p>This text was taken from <a class="ulink" href="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-filesystem.html" target="_top">The Official Red Hat Linux Reference Guide</a></p><h2><a name="idm1014"></a>Why Share a Common Structure?</h2><p>An operating system's filesystem structure is its most basic level of organization. Almost all of the ways an operating system interacts with its users, applications, and security model are dependent upon the way it stores its files on a primary storage device (normally a hard disk drive). It is crucial for a variety of reasons that users, as well as programs at the time of installation and beyond, be able to refer to a common guideline to know where to read and write their <a class="link" href="#software.body">binary</a>, <a class="link" href="#software.soul">configuration</a>, <a class="link" href="#software.logs">log</a>, and other necessary files.</p><p>A filesystem can be seen in terms of two different logical categories of files:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Shareable vs. unsharable files</p></li><li class="listitem"><p>Variable vs. static files</p></li></ol></div><p>Shareable files are those that can be accessed by various hosts; unsharable files are not available to any other hosts. Variable files can change at any time without system administrator intervention (whether active or passive); static files, such as <a class="link" href="#software.body">documentation and binaries</a>, do not change without an action from the system administrator or an agent that the system administrator has placed in motion to accomplish that task.</p><p>The reason for looking at files in this way has to do with the type of permissions given to the directory that holds them. The way in which the operating system and its users need to utilize the files determines the directory where those files should be placed, whether the directory is mounted read-only or read-write, and the level of access allowed on each file. The top level of this organization (<span class="emphasis"><em>/ directory</em></span>)is crucial, as the access to the underlying directories can be restricted or <a class="link" href="#security" title="7. Security: The Omnipresent Concept">security</a> problems may manifest themselves if the top level is left disorganized (<a class="link" href="#security" title="7. Security: The Omnipresent Concept">security=organization</a>) or without a <a class="link" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts">widely-utilized structure</a>.</p><p>However, simply having a structure does not mean very much unless it is a <a class="link" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts">standard</a>. Competing structures can actually cause more problems than they fix. Because of this, Red Hat has chosen <a class="link" href="#fhs" title="4. Linux Directory Hierarchy: Oriented to the Software Parts">the most widely-used filesystem structure</a> and extended it only slightly to accommodate special files used within Red Hat Linux.</p></div><div class="appendix"><h2 class="title" style="clear: both"><a name="about"></a>B. About this Document</h2><p>This document must be distributed under the terms of <a class="ulink" href="http://www.gnu.org/copyleft/fdl.html" target="_top">GNU Free Documentation License</a>, which makes him sufficiently free. Everybody in invited to contribute to his content and ideas.</p><p>Copyright 2002, Avi Alkalay.</p><p>This document is published in the following locations:
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://avi.alkalay.net/linux/docs/HighQuality/" target="_top">Main distribution</a> [<a class="ulink" href="http://avi.alkalay.net/linux/docs/HighQuality/HighQuality.pt.html" target="_top">pt_BR</a>] [<a class="ulink" href="http://avi.alkalay.net/linux/docs/HighQuality/highquality.tar.gz" target="_top">XML Source</a>]</p></li><li class="listitem"><p><a class="ulink" href="http://en.tldp.org/HOWTO/HighQuality-Apps-HOWTO/" target="_top">LinuxDoc, as a HOWTO</a> [<a class="ulink" href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/HighQuality-Apps-HOWTO.html" target="_top">single page</a>] [<a class="ulink" href="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/pdf/HighQuality-Apps-HOWTO.pdf" target="_top">PDF</a>]</p></li><li class="listitem"><p><a class="ulink" href="http://www.linuxandmain.org/essay/avi.html" target="_top">Linux and Main essay</a> (24<sup>th</sup> March 2002)</p></li></ul></div><p>
		</p><p>It was written originally in brazilian portuguese, and then translated to english. SGML and the more-then-incredible DocBook was used, that made possible this document being distributed in other formats, found in website.</p><p>It got ready (potuguese+english) in mid march 2002. Everything changed after this epoch is cosmetics.</p><p>I wrote it to help commercial companies and OpenSource developers make plug-and-play, easy-to-use software for Linux, and this way improve Linux usability and popularity.</p><p>All concepts (from a high level perspective) described here, can be used in any UNIX flavor, or even other OS, like Windows. Maybe some day I'll write one of these for Windows....or Mac....</p></div></div></body></html>
