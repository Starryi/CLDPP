<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>Linux IPCHAINS-HOWTO</TITLE>
</HEAD>
<BODY>
<H1>Linux IPCHAINS-HOWTO</H1>

<H2>Rusty Russell</H2>v1.0.8, Tue Jul  4 14:20:53 EST 2000
<HR>
<EM>This document aims to describe how to obtain, install and configure
the enhanced IP firewalling chains software for Linux, and
some ideas on how you might use them.</EM>
<HR>
<H2><A NAME="intro"></A> <A NAME="s1">1. Introduction</A></H2>

<P>This is the Linux IPCHAINS-HOWTO; see 
<A HREF="#intro-where">Where?</A>
for the master site, which contains the latest copy.  You should read
the Linux NET-3-HOWTO as well.  The IP-Masquerading HOWTO, the
PPP-HOWTO, the Ethernet-HOWTO and the Firewall HOWTO might make
interesting reading.  (Then again, so might the alt.fan.bigfoot FAQ).</P>

<P>If packet filtering is passe to you, read Section 
<A HREF="#intro-why">Why?</A>, Section 
<A HREF="#basics-how">How?</A>, and
scan through the titles in Section 
<A HREF="#core">IP Firewalling Chains</A>.</P>

<P>If you are converting from <CODE>ipfwadm</CODE>, read Section 
<A HREF="#intro">Introduction</A>, Section 
<A HREF="#basics-how">How?</A>, and
Appendices in section 
<A HREF="#ipfwadm-diff">Differences between ipchains and ipfwadm</A> and section 
<A HREF="#upgrade">Using the `ipfwadm-wrapper' script</A>.</P>

<H2><A NAME="ss1.1">1.1 What?</A>
</H2>

<P>Linux <CODE>ipchains</CODE> is a rewrite of the Linux IPv4 firewalling code
(which was mainly stolen from BSD) and a rewrite of <CODE>ipfwadm</CODE>,
which was a rewrite of BSD's <CODE>ipfw</CODE>, I believe.  It is required to
administer the IP packet filters in Linux kernel versions 2.1.102 and
above.</P>

<H2><A NAME="intro-why"></A> <A NAME="ss1.2">1.2 Why?</A>
</H2>

<P>The older Linux firewalling code doesn't deal with fragments, has
32-bit counters (on Intel at least), doesn't allow specification of
protocols other than TCP, UDP or ICMP, can't make large changes
atomically, can't specify inverse rules, has some quirks, and can be
tough to manage (making it prone to user error).</P>

<H2><A NAME="ss1.3">1.3 How?</A>
</H2>

<P>Currently the code is in the mainstream kernel from 2.1.102.  For the
2.0 kernel series, you will need to download a kernel patch from the
web page.  If your 2.0 kernel is more recent than the supplied patch,
the older patch should be OK; this part of the 2.0 kernels is fairly
stable (eg. the 2.0.34 kernel patch works just fine on the 2.0.35
kernel).  Since the 2.0 patch is incompatible with the ipportfw and
ipautofw patches, I don't recommend applying it unless you really need
some functionality that ipchains offers.</P>

<H2><A NAME="intro-where"></A> <A NAME="ss1.4">1.4 Where?</A>
</H2>

<P>The official page is in three places:
<A HREF="http://netfilter.filewatcher.org/ipchains">Thanks to Penguin Computing</A>
<A HREF="http://www.samba.org/netfilter/ipchains">Thanks to the SAMBA Team</A>
<A HREF="http://netfilter.kernelnotes.org/ipchains">Thanks to Jim Pick</A></P>

<P>There is a mailing list for bug reports, discussion, development and
usage.  Join the mailing list by sending a message containing the word
``subscribe ipchains-list'' to subscribe at east.balius.com.  To mail
to everyone on the list use ipchains-list at east.balius.com.</P>

<H2><A NAME="s2">2. Packet Filtering Basics</A></H2>

<H2><A NAME="ss2.1">2.1 What?</A>
</H2>

<P>All traffic through a network is sent in the form of <B>packets</B>.  For
example, downloading this package (say it's 50k long) might cause you
to receive 36 or so packets of 1460 bytes each, (to pull numbers at
random).</P>

<P>The start of each packet says where it's going, where it came from,
the type of the packet, and other administrative details.  This start
of the packet is called the <B>header</B>.  The rest of the packet,
containing the actual data being transmitted, is usually called the
<B>body</B>.</P>

<P>Some protocols, such <B>TCP</B>, which is used for web traffic, mail, and
remote logins, use the concept of a `connection' -- before any packets
with actual data are sent, various setup packets (with special
headers) are exchanged saying `I want to connect', `OK' and `Thanks'.
Then normal packets are exchanged.</P>

<P>A packet filter is a piece of software which looks at the <EM>header</EM>
of packets as they pass through, and decides the fate of the entire
packet.  It might decide to <B>deny</B> the packet (ie. discard the
packet as if it had never received it), <B>accept</B> the packet
(ie. let the packet go through), or <B>reject</B> the packet (like deny,
but tell the source of the packet that it has done so).</P>

<P>Under Linux, packet filtering is built into the kernel, and there are
a few trickier things we can do with packets, but the general
principle of looking at the headers and deciding the fate of the
packet is still there.</P>

<H2><A NAME="ss2.2">2.2 Why?</A>
</H2>

<P>Control.  Security.  Watchfulness.</P>

<P>
<DL>
<DT><B>Control:</B><DD>
<P>when you are using a Linux box to connect your internal
network to another network (say, the Internet) you have an opportunity
to allow certain types of traffic, and disallow others.  For example,
the header of a packet contains the destination address of the packet,
so you can prevent packets going to a certain part of the outside
network.  As another example, I use Netscape to access the Dilbert
archives.  There are advertisements from doubleclick.net on the page,
and Netscape wastes my time by cheerfully downloading them.
Telling the packet filter not to allow any packets to or from the
addresses owned by doubleclick.net solves that problem (there are
better ways of doing this though).</P>

<DT><B>Security:</B><DD>
<P>when your Linux box is the only thing between the
chaos of the Internet and your nice, orderly network, it's nice to
know you can restrict what comes tromping in your door.  For example,
you might allow anything to go out from your network, but you might be
worried about the well-known `Ping of Death' coming in from malicious
outsiders.  As another example, you might not want outsiders
telnetting to your Linux box, even though all your accounts have
passwords; maybe you want (like most people) to be an observer on the
Internet, and not a server (willing or otherwise) -- simply don't let
anyone connect in, by having the packet filter reject incoming packets
used to set up connections.</P>

<DT><B>Watchfulness:</B><DD>
<P>sometimes a badly configured machine on the local
network will decide to spew packets to the outside world.  It's nice
to tell the packet filter to let you know if anything abnormal occurs;
maybe you can do something about it, or maybe you're just curious by
nature.</P>
</DL>
</P>

<H2><A NAME="basics-how"></A> <A NAME="ss2.3">2.3 How?</A>
</H2>

<H3>A Kernel With Packet Filtering</H3>

<P>You need a kernel which has the new IP firewall chains in it.
You can tell if the kernel you are running right now has this
installed by looking for the file `/proc/net/ip_fwchains'.  If it
exists, you're in.</P>

<P>If not, you need to make a kernel that has IP firewall chains.
First, download the source to the kernel you want.  If you have a
kernel numbered 2.1.102 or higher, you won't need to patch it (it's in
the mainstream kernel now).  Otherwise, apply the patch from the web
page listed above, and set the configuration as detailed below.  If
you don't know how to do this, don't panic -- read the Kernel-HOWTO.</P>


<P>The configuration options you will need to set <EM>for the 2.0-series
kernel</EM> are:</P>
<P>
<HR>
<PRE>
        CONFIG_EXPERIMENTAL=y
        CONFIG_FIREWALL=y
        CONFIG_IP_FIREWALL=y
        CONFIG_IP_FIREWALL_CHAINS=y
</PRE>
<HR>
</P>
<P>For the <EM>2.1 or 2.2 series kernels</EM>:
<HR>
<PRE>
        CONFIG_FIREWALL=y
        CONFIG_IP_FIREWALL=y
</PRE>
<HR>
</P>

<P>The tool <CODE>ipchains</CODE> talks to the kernel and tells it what packets to
filter.  Unless you are a programmer, or overly curious, this is how
you will control the packet filtering.</P>

<H3>ipchains</H3>

<P>The <CODE>ipchains</CODE> tool inserts and deletes rules from the kernel's packet
filtering section.  This means that whatever you set up, it will be
lost upon reboot; see 
<A HREF="#permanent">Making Rules Permanent</A> 
for how to make sure they are restored the next time Linux is booted.</P>

<P><CODE>ipchains</CODE> replaces <CODE>ipfwadm</CODE>, which was used for the
old IP Firewall code.  There is a set of useful scripts available from
the ipchains ftp site:</P>
<P>
<A HREF="http://netfilter.filewatcher.org/ipchains/ipchains-scripts-1.1.2.tar.gz">http://netfilter.filewatcher.org/ipchains/ipchains-scripts-1.1.2.tar.gz</A></P>

<P>This contains a shell script called <CODE>ipfwadm-wrapper</CODE> which
allows you to do packet filtering as it was done before.  You probably
shouldn't use this script unless you want a quick way of upgrading a
system which uses <CODE>ipfwadm</CODE> (it's slower, and doesn't check
arguments, etc).  In that case, you don't need this HOWTO much either.</P>
<P>See Appendix 
<A HREF="#ipfwadm-diff">Differences between ipchains and ipfwadm</A> 
and Appendix 
<A HREF="#upgrade">Using the `ipfwadm-wrapper' script</A> 
for more details on <CODE>ipfwadm</CODE> issues.</P>

<H3><A NAME="permanent"></A> Making Rules Permanent</H3>

<P>Your current firewall setup is stored in the kernel, and thus will
be lost on reboot.  I recommend using the `ipchains-save' and
`ipchains-restore' scripts to make your rules permanent.  To do this,
set up your rules, then run (as root):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains-save > /etc/ipchains.rules
#
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Create a script like the following:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#! /bin/sh
# Script to control packet filtering.

# If no rules, do nothing.
[ -f /etc/ipchains.rules ] || exit 0

case "$1" in
    start)
        echo -n "Turning on packet filtering:"
        /sbin/ipchains-restore &lt; /etc/ipchains.rules || exit 1
        echo 1 > /proc/sys/net/ipv4/ip_forward
        echo "."
        ;;
    stop)
        echo -n "Turning off packet filtering:"
        echo 0 > /proc/sys/net/ipv4/ip_forward
        /sbin/ipchains -F
        /sbin/ipchains -X
        /sbin/ipchains -P input ACCEPT
        /sbin/ipchains -P output ACCEPT
        /sbin/ipchains -P forward ACCEPT
        echo "."
        ;;
    *)
        echo "Usage: /etc/init.d/packetfilter {start|stop}"
        exit 1
        ;;
esac

exit 0
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Make sure this is run early in the bootup procedure.  In my case
(Debian 2.1), I make a symbolic link called `S39packetfilter' in the
`/etc/rcS.d' directory (this will be run before S40network).</P>

<H2><A NAME="s3">3. I'm confused!  Routing, masquerading, portforwarding, ipautofw...</A></H2>

<P>This HOWTO is about packet filtering.  This means deciding whether a
packet should be allowed to pass or not.  However, Linux being the
hacker's playground that it is, you probably want to do more than
that.</P>

<P>One problem is that the same tool (``ipchains'') is used to control
both masquerading and transparent proxying, although these are
notionally separate from packet filtering (the current Linux
implementation blurs these together unnaturally, leaving the
impression that they are closely related).</P>

<P>Masquerading and proxying are covered by separate HOWTOs, and the auto
forwarding and port forwarding features are controlled by separate
tools, but since so many people keep asking me about it, I'll include
a set of common scenarios and indicate when each one should be
applied.  The security merits of each setup will not be discussed
here.</P>

<H2><A NAME="ss3.1">3.1 Rusty's Three-Line Guide To Masquerading</A>
</H2>

<P>This assumes that your <B>external</B> interface is called `ppp0'.
Use ifconfig to find out, and adjust to taste.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -P forward DENY
# ipchains -A forward -i ppp0 -j MASQ
# echo 1 > /proc/sys/net/ipv4/ip_forward
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss3.2">3.2 Gratuitous Promotion: WatchGuard Rules</A>
</H2>

<P>You can buy off-the-shelf firewalls.  An excellent one is WatchGuard's
FireBox.  It's excellent because I like it, it's secure, it's
Linux-based, and because they funded the maintenance of ipchains as
well as the new firewalling code (for 2.4).  In short, WatchGuard were
paying for me to eat while I work for you.  So please consider their
stuff.</P>
<P>
<A HREF="http://www.watchguard.com">http://www.watchguard.com</A></P>

<H2><A NAME="ss3.3">3.3 Common Firewall-like Setups</A>
</H2>

<P>You run littlecorp.com.  You have an internal network, and a single
dialup (PPP) connection to the Internet (firewall.littlecorp.com which
is 1.2.3.4).  You run Ethernet on your local network, and your
personal machine is called "myhost".</P>

<P>This section will illustrate the different arrangement which are
common.  Read carefully, because they are each subtly different.</P>

<H3>Private Network: Traditional Proxies</H3>

<P>In this scenario, packets from the private network never traverse the
Internet, and vice versa.  The IP addresses of the private network
should be assigned from the RFC1918 Address Allocation for Private
Internets (ie. 10.*.*.*, 172.16.*.*-172.31.*.* or 192.168.*.*).</P>

<P>The only way things ever connect to the Internet is by connecting to
the firewall, which is the only machine on both networks which
connects onwards.  You run a program (on the firewall) called a proxy
to do this (there are proxies for FTP, web access, telnet, RealAudio,
Usenet News and other services).  See the Firewall HOWTO.</P>

<P>Any services you wish the Internet to access must be on the firewall.
(But see 
<A HREF="#limited-services">Limited Internal Services</A>
below).</P>

<P>Example: Allowing web access from private network to the Internet.
<OL>
<LI> The private network is assigned 192.168.1.* addresses, with
myhost being 192.168.1.100, and the firewall's Ethernet interface
being assigned 192.168.1.1.
</LI>
<LI> A web proxy (eg. "squid") is installed and configured on the
firewall, say running on port 8080.
</LI>
<LI> Netscape on the private network is configured to use the
firewall port 8080 as a proxy.
</LI>
<LI> DNS does not need to be configured on the private network.
</LI>
<LI> DNS does need to be configured on the firewall.
</LI>
<LI> No default route (aka gateway) needs to be configured on the
private network.</LI>
</OL>
</P>

<P>Netscape on myhost reads http://slashdot.org.
<OL>
<LI> Netscape connects to the firewall port 8080, using port 1050 on
myhost.  It asks for the web page of "http://slashdot.org".
</LI>
<LI> The proxy looks up the name "slashdot.org", and gets
207.218.152.131.  It then opens a connection to that IP address (using
port 1025 on the firewall's external interface), and asks the web
server (port 80) for the web page.
</LI>
<LI> As it receives the web page from its connection to the web
server, it copies the data to the connection from Netscape.
</LI>
<LI> Netscape renders the page.</LI>
</OL>
</P>
<P>ie.  From slashdot.org's point of view, the connection is made from
1.2.3.4 (firewall's PPP interface) port 1025 to 207.218.152.131
(slashdot.org) port 80.  From myhost's point of view, the connection
is made from 192.168.1.100 (myhost) port 1050, to 192.168.1.1
(firewall's Ethernet interface) port 8080.</P>


<H3>Private Network: Transparent Proxies</H3>

<P>In this scenario, packets from the private network never traverse the
Internet, and vice versa.  The IP addresses of the private network
should be assigned from the RFC1918 Address Allocation for Private
Internets (ie. 10.*.*.*, 172.16.*.*-172.31.*.* or 192.168.*.*).</P>

<P>The only way things ever connect to the Internet is by connecting to
the firewall, which is the only machine on both networks, which
connects onwards.  You run a program (on the firewall) called a
transparent proxy to do this; the kernel sends outgoing packets to the
transparent proxy instead of sending them onwards (ie. it bastardizes
routing).</P>

<P>Transparent proxying means that the clients don't need to know there
is a proxy involved.</P>

<P>Any services you wish the Internet to access must be on the firewall.
(But see 
<A HREF="#limited-services">Limited Internal Services</A>
below).</P>

<P>Example: Allowing web access from private network to the Internet.
<OL>
<LI> The private network is assigned 192.168.1.* addresses, with
myhost being 192.168.1.100, and the firewall's Ethernet interface
being assigned 192.168.1.1.
</LI>
<LI> A transparent web proxy (I believe there are patches for squid
to allow it to operate in this manner, or try "transproxy") is
installed and configured on the firewall, say running on port 8080.
</LI>
<LI> The kernel is told to redirect connections to port 80 to the
proxy, using ipchains. 
</LI>
<LI> Netscape on the private network is configured to connect directly.
</LI>
<LI> DNS needs to be configured on the private network (ie. you need
to run a DNS server as a proxy on the firewall).
</LI>
<LI> The default route (aka gateway) needs to be configured on the
private network, to send packets to the firewall.</LI>
</OL>
</P>

<P>Netscape on myhost reads http://slashdot.org.
<OL>
<LI> Netscape looks up the name "slashdot.org", and gets
207.218.152.131.  It then opens a connection to that IP address, using
local port 1050, and asks the web server (port 80) for the web page.
</LI>
<LI> As the packets from myhost (port 1050) to slashdot.org (port
80) pass through the firewall, they are redirected to the waiting
transparent proxy on port 8080.  The transparent proxy opens a
connection (using local port 1025) to 207.218.152.131 port 80 (which
is where the original packets were going).
</LI>
<LI> As the proxy receives the web page from its connection to the
web server, it copies the data to the connection from Netscape.
</LI>
<LI> Netscape renders the page.</LI>
</OL>
</P>
<P>ie.  From slashdot.org's point of view, the connection is made from
1.2.3.4 (firewall's PPP interface) port 1025 to 207.218.152.131
(slashdot.org) port 80.  From myhost's point of view, the connection
is made from 192.168.1.100 (myhost) port 1050, to 207.218.152.131
(slashdot.org) port 80, but it's actually talking to the transparent
proxy.</P>

<H3>Private Network: Masquerading</H3>

<P>In this scenario, packets from the private network never traverse the
Internet without special treatment, and vice versa.  The IP addresses
of the private network should be assigned from the RFC1918 Address
Allocation for Private Internets (ie. 10.*.*.*, 172.16.*.*-172.31.*.*
or 192.168.*.*).</P>

<P>Instead of using a proxy, we use a special kernel facility called
"masquerading".  Masquerading rewrites packets as they pass through
the firewall, so that they always seem to come from the firewall
itself.  It then rewrites the responses so that they look like they
are going to the original recipient.</P>

<P>Masquerading has separate modules to handle "tricky" protocols, such
as FTP, RealAudio, Quake, etc.  For really hard-to-handle protocols,
the "auto forwarding" facility can handle some of them by
automatically setting up port forwarding for related sets of ports:
look for ``ipportfw'' (2.0 kernels) or ``ipmasqadm'' (2.1 kernels).</P>

<P>Any services you wish the Internet to access must be on the firewall.
(But see 
<A HREF="#limited-services">Limited Internal Services</A>
below).</P>

<P>Example: Allowing web access from private network to the Internet.
<OL>
<LI> The private network is assigned 192.168.1.* addresses, with
myhost being 192.168.1.100, and the firewall's Ethernet interface
being assigned 192.168.1.1.
</LI>
<LI> The firewall is set up to masquerade any packets coming from
the private network and going to port 80 on an Internet host.
</LI>
<LI> Netscape is configured to connect directly.
</LI>
<LI> DNS must be configured correctly on the private network.
</LI>
<LI> The firewall should be the default route (aka gateway) for the
private network.</LI>
</OL>
</P>
<P>Netscape on myhost reads http://slashdot.org.
<OL>
<LI> Netscape looks up the name "slashdot.org", and gets
207.218.152.131.  It then opens a connection to that IP address, using
local port 1050, and asks the web server (port 80) for the web page.
</LI>
<LI> As the packets from myhost (port 1050) to slashdot.org (port
80) pass through the firewall, they are rewritten to come from the PPP
interface of the firewall, port 65000.  The firewall has a valid
Internet address (1.2.3.4) so reply packets from slashdot.org get
routed back OK.
</LI>
<LI> As packets from slashdot.org (port 80) to
firewall.littlecorp.com (port 65000) come in, they are rewritten to go
to myhost, port 1050.  This is the real magic of masquerading: it
remembers when it rewrites outgoing packets to it can write them back
as replies come in.
</LI>
<LI> Netscape renders the page.</LI>
</OL>
</P>
<P>ie.  From the slashdot.org's point of view, the connection is made
from 1.2.3.4 (firewall's PPP interface) port 65000 to 207.218.152.131
(slashdot.org) port 80.  From the myhost's point of view, the
connection is made from 192.168.1.100 (myhost) port 1050, to
207.218.152.131 (slashdot.org) port 80.</P>


<H3>Public Network</H3>

<P>In this scenario, your personal network is a part of the Internet:
packets can flow without change across both networks.  The IP
addresses of the internal network must be assigned by applying for a
block of IP addresses, so the rest of the network will know how to get
packets to you.  This implies a permanent connection.</P>

<P>In this role, packet filtering is used to restrict which packets can
be forwarded between your network and the rest of the Internet, eg. to
restrict the rest of the Internet to only accessing your internal web
servers.</P>

<P>Example: Allowing web access from private network to the Internet.
<OL>
<LI> Your internal network is assigned according to the IP address
block you have registered, (say 1.2.3.*).
</LI>
<LI> The firewall is set up to allow all traffic.
</LI>
<LI> Netscape is configured to connect directly.
</LI>
<LI> DNS must be configured correctly on your network.
</LI>
<LI> The firewall should be the default route (aka gateway) for the
private network.</LI>
</OL>
</P>
<P>Netscape on myhost reads http://slashdot.org.
<OL>
<LI> Netscape looks up the name "slashdot.org", and gets
207.218.152.131.  It then opens a connection to that IP address, using
local port 1050, and asks the web server (port 80) for the web page.
</LI>
<LI> Packets pass through your firewall, just as they pass through
several other routers between you and slashdot.org.
</LI>
<LI> Netscape renders the page.</LI>
</OL>
</P>
<P>ie.  There is only one connection: from 1.2.3.100 (myhost) port
1050, to 207.218.152.131 (slashdot.org) port 80.</P>

<H3><A NAME="limited-services"></A> Limited Internal Services</H3>

<P>There are a few tricks you can pull to allow the Internet to access
your internal services, rather than running the services on the
firewall.  These will work with either a proxy or masquerading based
approach for external connections.</P>

<P>The simplest approach is to run a "redirector", which is a poor-man's
proxy which waits for a connection on a given port, and then open a
connection a fixed internal host and port, and copies data between the
two connections.  An example of this is the "redir" program.  From the
Internet point of view, the connection is made to your firewall.
From your internal server's point of view, the connection is made from
the internal interface of the firewall to the server.</P>

<P>Another approach (which requires a 2.0 kernel patched for ipportfw, or
a 2.1 or later kernel) is to use port forwarding in the kernel.  This
does the same job as "redir" in a different way: the kernel rewrites
packets as they pass through, changing their destination address and
ports to point them at an internal host and port.  From the Internet's
point of view, the connection is made to your firewall.  From your
internal server's point of view, a direct connection is made from the
Internet host to the server.</P>

<H2><A NAME="ss3.4">3.4 More Information on Masquerading</A>
</H2>

<P>David Ranch has written an excellent new HOWTO on Masquerading, which
has a large amount of overlap with this HOWTO.  You can currently find
that HOWTO at</P>
<P>
<A HREF="http://www.linuxdoc.org/HOWTO/IP-Masquerade-HOWTO.html">http://www.linuxdoc.org/HOWTO/IP-Masquerade-HOWTO.html</A></P>

<P>The official Masquerading home page is at </P>
<P>
<A HREF="http://ipmasq.cjb.net">http://ipmasq.cjb.net</A></P>


<H2><A NAME="core"></A> <A NAME="s4">4. IP Firewalling Chains</A></H2>

<P>This section describes all you really need to know to build a packet
filter that meets your needs.</P>

<H2><A NAME="ss4.1">4.1 How Packets Traverse The Filters</A>
</H2>

<P>The kernel starts with three lists of rules; these lists are called
<B>firewall chains</B> or just <B>chains</B>.  The three chains are
called <B>input</B>, <B>output</B> and <B>forward</B>.  When a packet comes
in (say, through the Ethernet card) the kernel uses the <CODE>input</CODE>
chain to decide its fate.  If it survives that step, then the kernel
decides where to send the packet next (this is called <B>routing</B>).
If it is destined for another machine, it consults the <CODE>forward</CODE>
chain.  Finally, just before a packet is to go out, the kernel
consults the <CODE>output</CODE> chain.</P>

<P>A chain is a checklist of <B>rules</B>.  Each rule says `if the packet
header looks like this, then here's what to do with the packet'.  If
the rule doesn't match the packet, then the next rule in the chain is
consulted.  Finally, if there are no more rules to consult, then the
kernel looks at the chain <B>policy</B> to decide what to do.  In a
security-conscious system, this policy usually tells the kernel to
reject or deny the packet.</P>

<P>For ASCII-art fans, this shown the complete path of a packet coming
into a machine.</P>
<P>
<PRE>
        ----------------------------------------------------------------
        |            ACCEPT/                              lo interface |
        v           REDIRECT                  _______                  |
--> C --> S --> ______ --> D --> ~~~~~~~~ -->|forward|----> _______ --> 
    h     a    |input |    e    {Routing }   |Chain  |     |output |ACCEPT
    e     n    |Chain |    m    {Decision}   |_______| --->|Chain  |
    c     i    |______|    a     ~~~~~~~~        |     | ->|_______|
    k     t       |        s       |             |     | |     |    
    s     y       |        q       |             v     | |     |    
    u     |       v        e       v            DENY/  | |     v    
    m     |     DENY/      r   Local Process   REJECT  | |   DENY/
    |     v    REJECT      a       |                   | |  REJECT
    |   DENY               d       --------------------- | 
    v                      e -----------------------------
   DENY                              
</PRE>

Here is a blow-by-blow description of each stage:</P>
<P>
<DL>
<DT><B>Checksum:</B><DD>
<P>This is a test that the packet hasn't been corrupted
in some way.  If it has, it is denied.</P>

<DT><B>Sanity:</B><DD>
<P>There is actually one of these sanity checks before each
firewall chain, but the input chain's is the most important.  Some
malformed packets might confuse the rule-checking code, and these are
denied here (a message is printed to the syslog if this happens).</P>

<DT><B>input chain:</B><DD>
<P>This is the first firewall chain against which the
packet will be tested.  If the verdict of the chain is not <CODE>DENY</CODE>
or <CODE>REJECT</CODE>, the packet continues on.</P>

<DT><B>Demasquerade:</B><DD>
<P>If the packet is a reply to a previously
masqueraded packet, it is demasqueraded, and skips straight to the
<CODE>output</CODE> chain.  If you don't use IP Masquerading, you can mentally
erase this from the diagram.</P>

<DT><B>Routing decision:</B><DD>
<P>The destination field is examined by the
routing code, to decide if this packet should go to a local process
(see Local process below) or forwarded to a remote machine (see forward
chain below).</P>

<DT><B>Local process:</B><DD>
<P>A process running on the machine can receive
packets after the Routing Decision step, and can send packets (which
go through the Routing Decision step, then traverse the output chain).</P>

<DT><B>lo interface:</B><DD>
<P>If packets from a local process are destined for a
local process, they will go through the output chain with interface
set to `lo', then return through the input chain with interface also
`lo'.  The lo interface is usually called the loopback interface.</P>

<DT><B>local:</B><DD>
<P>If the packet was not created by a local process, then
the forward chain is checked, otherwise the packet goes to the output
chain.</P>

<DT><B>forward chain:</B><DD>
<P>This chain is traversed for any packets which are
attempting to pass through this machine to another.</P>

<DT><B>output chain:</B><DD>
<P>This chain is traversed for all packets just
before they are sent out.</P>
</DL>
</P>

<H3>Using ipchains</H3>

<P>First, check that you have the version of ipchains that this document
refers to: </P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ipchains --version
ipchains 1.3.9, 17-Mar-1999
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Note that I recommend 1.3.4 (which has no long options, like
`--sport'), or 1.3.8 or above; these are very stable.</P>

<P>ipchains has a fairly detailed manual page (<CODE>man ipchains</CODE>),
and if you need more detail on particulars, you can check out the
programming interface (<CODE>man 4 ipfw</CODE>), or the file
<CODE>net/ipv4/ip_fw.c</CODE> in the 2.1.x kernel source, which is
(obviously) authoritative.</P>

<P>There is also an excellent quick reference card by Scott Bronson in
the source package, in both A4 and US Letter PostScript(TM).</P>

<P>There are several different things you can do with <CODE>ipchains</CODE>.
First the operations to manage whole chains.  You start with three
built-in chains <CODE>input</CODE>, <CODE>output</CODE> and <CODE>forward</CODE>
which you can't delete.</P>
<P>
<OL>
<LI> Create a new chain (-N).</LI>
<LI> Delete an empty chain (-X).</LI>
<LI> Change the policy for a built-in chain. (-P).</LI>
<LI> List the rules in a chain (-L).</LI>
<LI> Flush the rules out of a chain (-F).</LI>
<LI> Zero the packet and byte counters on all rules in a chain (-Z).</LI>
</OL>
</P>
<P>There are several ways to manipulate rules inside a chain:</P>
<P>
<OL>
<LI> Append a new rule to a chain (-A).</LI>
<LI> Insert a new rule at some position in a chain (-I).</LI>
<LI> Replace a rule at some position in a chain (-R).</LI>
<LI> Delete a rule at some position in a chain (-D).</LI>
<LI> Delete the first rule that matches in a chain (-D).</LI>
</OL>
</P>
<P>There are a few operations for masquerading, which are in
<CODE>ipchains</CODE> for want of a good place to put them:</P>
<P>
<OL>
<LI> List the currently masqueraded connections (-M -L).</LI>
<LI> Set masquerading timeout values (-M -S). (But see 
<A HREF="#no-timeout">I can't set masquerading timeouts!</A>).</LI>
</OL>
</P>
<P>The final (and perhaps the most useful) function allows you to check
what would happen to a given packet if it were to traverse a given
chain.</P>

<H3>What You'll See When Your Computer Starts Up</H3>

<P>Before any ipchains commands have been run (be careful: some
distributions run ipchains in their initialization scripts), there
will be no rules in any of the built-in chains (`input', `forward' and
`output'), and each of the chains will have a policy of ACCEPT.  This
is as wide-open as you can get.</P>

<H3>Operations on a Single Rule</H3>

<P>This is the bread-and-butter of ipchains; manipulating rules.  Most
commonly, you will probably use the append (-A) and delete (-D)
commands.  The others (-I for insert and -R for replace) are simple
extensions of these concepts.</P>

<P>Each rule specifies a set of conditions the packet must meet, and what
to do if it meets them (a `target').  For example, you might want to
deny all ICMP packets coming from the IP address 127.0.0.1.  So in
this case our conditions are that the protocol must be ICMP and that
the source address must be 127.0.0.1.  Our target is `DENY'.</P>

<P>127.0.0.1 is the `loopback' interface, which you will have even if you
have no real network connection.  You can use the `ping' program to
generate such packets (it simply sends an ICMP type 8 (echo request)
which all cooperative hosts should obligingly respond to with an ICMP
type 0 (echo reply) packet).  This makes it useful for testing.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.2 ms

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max = 0.2/0.2/0.2 ms
# ipchains -A input -s 127.0.0.1 -p icmp -j DENY
# ping -c 1 127.0.0.1
PING 127.0.0.1 (127.0.0.1): 56 data bytes

--- 127.0.0.1 ping statistics ---
1 packets transmitted, 0 packets received, 100% packet loss
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>You can see here that the first ping succeeds (the `-c 1' tells ping
to only send a single packet).</P>

<P>Then we append (-A) to the `input' chain, a rule specifying that for
packets from 127.0.0.1 (`-s 127.0.0.1') with protocol ICMP (`-p ICMP')
we should jump to DENY (`-j DENY').</P>

<P>Then we test our rule, using the second ping.  There will be a pause
before the program gives up waiting for a response that will never
come.</P>

<P>We can delete the rule in one of two ways.  Firstly, since we know
that it is the only rule in the input chain, we can use a numbered
delete, as in:
<BLOCKQUOTE><CODE>
<PRE>
        # ipchains -D input 1
        #
</PRE>
</CODE></BLOCKQUOTE>

To delete rule number 1 in the input chain.</P>

<P>The second way is to mirror the -A command, but replacing the -A with
-D.  This is useful when you have a complex chain of rules and you
don't want to have to count them to figure out that it's rule 37 that
you want to get rid of.  In this case, we would use:
<BLOCKQUOTE><CODE>
<PRE>
        # ipchains -D input -s 127.0.0.1 -p icmp -j DENY
        #
</PRE>
</CODE></BLOCKQUOTE>

The syntax of -D must have exactly the same options as the -A (or -I
or -R) command.  If there are multiple identical rules in the same
chain, only the first will be deleted.</P>

<H3>Filtering Specifications</H3>

<P>We have seen the use of `-p' to specify protocol, and `-s' to specify
source address, but there are other options we can use to specify
packet characteristics.  What follows is an exhaustive compendium.</P>

<H3>Specifying Source and Destination IP Addresses</H3>

<P>Source (-s) and destination (-d) IP addresses can be specified in four
ways.  The most common way is to use the full name, such as
`localhost' or `www.linuxhq.com'.  The second way is to specify the IP
address such as `127.0.0.1'.  </P>

<P>The third and fourth ways allow specification of a group of IP
addresses, such as `199.95.207.0/24' or `199.95.207.0/255.255.255.0'.
These both specify any IP address from 199.95.207.0 to 199.95.207.255
inclusive; the digits after the `/' tell which parts of the IP address
are significant.  `/32' or `/255.255.255.255' is the default (match
all of the IP address).  To specify any IP address at all `/0' can be
used, like so:
<BLOCKQUOTE><CODE>
<PRE>
        # ipchains -A input -s 0/0 -j DENY
        #
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This is rarely used, as the effect above is the same as not specifying
the `-s' option at all.</P>

<H3>Specifying Inversion</H3>

<P>Many flags, including the `-s' and `-d' flags can have their arguments
preceded by `!' (pronounced `not') to match addresses NOT equal to the
ones given.  For example. `-s ! localhost' matches any packet not
coming from localhost.</P>

<P>Don't forget the spaces around the `!': they really are needed.</P>

<H3>Specifying Protocol</H3>

<P>The protocol can be specified with the `-p' flag.  Protocol can be a
number (if you know the numeric protocol values for IP) or a name for
the special cases of `TCP', `UDP' or `ICMP'.  Case doesn't matter, so
`tcp' works as well as `TCP'.</P>

<P>The protocol name can be prefixed by a `!', to invert it, such as `-p
! TCP'.</P>

<H3>Specifying UDP and TCP Ports</H3>

<P>For the special case where a protocol of TCP or UDP is specified,
there can be an extra argument indicating the TCP or UDP port, or an
(inclusive) range of ports (but see 
<A HREF="#handling-fragments">Handling Fragments</A> below).  A range is represented using a `:'
character, such as `6000:6010', which covers 11 port numbers, from
6000 to 6010 inclusive.  If the lower bound is omitted, it defaults to
0.  If the upper bound is omitted, it defaults to 65535.  So to
specify TCP connections coming from ports under 1024, the syntax would
be as `-p TCP -s 0.0.0.0/0 :1023'.  Port numbers can be specified by
name, eg. `www'.</P>

<P>Note that the port specification can be preceded by a `!', which
inverts it.  So to specify every TCP packet BUT a WWW packet, you
would specify
<PRE>
-p TCP -d 0.0.0.0/0 ! www
</PRE>
</P>
<P>It is important to realize that the specification </P>
<P>
<PRE>
-p TCP -d ! 192.168.1.1 www
</PRE>
</P>
<P>is very different from 
<PRE>
-p TCP -d 192.168.1.1 ! www
</PRE>
</P>
<P>The first specifies any TCP packet to the WWW port on any machine but
192.168.1.1.  The second specifies any TCP connection to any port on
192.168.1.1 but the WWW port.</P>

<P>Finally, this case means not the WWW port and not 192.168.1.1:
<PRE>
-p TCP -d ! 192.168.1.1 ! www
</PRE>
</P>

<H3>Specifying ICMP Type and Code</H3>

<P>ICMP also allows an optional argument, but as ICMP doesn't have ports,
(ICMP has a <B>type</B> and a <B>code</B>) they have a different meaning.</P>

<P>You can specify them as ICMP names (use <CODE>ipchains -h icmp</CODE> to list the
names) after the `-s' option, or as a numeric ICMP type and code,
where the type follows the `-s' option and the code follows the `-d'
option.</P>

<P>The ICMP names are fairly long: you only need use enough letters to
make the name distinct from any other.</P>

<P>Here is a small table of some of the most common ICMP packets:
<BLOCKQUOTE><CODE>
<PRE>
Number  Name                     Required by

0       echo-reply               ping
3       destination-unreachable  Any TCP/UDP traffic.
5       redirect                 routing if not running routing daemon
8       echo-request             ping
11      time-exceeded            traceroute
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Note that the ICMP names cannot be preceeded by `!' at the moment.</P>

<P>DO NOT DO NOT DO NOT block all ICMP type 3 messages!  (See 
<A HREF="#ICMP">ICMP Packets</A> below).</P>

<H3>Specifying an Interface </H3>

<P>The `-i' option specifies the name of an <B>interface</B> to match.  An
interface is the physical device the packet came in on, or is going
out on.  You can use the <CODE>ifconfig</CODE> command to list the interfaces
which are `up' (ie. working at the moment).</P>

<P>The interface for incoming packets (ie. packets traversing the <CODE>input</CODE>
chain) is considered to be the interface they came in on.  Logically,
the interface for outgoing packets (packets traversing the <CODE>output</CODE>
chain) is the interface they will go out on.  The interface for
packets traversing the <CODE>forward</CODE> chain is also the interface they will
go out on; a fairly arbitrary decision it seems to me.</P>

<P>It is perfectly legal to specify an interface that currently does not
exist; the rule will not match anything until the interface comes up.
This is extremely useful for dial-up PPP links (usually interface
<CODE>ppp0</CODE>) and the like.</P>

<P>As a special case, an interface name ending with a `+' will match all
interfaces (whether they currently exist or not) which begin with that
string.  For example, to specify a rule which matches all PPP
interfaces, the <CODE>-i ppp+</CODE> option would be used.</P>

<P>The interface name can be preceded by a `!' to match a packet which
does NOT match the specified interface(s).</P>

<H3>Specifying TCP SYN Packets Only</H3>

<P>It is sometimes useful to allow TCP connections in one direction, but
not the other.  For example, you might want to allow connections to an
external WWW server, but not connections from that server.</P>

<P>The naive approach would be to block TCP packets coming from the
server.  Unfortunately, TCP connections require packets going in both
directions to work at all.</P>

<P>The solution is to block only the packets used to request a
connection.  These packets are called <B>SYN</B> packets (ok,
technically they're packets with the SYN flag set, and the FIN and ACK
flags cleared, but we call them SYN packets).  By disallowing only
these packets, we can stop attempted connections in their tracks.</P>

<P>The `-y' flag is used for this: it is only valid for rules which
specify TCP as their protocol.  For example, to specify TCP connection
attempts from 192.168.1.1:
<PRE>
-p TCP -s 192.168.1.1 -y
</PRE>
</P>

<P>Once again, this flag can be inverted by preceding it with a `!',
which means every packet other than the connection initiation.</P>

<H3><A NAME="handling-fragments"></A> Handling Fragments</H3>

<P>Sometimes a packet is too large to fit down a wire all at once.  When
this happens, the packet is divided into <B>fragments</B>, and sent as
multiple packets.  The other end reassembles the fragments to
reconstruct the whole packet.</P>

<P>The problem with fragments is that some of the specifications listed
above (in particular, source port, destinations port, ICMP type, ICMP
code, or TCP SYN flag) require the kernel to peek at the start of the
packet, which is only contained in the first fragment.</P>

<P>If your machine is the only connection to an external network, then
you can tell the Linux kernel to reassemble all fragments which pass
through it, by compiling the kernel with <CODE>IP: always defragment</CODE> set
to `Y'.  This sidesteps the issue neatly.</P>

<P>Otherwise, it is important to understand how fragments get treated by
the filtering rules.  Any filtering rule that asks for information we
don't have will <EM>not</EM> match.  This means that the first fragment is
treated like any other packet.  Second and further fragments won't be.
Thus a rule <CODE>-p TCP -s 192.168.1.1 www</CODE> (specifying a source port of
`www') will never match a fragment (other than the first fragment).
Neither will the opposite rule <CODE>-p TCP -s 192.168.1.1 ! www</CODE>.</P>

<P>However, you can specify a rule specifically for second and further
fragments, using the `-f' flag.  Obviously, it is illegal to specify a
TCP or UDP port, ICMP type, ICMP code or TCP SYN flag in such a
fragment rule.</P>

<P>It is also legal to specify that a rule does <EM>not</EM> apply to second
and further fragments, by preceding the `-f' with `!'.</P>

<P>Usually it is regarded as safe to let second and further fragments
through, since filtering will effect the first fragment, and thus
prevent reassembly on the target host, however, bugs have been known
to allow crashing of machines simply by sending fragments.  Your call.</P>

<P>Note for network-heads: malformed packets (TCP, UDP and ICMP packets
too short for the firewalling code to read the ports or ICMP code and
type) are treated as fragments as well.  Only TCP fragments starting
at position 8 are explicitly dropped by the firewall code (a message
should appear in the syslog if this occurs).</P>

<P>As an example, the following rule will drop any fragments going to
192.168.1.1:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
 
# ipchains -A output -f -d 192.168.1.1 -j DENY
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Filtering Side Effects</H3>

<P>OK, so now we know all the ways we can match a packet using a rule.
If a packet matches a rule, the following things happen:</P>
<P>
<OL>
<LI> The byte counter for that rule is increased by the size of the
packet (header and all).
</LI>
<LI> The packet counter for that rule is incremented.
</LI>
<LI> If the rule requests it, the packet is logged.
</LI>
<LI> If the rule requests it, the packet's Type Of Service field is
changed.
</LI>
<LI> If the rule requests it, the packet is marked (not in 2.0
kernel series).
</LI>
<LI> The rule target is examined to decide what to do to the packet
next.</LI>
</OL>
</P>

<P>For variety, I'll address these in order of importance.</P>

<H3><A NAME="target-spec"></A> Specifying a Target</H3>

<P>A <B>target</B> tells the kernel what to do with a packet that
matches a rule.  ipchains uses `-j' (think `jump-to') for the target
specification.  The target name must be less than 8 letters, and case
matters: "RETURN" and "return" are completely different.</P>

<P>The simplest case is when there is no target specified.  This type of
rule (often called an `accounting' rule) is useful for simply counting
a certain type of packet.  Whether this rule matches or not, the
kernel simply examines the next rule in the chain.  For example, to
count the number of packets from 192.168.1.1, we could do this:
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -s 192.168.1.1
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>(Using `ipchains -L -v' we can see the byte and packet counters
associated with each rule).</P>

<P>There are six special targets.  The first three, <CODE>ACCEPT</CODE>,
<CODE>REJECT</CODE> and <CODE>DENY</CODE> are fairly simple.  <CODE>ACCEPT</CODE> allows the
packet through.  <CODE>DENY</CODE> drops the packet as if it had never been
received.  <CODE>REJECT</CODE> drops the packet, but (if it's not an ICMP
packet) generates an ICMP reply to the source to tell it that the
destination was unreachable.</P>

<P>The next one, <CODE>MASQ</CODE> tells the kernel to masquerade the packet.  For
this to work, your kernel needs to be compiled with IP Masquerading
enabled.  For details on this, see the Masquerading-HOWTO and the
Appendix 
<A HREF="#ipfwadm-diff">Differences between ipchains and ipfwadm</A>.  This target is only valid for packets traversing the
<CODE>forward</CODE> chain.</P>

<P>The other major special target is <CODE>REDIRECT</CODE> which tells the kernel
to send a packet to a local port instead of wherever it was heading.
This can only be specified for rules specifying TCP or UDP as their
protocol.  Optionally, a port (name or number) can be specified
following `-j REDIRECT' which will cause the packet to be redirected
to that particular port, even if it was addressed to another port.
This target is only valid for packets traversing the <CODE>input</CODE> chain.</P>

<P>The final special target is <CODE>RETURN</CODE> which is identical to falling
off the end of the chain immediately.  (See 
<A HREF="#policy">Setting Policy</A> below).</P>

<P>Any other target indicates a user-defined chain (as described in 
<A HREF="#chain-ops">Operations on an Entire Chain</A> below).  The
packet will begin traversing the rules in that chain.  If that chain
doesn't decide the fate of the packet, then once traversal on that
chain has finished, traversal resumes on the next rule in the current
chain.</P>

<P>Time for more ASCII art.  Consider two (silly) chains: <CODE>input</CODE> (the
built-in chain) and <CODE>Test</CODE> (a user-defined chain).</P>
<P>
<PRE>
         `input'                         `Test'
        ----------------------------    ----------------------------
        | Rule1: -p ICMP -j REJECT |    | Rule1: -s 192.168.1.1    |
        |--------------------------|    |--------------------------|
        | Rule2: -p TCP -j Test    |    | Rule2: -d 192.168.1.1    |
        |--------------------------|    ----------------------------
        | Rule3: -p UDP -j DENY    |
        ----------------------------
</PRE>
</P>

<P>Consider a TCP packet coming from 192.168.1.1, going to 1.2.3.4.  It
enters the <CODE>input</CODE> chain, and gets tested against Rule1 - no match.
Rule2 matches, and its target is <CODE>Test</CODE>, so the next rule examined
is the start of <CODE>Test</CODE>.  Rule1 in <CODE>Test</CODE> matches, but doesn't
specify a target, so the next rule is examined, Rule2.  This doesn't
match, so we have reached the end of the chain.  We return to the
<CODE>input</CODE> chain, where we had just examined Rule2, so we now examine
Rule3, which doesn't match either.</P>

<P>So the packet path is:
<PRE>
                                v    __________________________
         `input'                |   /    `Test'                v
        ------------------------|--/    -----------------------|----
        | Rule1                 | /|    | Rule1                |   |
        |-----------------------|/-|    |----------------------|---|
        | Rule2                 /  |    | Rule2                |   |
        |--------------------------|    -----------------------v----
        | Rule3                 /--+___________________________/
        ------------------------|---
                                v
</PRE>
</P>

<P>See the section 
<A HREF="#organisation">How to Organise Your Firewall Rules</A> for ways to use user-defined chains effectively.</P>

<H3>Logging Packets</H3>

<P>This is a side effect that matching a rule can have; you can have the
matching packet logged using the `-l' flag.  You will usually not want
this for routine packets, but it is a useful feature if you want to
look for exceptional events.</P>

<P>The kernel logs this information looking like:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Packet log: input DENY eth0 PROTO=17 192.168.2.1:53 192.168.1.1:1025
  L=34 S=0x00 I=18 F=0x0000 T=254
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This log message is designed to be terse, and contain technical
information useful only to networking gurus, but it can be useful to
the rest of us.  It breaks down like so:</P>
<P>
<OL>
<LI> `input' is the chain which contained the rule which matched the
packet, causing the log message.
</LI>
<LI> `DENY' is what the rule said to do to the packet.  If this is
`-' then the rule didn't effect the packet at all (an accounting rule).
</LI>
<LI> `eth0' is the interface name.  Because this was the input
chain, it means that the packet came in `eth0'.
</LI>
<LI> `PROTO=17' means that the packet was protocol 17.  A list of
protocol numbers is given in `/etc/protocols'.  The most common are 1
(ICMP), 6 (TCP) and 17 (UDP).
</LI>
<LI> `192.168.2.1' means that the packet's source IP address was
192.168.2.1.
</LI>
<LI> `:53' means that the source port was port 53.  Looking in
`/etc/services' shows that this is the `domain' port (ie. this is
probably an DNS reply).  For UDP and TCP, this number is the source
port.  For ICMP, it's the ICMP type.  For others, it will be 65535.
</LI>
<LI> `192.168.1.1' is the destination IP address.
</LI>
<LI> `:1025' means that the destination port was 1025.  For UDP and
TCP, this number is the destination port.  For ICMP, it's the ICMP
code.  For others, it will be 65535.
</LI>
<LI> `L=34' means that packet was a total of 34 bytes long.
</LI>
<LI> `S=0x00' means the Type of Service field (divide by 4 to get
the Type of Service as used by ipchains).
</LI>
<LI> `I=18' is the IP ID.
</LI>
<LI> `F=0x0000' is the 16-bit fragment offset plus flags.  A value
starting with `0x4' or `0x5' means that the Don't Fragment bit is set.
`0x2' or `0x3' means the `More Fragments' bit is set; expect more
fragments after this.  The rest of the number is the offset of this
fragment, divided by 8.
</LI>
<LI> `T=254' is the Time To Live of the packet.  One is subtracted
from this value for every hop, and it usually starts at 15 or 255.
</LI>
<LI> `(#5)' there may be a final number in brackets on more recent
kernels (perhaps after 2.2.9).  This is the rule number which caused
the packet log.
</LI>
</OL>
</P>

<P>On standard Linux systems, this kernel output is captured by klogd
(the kernel logging daemon) which hands it to syslogd (the system
logging daemon).  The `/etc/syslog.conf' controls the behaviour of
syslogd, by specifying a destination for each `facility' (in our case,
the facility is "kernel") and `level' (for ipchains, the level used is
"info").</P>

<P>For example, my (Debian) /etc/syslog.conf contains two lines which
match `kern.info':</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kern.*                          -/var/log/kern.log
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>These mean that the messags are duplicated in `/var/log/kern.log' and
`/var/log/messages'.  For more details, see `man syslog.conf'.</P>

<H3>Manipulating the Type Of Service</H3>

<P>There are four seldom-used bits in the IP header, called the <B>Type of
Service</B> (TOS) bits.  They effect the way packets are treated; the four
bits are "Minimum Delay", "Maximum Throughput", "Maximum Reliability"
and "Minimum Cost".  Only one of these bits is allowed to be set.  Rob
van Nieuwkerk, the author of the TOS-mangling code, puts it as
follows:</P>
<P>
<BLOCKQUOTE>
Especially the "Minimum Delay" is important for me.  I switch it on
for "interactive" packets in my upstream (Linux) router.  I'm behind a
33k6 modem link.  Linux prioritizes packets in 3 queues.  This way I
get acceptable interactive performance while doing bulk downloads at
the same time.  (It could even be better if there wasn't such a big
queue in the serial driver, but latency is kept down 1.5 seconds now).
</BLOCKQUOTE>
</P>

<P>Note: obviously, you have no control over incoming packets; you can
only control the priority of packets leaving your box.  To negotiate
priorities with the other end, a protocol like RSVP (which I know
nothing about, so don't ask me) must be used.</P>

<P>The most common use is to set telnet &amp; ftp control connections to
"Minimum Delay" and FTP data to "Maximum Throughput".  This would be
done as follows:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A output -p tcp -d 0.0.0.0/0 telnet -t 0x01 0x10
ipchains -A output -p tcp -d 0.0.0.0/0 ftp -t 0x01 0x10
ipchains -A output -p tcp -s 0.0.0.0/0 ftp-data -t 0x01 0x08
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>The `-t' flag takes two extra parameters, both in hexadecimal.  These
allow complex twiddling of the TOS bits: the first mask is ANDed with
the packet's current TOS, and then the second mask is XORed with it.
If this is too confusing, just use the following table:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
TOS Name                Value           Typical Uses

Minimum Delay           0x01 0x10       ftp, telnet
Maximum Throughput      0x01 0x08       ftp-data
Maximum Reliability     0x01 0x04       snmp
Minimum Cost            0x01 0x02       nntp
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Andi Kleen goes on to point out the following (mildly edited for
posterity):
<BLOCKQUOTE>
Maybe it would be useful to add an reference to the txqueuelen
parameter of ifconfig to the discussion of TOS bits. The default
device queue length is tuned for ethernet cards, on modems it is too
long and makes the 3 band scheduler (which queues based on TOS) work
suboptimally. It is a good idea to set it to a value between 4-10 on
modem or single b channel ISDN links: on bundled devices a longer
queue is needed.  This is a 2.0 and 2.1 problem, but in 2.1 it is a
ifconfig flag (with recent nettools), while in 2.0 it requires source
patches in the device drivers to change.
</BLOCKQUOTE>
</P>
<P>So, to see maximal benifits of TOS manipulation for modem PPP links,
do `ifconfig $1 txqueuelen' in your /etc/ppp/ip-up script.  The number
to use depends on the modem speed and the amount of buffering in the
modem; here's Andi setting me straight again:</P>
<P>
<BLOCKQUOTE>
The best value for a given configuration needs experiment.  If the
queues are too short on a router then packets will get dropped.  Also
of course one gets benefits even without TOS rewriting, just that TOS
rewriting helps to give the benefits to non cooperating programs (but
all standard linux programs are cooperating).  
</BLOCKQUOTE>
</P>

<H3>Marking a Packet</H3>

<P>This allows complex and powerful interactions with Alexey Kuznetsov's
new Quality of Service implementation, as well as the mark-based
forwarding in later 2.1 series kernels.  More news as it comes to
hand.  This option is ignored altogether in the 2.0 kernel series.</P>

<H3><A NAME="chain-ops"></A> Operations on an Entire Chain</H3>

<P>A very useful feature of ipchains is the ability to group related
rules into chains.  You can call the chains whatever you want, as long
as the names don't clash with the built-in chains (<CODE>input</CODE>,
<CODE>output</CODE> and <CODE>forward</CODE>) or the targets (<CODE>MASQ</CODE>,
<CODE>REDIRECT</CODE>, <CODE>ACCEPT</CODE>, <CODE>DENY</CODE>, <CODE>REJECT</CODE> or <CODE>RETURN</CODE>).  I
suggest avoiding upper-case labels entirely, since I may use these for
future extensions.  The chain name can be up to 8 characters long.</P>

<H3>Creating a New Chain</H3>

<P>Let's create a new chain.  Because I am such an imaginative fellow,
I'll call it <CODE>test</CODE>.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -N test
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>It's that simple.  Now you can put rules in it as detailed above.</P>

<H3>Deleting a Chain</H3>

<P>Deleting a chain is simple as well.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -X test
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Why `-X'?  Well, all the good letters were taken.</P>

<P>There are a couple of restrictions to deleting chains: they must be
empty (see 
<A HREF="#flushing">Flushing a Chain</A> below) and they
must not be the target of any rule.  You can't delete any of the three
built-in chains.</P>

<H3><A NAME="flushing"></A> Flushing a Chain</H3>

<P>There is a simple way of emptying all rules out of a chain, using the
`-F' command.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        # ipchains -F forward
        # 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>If you don't specify a chain, then <EM>all</EM> chains will be flushed.</P>

<H3>Listing a Chain</H3>

<P>You can list all the rules in a chain by using the `-L' command.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -L input
Chain input (refcnt = 1): (policy ACCEPT)
target     prot opt    source                destination           ports
ACCEPT     icmp -----  anywhere              anywhere              any
# ipchains -L test
Chain test (refcnt = 0):
target     prot opt    source                destination           ports
DENY       icmp -----  localnet/24           anywhere              any
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>The `refcnt' listed for <CODE>test</CODE> is the number of rules which have
<CODE>test</CODE> as their target.  This must be zero (and the chain be empty)
before this chain can be deleted.</P>

<P>If the chain name is omitted, all chains are listed, even empty ones.</P>

<P>There are three options which can accompany `-L'.  The `-n' (numeric)
option is very useful as it prevents <CODE>ipchains</CODE> from trying to
lookup the IP addresses, which (if you are using DNS like most people)
will cause large delays if your DNS is not set up properly, or you
have filtered out DNS requests.  It also causes ports to be printed
out as numbers rather than names.</P>

<P>The `-v' options shows you all the details of the rules, such as the
the packet and byte counters, the TOS masks, the interface, and the
packet mark.  Otherwise these values are omitted.  For example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -v -L input
Chain input (refcnt = 1): (policy ACCEPT)
 pkts bytes target     prot opt   tosa tosx  ifname    mark        source                destination           ports
   10   840 ACCEPT     icmp ----- 0xFF 0x00  lo                    anywhere              anywhere              any
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Note that the packet and byte counters are printed out using the
suffixes `K', `M' or `G' for 1000, 1,000,000 and 1,000,000,000
respectively.  Using the `-x' (expand numbers) flag as well prints the
full numbers, no matter how large they are.</P>

<H3>Resetting (Zeroing) Counters</H3>

<P>It is useful to be able to reset the counters.  This can be done with
the `-Z' (zero counters) option.  For example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -v -L input
Chain input (refcnt = 1): (policy ACCEPT)
 pkts bytes target     prot opt   tosa tosx  ifname    mark        source                destination           ports
   10   840 ACCEPT     icmp ----- 0xFF 0x00  lo                    anywhere              anywhere              any
# ipchains -Z input
# ipchains -v -L input
Chain input (refcnt = 1): (policy ACCEPT)
 pkts bytes target     prot opt   tosa tosx  ifname    mark        source                destination           ports
    0     0 ACCEPT     icmp ----- 0xFF 0x00  lo                    anywhere              anywhere              any
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>The problem with this approach is that sometimes you need to know the
counter values immediately before they are reset.  In the above
example, some packets could pass through between the `-L' and `-Z'
commands.  For this reason, you can use the `-L' and `-Z'
<EM>together</EM>, to reset the counters while reading them.
Unfortunately, if you do this, you can't operate on a single chain:
you have to list and zero all the chains at once.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -L -v -Z
Chain input (policy ACCEPT):
 pkts bytes target     prot opt   tosa tosx  ifname    mark        source                destination           ports
   10   840 ACCEPT     icmp ----- 0xFF 0x00  lo                    anywhere              anywhere              any

Chain forward (refcnt = 1): (policy ACCEPT)
Chain output (refcnt = 1): (policy ACCEPT)
Chain test (refcnt = 0):
    0     0 DENY       icmp ----- 0xFF 0x00  ppp0                  localnet/24           anywhere              any
# ipchains -L -v
Chain input (policy ACCEPT):
 pkts bytes target     prot opt   tosa tosx  ifname    mark        source                destination           ports
   10   840 ACCEPT     icmp ----- 0xFF 0x00  lo                    anywhere              anywhere              any

Chain forward (refcnt = 1): (policy ACCEPT)
Chain output (refcnt = 1): (policy ACCEPT)
Chain test (refcnt = 0):
    0     0 DENY       icmp ----- 0xFF 0x00  ppp0                  localnet/24           anywhere              any
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3><A NAME="policy"></A> Setting Policy</H3>

<P>We glossed over what happens when a packet hits the end of a built-in
chain when we discussed how a packet walks through chains in 
<A HREF="#target-spec">Specifying a Target</A> above.  In this case,
the <B>policy</B> of the chain determines the fate of the packet.  Only
built-in chains (<CODE>input</CODE>, <CODE>output</CODE> and <CODE>forward</CODE>) have policies,
because if a packet falls off the end of a user-defined chain,
traversal resumes at the previous chain.</P>

<P>The policy can be any of the first four special targets: <CODE>ACCEPT</CODE>,
<CODE>DENY</CODE>, <CODE>REJECT</CODE> or <CODE>MASQ</CODE>.  <CODE>MASQ</CODE> is only valid for the
`forward' chain.</P>

<P>It is also important to note that a <CODE>RETURN</CODE> target in a rule in
one of the built-in chains is useful to explicitly target the chain
policy when a packet matches a rule.</P>

<H3>Operations on Masquerading</H3>

<P>There are several parameters you can tweak for IP Masquerading.  They
are bundled with <CODE>ipchains</CODE> because it's not worth writing a
separate tool for them (although this will change).</P>

<P>The IP Masquerading command is `-M', and it can be combined with `-L'
to list currently masqueraded connections, or `-S' to set the
masquerading parameters.</P>

<P>The `-L' command can be accompanied by `-n' (show numbers instead of
hostnames and port names) or `-v' (show deltas in sequence numbers for
masqueraded connection, just in case you care).</P>

<P>The `-S' command should be followed by three timeout values, each in
seconds: for TCP sessions, for TCP sessions after a FIN packet, and
for UDP packets.  If you don't want to change one of these values,
simply give a value of `0'.</P>

<P>The default values are listed in `/usr/src/linux/include/net/ip_masq.h',
currently 15 minutes, 2 minutes and 5 minutes respectively.</P>

<P>The most common value to change is the first one, for FTP (see 
<A HREF="#ftp">FTP Nightmares</A> below).</P>

<P>Note the problems with setting timeouts listed in 
<A HREF="#no-timeout">I can't set masquerading timeouts!</A>.</P>

<H3>Checking a Packet</H3>

<P>Sometimes you want to see what happens when a certain packet enters
your machine, such as for debugging your firewall chains.
<CODE>ipchains</CODE> has the `-C' command to allow this, using the exact same
routines that the kernel uses to diagnose real packets.</P>

<P>You specify which chain to test the packet on by following the `-C'
argument with its name.  Whereas the kernel always starts traversing
on the <CODE>input</CODE>, <CODE>output</CODE> or <CODE>forward</CODE> chains, you are allowed
to begin traversing on any chain for testing purposes.</P>

<P>The details of the `packet' are specified using the same syntax used
to specify firewall rules.  In particular, a protocol (`-p'), source
address (`-s'), destination address (`-d') and interface (`-i') are
compulsory.  If the protocol is TCP or UDP, then a single source and a
single destination port must be specified, and a ICMP type and code
must be specified for the ICMP protocol (unless the `-f' flag is
specified to indicate a fragment rule, in which case these options are
illegal).</P>

<P>If the protocol is TCP (and the `-f' flag is not specified), the `-y'
flag may be specified, to indicate that the test packet should have
the SYN bit set.</P>

<P>Here is an example of testing a TCP SYN packet from 192.168.1.1 port
60000 to 192.168.1.2 port www, coming in the eth0 interface, entering
the `input' chain.  (This is a classic incoming WWW connection
initiation):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -C input -p tcp -y -i eth0 -s 192.168.1.1 60000 -d 192.168.1.2 www
packet accepted
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Multiple Rules at Once and Watching What Happens</H3>

<P>Sometimes a single command line can result in multiple rules being
effected.  This is done in two ways.  Firstly, if you specify a
hostname which resolves (using DNS) to multiple IP addresses,
<CODE>ipchains</CODE> will act as if you had typed multiple commands with each
combination of addresses.</P>

<P>So if the hostname `www.foo.com' resolves to three IP addresses, and
the hostname `www.bar.com' resolves to two IP addresses, then the
command `ipchains -A input -j reject -s www.bar.com -d www.foo.com'
would append six rules to the <CODE>input</CODE> chain.</P>

<P>The other way to have <CODE>ipchains</CODE> perform multiple actions is to use
the bidirectional flag (`-b').  This flag makes <CODE>ipchains</CODE> behave
as if you had typed the command twice, the second time with the `-s'
and `-d' arguments reversed.  So, to avoid forwarding either to or
from 192.168.1.1, you could do the following:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -b -A forward -j reject -s 192.168.1.1
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Personally, I don't like the `-b' option much; if you want
convenience, see 
<A HREF="#ipchains-save">Using ipchains-save</A>
below.</P>

<P>The -b option can be used with the insert (`-I'), delete (`-D') (but
not the variation which takes a rule number), append (`-A') and check
(`-C') commands.</P>

<P>Another useful flag is `-v' (verbose) which prints out exactly what
<CODE>ipchains</CODE> is doing with your commands.  This is useful if you are
dealing with commands that may effect multiple rules.  For example,
here we check the behaviour of fragments between 192.168.1.1 and
192.168.1.2.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -v -b -C input -p tcp -f -s 192.168.1.1 -d 192.168.1.2 -i lo
  tcp opt   ---f- tos 0xFF 0x00  via lo    192.168.1.1  -> 192.168.1.2    * ->   *
packet accepted
  tcp opt   ---f- tos 0xFF 0x00  via lo    192.168.1.2  -> 192.168.1.1    * ->   *
packet accepted
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss4.2">4.2 Useful Examples</A>
</H2>

<P>I have a dialup PPP connection (<CODE>-i ppp0</CODE>).  I grab news (<CODE>-p
TCP -s news.virtual.net.au nntp</CODE>) and mail (<CODE>-p TCP -s
mail.virtual.net.au pop-3</CODE>) every time I dial up.  I use Debian's FTP
method to update my machine regularly (<CODE>-p TCP -y -s
ftp.debian.org.au ftp-data</CODE>).  I surf the web through my ISP's proxy
while this is going on (<CODE>-p TCP -d proxy.virtual.net.au 8080</CODE>), but
hate the ads from doubleclick.net on the Dilbert Archive (<CODE>-p TCP -y
-d 199.95.207.0/24</CODE> and <CODE>-p TCP -y -d 199.95.208.0/24</CODE>).</P>

<P>I don't mind people trying to ftp to my machine while I'm online
(<CODE>-p TCP -d $LOCALIP ftp</CODE>), but don't want anyone outside
pretending to have an IP address of my internal network (<CODE>-s
192.168.1.0/24</CODE>).  This is commonly called IP spoofing, and there
is a better way to protect yourself from it in the 2.1.x kernels and
above: see 
<A HREF="#antispoof">How do I set up IP spoof protection?</A>.</P>

<P>This setup is fairly simple, because there are currently no other
boxes on my internal network.</P>

<P>I don't want any local process (ie. Netscape, lynx etc.) to connect
to doubleclick.net:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A output -d 199.95.207.0/24 -j REJECT
# ipchains -A output -d 199.95.208.0/24 -j REJECT
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Now I want to set priorities on various outgoing packets (there isn't
much point in doing it on incoming packets).  Since I have a fair
number of these rules, it makes sense to put them all in a single
chain, called <CODE>ppp-out</CODE>.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -N ppp-out
# ipchains -A output -i ppp0 -j ppp-out
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Minimum delay for web traffic &amp; telnet.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A ppp-out -p TCP -d proxy.virtual.net.au 8080 -t 0x01 0x10
# ipchains -A ppp-out -p TCP -d 0.0.0.0/0 telnet -t 0x01 0x10
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Low cost for ftp data, nntp, pop-3:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A ppp-out -p TCP -d 0.0.0.0/0 ftp-data -t 0x01 0x02
# ipchains -A ppp-out -p TCP -d 0.0.0.0/0 nntp -t 0x01 0x02
# ipchains -A ppp-out -p TCP -d 0.0.0.0/0 pop-3 -t 0x01 0x02
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>There are a few restrictions on packets coming in the ppp0 interface:
let's create a chain called `ppp-in':</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -N ppp-in
# ipchains -A input -i ppp0 -j ppp-in
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Now, no packets coming in <CODE>ppp0</CODE> should be claiming a source
address of 192.168.1.*, so we log and deny them:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A ppp-in -s 192.168.1.0/24 -l -j DENY
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>I allow UDP packets in for DNS (I run a caching nameserver which
forwards all requests to 203.29.16.1, so I expect DNS replies from
them only), incoming ftp, and return ftp-data only (which should only
be going to a port above 1023, and not the X11 ports around 6000).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A ppp-in -p UDP -s 203.29.16.1 -d $LOCALIP dns -j ACCEPT
# ipchains -A ppp-in -p TCP -s 0.0.0.0/0 ftp-data -d $LOCALIP 1024:5999 -j ACCEPT
# ipchains -A ppp-in -p TCP -s 0.0.0.0/0 ftp-data -d $LOCALIP 6010: -j ACCEPT
# ipchains -A ppp-in -p TCP -d $LOCALIP ftp -j ACCEPT
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>I allow TCP reply packets back in</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A ppp-in -p TCP ! -y -j ACCEPT
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Finally, local-to-local packets are OK:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -i lo -j ACCEPT
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Now, my default policy on the <CODE>input</CODE> chain is <CODE>DENY</CODE>, so
everything else gets dropped:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -P input DENY
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>NOTE: I wouldn't set up my chains in this order, as packets might get
through while I'm setting up.  Safest is usually to set the policy to
DENY first, then insert the rules.  Of course, if your rules require
DNS lookups to resolve hostnames, you could be in trouble.</P>

<H3><A NAME="ipchains-save"></A> Using ipchains-save</H3>

<P>Setting up firewall chains just the way you want them, and then trying
to remember the commands you used so you can do them next time is a
pain.</P>

<P>So, <CODE>ipchains-save</CODE> is a script which reads your current chains
setup and saves it to a file.  For the moment I'll keep you in
suspense with regards to what <CODE>ipchains-restore</CODE> does.</P>

<P><CODE>ipchains-save</CODE> can save a single chain, or all chains (if no chain
name is specified).  The only option currently permitted is `-v' which
prints the rules (to stderr) as they are saved.  The policy of the
chain is also saved for <CODE>input</CODE>, <CODE>output</CODE> and <CODE>forward</CODE>
chains.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains-save > my_firewall
Saving `input'.
Saving `output'.
Saving `forward'.
Saving `ppp-in'.
Saving `ppp-out'.
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Using ipchains-restore</H3>

<P><CODE>ipchains-restore</CODE> restores chains as saved with
<CODE>ipchains-save</CODE>.  It can take two options: `-v' which describes
each rule as it is added, and `-f' which forces flushing of
user-defined chains if they exist, as described below.</P>

<P>If a user-defined chain is found in the input, <CODE>ipchains-restore</CODE>
checks if that chain already exists.  If it does, then you will be
prompted whether the chains should be flushed (cleared of all rules)
or whether restoring this chain should be skipped.  If you specified
`-f' on the command line, you will not be prompted; the chain will be
flushed.</P>

<P>For example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains-restore &lt; my_firewall
Restoring `input'.
Restoring `output'.
Restoring `forward'.
Restoring `ppp-in'.
Chain `ppp-in' already exists. Skip or flush? [S/f]? s
Skipping `ppp-in'.
Restoring `ppp-out'.
Chain `ppp-out' already exists. Skip or flush? [S/f]? f
Flushing `ppp-out'.
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="s5">5. Miscellaneous.</A></H2>

<P>This section contains all the information and FAQs that I couldn't fit
inside the structure above.</P>

<H2><A NAME="organisation"></A> <A NAME="ss5.1">5.1 How to Organize Your Firewall Rules</A>
</H2>

<P>This question requires some thought.  You can try to organize them to
optimize speed (minimize the number of rule-checks for the most common
packets) or to increase manageability.</P>

<P>If you have an intermittent link, say a PPP link, you might want to
set the first rule in the input chain to be set to `-i ppp0 -j DENY' at
boot time, then have something like this in your <CODE>ip-up</CODE> script:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Re-create the `ppp-in' chain.
ipchains-restore -f &lt; ppp-in.firewall

# Replace DENY rule with jump to ppp-handling chain.
ipchains -R input 1 -i ppp0 -j ppp-in
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Your <CODE>ip-down</CODE> script would look like:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -R input 1 -i ppp0 -j DENY
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss5.2">5.2 What Not To Filter Out</A>
</H2>

<P>There are some things you should be aware of before you start
filtering out everything you don't want.</P>

<H3><A NAME="ICMP"></A> ICMP packets</H3>

<P>ICMP packets are used (among other things) to indicate failure for
other protocols (such as TCP and UDP).  `destination-unreachable'
packets in particular.  Blocking these packets means that you will
never get `Host unreachable' or `No route to host' errors; any
connections will just wait for a reply that never comes.  This is
irritating, but rarely fatal.</P>

<P>A worse problem is the role of ICMP packets in MTU discovery.  All
good TCP implementations (Linux included) use MTU discovery to try to
figure out what the largest packet that can get to a destination
without being fragmented (fragmentation slows performance, especially
when occasional fragments are lost).  MTU discovery works by sending
packets with the "Don't Fragment" bit set, and then sending smaller
packets if it gets an ICMP packet indicating "Fragmentation needed but
DF set" (`fragmentation-needed').  This is a type of
`destination-unreachable' packet, and if it is never received, the
local host will not reduce MTU, and performance will be abysmal or
non-existent.</P>

<P>Note that it is common to block all ICMP redirect messages (type 5);
these can be used to manipulate routing (although good IP stacks have
safeguards), and so are often seen as slightly risky.</P>

<H3>TCP Connections to DNS (nameservers)</H3>

<P>If you're trying to block outgoing TCP connections, remember that DNS
doesn't always use UDP; if the reply from the server exceeds 512
bytes, the client uses a TCP connection (still going to port number
53) to get the data.</P>

<P>This can be a trap because DNS will `mostly work' if you disallow such
TCP transfers; you may experience strange long delays and other
occasional DNS problems if you do.</P>

<P>If your DNS queries are always directed at the same external source
(either directly by using the <CODE>nameserver</CODE> line in
<CODE>/etc/resolv.conf</CODE> or by using a caching nameserver in forward
mode), then you need only allow TCP connections to port <CODE>domain</CODE>
on that nameserver from the local <CODE>domain</CODE> port (if using a caching
nameserver) or from a high port (&gt; 1023) if using
<CODE>/etc/resolv.conf</CODE>.</P>

<H3><A NAME="ftp"></A> FTP Nightmares</H3>

<P>The classic packet filtering problem is FTP.  FTP has two <B>modes</B>;
the traditional one is called <B>active mode</B> and the more recent one
is called <B>passive mode</B>.  Web browsers usually default to passive
mode, but command-line FTP programs usually default to active mode.</P>

<P>In active mode, when the remote end wants to send a file (or even the
results of an <CODE>ls</CODE> or <CODE>dir</CODE> command) it tries to open a TCP
connection to the local machine.  This means you can't filter out
these TCP connections without breaking active FTP.</P>

<P>If you have the option of using passive mode, then fine; passive mode
makes data connections from client to server, even for incoming data.
Otherwise, it is recommended that you only allow TCP connections to
ports above 1024 and not between 6000 and 6010 (6000 is used for
X-Windows).</P>

<H2><A NAME="ss5.3">5.3 Filtering out Ping of Death</A>
</H2>

<P>Linux boxes are now immune to the famous <B>Ping of Death</B>, which
involves sending an illegally-large ICMP packet which overflows
buffers in the TCP stack on the receiver and causes havoc.</P>

<P>If you are protecting boxes which might be vulnerable, you could simply
block ICMP fragments.  Normal ICMP packets aren't large enough to
require fragmentation, so you won't break anything except big pings.
I have heard (unconfirmed) reports that some systems required only the
last fragment of an oversize ICMP packet to corrupt them, so blocking
only the first fragment is not recommended.</P>

<P>While the exploit programs I have seen all use ICMP, there is no
reasons that TCP or UDP fragments (or an unknown protocol) could not
be used for this attack, so blocking ICMP fragments is only a
temporary solution.</P>

<H2><A NAME="ss5.4">5.4 Filtering out Teardrop and Bonk</A>
</H2>

<P>Teardrop and Bonk are two attacks (mainly against Microsoft Windows NT
machines) which rely on overlapping fragments.  Having your Linux
router do defragmentation, or disallowing all fragments to your
vulnerable machines are the other options.</P>

<H2><A NAME="ss5.5">5.5 Filtering out Fragment Bombs</A>
</H2>

<P>Some less-reliable TCP stacks are said to have problems dealing with
large numbers of fragments of packets when they don't receive all the
fragments.  Linux does not have this problem.  You can filter out
fragments (which might break legitimate uses) or compile your kernel
with `IP: always defragment' set to `Y' (only if your Linux box is the
only possible route for these packets).</P>

<H2><A NAME="ss5.6">5.6 Changing Firewall Rules</A>
</H2>

<P>There are some timing issues involved in altering firewall rules.  If
you are not careful, you can let packets through while you are
half-way through your changes.  A simplistic approach is to do the
following:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -I input 1 -j DENY
# ipchains -I output 1 -j DENY
# ipchains -I forward 1 -j DENY

... make changes ...

# ipchains -D input 1
# ipchains -D output 1
# ipchains -D forward 1
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This drops all packets for the duration of the changes.</P>

<P>If your changes are restricted to a single chain, you might want to
create a new chain with the new rules, and then replace (`-R') the
rule that pointed to the old chain with one that points to the new
chain: then you can delete the old chain.  This replacement will occur
atomically.</P>

<H2><A NAME="antispoof"></A> <A NAME="ss5.7">5.7 How Do I Set Up IP Spoof Protection?</A>
</H2>

<P>IP spoofing is a technique where a host sends out packets which claim
to be from another host.  Since packet filtering makes decisions based
on this source address, IP spoofing is uses to fool packet filters.
It is also used to hide the identity of attackers using SYN attacks,
Teardrop, Ping of Death and the like (don't worry if you don't know
what they are).</P>

<P>The best way to protect from IP spoofing is called Source Address
Verification, and it is done by the routing code, and not firewalling
at all.  Look for a file called
<CODE>/proc/sys/net/ipv4/conf/all/rp_filter</CODE>.  If this exists, then
turning on Source Address Verification at every boot is the right
solution for you.  To do that, insert the following lines somewhere in
your init scripts, before any network interfaces are initialized:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# This is the best method: turn on Source Address Verification and get
# spoof protection on all current and future interfaces.
if [ -e /proc/sys/net/ipv4/conf/all/rp_filter ]; then
  echo -n "Setting up IP spoofing protection..."
  for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
      echo 1 > $f
  done
  echo "done."
else
  echo PROBLEMS SETTING UP IP SPOOFING PROTECTION.  BE WORRIED.
  echo "CONTROL-D will exit from this shell and continue system startup."
  echo
  # Start a single user shell on the console
  /sbin/sulogin $CONSOLE
fi
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>If you cannot do this, you can manually insert rules to protect every
interface.  This requires knowledge of each interface.  The 2.1
kernels automatically reject packets claiming to come from the 127.*
addresses (reserved for the local loopback interface, <CODE>lo</CODE>).  </P>

<P>For example, say we have three interfaces, <CODE>eth0</CODE>, <CODE>eth1</CODE> and
<CODE>ppp0</CODE>.  We can use <CODE>ifconfig</CODE> to tell us the address and
netmask of the interfaces.  Say <CODE>eth0</CODE> was attached to a network
192.168.1.0 with netmask 255.255.255.0, <CODE>eth1</CODE> was attached to a
network 10.0.0.0 with netmask 255.0.0.0, and <CODE>ppp0</CODE> connected to
the Internet (where any address except the reserved private IP
addresses are allowed), we would insert the following rules:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -i eth0 -s ! 192.168.1.0/255.255.255.0 -j DENY
# ipchains -A input -i ! eth0 -s 192.168.1.0/255.255.255.0 -j DENY
# ipchains -A input -i eth1 -s ! 10.0.0.0/255.0.0.0 -j DENY
# ipchains -A input -i ! eth1 -s 10.0.0.0/255.0.0.0 -j DENY
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>This approach is not as good as the Source Address Verification
approach, because if your network changes, you have to change your
firewalling rules to keep up.</P>

<P>If you are running a 2.0 series kernel, you might want to protect the
loopback interface as well, using a rule like this:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -i ! lo -s 127.0.0.0/255.0.0.0 -j DENY
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.8">5.8 Advanced Projects</A>
</H2>

<P>There is a userspace library I have written which is included with the
source distribution called `libfw'.  It uses the ability of IP Chains
1.3 and above to copy a packet to userspace (using the
IP_FIREWALL_NETLINK config option).</P>

<P>The mark value can be used to specify the Quality of Service
parameters for packets, or to specify how packets should be
port-forwarded.  I've never used either, but if you want to write
about it, please contact me.</P>

<P>Things such as <B>stateful inspection</B> (I prefer the term
dynamic firewalling) can be implemented in userspace using this
library.  Other nifty ideas include controlling packets on a per-user
basis by doing a lookup in a userspace daemon.  This should be pretty
easy.</P>

<H3>SPF: Stateful Packet Filtering</H3>

<P>
<A HREF="ftp://ftp.interlinx.bc.ca/pub/spf">ftp://ftp.interlinx.bc.ca/pub/spf</A> is the site of Brian
Murrell's SPF project, which does connection tracking in userspace.
It adds significant security for low-bandwidth sites.</P>

<P>There's little documentation at present, but here's a post to the
mailing list in which Brian answered some questions:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>

> I believe it does exactly what I want: Installing a temporary
> "backward"-rule to let packets in as a response to an
> outgoing request.

Yup, that is exactly what it does.  The more protocols it
understands, the more "backward" rules it gets right.  Right
now it has support for (from memory, please excuse any errors
or omissions) FTP (both active and passive, in and out), some
RealAudio, traceroute, ICMP and basic ICQ (inbound from the ICQ
servers, and direct TCP connections, but alas the secondary
direct TCP connections for things like file transfer, etc. are
not there yet)

> Is it a replacement for ipchains or a supplement?

It is a supplement.  Think of ipchains as the engine to allow
and prevent packets from travelling across a Linux box.  SPF is
the driver, constantly monitoring traffic and telling ipchains
how to change it's policies to reflect the changes in traffic
patterns.
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Michael Hasenstein's ftp-data hack</H3>

<P> Michael Hasenstein of SuSE has written a kernel patch which adds
ftp connection tracking to ipchains.  It can currently be found at
<A HREF="http://www.suse.de/~mha/patch.ftp-data-2.gz">http://www.suse.de/~mha/patch.ftp-data-2.gz</A></P>

<H2><A NAME="ss5.9">5.9 Future Enhancements</A>
</H2>

<P>Firewalling and NAT have being redesigned for 2.4.  Plans and
discussions are available on the netfilter list (see 
<A HREF="http://lists.samba.org">http://lists.samba.org</A>).  These
enhancements should clear up many outstanding usability issues
(really, firewalling and masquerading shouldn't be <EM>this
hard</EM>), and allow growth for far more flexible firewalling.</P>

<H2><A NAME="s6">6. Common Problems</A></H2>


<H2><A NAME="ss6.1">6.1 ipchains -L Freezes!</A>
</H2>

<P>You're probably blocking DNS lookups; it will eventually time out.
Try using the `-n' (numeric) flag to ipchains, which suppresses the
lookup of names.</P>


<H2><A NAME="ss6.2">6.2 Inverse doesn't work!</A>
</H2>

<P>You must put the `!' option by itself, with spaces either side.  A
classic mistake (warned about in 1.3.10) is:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -i !eth0 -j DENY
#
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>There will never be an interface called `!eth0', but ipchains doesn't
know that.</P>


<H2><A NAME="ss6.3">6.3 Masquerading/Forwarding Doesn't Work!</A>
</H2>

<P>Make sure that packet forwarding is enabled (in recent kernels it is
disabled by default, meaning that packets never even try to traverse
the `forward' chain).  You can override this (as root) by typing</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# echo 1 > /proc/sys/net/ipv4/ip_forward
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>If this works for you, you can put this somewhere in your bootup
scripts so it is enabled every time; you'll want to set up your
firewalling before this command runs though, otherwise there's an
opportunity for packets to slip through.</P>


<H2><A NAME="ss6.4">6.4 -j REDIR doesn't work!</A>
</H2>

<P>You must allow forwarding packets (see above) for redirect to work;
otherwise the routing code drops the packet.  So if you are just using
redirect, and don't have any forwarding at all, you should be aware of
that.</P>

<P>Note that REDIR (being in the input chain) doesn't effect connections
from a local process.</P>

<H2><A NAME="ss6.5">6.5 Wildcard Interfaces Don't Work!</A>
</H2>

<P>There was a bug in versions 2.1.102 and 2.1.103 of the kernel (and
some old patches I produced) which made ipchains commands which
specified a wildcard interface (such as <CODE>-i ppp+</CODE>) fail.</P>

<P>This is fixed in recent kernels, and in the 2.0.34 patch on the web
site.  You can also fix it by hand in the kernel source by changing
line 63 or so in include/linux/ip_fw.h:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#define IP_FW_F_MASK    0x002F  /* All possible flag bits mask   */
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>This should read ``0x003F''.  Fix this and recompile the kernel.</P>

<H2><A NAME="ss6.6">6.6 TOS Doesn't Work!</A>
</H2>

<P>This was my mistake: setting the Type of Service field did not
actually set the Type of Service in kernel versions 2.1.102 through
2.1.111.  This problem was fixed in 2.1.112.</P>

<H2><A NAME="ss6.7">6.7 ipautofw and ipportfw Don't Work!</A>
</H2>

<P>For 2.0.x, this is true; I haven't time to create and maintain a jumbo
patch for ipchains and ipautofw/ipportfw.</P>

<P>For 2.1.x, download Juan Ciarlante's ipmasqadm from 
<PRE>
&lt;url url="http://juanjox.linuxhq.com/"
        name="http://juanjox.linuxhq.com/">
</PRE>

and use it exactly as you would have used <CODE>ipautofw</CODE> or
<CODE>ipportfw</CODE>, except instead of <CODE>ipportfw</CODE> you type <CODE>ipmasqadm
portfw</CODE>, and instead of <CODE>ipautofw</CODE> you type <CODE>ipmasqadm autofw</CODE>.</P>

<H2><A NAME="ss6.8">6.8 xosview is Broken!</A>
</H2>

<P>Upgrade to version 1.6.0 or above, which doesn't require any firewall
rules at all for 2.1.x kernels.  This seems to have broken again in
the 1.6.1 release; please bug the author (it's not my fault!).</P>

<H2><A NAME="ss6.9">6.9 Segmentation Fault With `-j REDIRECT'!</A>
</H2>

<P>This was a bug in ipchains version 1.3.3.  Please upgrade.</P>


<H2><A NAME="no-timeout"></A> <A NAME="ss6.10">6.10 I Can't Set Masquerading Timeouts!</A>
</H2>

<P>True (for 2.1.x kernels) up to 2.1.123.  In 2.1.124, trying to set the
masquerading timeouts causes a kernel lockup (change <CODE>return</CODE>
to <CODE>ret =</CODE> on line 1328 of net/ipv4/ip_fw.c).  In 2.1.125, it
works fine.</P>

<H2><A NAME="ss6.11">6.11 I Want to Firewall IPX!</A>
</H2>

<P>So do a number of others, it seems.  My code only covers IP,
unfortunately.  On the good side, all the hooks are there to firewall
IPX!  You just need to write the code; I will happily help where
possible.</P>

<H2><A NAME="s7">7. A Serious Example.</A></H2>

<P>This example was extracted from Michael Neuling and my March 1999
LinuxWorld Tutorial; this is not the only way to solve the given
problem, but it is probably the simplest.  I hope you will find it
informative.</P>


<H2><A NAME="ss7.1">7.1 The Arrangement</A>
</H2>

<P>
<UL>
<LI> Masqueraded internal network (various operating systems), which
we call "GOOD".
</LI>
<LI> Exposed servers in a separate network (called "DMZ" for
Demilitarized Zone).
</LI>
<LI> PPP Connection to the Internet (called "BAD").</LI>
</UL>
</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
   External Network (BAD)
           |
           |
       ppp0|
    ---------------
    | 192.84.219.1|             Server Network (DMZ)
    |             |eth0
    |             |----------------------------------------------
    |             |192.84.219.250 |             |              |
    |             |               |             |              |
    |192.168.1.250|               |             |              |
    ---------------          --------       -------        -------
           | eth1            | SMTP |       | DNS |        | WWW |
           |                 --------       -------        -------
           |              192.84.219.128  192.84.219.129  192.84.218.130
           |
   Internal Network (GOOD)
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss7.2">7.2 Goals</A>
</H2>


<P>Packet Filter box:
<DL>
<DT><B> PING any network</B><DD>
<P>This is really useful to tell if a machine is down.</P>

<DT><B> TRACEROUTE any network </B><DD>
<P>Once again, useful for diagnosis.</P>

<DT><B> Access DNS </B><DD>
<P>To make ping and DNS more useful.</P>

</DL>
</P>

<P>Within the DMZ: </P>

<P>Mail server
<UL>
<LI> SMTP to external</LI>
<LI> Accept SMTP from internal and external</LI>
<LI> Accept POP-3 from internal</LI>
</UL>
</P>
<P>Name Server 
<UL>
<LI> Send DNS to external</LI>
<LI> Accept DNS from internal, external and packet filter box</LI>
</UL>
</P>

<P>Web server 
<UL>
<LI> Accept HTTP from internal and external</LI>
<LI> Rsync access from internal</LI>
</UL>
</P>

<P> Internal:
<DL>
<DT><B>Allow WWW, ftp, traceroute, ssh to external</B><DD>
<P>These are fairly standard things to allow: some places start by
allowing the internal machines to do just about everything, but here
we're being restrictive.</P>

<DT><B> Allow SMTP to Mail server </B><DD>
<P>Obviously, we want them to be able to send mail out. </P>

<DT><B> Allow POP-3 to Mail server </B><DD>
<P>This is how they read their mail.</P>

<DT><B> Allow DNS to Name server </B><DD>
<P>They need to be able to look up external names for WWW, ftp,
traceroute and ssh.</P>

<DT><B> Allow rsync to Web server </B><DD>
<P>This is how they synchronize the external web server with the
internal one.</P>

<DT><B> Allow WWW to Web server </B><DD>
<P>Obviously, they should be able to connect to our external web server.</P>

<DT><B> Allow ping to packet filter box </B><DD>
<P>This is a courteous thing to allow: it means that they can test if
the firewall box is down (so we don't get blamed if an external site
is broken).</P>

</DL>
</P>

<H2><A NAME="ss7.3">7.3 Before Packet Filtering</A>
</H2>

<P>
<UL>
<LI> Anti-spoofing

<P>Since we don't have any asymmetric routing, we can simply turn on
anti-spoofing for all interfaces.</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
# for f in /proc/sys/net/ipv4/conf/*/rp_filter; do echo 1 > $f; done
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

</LI>
<LI> Set filtering rules to DENY all:

<P>We still allow local loopback traffic, but deny anything else.</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
# ipchains -A input -i ! lo -j DENY
# ipchains -A output -i ! lo -j DENY
# ipchains -A forward -j DENY
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>

</LI>
<LI> Set Up Interfaces

<P>This is usually done in the boot scripts.  Make sure the above steps
are done before the interfaces are configured, to prevent packet
leakage before the rules are set up.</P>

</LI>
<LI> Insert per-protocol masquerading modules.
<P>We need to insert the masquerading module for FTP, so that active and
passive FTP `just work' from the internal network.</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
# insmod ip_masq_ftp
# 
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
</UL>
</P>

<H2><A NAME="ss7.4">7.4 Packet Filtering for Through Packets</A>
</H2>

<P>With masquerading, it's best to filter in the forward chain.</P>

<P>Split forward chain into various user chains depending on source/dest
interfaces; this breaks the problem down into managable chunks.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -N good-dmz
ipchains -N bad-dmz
ipchains -N good-bad
ipchains -N dmz-good
ipchains -N dmz-bad
ipchains -N bad-good
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>ACCEPTing standard error ICMPs is a common thing to do, so we create a
chain for it.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -N icmp-acc
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Set Up Jumps From forward Chain</H3>

<P>Unfortunately, we only know (in the forward chain) the outgoing
interface.  Thus, to figure out what interface the packet came in on,
we use the source address (the anti-spoofing prevents address faking).</P>

<P>Note that we log anything which doesn't match any of these (obviously,
this should never happen).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A forward -s 192.168.1.0/24 -i eth0 -j good-dmz
ipchains -A forward -s 192.168.1.0/24 -i ppp0 -j good-bad
ipchains -A forward -s 192.84.219.0/24 -i ppp0 -j dmz-bad
ipchains -A forward -s 192.84.219.0/24 -i eth1 -j dmz-good
ipchains -A forward -i eth0 -j bad-dmz
ipchains -A forward -i eth1 -j bad-good
ipchains -A forward -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Define the icmp-acc Chain</H3>

<P>Packets which are one of the error ICMPs get ACCEPTed, otherwise,
control will pass back to the calling chain.</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A icmp-acc -p icmp --icmp-type destination-unreachable -j ACCEPT
ipchains -A icmp-acc -p icmp --icmp-type source-quench -j ACCEPT
ipchains -A icmp-acc -p icmp --icmp-type time-exceeded -j ACCEPT
ipchains -A icmp-acc -p icmp --icmp-type parameter-problem -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Good (Internal) to DMZ (Servers)</H3>

<P>Internal restrictions:
<UL>
<LI> Allow WWW, ftp, traceroute, ssh to external</LI>
<LI> <B>Allow SMTP to Mail server</B></LI>
<LI> <B>Allow POP-3 to Mail server</B></LI>
<LI> <B>Allow DNS to Name server</B></LI>
<LI> <B>Allow rsync to Web server</B></LI>
<LI> <B>Allow WWW to Web server</B></LI>
<LI> Allow ping to packet filter box</LI>
</UL>
</P>
<P>Could do masquerading from internal network into DMZ, but here we
don't.  Since noone in the internal network should be trying to do
evil things, we log any packets that get denied.</P>

<P>Note that old versions of Debian called `pop3' `pop-3' in
/etc/services, which disagrees with RFC1700.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A good-dmz -p tcp -d 192.84.219.128 smtp -j ACCEPT
ipchains -A good-dmz -p tcp -d 192.84.219.128 pop3 -j ACCEPT
ipchains -A good-dmz -p udp -d 192.84.219.129 domain -j ACCEPT
ipchains -A good-dmz -p tcp -d 192.84.219.129 domain -j ACCEPT
ipchains -A good-dmz -p tcp -d 192.84.218.130 www -j ACCEPT
ipchains -A good-dmz -p tcp -d 192.84.218.130 rsync -j ACCEPT
ipchains -A good-dmz -p icmp -j icmp-acc
ipchains -A good-dmz -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H3>Bad (external) to DMZ (servers).</H3>


<P>
<UL>
<LI> DMZ restrictions: 
<UL>
<LI> Mail server
<UL>
<LI> <B>SMTP to external</B></LI>
<LI> <B>Accept SMTP from</B> internal and <B>external</B></LI>
<LI> Accept POP-3 from internal</LI>
</UL>

</LI>
<LI> Name server 
<UL>
<LI> <B>Send DNS to external</B></LI>
<LI> <B>Accept DNS from</B> internal, <B>external</B> and packet filter box</LI>
</UL>

</LI>
<LI> Web server 
<UL>
<LI> <B>Accept HTTP from</B> internal and <B>external</B></LI>
<LI> Rsync access from internal</LI>
</UL>
</LI>
</UL>

</LI>
<LI> Things we allow from external network to DMZ.
<UL>
<LI> Don't log violations, as they may happen.</LI>
</UL>

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A bad-dmz -p tcp -d 192.84.219.128 smtp -j ACCEPT
ipchains -A bad-dmz -p udp -d 192.84.219.129 domain -j ACCEPT
ipchains -A bad-dmz -p tcp -d 192.84.219.129 domain -j ACCEPT
ipchains -A bad-dmz -p tcp -d 192.84.218.130 www -j ACCEPT
ipchains -A bad-dmz -p icmp -j icmp-acc
ipchains -A bad-dmz -j DENY
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>Good (internal) to Bad (external).</H3>

<P>
<UL>
<LI> Internal restrictions:
<UL>
<LI> <B>Allow WWW, ftp, traceroute, ssh to external</B></LI>
<LI> Allow SMTP to Mail server</LI>
<LI> Allow POP-3 to Mail server</LI>
<LI> Allow DNS to Name server</LI>
<LI> Allow rsync to Web server</LI>
<LI> Allow WWW to Web server</LI>
<LI> Allow ping to packet filter box</LI>
</UL>
</LI>
<LI> Many people allow everything from the internal to external networks,
then add restrictions.  We're being fascist.
<UL>
<LI> Log violations.</LI>
<LI> Passive FTP handled by masq. module.</LI>
<LI> UDP destination ports 33434 and up are used by traceroute.</LI>
</UL>

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A good-bad -p tcp --dport www -j MASQ
ipchains -A good-bad -p tcp --dport ssh -j MASQ
ipchains -A good-bad -p udp --dport 33434:33500 -j MASQ
ipchains -A good-bad -p tcp --dport ftp -j MASQ
ipchains -A good-bad -p icmp --icmp-type ping -j MASQ
ipchains -A good-bad -j REJECT -l
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>DMZ to Good (internal).</H3>


<P>
<UL>
<LI> Internal restrictions:
<UL>
<LI> Allow WWW, ftp, traceroute, ssh to external</LI>
<LI> <B>Allow SMTP to Mail server</B></LI>
<LI> <B>Allow POP-3 to Mail server</B></LI>
<LI> <B>Allow DNS to Name server</B></LI>
<LI> <B>Allow rsync to Web server</B></LI>
<LI> <B>Allow WWW to Web server</B></LI>
<LI> Allow ping to packet filter box</LI>
</UL>

</LI>
<LI> If we were masquerading from the internal network to the DMZ, simply
refuse any packets coming the other way. As it is, only allow packets
which might be part of an established connection.

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A dmz-good -p tcp ! -y -s 192.84.219.128 smtp -j ACCEPT
ipchains -A dmz-good -p udp -s 192.84.219.129 domain -j ACCEPT
ipchains -A dmz-good -p tcp ! -y -s 192.84.219.129 domain -j ACCEPT
ipchains -A dmz-good -p tcp ! -y -s 192.84.218.130 www -j ACCEPT
ipchains -A dmz-good -p tcp ! -y -s 192.84.218.130 rsync -j ACCEPT
ipchains -A dmz-good -p icmp -j icmp-acc
ipchains -A dmz-good -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>DMZ to bad (external).</H3>


<P>
<UL>
<LI> DMZ restrictions:
<UL>
<LI> Mail server
<UL>
<LI> <B>SMTP to external</B></LI>
<LI> <B>Accept SMTP from</B> internal and <B>external</B></LI>
<LI> Accept POP-3 from internal</LI>
</UL>

</LI>
<LI> Name server 
<UL>
<LI> <B>Send DNS to external</B></LI>
<LI> <B>Accept DNS from</B> internal, <B>external</B> and packet filter box</LI>
</UL>

</LI>
<LI> Web server 
<UL>
<LI> <B>Accept HTTP from</B> internal and <B>external</B></LI>
<LI> Rsync access from internal</LI>
</UL>
</LI>
</UL>

</LI>
<LI>
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A dmz-bad -p tcp -s 192.84.219.128 smtp -j ACCEPT
ipchains -A dmz-bad -p udp -s 192.84.219.129 domain -j ACCEPT
ipchains -A dmz-bad -p tcp -s 192.84.219.129 domain -j ACCEPT
ipchains -A dmz-bad -p tcp ! -y -s 192.84.218.130 www -j ACCEPT
ipchains -A dmz-bad -p icmp -j icmp-acc
ipchains -A dmz-bad -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>Bad (external) to Good (internal).</H3>


<P>
<UL>
<LI> We don't allow anything (non-masqueraded) from the external network
to the internal network
<BLOCKQUOTE><CODE>
<PRE>
ipchains -A bad-good -j REJECT
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>Packet Filtering for the Linux Box Itself</H3>


<P>
<UL>
<LI> If we want to use packet filtering on packets coming into the box
itself, we need to do filtering in the input chain. We create one
chain for each destination interface:
<BLOCKQUOTE><CODE>
<PRE>
ipchains -N bad-if
ipchains -N dmz-if
ipchains -N good-if
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI> Create jumps to them:

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A input -d 192.84.219.1 -j bad-if
ipchains -A input -d 192.84.219.250 -j dmz-if
ipchains -A input -d 192.168.1.250 -j good-if
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>Bad (external) interface.</H3>


<P>
<UL>
<LI> Packet Filter box:
<UL>
<LI> <B>PING any network</B></LI>
<LI> <B>TRACEROUTE any network</B></LI>
<LI> Access DNS</LI>
</UL>

</LI>
<LI> External interface also receives replies to masqueraded packets
(masquerading uses source ports 61000 to 65095) and ICMP errors for
them and PING replies.

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A bad-if -i ! ppp0 -j DENY -l
ipchains -A bad-if -p TCP --dport 61000:65095 -j ACCEPT
ipchains -A bad-if -p UDP --dport 61000:65095 -j ACCEPT
ipchains -A bad-if -p ICMP --icmp-type pong -j ACCEPT
ipchains -A bad-if -j icmp-acc
ipchains -A bad-if -j DENY
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>DMZ interface.</H3>


<P>
<UL>
<LI> Packet Filter box restrictions:
<UL>
<LI> <B>PING any network</B></LI>
<LI> <B>TRACEROUTE any network</B></LI>
<LI> <B>Access DNS</B></LI>
</UL>

</LI>
<LI> DMZ interface receives DNS replies, ping replies and ICMP errors.

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A dmz-if -i ! eth0 -j DENY
ipchains -A dmz-if -p TCP ! -y -s 192.84.219.129 53 -j ACCEPT
ipchains -A dmz-if -p UDP -s 192.84.219.129 53 -j ACCEPT
ipchains -A dmz-if -p ICMP --icmp-type pong -j ACCEPT
ipchains -A dmz-if -j icmp-acc
ipchains -A dmz-if -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H3>Good (internal) interface.</H3>


<P>
<UL>
<LI> Packet Filter box restrictions:
<UL>
<LI> <B>PING any network</B></LI>
<LI> <B>TRACEROUTE any network</B></LI>
<LI> <B>Access DNS</B></LI>
</UL>

</LI>
<LI> Internal restrictions:
<UL>
<LI> Allow WWW, ftp, traceroute, ssh to external</LI>
<LI> Allow SMTP to Mail server</LI>
<LI> Allow POP-3 to Mail server</LI>
<LI> Allow DNS to Name server</LI>
<LI> Allow rsync to Web server</LI>
<LI> Allow WWW to Web server</LI>
<LI> <B>Allow ping to packet filter box</B></LI>
</UL>

</LI>
<LI> Internal interface receives pings, ping replies and ICMP errors.

<BLOCKQUOTE><CODE>
<PRE>
ipchains -A good-if -i ! eth1 -j DENY
ipchains -A good-if -p ICMP --icmp-type ping -j ACCEPT
ipchains -A good-if -p ICMP --icmp-type pong -j ACCEPT
ipchains -A good-if -j icmp-acc
ipchains -A good-if -j DENY -l
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H2><A NAME="ss7.5">7.5 Finally</A>
</H2>

<P>
<UL>
<LI> Delete blocking rules:
<BLOCKQUOTE><CODE>
<PRE>
ipchains -D input 1
ipchains -D forward 1
ipchains -D output 1
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<H2><A NAME="ipfwadm-diff"></A> <A NAME="s8">8. Appendix: Differences between ipchains and ipfwadm.</A></H2>

<P>Some of these changes are a result of kernel changes, and some a
result of <CODE>ipchains</CODE> being different from <CODE>ipfwadm</CODE>.</P>

<P>
<OL>
<LI> Many arguments have been remapped: capitals now indicates a
command, and lower case now indicates an option.
</LI>
<LI> Arbitrary chains are supported, so even built-in chains have
full names instead of flags (eg. `input' instead of `-I').
</LI>
<LI> The `-k' option has vanished: use `! -y'.
</LI>
<LI> The `-b' option actually inserts/appends/deletes two rules,
rather than a single `bidirectional' rule.
</LI>
<LI> The `-b' option can be passed to `-C' to do two checks (one in
each direction).
</LI>
<LI> The `-x' option to `-l' has been replaced by `-v'.
</LI>
<LI> Multiple source and destination ports are not supported
anymore.  Hopefully being able to negate the port range will somewhat
make up for that.
</LI>
<LI> Interfaces can only be specified by name (not address).  The
old semantics got silently changed in the 2.1 kernel series anyway.
</LI>
<LI> Fragments are examined, not automatically allowed through.
</LI>
<LI> Explicit accounting chains have been done away with.
</LI>
<LI> Arbitrary protocols over IP can be tested for.
</LI>
<LI> The old behavior of SYN and ACK matching (which was previously
ignored for non-TCP packets) has changed; the SYN option is not valid
for non-TCP-specific rules.
</LI>
<LI> Counters are now 64-bit on 32-bit machines, not 32-bit.
</LI>
<LI> Inverse options are now supported.
</LI>
<LI> ICMP codes are now supported.
</LI>
<LI> Wildcard interfaces are now supported.
</LI>
<LI> TOS manipulations are now sanity-checked: the old kernel code
would silently stop you from (illegally) manipulating the `Must Be
Zero' TOS bit; ipchains now returns an error if you try, as well as
for other illegal cases.</LI>
</OL>
</P>

<H2><A NAME="ss8.1">8.1 Quick-Reference table.</A>
</H2>

<P>[ Mainly, command arguments are UPPER CASE, and option arguments are
lower case ]</P>

<P>One thing to note, masquerading is specified by `-j MASQ'; it is
completely different from `-j ACCEPT', and not treated as merely a
side-effect, unlike <CODE>ipfwadm</CODE> does.</P>

<P>
<PRE>
================================================================
| ipfwadm      | ipchains              | Notes
----------------------------------------------------------------
| -A [both]    | -N acct               | Create an `acct' chain
|              |&amp; -I 1 input -j acct   | and have output and input
|              |&amp; -I 1 output -j acct  | packets traverse it.
|              |&amp; acct                 |
----------------------------------------------------------------
| -A in        | input                 | A rule with no target
----------------------------------------------------------------
| -A out       | output                | A rule with no target
----------------------------------------------------------------
| -F           | forward               | Use this as [chain].
----------------------------------------------------------------
| -I           | input                 | Use this as [chain].
----------------------------------------------------------------
| -O           | output                | Use this as [chain].
----------------------------------------------------------------
| -M -l        | -M -L                 |
----------------------------------------------------------------
| -M -s        | -M -S                 |
----------------------------------------------------------------
| -a policy    | -A [chain] -j POLICY  | (but see -r and -m).
----------------------------------------------------------------
| -d policy    | -D [chain] -j POLICY  | (but see -r and -m).
----------------------------------------------------------------
| -i policy    | -I 1 [chain] -j POLICY| (but see -r and -m).
----------------------------------------------------------------
| -l           | -L                    |
----------------------------------------------------------------
| -z           | -Z                    |
----------------------------------------------------------------
| -f           | -F                    |
----------------------------------------------------------------
| -p           | -P                    |
----------------------------------------------------------------
| -c           | -C                    |
----------------------------------------------------------------
| -P           | -p                    |
----------------------------------------------------------------
| -S           | -s                    | Only takes one port or 
|              |                       | range, not multiples.
----------------------------------------------------------------
| -D           | -d                    | Only takes one port or 
|              |                       | range, not multiples.
----------------------------------------------------------------
| -V           | &lt;none>                | Use -i [name].
----------------------------------------------------------------
| -W           | -i                    |
----------------------------------------------------------------
| -b           | -b                    | Now actually makes 2 rules.
----------------------------------------------------------------
| -e           | -v                    |
----------------------------------------------------------------
| -k           | ! -y                  | Doesn't work unless 
|              |                       | -p tcp also specified.
----------------------------------------------------------------
| -m           | -j MASQ               |
----------------------------------------------------------------
| -n           | -n                    |
----------------------------------------------------------------
| -o           | -l                    |
----------------------------------------------------------------
| -r [redirpt] | -j REDIRECT [redirpt] |
----------------------------------------------------------------
| -t           | -t                    |
----------------------------------------------------------------
| -v           | -v                    |
----------------------------------------------------------------
| -x           | -x                    |
----------------------------------------------------------------
| -y           | -y                    | Doesn't work unless 
|              |                       | -p tcp also specified.
----------------------------------------------------------------
</PRE>
</P>

<H2><A NAME="ss8.2">8.2 Examples of translated ipfwadm commands</A>
</H2>

<P>Old command: ipfwadm -F  -p deny</P>
<P>New command: ipchains -P forward DENY</P>

<P>Old command: ipfwadm -F -a m -S 192.168.0.0/24 -D 0.0.0.0/0</P>
<P>New command: ipchains -A forward -j MASQ -s 192.168.0.0/24 -d 0.0.0.0/0</P>

<P>Old command: ipfwadm -I -a accept -V 10.1.2.1 -S 10.0.0.0/8 -D 0.0.0.0/0</P>
<P>New command: ipchains -A input -j ACCEPT -i eth0 -s 10.0.0.0/8 -d 0.0.0.0/0</P>
<P>(Note that there is no equivalent for specifying interfaces by
address: use the interface name.  On this machine, 10.1.2.1
corresponds to eth0).</P>

<H2><A NAME="upgrade"></A> <A NAME="s9">9. Appendix: Using the ipfwadm-wrapper script.</A></H2>

<P>The <CODE>ipfwadm-wrapper</CODE> shell script should be a plug-in replacement of
<CODE>ipfwadm</CODE> for backwards compatibility with ipfwadm 2.3a.</P>

<P>The only feature it can't really handle is the `-V' option.  When this
is used, a warning is given.  If the `-W' option is also used, the
`-V' option is ignored.  Otherwise, the script tries to find the
interface name associated with that address, using <CODE>ifconfig</CODE>.  If
that fails (such as for an interface which is down) then it will exit
with an error message.</P>

<P>This warning can be suppressed by either changing the `-V' to a `-W',
or directing the standard output of the script to /dev/null.</P>

<P>If you should find any mistakes in this script, or any changes between
the real ipfwadm and this script, <EM>please</EM> report a bug to me: send
an EMail to rusty@linuxcare.com with "BUG-REPORT" in the subject.
Please list your old version of <CODE>ipfwadm</CODE> (<CODE>ipfwadm -h</CODE>), your
version of <CODE>ipchains</CODE> (<CODE>ipchains --version</CODE>), the version of the
ipfwadm wrapper script (<CODE>ipfwadm-wrapper --version</CODE>).  Also send the
output of <CODE>ipchains-save</CODE>.  Thanks in advance.</P>

<P>Mix <CODE>ipchains</CODE> with this <CODE>ipfwadm-wrapper</CODE> script at
your own peril.</P>

<H2><A NAME="s10">10. Appendix: Thanks.</A></H2>

<P>Many thanks have to go to Michael Neuling, who wrote the first
releasable cut of the IP chains code while working for me.  Public
apologies for nixing his result-caching idea, which Alan Cox later
proposed and I have finally begun implementing, having seen the error
of my ways.</P>

<P>Thanks to Alan Cox for his 24-hour EMail tech support, and
encouragement.</P>

<P>Thanks to all the authors of the ipfw and ipfwadm code, especially Jos
Vos.  Standing on the shoulders of giants and all that...  This
applies to Linus Torvalds and all the kernel and userspace hackers as
well.</P>

<P>Thanks to the diligent beta testers and bughunters, especially Jordan
Mendelson, Shaw Carruthers, Kevin Moule, Dr. Liviu Daia, Helmut Adams,
Franck Sicard, Kevin Littlejohn, Matt Kemner, John D. Hardin, Alexey
Kuznetsov, Leos Bitto, Jim Kunzman, Gerard Gerritsen, Serge Sivkov,
Andrew Burgess, Steve Schmidtke, Richard Offer, Bernhard Weisshuhn,
Larry Auton, Ambrose Li, Pavel Krauz, Steve Chadsey, Francesco
Potorti`, Alain Knaff, Casper Boden-Cummins and Henry Hollenberg.</P>

<H2><A NAME="ss10.1">10.1 Translations</A>
</H2>

<P>People who do translations should put themselves at the <EM>top</EM>
of the Thanks page, like so: `Special thanks to XXX, for translating
everything exactly from my English.'.  Then tell me about your
translation so I can include it here.</P>

<P>Arnaud Launay, asl@launay.org: 
<A HREF="http://www.freenix.fr/unix/linux/HOWTO/IPCHAINS-HOWTO.html">http://www.freenix.fr/unix/linux/HOWTO/IPCHAINS-HOWTO.html</A></P>

<P>Giovanni Bortolozzo, borto@pluto.linux.it:
<A HREF="http://www.pluto.linux.it/ildp/HOWTO/IPCHAINS-HOWTO.html">http://www.pluto.linux.it/ildp/HOWTO/IPCHAINS-HOWTO.html</A></P>

<P>Herman Rodrguez, herman@maristas.dhis.org:
<A HREF="http://netfilter.kernelnotes.org/ipchains/spanish/HOWTO.html">http://netfilter.kernelnotes.org/ipchains/spanish/HOWTO.html</A></P>

</BODY>
</HTML>
