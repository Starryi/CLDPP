<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.72">
 <TITLE>Linux and Android HOWTO: Terminal emulator and shells </TITLE>
 <LINK HREF="Linux-Android-HOWTO-7.html" REL=next>
 <LINK HREF="Linux-Android-HOWTO-5.html" REL=previous>
 <LINK HREF="Linux-Android-HOWTO.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="Linux-Android-HOWTO-7.html">Next</A>
<A HREF="Linux-Android-HOWTO-5.html">Previous</A>
<A HREF="Linux-Android-HOWTO.html#toc6">Contents</A>
<HR>
<H2><A NAME="terminals"></A> <A NAME="s6">6.</A> <A HREF="Linux-Android-HOWTO.html#toc6">Terminal emulator and shells </A></H2>

<P>If you're a geek, you'll want to use a command line interface on your
Andbox. Properly configured, a terminal emulator will give you
almost the same interface as the Linux terminal. This is especially
useful if your Andbox has a physical keyboard.</P>

<P>If you're not a geek, you should install a terminal emulator
nonetheless: it will be useful anyway, since you'll be able to use
some important command-line commands like Busybox. More about this
later.</P>

<P>One of the best FOSS options is Android Terminal Emulator, available
here:</P>

<P>
<A HREF="https://github.com/jackpal/Android-Terminal-Emulator/wiki">https://github.com/jackpal/Android-Terminal-Emulator/wiki</A></P>

<P>It provides a fully functional terminal emulator, which is invaluable
for at least two reasons. First and foremost, you will be able to run
most command-line programs available on Linux; in many cases, you can
even compile them yourself. Secondly, the terminal makes the standard
Android commands found in <CODE>/system/bin</CODE> and
<CODE>/system/xbin</CODE> available to you. But <EM>beware</EM>: these are
not the same as the standard Linux commands! They're only a subset of
the standard GNU commands (even <CODE>cp</CODE> is missing: use <CODE>cat
file > newfile</CODE> instead), and they usually don't behave exactly
the same.</P>

<P>If you need a more complete command-line experience, you will also
want to install a command-line environment like KBOX, ZShaolin,
Terminal IDE, or Termux:</P>
<P>
<UL>
<LI>KBOX3 (KBOX2 is an older version):
  
<P>
<A HREF="http://kevinboone.net/kbox3.html">http://kevinboone.net/kbox3.html</A></P>

<P>KBOX is a compact and fully functional Linux-like command-line
environment. It also provides additional software, such as
<CODE>gcc</CODE>, <CODE>tmux</CODE>, the <CODE>dropbear</CODE> SSH server, and
much more.</P>

</LI>
<LI>Zshaolin:
  
<P>
<A HREF="http://www.dyne.org/software/zshaolin/">http://www.dyne.org/software/zshaolin/</A></P>

<P>Zshaolin is a <CODE>zsh</CODE>-based terminal that provides lots (I mean
<EM>lots</EM>) of additional free software. The whole thing is FOSS,
but is not cost-free.</P>

</LI>
<LI>Terminal IDE:
  
<P>
<A HREF="http://www.spartacusrex.com/terminalide.htm">http://www.spartacusrex.com/terminalide.htm</A></P>

<P>It's a very complete Linux-like command-line environment. It's
focused on development, providing Vim, <CODE>gcc</CODE>, <CODE>mc</CODE>,
<CODE>ssh</CODE>, and loads of software. Once installed, it gives you
the option ``Install System'' to install additional components,
including the <CODE>bash</CODE> shell.</P>

</LI>
</UL>
</P>

<P>All of them are great programs: advanced users really can't do without
a terminal.</P>

<P>Which one to install depends on how much sdcard space you can afford.
If you have a few hundreds of MBytes to devote to it, I would suggest
that you install Terminal IDE: it provides a very Linux-like
experience. If you're short on storage, I suggest that you install
KBOX: it's a very good compromise.</P>
<P>Users of Android 5 and later versions may want to install an
alternative terminal emulator called Termux:</P>

<P>
<A HREF="https://termux.com/">https://termux.com/</A></P>

<P>It's very nice and self-contained, i.e. it does not need KBOX or
another command-line environment. Additional software can be installed
simply using apt (Debian users, does that ring a bell?):</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc
The program 'gcc' is not installed. Install it by executing:
  apt install gcc
$ ...
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Termux is released under GPLv3, but some add-ons are available for a
small fee.  </P>



<H2><A NAME="ss6.1">6.1</A> <A HREF="Linux-Android-HOWTO.html#toc6.1">Installing KBOX</A>
</H2>

<P>Whether to install KBOX2 or KBOX3 depends on your Andbox' Android
version. I installed KBOX2 on two of my Andboxes, which run Android
4.*, and KBOX3 on my new phone. In the following, I'll show how to
install KBOX2; installing KBOX3 is very similar. Try KBOX3 first; if
you get a segmentation fault running the KBOX3 installer, then try
with KBOX2. </P>

<P>Download the base installer, called <CODE>kbox2-base-installer</CODE> or
<CODE>kbox3-install-base</CODE>. Open Terminal Emulator and issue the
following commands:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
foo@android:/ $ cd
foo@android:/.../app_HOME $ cat /sdcard/Download/kbox2-base-installer > kbox2-base-installer
foo@android:/.../app_HOME $ chmod 755 kbox2-base-installer
foo@android:/.../app_HOME $ ./kbox2-base-installer
UnZipSFX 6.00 of 20 April 2009, by Info-ZIP (http://www.info-zip.org).
  inflating: setup
   creating: installer-image/
  inflating: installer-image/install.sh
  inflating: installer-image/base-image.tar
  inflating: installer-image/busybox
  inflating: installer-image/.install.sh.swp
foo@android:/.../app_HOME $ ./setup
Running installer for KBOX2
Running installation script using busybox
CWD is /data/data/jackpal.androidterm/app_HOME
KBOX root directory is /data/data/jackpal.androidterm/app_HOME/kbox2
KBOX shell is /data/data/jackpal.androidterm/app_HOME/kbox2/bin/kbox_shell
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>If installation succeeds, you can replace the standard Android shell
with KBOX's. Open the Terminal Emulator preferences, select ``Command
line'', and change:</P>

<P><CODE>/system/bin/sh -</CODE></P>

<P>to:</P>

<P><CODE>/data/data/jackpal.androidterm/app_HOME/kbox2/bin/kbox_shell</CODE></P>

<P>Be very careful to write the above correctly! If you make a mistake,
Terminal Emulator will not start and you will have to remove it and
reinstall it.</P>

<P>Exit Terminal Emulator and reopen it. The command prompt should have
changed to <CODE>kbox$</CODE>:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kbox$ pwd
/home/kbox
kbox$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Now you're working in a fake UNIX environment; many commands are
provided by Busybox. If you want to access the Android file system,
you'll find it under the <CODE>/android_root</CODE> directory.</P>

<P>You may want to install additional software from KBOX home page.
Depending on your KBOX version, either link:</P>

<P>
<A HREF="http://kevinboone.net/kbox2_downloads.html">http://kevinboone.net/kbox2_downloads.html</A></P>

<P>
<A HREF="http://kevinboone.net/kbox3_downloads.html">http://kevinboone.net/kbox3_downloads.html</A></P>

<P>Additional programs are provided as <CODE>.deb</CODE> packages. This is
the very same format used by Debian and many other Linux
distributions, but obviously the packages provided for KBOX only work
on KBOX. Download the package you want and install it as in the
following example. Let's install coreutils, an improved implementation
that replaces the default provided by KBOX's BusyBox:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kbox$ dpkg -i /android_root/mnt/sdcard/Download/coreutils_8.22_kbox.deb
Unpacking coreutils (from /android_root/mnt/sdcard/Download/coreutils_8.22_kbox.deb)...
Setting up coreutils (8.22)...
kbox$ ls --color /android_root
...
</PRE>
</CODE></BLOCKQUOTE>
</P>



<H3>Printing via FTP</H3>

<P>If you install the KBOX command-line ftp client, you <EM>could</EM> be
able to print PDF files from your Andbox. I don't mean Google Cloud
Print; and I repeat you <EM>could</EM>, because it actually depends on
your printer's capabilities.</P>

<P>Some network printers include an FTP server, and you can print
PostScript or PDF files sending them directly to the printer via FTP.
First of all, find out whether your printer supports FTP:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Linux:~$ nmap MY.OFFICE.PRINTER

Starting Nmap 6.40 ( http://nmap.org ) at 2015-10-22 11:08 CEST
Nmap scan report for MY.OFFICE.PRINTER (10.15.130.105)
Host is up (0.00023s latency).
rDNS record for 10.15.130.105: csf-p1-v7913500307.xxx.yyy.zzz
Not shown: 990 closed ports
PORT     STATE SERVICE
21/tcp   open  ftp
23/tcp   open  telnet
80/tcp   open  http
139/tcp  open  netbios-ssn
514/tcp  open  shell
515/tcp  open  printer
631/tcp  open  ipp
7443/tcp open  oracleas-https
8080/tcp open  http-proxy
9100/tcp open  jetdirect

Nmap done: 1 IP address (1 host up) scanned in 12.27 seconds
Linux:~$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>As you can see, the above printer (it's an Aficio MP 4001) has an open
FTP port, in addition to the standard JetDirect port 9100 and many
others (that should be closed, but still...)</P>

<P>From KBOX, run the ftp client and copy a file to the printer as in the
following session. The user name is ``ftp'', the password is
``guest''. These are common FTP defaults.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kbox$ ftp MY.OFFICE.PRINTER
Connected to csf-p1-v7913500307.MY.OFFICE.DOMAIN
220 NRG MP 4001 FTP server (7.34) ready.
Name (MY.OFFICE.PRINTER:guido): ftp
331 Password required for ftp.
Password:
230 User ftp logged in.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> put my_file.pdf
local: my_file.pdf remote: my_file.pdf
200 PORT command successful.
150 Opening BINARY mode data connection for 'my_file.pdf'.
226 Transfer complete.
24057 bytes sent in 0.00 secs (405054.5 kB/s)
ftp> bye
221 Goodbye.
kbox$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>When the file is transfered to the printer, it will be printed.</P>

<P>I successfuly tested this method on several HP and Aficio network
printers. Obviously, you mileage may vary; for instance, you may need
to provide a real user name and password instead of ``ftp'',
``guest''. Ask your local sysadmin (and buy him/her a beer while
you're at it).</P>

<P>Ghost Commander provides access to ftp servers natively, so it can be
used instead of the command-line ftp client.</P>



<H2><A NAME="ss6.2">6.2</A> <A HREF="Linux-Android-HOWTO.html#toc6.2">Remote shell via SSH</A>
</H2>

<P>In addition to local shells, you can open a shell on your device
remotely, via <CODE>ssh</CODE>; you will need a <CODE>ssh</CODE> server on the
Andbox. Such server is SSHelper (free software, GPL'ed):</P>

<P>
<A HREF="http://arachnoid.com/android/SSHelper/">http://arachnoid.com/android/SSHelper/</A></P>

<P>Since it runs on unrooted devices, it uses the port 2222 instead of
the standard port 22; i.e., to connect to it from the Linux terminal
you will do:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Linux:~$ ssh -p 2222 157.27.188.78
The authenticity of host '[xx.xx.xx.xx]:2222 ([xx.xx.xx.xx]:2222)' can't be established.
ECDSA key fingerprint is 20:3f:f1:c1:3b:ce:fb:61:3e:a3:bb:0d:a4:15:54:c7.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[xx.xx.xx.xx]:2222' (ECDSA) to the list of known hosts.
SSHelper Version 7.8 Copyright 2014, P. Lutus
Default password is "admin" (recommend: change it)
guido@157.27.188.78's password: 
Android:2.6.39.4-g9560a99
app_105@android:/data/data/com.arachnoid.sshelper/home $ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>The connection uses the standard Android shell,
<CODE>/system/bin/sh</CODE>. Nothing prevents you from starting, say,
KBOX. All you have to do is type the full path of the KBOX shell:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
...home $ /data/data/jackpal.androidterm/app_HOME/kbox2/bin/kbox_shell
kbox$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>



<H2><A NAME="ss6.3">6.3</A> <A HREF="Linux-Android-HOWTO.html#toc6.3">Compiling C programs, Linux side</A>
</H2>

<P>Once you have a terminal emulator, you can add a lot of command-line
based software to your Android box. If you're a geek, this is an
invaluable extension that makes your Andbox closer to a ``real''
computer; but even if you're a casual user, please read on.</P>

<P>You can compile C programs directly on your Andbox, and also on your
Linux box. In the latter case, you use a so-called <EM>cross compiler
toolchain</EM>: a compiler and associated binutils that produce code
for Android. In many cases, but not only, for the ARM cpu.</P>

<P>Most Linux distributions provide one or more cross compiler toolchains
that target ARM on Android. On my box, I installed the package
<CODE>gcc-arm-linux-androideabi</CODE> and its dependencies. If your Linux
distributions doesn't include it by default, get the relevant
toolchain from the NDK home page:</P>

<P>
<A HREF="http://developer.android.com/ndk/downloads/index.html">http://developer.android.com/ndk/downloads/index.html</A></P>

<P>Another toolchain that targets Android on x86 CPUs is called
<CODE>gcc-i686-linux-android</CODE>.</P>

<P>Choose the relevant architecture and download the binary package for
Linux 32-bit or 64-bit. The directory</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86/bin/
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>contains prebuilt binaries: include that directory in the
<CODE>$PATH</CODE>. MIPS and x86 binaries are also available.</P>

<P>Supposing you're compiling for ARM, the compiler is called
<CODE>arm-linux-androideabi-gcc</CODE>. You use it instead of <CODE>gcc</CODE>
to compile Android binaries. In general, all binutils have a
<CODE>arm-linux-androideabi-</CODE> prefix.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Linux:~$ arm-linux-androideabi-gcc -static -o hello hello.c
Linux:~$ arm-linux-androideabi-strip hello
Linux:~$ file hello
hello: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, stripped
Linux:~$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>The <CODE>-static</CODE> option makes the executable self-contained. It
may be necessary to avoid problems with shared libraries, but it also
makes the executable larger.</P>

<P>Now you can copy the program to your Android box, but you can't copy
it to any directory of your choice. In fact, if you copy a program to
a directory in the internal memory, like <CODE>/mnt/sdcard</CODE>, you'll
be unable to run the program as it lacks the 755 permissions.
Remember, <CODE>/mnt/sdcard</CODE> is mounted as VFAT, so it cannot provide
file permissions.</P>

<P>Fortunately, the Android file system has a directory that is writeable
and supports file permissions: <CODE>/data/local/tmp</CODE>. Unlike the
<CODE>/tmp</CODE> directory in Linux, files in this directory are not
deleted at boot time.</P>

<P>Here is how to copy (all Android versions) and run (Android older than
5.*) your application on the Andbox:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Linux:~$ adb push hello /data/local/tmp
57 KB/s (2752 bytes in 0.046s)
geo:~$ adb shell
shell@android:/ $ cd /data/local/tmp
shell@android:/data/local/tmp $ chmod 755 hello
shell@android:/data/local/tmp $ ./hello
Hello, world!
32|shell@android:/data/local/tmp $ exit
Linux:~$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Beware: Android 5.* has better security policies and will not allow
running programs from <CODE>/data/local/tmp</CODE>, or even accessing that
directory. From the terminal, you'll have to copy the compiled
programs to a directory where you have write and execute permissions.
Beware: you will have to copy files in the blind, specifying their
exact names, no wildcards allowed!</P>

<P>For instance, using KBOX:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kbox$ ls /android_root/data/local/tmp
ls: cannot open directory  /android_root/data/local/tmp: permission denied
kbox$ cp /android_root/data/local/tmp/hello .
kbox$ ls
hello
kbox$ chmod 755 hello
kbox$ ./hello
hello, world!
kbox$ _
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>A remarkable list of command-line programs can be easily compiled for
Android. Among others, I ported the Bywater BASIC interpreter:</P>

<P>
<A HREF="http://sourceforge.net/projects/bwbasic/">http://sourceforge.net/projects/bwbasic/</A></P>

<P>(minor tweaks were needed: I added <CODE>-DHAVE_ISNAN=1</CODE> to the DEFS
in the <CODE>Makefile</CODE>, and also <CODE>#define uint64_t unsigned
long</CODE> at the top of <CODE>bwbasic.h</CODE>)</P>

<P>The C version of the e3 text editor (version 2.7.1) can be compiled
with no tweaks at all:</P>

<P>
<A HREF="https://sites.google.com/site/e3editor/">https://sites.google.com/site/e3editor/</A></P>

<P>same for the ABC music tools:</P>

<P>
<A HREF="http://abcplus.sourceforge.net/">http://abcplus.sourceforge.net/</A></P>

<P>In general, any program that doesn't depend on fancy libraries is
readily portable to Android. Explanations on compiling stuff in
Android are available here:</P>

<P>
<A HREF="http://kevinboone.net/android_native.html">http://kevinboone.net/android_native.html</A>.</P>

<P>Compile the programs you need, copy them to <CODE>/data/local/tmp/</CODE>,
and make sure this directory is included in the <CODE>$PATH</CODE> of your
favourite terminal.</P>


<H2><A NAME="ss6.4">6.4</A> <A HREF="Linux-Android-HOWTO.html#toc6.4">Compiling C programs, Android side</A>
</H2>

<P>The simplest way to compile programs on an Android box is installing
Terminal IDE, cited above, and its ``System'' that includes the
<CODE>gcc</CODE> compiler. It's included, but as a compressed archive:
it's up to the user to unpack it and install it. Let's see how to do it.</P>

<P>Start Terminal IDE, enter the terminal and insert these commands:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
cd system
tar zxvf android-gcc-4.4.0.tar.gz
cd
vi .bashrc
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Surely you can use <CODE>vi</CODE>, can't you? Move to the end of the file
and add this line:</P>
<P>
<HR>
<PRE>
export PATH=$HOME/system/android-gcc-4.4.0/arm-eabi/bin:$PATH
</PRE>
<HR>
</P>

<P>save, exit <CODE>vi</CODE>, exit Terminal IDE then restart it. You have
expanded the PATH to include the directory containing the <CODE>gcc</CODE>
executable. Now you should be able to run it:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
gcc
gcc: no input files
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>That's it! From now on, you can compile programs directly on your
Android box. Don't expect to be able to compile every single, though.</P>


<H2><A NAME="ss6.5">6.5</A> <A HREF="Linux-Android-HOWTO.html#toc6.5">CCTools</A>
</H2>

<P>As the CCTools home page states, ``CCTools is native IDE for Android
devices. It includes C/C++/Lua/GNU Makefile/Shell source code editor
with syntax highlighting and complete android gcc toolchain for
arm/mips/x86 devices.''</P>

<P>CCTools is a very nice addition, and it also provides support for
Fortran, SDL and much more. I suggest that you give it a try.</P>



<HR>
<A HREF="Linux-Android-HOWTO-7.html">Next</A>
<A HREF="Linux-Android-HOWTO-5.html">Previous</A>
<A HREF="Linux-Android-HOWTO.html#toc6">Contents</A>
</BODY>
</HTML>
