<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2. AVR Microcontrollers in Linux HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Avr-Microcontrollers-in-Linux-Howto"><link rel="up" href="index.html" title="Avr-Microcontrollers-in-Linux-Howto"><link rel="prev" href="ar01s01.html" title="1. HOWTO"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. AVR Microcontrollers in Linux HOWTO</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s01.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> </td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm207"></a>2. AVR Microcontrollers in Linux HOWTO</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm209"></a>2.1. Licence</h3></div></div></div><pre class="screen">      Permission is granted to copy, distribute, and/or modify this
      document under the terms of the GNU Free Documentation License,
      Version 1.2, or any later version published by the Free Software
      Foundation; with no Invariant Sections, no Front-Cover Texts, and
      no Back-Cover Texts.  A copy of the license is included in the
      section entitled "GNU Free Documentation License".</pre><p><a class="ulink" href="http://wiki.tldp.org/LdpWikiDefaultLicence#GNUFreeDocumentationLicense" target="_top">GNU Free Documentation License</a> </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm214"></a>2.2. What Is a Microcontroller?</h3></div></div></div><p>A microcontroller is a single-chip computer. It has internal RAM, ROM, timers, counters, interrupt circuitry, I/O ports, analog comparators, serial USARTs, analog to digital converters, watchdog timers, and a RISC architecture. When you are using a microprocessor, you cannot program it alone.  You need other components, like RAM, ROM, timers, etc. For programming, you should know its architecture thoroughly: You must read the datasheet for your microcontroller. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm217"></a>2.3. Software Required</h3></div></div></div><p><span class="strong"><strong>binutils:</strong></span> Tools like the assembler, linker, etc. </p><p><span class="strong"><strong>gcc-avr:</strong></span> The GNU C compiler (cross-compiler for avr). </p><p><span class="strong"><strong>avr-libc:</strong></span> Package for the AVR C library, containing many utility functions. </p><p><span class="strong"><strong>uisp:</strong></span> A Micro In-System Programmer for Atmel's AVR MCUs (for burning code to MCUs' memory). </p><p>The following Atmel microcontrollers are supported by avr-gcc in Linux: </p><p><span class="strong"><strong>at90s Type Devices</strong></span> </p><p>at90s2313, at90s2323, at90s2333, at90s2343, at90s4414, at90s4433, at90s4434, at90s8515, at90s8515, at90s8515, at90s8535, at90s1200. </p><p><span class="strong"><strong>atmega Type Devices</strong></span> </p><p>atmega103, atmega603, atmega8, atmega48, atmega88, atmega8515, atmega8535, atmega16, atmega161, atmega162, atmega163, atmega165, atmega168, atmega169, atmega32, atmega323, atmega325, atmega3250, atmega64, atmega645, atmega6450, atmega128. </p><p><span class="strong"><strong>attiny Type Devices</strong></span> </p><p>attiny22, attiny26, attiny26, attiny13, attiny13, attiny13, attiny13, attiny2313, attiny11, attiny12, attiny15, attiny28. </p><p><span class="strong"><strong>Other AVR Devices</strong></span> </p><p>avr2, at90c8534, at86rf401, avr3, at43usb320, at43usb355, at76c711, avr4, avr5, at90can128, at94k, avr1. </p><p><span class="strong"><strong>binutils:</strong></span> Programs to manipulate binary and object files that may have been created for Atmel's AVR architecture. This package is primarily for AVR developers and cross-compilers. </p><p><span class="strong"><strong>gcc-avr:</strong></span> The GNU C compiler, a fairly portable optimising compiler that supports multiple languages. This package includes C language support. </p><p><span class="strong"><strong>avr-libc:</strong></span> Standard library used for developing C programs for Atmel AVR microcontrollers. This package contains static libraries, as well as needed header files. </p><p><span class="strong"><strong>uisp:</strong></span> Utility to program AVR chips with object code created by gcc-avr. It supports in-system programming. </p><p>You download the above packages untar, configure, and install it. If you are using Debian or Ubuntu, these packages are available in your distribution: Install them using apt or synaptic package manager. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm249"></a>2.4. Hello World</h3></div></div></div><p>We are writing <span class="strong"><strong>hello world</strong></span> for the atmega8 microcontroller, which has a 28-pin, 8-bit, RISC architecture. </p><p>Before proceeding, have a look at <a class="ulink" href="http://www.nongnu.org/avr-libc/user-manual/" target="_top">this manual about __avr-libc__</a>, which will help you program better, and understand. Also, refer to the datasheets for the various AVR microcontrollers. </p><p>Here is our first program: </p><pre class="screen">/* ledblink.c, an LED blinking program */
#include&lt;avr/io.h&gt;
#include&lt;util/delay.h&gt;
void sleep(uint8_t millisec)
{
        while(millisec)

        {
                _delay_ms(1);/* 1 ms delay */
                millisec--;
        }
}
main()
{

        DDRC |=1&lt;&lt;PC2;  /* PC2 will now be the output pin */
        while(1)
        {
                PORTC &amp;= ~(1&lt;&lt;PC2);/* PC2 LOW */
                sleep(100);/* 100 ms delay */

                PORTC |=(1&lt;&lt;PC2); /* PC2 HIGH */
                sleep(100);/* 100 ms delay */
        }
}</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm257"></a>2.4.1. Code Explanation</h4></div></div></div><p>The GNU C compiler for the Atmel family identifies all functional units within the microcontroller with meaningful names.  Thus, writing `PORTC=0xff' will result in the compiler generating machine code that writes 0xff to I/O port C, which will set all port C pins to logic high. Because ports are bidirectional, we must decide whether each pin should act as input or output. If the i'th bit of a register called DDRC (data direction register C) is 1, then the i'th pin of PORTC's i'th pin will be an output. Otherwise, it will act as an input pin. (Note that pin and bit numbers start at zero.) To make an LED blink, you have to make a pin high, then low. (Here, we use PORTC's 2<sup>nd</sup> port. That is, PC2 will be the 25<sup>th</sup> pin.) There should be a delay between the two.  This is what the rest of the code does. For the delay, we use built-in function <span class="emphasis"><em>_delay_ms(1)</em></span>, which causes a 1 ms delay. </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm263"></a>2.4.2. Compilation</h4></div></div></div><pre class="screen">avr-gcc -mmcu=atmega8 Os ledblink.c o ledblink.o</pre><p>which will result in object file ledblink.o. Now, we will covert it to hex file, suitable for burning to the microcontroller's memory. </p><pre class="screen">avr-objcopy -j .text -j .data -O ihex  ledblink.o  ledblink.hex</pre><p>We are converting it to a hex file because, for burning the code to atmega8, we will use uisp, whose input file must be a .hex file. </p><p>Notice that you can <span class="emphasis"><em>less</em></span> the ledblink.hex file. </p><pre class="screen">:1000000012C02BC02AC029C028C027C026C025C0C6
:1000100024C023C022C021C020C01FC01EC01DC0DC
:100020001CC01BC01AC011241FBECFE5D4E0DEBF28
:10003000CDBF10E0A0E6B0E0EAE8F0E002C0059035
:100040000D92A036B107D9F710E0A0E6B0E001C0EC
:100050001D92A036B107E1F70CC0D2CF282FE4ECF7
:10006000F9E004C0CF010197F1F721502223D1F725
:100070000895CFE5D4E0DEBFCDBFA29AAA9884E66A

:0A008000EDDFAA9A84E6EADFF9CF6B
:00000001FF</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm272"></a>2.4.3. Burning the Code</h4></div></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm274"></a>2.4.3.1. Hardware</h5></div></div></div><p>We will be using the parallel port for burning. First, we have to develop a burning circuit for it. </p><p><span class="inlinemediaobject"><img src="avr_html_m7e400112-2.jpg" alt="atmega8 microcontroller"></span> </p><p>This is the circuit for the atmega8 microcontroller. Pin 9 &amp; pin 10 are connected by a 4 MHz crystal oscillator, which is the external clock. The bottom right connector is for a parallel port. </p><p>If you are using any other microcontroller, as mentioned above, you should change accordingly. }}} </p><p>You should watch for <span class="emphasis"><em>RESET,XTAL1,XTAL2,SCK,MISO,MOSI pins</em></span>, <span class="emphasis"><em> </em></span>and connect.<span class="emphasis"><em> </em></span> </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idm289"></a>2.4.3.2. Software</h5></div></div></div><p>Now, we will burn ledblink.hex to the microcontroller. </p><pre class="screen">uisp -dprog=dapa -dlpt=0x378</pre><p>You should get message <span class="emphasis"><em>Atmega8 Found</em></span>. </p><p><span class="emphasis"><em><span class="underline">dprog</span></em></span> is the programming method specifier, which in this case is <span class="emphasis"><em>dapa</em></span>, i.e., Direct AVR Parallel Access. <span class="emphasis"><em><span class="underline">dlpt</span></em></span> is for the parallel device setting, which is 0x378, the parallel port's device address. </p><pre class="screen">uisp -dprog=dapa -dlpt=0x378 --erase</pre><p>Will erase the microcontroller's code. </p><pre class="screen">uisp -dprog=dapa -dlpt=0x378 --upload if=ledblink.hex</pre><p>Will <span class="emphasis"><em>upload</em></span> the <span class="emphasis"><em>I</em></span>nput <span class="emphasis"><em>F</em></span>ile ledblink.hex </p><p>Notice that you can see the LED at pin 25 blinking. </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm309"></a>2.5. Author</h3></div></div></div><p>Comments to: <a class="ulink" href="mailto:ranjeeth_gecmail%5Bat%5Dyahoo%5Bdot%5Dcom" target="_top">mailto:ranjeeth_gecmail[at]yahoo[dot]com</a> </p><p><a class="ulink" href="http://ranjeethpt.wordpress.com" target="_top">Ranjeeth Weblog</a> </p><p>Govt Engg College Sreekrishnapuram, </p><p>Palakkad,Kerala India. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm317"></a>2.6. Last version</h3></div></div></div><p>You may find the last up-to-date version of this HOWTO <a class="ulink" href="http://wiki.tldp.org/Avr-Microcontrollers-in-Linux-Howto" target="_top">on the LDP wiki</a>. </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s01.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> </td></tr><tr><td width="40%" align="left" valign="top">1. HOWTO </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>
