<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux Complete Backup and Recovery HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux Complete Backup and Recovery HOWTO</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Charles Curley</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.3</TD
><TD
ALIGN="LEFT"
>2007-05-26</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes for FHS compliance. Changes in <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
> to handle the libata problem.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.2</TD
><TD
ALIGN="LEFT"
>2006-07-11</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Clarified that the ZIP disk is not required, and there are alternatives.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.1</TD
><TD
ALIGN="LEFT"
>2006-03-28</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added notes for NTFS. Edited the To Do list. Started work on LVM and using <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.0</TD
><TD
ALIGN="LEFT"
>2005-10-12</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Notes for Fedora Core 4. Removed notes for older versions of FC and Red Hat. Also, changes in the writeup and scripts to reflect using <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> instead of <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. See the scripts for change notes. Changed some scripts so that long lines don't fall off the right side of printed pages (oops).</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.8</TD
><TD
ALIGN="LEFT"
>2005-02-19</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added notes for Fedora Core 3</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.7</TD
><TD
ALIGN="LEFT"
>2004-05-11</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Adjusted copyright language.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.6</TD
><TD
ALIGN="LEFT"
>2004-04-29</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> notes, Syslinux, PPART, QtParted, some other rescue CDs, and made some fixes.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.5</TD
><TD
ALIGN="LEFT"
>2003-12-19</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Fedora 1 and GRUB notes.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.4</TD
><TD
ALIGN="LEFT"
>2003-08-17</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Some notes on burning CD-ROMs, and more on files to exclude.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.3</TD
><TD
ALIGN="LEFT"
>2003-04-24</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Substituted new email address and URL for old.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.2</TD
><TD
ALIGN="LEFT"
>2003-02-12</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added Red Hat 8.0 notes, support for FAT32, split the first stage restore scripts, and other minor changes. Notes on <A
HREF="#AMANDA"
>Amanda</A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.1</TD
><TD
ALIGN="LEFT"
>2002-09-10</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>New code to handle ext3 partitions in <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, and a note on <A
HREF="#INITRD"
><TT
CLASS="FILENAME"
>initrd</TT
></A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2002-07-24</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>We now use bz2 compression in the first stage, have the run time option to check for bad blocks, and have a script that runs the entire first stage.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN89"
></A
><P
>Imagine your disk drive has just become a very expensive hockey puck. Imagine you have had a fire, and your computer case now looks like something Salvador Dal&#297; would like to paint. Now what?</P
><P
>Total restore, sometimes called bare metal recovery, is the process of rebuilding a computer after a catastrophic failure. In order to make a total restoration, you must have complete backups, not only of your file system, but of partition information and other data. This HOWTO is a step-by-step tutorial on how to back up a Linux computer so as to be able to make a bare metal recovery, and how to make that bare metal recovery. It includes some related scripts.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#INTRO"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#COPYRIGHT"
>Copyright Information</A
></DT
><DT
>1.2. <A
HREF="#DISCLAIMERS"
>Disclaimers</A
></DT
><DT
>1.3. <A
HREF="#NEWVERSIONS"
>New Versions</A
></DT
><DT
>1.4. <A
HREF="#CREDITS"
>Credits</A
></DT
><DT
>1.5. <A
HREF="#FEEDBACK"
>Feedback</A
></DT
><DT
>1.6. <A
HREF="#TRANSLATIONS"
>Translations</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#OVERVIEW"
>Overview</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#LIMITATIONS"
>Limitations</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#PREPARATION"
>Preparation</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#INSTALLINGZIPDRIVE"
>Installing the ZIP Drive</A
></DT
><DT
>3.2. <A
HREF="#BACKUP.SERVER"
>Backup Server</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#CREATINGTHESTAGE1BACKUP"
>Creating the Stage 1 Back Up</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN372"
>The Archive</A
></DT
><DT
>4.2. <A
HREF="#THEMEANDVARIATIONS"
>Theme And Variations</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#FIRSTSTAGERESTORE"
>First Stage Restore</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#BOOTING"
>Booting</A
></DT
><DT
>5.2. <A
HREF="#RESTORATION"
>Restoration</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#SECONDSTAGERESTORATION"
>Second Stage Restoration</A
></DT
><DT
>7. <A
HREF="#DISTRIBUTIONSPECIFICNOTES"
>Distribution Specific Notes</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#FEDORA3"
>Fedora</A
></DT
><DT
>7.2. <A
HREF="#KNOPPIX"
>Knoppix</A
></DT
><DT
>7.3. <A
HREF="#AEN672"
>Finnix</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#APPLICATIONSPECIFICNOTES"
>Application Specific Notes</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#LVM"
>Logical Volume Manager</A
></DT
><DT
>8.2. <A
HREF="#SELINUX"
>Selinux</A
></DT
><DT
>8.3. <A
HREF="#GRUB"
>GRUB</A
></DT
><DT
>8.4. <A
HREF="#TRIPWIRE"
>Tripwire</A
></DT
><DT
>8.5. <A
HREF="#SQUID"
>Squid</A
></DT
><DT
>8.6. <A
HREF="#ARKEIA"
>Arkeia</A
></DT
><DT
>8.7. <A
HREF="#AMANDA"
>Amanda</A
></DT
><DT
>8.8. <A
HREF="#NTFS"
>NTFS</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#SOMEADVICEFORDISASTERRECOVERY"
>Some Advice for Disaster Recovery</A
></DT
><DT
>10. <A
HREF="#WHATNOW"
>What Now?</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#TODO"
>To Do</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#THESCRIPTS"
>The Scripts</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#FIRSTSTAGE"
>First Stage</A
></DT
><DT
>11.2. <A
HREF="#SECONDSTAGE"
>Second Stage</A
></DT
><DT
>11.3. <A
HREF="#BACKUPSERVERSCRIPTS"
>Backup Server Scripts</A
></DT
><DT
>11.4. <A
HREF="#MISC.FILES"
>Miscellaneous Files</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#RESOURCES"
>Resources</A
></DT
><DT
>A. <A
HREF="#APPENDIX1GFDL"
>GNU Free Documentation License</A
></DT
><DD
><DL
><DT
>0. <A
HREF="#GFDL02"
>PREAMBLE</A
></DT
><DT
>1. <A
HREF="#GFDL03"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>2. <A
HREF="#GFDL04"
>VERBATIM COPYING</A
></DT
><DT
>3. <A
HREF="#GFDL05"
>COPYING IN QUANTITY</A
></DT
><DT
>4. <A
HREF="#GFDL06"
>MODIFICATIONS</A
></DT
><DT
>5. <A
HREF="#GFDL07"
>COMBINING DOCUMENTS</A
></DT
><DT
>6. <A
HREF="#GFDL08"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>7. <A
HREF="#GFDL09"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>8. <A
HREF="#GFDL10"
>TRANSLATION</A
></DT
><DT
>9. <A
HREF="#GFDL11"
>TERMINATION</A
></DT
><DT
>10. <A
HREF="#GFDL12"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>11. <A
HREF="#GFDL13"
>How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="INTRO"
>1. Introduction</A
></H2
><P
>The normal bare metal restoration process is: install the operating system from the product disks. Install the backup software, so you can restore your data. Restore your data. Then you get to restore functionality by verifying your configuration files, permissions, etc.</P
><P
>   The process and scripts explained in this HOWTO will save re-installing the operating system. The process explained here will restore only files that were backed up from the production computer. Your configuration will be intact when you restore the system, which should save you hours of verifying configurations and data.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="COPYRIGHT"
>1.1. Copyright Information</A
></H3
><P
>Copyright © 2001 through last date of modification Charles Curley and distributed under the terms of the GNU Free Documentation License (GFDL) license, stated below. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in the section entitled <A
HREF="#APPENDIX1GFDL"
><SPAN
CLASS="QUOTE"
>"GNU Free Documentation License"</SPAN
></A
>.</P
><P
>If you have any questions, please contact <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto at metalab.unc.edu"
>linux-howto at metalab.unc.edu</A
>&#62;</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DISCLAIMERS"
>1.2. Disclaimers</A
></H3
><P
> No liability for the contents of this documents can be accepted by the author, the <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
> or anyone else. Use the concepts, examples and other content at your own risk. There may be errors and inaccuracies that may damage your system. Proceed with caution, and, although errors are unlikely, the author take no responsibility for them.</P
><P
> All copyrights are held by their by their respective owners, unless specifically noted otherwise.  Use of a term in this document should not be regarded as affecting the validity of any trademark or service mark.</P
><P
>Naming of particular products or brands should not be seen as endorsements.</P
><P
>You are strongly recommended to take a backup of your system before major installation and backups at regular intervals. In addition, you are strongly recommended to use a sacrificial experimental computer when mucking with the material, especially the scripts, in this HOWTO.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NEWVERSIONS"
>1.3. New Versions</A
></H3
><P
>You can find this document at its <A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO.html"
TARGET="_top"
>home page</A
> or at the <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
> web site in many formats. Please comment to <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</CODE
></P
><P
>Depending on your browser, you may have to hold down the shift button while you click on these in order to get them to download.</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.chunky.html.tar.bz2"
TARGET="_top"
>bzip2 compressed chunky (lots of small pages. Faster reading.) HTML</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.smooth.html.tar.bz2"
TARGET="_top"
>bzip2 compressed smooth (one monster page -- no chunks. Easier to search.) HTML</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.ps.bz2"
TARGET="_top"
>bzip2 compressed postscript (US letter format)</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.pdf.bz2"
TARGET="_top"
>bzip2 compressed PDF (US letter format)</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.txt.bz2"
TARGET="_top"
>bzip2 compressed raw ASCII text</A
>.</P
></LI
><LI
><P
>Use the <A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.tar.bz2"
TARGET="_top"
>source</A
>, Luke.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/md5sums"
TARGET="_top"
>MD5</A
> and <A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/sha1sums"
TARGET="_top"
>SHA1</A
> sums.</P
></LI
></UL
><P
>To ensure that you got a good download, validate the files against the checksums above. The easiest way to do this is to pull in the sha1sum or md5sum files (or both), and run the appropriate program against it:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>$ sha1sum -c sha1sums</PRE
></FONT
></TD
></TR
></TABLE
><P
>or/and</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>$ md5sum -c md5sums</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CREDITS"
>1.4. Credits</A
></H3
><P
>This document is derived from two articles originally published in <A
HREF="http://www.linuxjournal.com/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux Journal</I
></A
>. My thanks to <I
CLASS="CITETITLE"
>Linux Journal</I
> for reverting the rights to those articles, thereby helping make this HOWTO possible.</P
><P
>Thanks to Joy Y. Goodreau for excellent HOWTO editing, and to David Palomares for correcting the spelling of Salvador Dal&#297;'s name.</P
><P
>Also, thanks to <A
HREF="mailto:pon at iki dot fi"
TARGET="_top"
>Pasi Oja-Nisula</A
> for a bug fix and information on <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FEEDBACK"
>1.5. Feedback</A
></H3
><P
>    Feedback is most certainly welcome for this document. Without your corrections, suggestions and other input, this document wouldn't exist. Please send your additions, comments and criticisms to me at: <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TRANSLATIONS"
>1.6. Translations</A
></H3
><P
>Not everyone speaks English. Volunteers are welcome.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="OVERVIEW"
>2. Overview</A
></H2
><P
>The process shown below is not easy, and can be hazardous to your data. Practice it before you need it! Do as I did, and <EM
>practice on a sacrificial computer</EM
>!</P
><P
>The original target computer for this HOWTO was a Pentium computer. Originally, it had a <A
HREF="http://www.redhat.com"
TARGET="_top"
>Red Hat</A
> 7.1 Linux server or workstation installation on one IDE hard drive. Since then, I have used a number of computers, and they have been ugraded to Red Hat 8.0 and <A
HREF="http://fedora.redhat.com/"
TARGET="_top"
>Fedora Cores 1, 3 and 4.</A
>. The target computer does not have vast amounts of data because the computer was set up as a <SPAN
CLASS="QUOTE"
>"sacrificial"</SPAN
> test bed. That is, I did not want to test this process with a production computer and production data. Also, I did a fresh installation before I started the testing so that I could always re-install if I needed to revert to a known configuration.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The sample commands will show, in most cases, what I had to type to recover the target system. You may have to use similar commands, but with different parameters. It is up to you to be sure you duplicate your setup, and not the test computer's setup.</P
></TD
></TR
></TABLE
></DIV
><P
>The basic procedure is set out in W. Curtis Preston, <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>, O'Reilly &#38; Associates, 1999, which I have favorably reviewed in <A
HREF="http://www2.linuxjournal.com/lj-issues/issue78/3839.html"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux Journal</I
></A
>. However, the book is a bit thin on specific, real-time questions. For example, exactly which files do you back up? What metadata should you preserve, and how? This document explores those questions.</P
><P
>Before beginning the process set forth in this HOWTO you will need to back up your system with a typical backup tool such as Amanda, <SPAN
CLASS="TRADEMARK"
>BRU</SPAN
>&#8482;, tar, <SPAN
CLASS="TRADEMARK"
>Arkeia</SPAN
>&reg; or cpio. The question, then, is how to get from toasted hardware to the point where you can run the restoration tool that will restore your data.</P
><P
>Users of Red Hat Package Manager (RPM) based Linux distributions should also save RPM metadata as part of their normal backups. The following is in one of the scripts in this HOWTO:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -Va | sort +2 -t ' ' | uniq &#62; /etc/rpmVa.txt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>It provides a basis for comparison after a bare metal restoration.</P
><P
>To get to this point, you must have:</P
><P
></P
><UL
><LI
><P
>Your hardware up and running again, with replacement components as needed. The BIOS should be correctly configured, including time and date, and hard drive parameters. At the moment, there is no provision for using a different hard drive.</P
></LI
><LI
><P
>When I started this project, I used a <A
HREF="http://www.iomega.com/zip/products/par100_250.html"
TARGET="_top"
><SPAN
CLASS="TRADEMARK"
>ZIP</SPAN
>&reg; drive</A
>. Now, they are rather cramped for space and can be inconvenient. You can substitute a USB flash disk, NFS mount, CD-RW or other medium. Just be sure that the Linux distribution you use for first stage restore supports your medium. For historical reasons, this document will refer to the <A
HREF="http://www.iomega.com/zip/products/par100_250.html"
TARGET="_top"
><SPAN
CLASS="TRADEMARK"
>ZIP</SPAN
>&reg; drive</A
>; please substitute the medium of your choice. There is more discussion of alternatives below in the section on <A
HREF="#THEMEANDVARIATIONS"
>Theme And Variations</A
>.</P
></LI
><LI
><P
>Your normal backup media: tape hard drive, etc.</P
></LI
><LI
><P
>A minimal Linux system that will allow you to run the restoration software, which we will call the restoration Linux.</P
></LI
></UL
><P
>To get there, you need at least two stages of backup, and possibly three. Exactly what you back up and in which stage you back it up is determined by your restoration process. For example, if you are restoring a tape server, you may not need networking during the restoration process. So only back up networking in your regular backups.</P
><P
>You will restore in stages as well. In stage one, we build partitions, file systems, etc. and restore a minimum of files from the ZIP disk. The goal of stage one is to be able to boot to a running computer with a network connection, tape drives, restoration software, or whatever we need for stage two.</P
><P
>The second stage, if it is necessary, consists of restoring backup software and any relevant databases. For example, suppose you use Arkeia and you are building a bare metal recovery ZIP disk for your backup server. Arkeia keeps a huge database on the server's hard drives. You can recover the database from the tapes, if you want. Instead, why not tar and gzip the whole arkeia directory (at /usr/knox), and save that to another computer over NFS or SSH? Stage one, as we have defined it below, does not include X, so you will have some experimenting to do if you wish to back up X as well as your backup program. Some restore programs require X.</P
><P
>Of course, if you are using some other backup program, you may have some detective work to do to. You will have to find out the directories and files it needs to run. If you use tar, gzip, cpio, mt or dd for your backup and recovery tools, they will be saved to and restored from our ZIP disk as part of the stage one process describe below.</P
><P
>The last stage is a total restoration from tape or other media. After you have done that last stage, you should be able to boot to a fully restored and operational system.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LIMITATIONS"
>2.1. Limitations</A
></H3
><P
>This HOWTO is restricted to making a minimal backup such that, having then restored that backup to new hardware (<SPAN
CLASS="QUOTE"
>"bare metal"</SPAN
>), you can then use your regular backups to restore a completely working system. This HOWTO does not deal with your regular backups at all.</P
><P
>Even within that narrow brief, this HOWTO is not exhaustive. You still have some research, script editing, and testing to do.</P
><P
>The scripts here restore the partition data exactly as found on the source hard drive. This is nice if you are restoring on an identical computer or at least an identical hard drive, but that is often not the case. For now, there are two remedies (which will make more sense after you've read the rest of the HOWTO):</P
><P
></P
><UL
><LI
><P
>Edit the partition table input file. I've done that a few times. You can also do this to add new partitions or delete existing ones (but edit the scripts that use the partition table input file as well).</P
></LI
><LI
><P
>Hand build a new partition table and go from there. That is one reason why <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> does not call the hard drive rebuilding script. Use the <A
HREF="#MAKE.DEV.HDA"
>rebuilding script</A
>.</P
></LI
></UL
><P
>The scripts shown here only handle ext2fs, FAT12, FAT16 and FAT32. Until some eager volunteer supplies code for doing so in these scripts, you will need other tools for backing up and restoring file systems we haven't covered. However, see the note below on <A
HREF="#NTFS"
>NTFS</A
>. <A
HREF="http://www.partimage.org/"
TARGET="_top"
>Partition Image</A
> looks like a useful candidate here.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PREPARATION"
>3. Preparation</A
></H2
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do your normal backups on their regular schedule. This HOWTO is useless if you don't do that.</P
></TD
></TR
></TABLE
></DIV
><P
>Build yourself a restoration Linux disk. I have used <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>. See the notes on <A
HREF="#KNOPPIX"
>Knoppix</A
> below. However, everything here is command line. We don't need a GUI. A GUI-less distribution will boot faster and can load itself into memory (so you can use the CD drive) even on a minimal machine. For this I now use <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
>.</P
><P
>In the past, I have used <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. It is well documented and packs a lot of useful tools onto one floppy diskette. Unfortunately, the changes I've had to make in the scripts to handle more recent Linux systems cause problems for <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. The <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> 2.0.103 tar is based on <A
HREF="http://www.busybox.net/"
TARGET="_top"
>busybox</A
>, so remarks about it may apply to other Linux disties which use busybox.</P
><P
>Next, figure out how to do the operating system backup you will need so that you can restore your normal backup. I used to follow Preston's advice and use an Iomega parallel port ZIP drive. The drives get approximately 90 MB of useful storage to a disk. I need about 85 MB to back up my desktop, so a 100MB ZIP drive may be pushing your luck. These days I use CD-RWs or NFS. For more on those, see the sections on using <A
HREF="#AEN395"
>CD-ROM</A
>s and <A
HREF="#AEN431"
>NFS</A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INSTALLINGZIPDRIVE"
>3.1. Installing the ZIP Drive</A
></H3
><P
>Installing the ZIP drive is covered in the <A
HREF="http://www.tldp.org/HOWTO/mini/ZIP-Drive.html"
TARGET="_top"
>ZIP Drive HOWTO</A
>, available at <A
HREF="http://www.tldp.org/"
TARGET="_top"
>the Linux Documentation Project</A
> and at its home page, <A
HREF="http://www.njtcom.com/dansie/zip-drive.html"
TARGET="_top"
>http://www.njtcom.com/dansie/zip-drive.html</A
>. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BACKUP.SERVER"
>3.2. Backup Server</A
></H3
><P
>You can set up a backup server for this process. Scripts on the backup server interact with the target machines (including itself) via SSH. They assume that your backup server user (root here, for simplicity) can log in with no password to the targets. This is necessary for unattended backups.</P
><P
>First, create a suitable directory to keep all the backups in. We'll call it <TT
CLASS="FILENAME"
>backs</TT
>. In backs, create a directory for each target computer. The first field in the directory should be the host name. Subsequent fields can be other useful information. For example, to preserve the last backup of a target before an installation of a new version of the distribution, I use an abbreviation for the distribution, e.g. <SPAN
CLASS="QUOTE"
>"fc5"</SPAN
>. Fields are separated with periods (<SPAN
CLASS="QUOTE"
>"."</SPAN
>). So, for example, <TT
CLASS="FILENAME"
>tester.f7</TT
>. The host name is required because the scripts use that to determine which host to back up.</P
><P
>Copy the scripts <TT
CLASS="FILENAME"
>get</TT
> and <TT
CLASS="FILENAME"
>restore</TT
> into each target's directory. Then customize them for each host as needed.</P
><P
>Also create in <TT
CLASS="FILENAME"
>backs</TT
> a directory called <TT
CLASS="FILENAME"
>scripts</TT
> and put in it the script <TT
CLASS="FILENAME"
>get.target</TT
>. This is a library for the backup and restore scripts. It performs actions common to all backups and restorations.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CREATINGTHESTAGE1BACKUP"
>4. Creating the Stage 1 Back Up</A
></H2
><P
>Having made your production backups, you need to preserve your partition information so that you can rebuild your partitions.</P
><P
>The script <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> scans a hard drive for partition information, and saves it in four files. The first is an executable script, called <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.x</TT
></A
> (where <SPAN
CLASS="QUOTE"
>"x"</SPAN
> is the name of the device file, e.g. hda). Second is <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.x</TT
></A
>, which creates mount points and mounts the newly created partitions on them. The next, <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.x</TT
></A
>, is the commands necessary for <B
CLASS="COMMAND"
>fdisk</B
> to build the partitions. Last is an input file for <B
CLASS="COMMAND"
>sfdisk</B
> to create partions. (<B
CLASS="COMMAND"
>sfdisk</B
> is preferable and used if found.) You specify which hard drive you want to build scripts for (and thus the file names) by naming the associated device file as the argument to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. For example, on a typical IDE system,</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>make.fdisk /dev/hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>spits out the scripts <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>, <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.hda</TT
></A
> and the input files for <B
CLASS="COMMAND"
>fdisk</B
> and <B
CLASS="COMMAND"
>sfdisk</B
>, <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> and <A
HREF="#DEV.HDA.SFD"
><TT
CLASS="FILENAME"
>dev.hda.sfd</TT
></A
>, respectively.</P
><P
>In addition, if <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> encounters a FAT partition, it preserves the partition's boot sector in a file named <TT
CLASS="FILENAME"
>dev.xy</TT
>, where x is the drive's device name (e.g. sdc, hda) and y is the partition number. The boot sector is the first sector, 512 bytes, of the partition. This sector is restored at the same time the partitions are rebuilt, in the script <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>.</P
><P
>Fortunately, the price of hard drives is plummeting almost as fast as the public's trust in politicians after an election. So it is good that the output files are text, and allow hand editing. That's the most difficult but most flexible way to rebuild on a larger replacement drive. (See the <A
HREF="#TODO"
>To Do list</A
>.)</P
><P
>Other metadata are preserved by the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>. The script saves the partition information in the file <TT
CLASS="FILENAME"
>fdisk.hda</TT
> in the root of the ZIP disk. It is a good idea to print this file and your <TT
CLASS="FILENAME"
>/etc/fstab</TT
> so that you have hard copy should you ever have to restore the partition data manually. You can save a tree by toggling between two virtual consoles, running <B
CLASS="COMMAND"
>fdisk</B
> in one and catting <TT
CLASS="FILENAME"
>/etc/fstab</TT
> or <TT
CLASS="FILENAME"
>/fdisk.hda</TT
> as needed. However, doing so is error prone.</P
><P
>You will also want to preserve files relevant to your restoration method. For example, if you use NFS to save your data, you will need to preserve hosts.allow, hosts.deny, exports, etc. Also, if you are using any network-backed restoration process, such as Amanda or Quick Restore, you will need to preserve networking files like HOSTNAME, hosts, etc. and the relevant software tree.</P
><P
>The simplest way to handle these and similar questions is to preserve the entire <TT
CLASS="FILENAME"
>/etc</TT
> directory.</P
><P
>There is no way a 100 MB ZIP drive is going to hold a server installation of a modern distribution of Linux. We have to be much more selective than simply preserving the whole kazoo. What files do we need?</P
><P
></P
><UL
><LI
><P
>The boot directory.</P
></LI
><LI
><P
>The /etc directory and subdirectories.</P
></LI
><LI
><P
>Directories needed at boot time.</P
></LI
><LI
><P
>Device files in /dev.</P
></LI
></UL
><P
>To determine the directories needed at boot, we look at the boot initialization file <TT
CLASS="FILENAME"
>/etc/rc.sysinit</TT
>. It sets its own path like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH</PRE
></FONT
></TD
></TR
></TABLE
><P
>Trial and error indicated that we needed some other directories as well, such as <TT
CLASS="FILENAME"
>/dev</TT
>. In Linux, you can't do much without device files.</P
><P
>In reading the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, note that we aren't necessarily saving files that are called with absolute paths.</P
><P
>We may require several iterations of back up, test the bare metal restore, re-install from CD and try again, before we have a working backup script. While I worked on this HOWTO, I made five such iterations before I had a successful restoration. That is one reason why it is essential to use scripts whenever possible. Test thoroughly!</P
><P
>One thing you can do on an RPM based system is use the <B
CLASS="COMMAND"
>rpm</B
> program to determine which files are where. For example, to get a complete list of the files used by the openssh package, run:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -ql openssh</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>There are some things you don't need, like the man pages. You can inspect each one and decide whether to back it up or not.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The second stage of restoration is run without overwriting previously restored files. This means that the files restored in the first stage are the ones that will be used after full restoration. So update your bare metal backups whenever you update files in these directories!</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Recent kernels have incorporated a new ATA (IDE) hard drive driver, libata. Because of this, parallel ATA drives (PATA) now show up as SCSI drives, as serial ATA (SATA) have always done. However, not all rescue distributions (e.g. finix) use this new driver. There is a line toward the bottom of <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
> wich very carefully replaces "/dev/sda" with "/dev/hda". Use this as a template if you have multiple IDE hard drives. Comment it out or delete it if this is not an issue for you.</P
><P
>Note that there is no guaranteed mapping! Systems with multiple hard drives may have confusing mappings. Be sure to edit this line carefully. Check it if you add or remove a hard drive of any interface type to or from your system!</P
><P
>N.B: if you have libata IDE drive issues, the grub-install line at the end of <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> won't work. If it doesn't, use your rescue disk to do the same. Or burn and boot to the boot image that is made as part of the first stage backup. Boot to it and do the second state restore as usual. The second state restore should re-run <TT
CLASS="FILENAME"
>grub-install</TT
> or you can run it manually.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version of <B
CLASS="COMMAND"
>tar</B
> included in <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> does not preserve ownership when it restores. This may cause problems for applications like <A
HREF="#AMANDA"
>Amanda</A
>. A backup and restoration tool, Amanda has several directories owned by its own eponymous user. The solution is:</P
><P
></P
><UL
><LI
><P
>Note which directories and files are not owned by root.</P
></LI
><LI
><P
>Note their owners.</P
></LI
><LI
><P
>Arrange to set the ownership correctly as part of the restoration process. E.g:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>chown -R amanda:disk /var/lib/amanda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You can also add that line to your scripts for second state restoration, such as <A
HREF="#RESTORE"
><TT
CLASS="FILENAME"
>restore</TT
></A
>.</P
></LI
></UL
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> does not support restoring owners by UID/GID. To make backups suitable for restoring with <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, remove the tar command line option <SPAN
CLASS="QUOTE"
>"--numeric-owner"</SPAN
> from the command line options for tar in the function crunch in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN372"
>4.1. The Archive</A
></H3
><P
>All of this gets stored into an archive under <TT
CLASS="FILENAME"
>/var/lib/bare.metal.recovery</TT
>. Each day a first stage backup is made a new directory is prepared, with the date encoded as YYYYMMDD, and the day's archive deposited therein. It is up to you to prune obsolete archives. It is a good idea to keep at least one old archive around in case the computer crashes while you are making an archive. If a second archive is made in a day, the earlier one for that day is replaced.</P
><P
>The files in the archive directory include a <TT
CLASS="FILENAME"
>README.txt</TT
>, which has information about the backup and the computer the backup was made on. Other files are there in case hand intervention is required.</P
><P
>Below the daily archive directory are several text files and three directories. The scripts reside in <TT
CLASS="FILENAME"
>bin</TT
>, the tarballs in <TT
CLASS="FILENAME"
>data</TT
>, and information about the system such as partitions and LVM volume backups are in <TT
CLASS="FILENAME"
>metadata</TT
>.</P
><P
>To create a CD, simply use a script or graphical tool to create a CD starting at the daily archive directory. It is up to you to be sure your archive will fit onto your medium, or to make other arrangements.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="THEMEANDVARIATIONS"
>4.2. Theme And Variations</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN385"
>4.2.1. No ZIP drive</A
></H4
><P
>This backup process used to require you to have the ZIP disk drive present at each backup. It now creates the archive in a directory, which you can back up over the net. Then you only need to build a ZIP disk (with <B
CLASS="COMMAND"
>cp -rp</B
>) on the backup server when you need to restore.</P
><P
>The backup process will be faster than directly writing to the ZIP drive, but you should check that the resulting directory will fit on your ZIP disk (with the output of <B
CLASS="COMMAND"
>du -hs $target.zip</B
> in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>)! See the definition of the variable <CODE
CLASS="VARNAME"
>zip</CODE
> in that script.</P
><P
>One of my laptops has problems running both a network card and a ZIP drive, so this is the process I use to back it up. I keep a backup image as well as the current one, so that I have a fallback in case the computer crashes during a backup.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN395"
>4.2.2. CD-ROM</A
></H4
><P
>This is similar to the no ZIP drive option above. Save your backups to a directory on your hard drive, as noted. Then use <B
CLASS="COMMAND"
>mkisofs</B
> to create an ISO 9660 image from that directory, and burn it. This does not work with some CD-ROM based restoration Linuxes, like <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, because the Linux has to have the CD-ROM drive. Unless you have two CD-ROM drives, say one in a USB clamshell. I have a DVD burner set up this way with exactly this in mind. Or have <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
> load itself into memory on boot and then use the CD-ROM drive from which you booted.</P
><P
>These remarks should also apply to DVDs.</P
><P
>Also, look at <A
HREF="http://www.knoppix.net/wiki/Knoppix_Remastering_Howto"
TARGET="_top"
>remastering</A
> Knoppix with your first and second stage backups on the CD-ROM. You should also be able to <A
HREF="http://www.finnix.org/Remastering_Finnix"
TARGET="_top"
>remaster Finnix</A
>.</P
><P
>These days many computers come with a CD-ROM drive but no floppy diskette. And floppy drives do fail. So it's a good idea to burn your CD-ROM with a bootable image on it. The bad news is that the <SPAN
CLASS="QUOTE"
>"El Torito"</SPAN
> format supports 1.2 MB, 1.44 MB and 2.88 MB floppy images, and <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> uses a 1.7 MB floppy. The good news is that you can get a 2.88 MB version, <TT
CLASS="FILENAME"
>tomsrtbt-2.0.103.ElTorito.288.img</TT
>, from the same mirrors where you get the floppy image. Place a <EM
>copy</EM
>
<A
NAME="AEN410"
HREF="#FTN.AEN410"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
 in the root directory of the backup files. Then use the <B
CLASS="COMMAND"
>mkisofs</B
> command line option -b to specify <TT
CLASS="FILENAME"
>tomsrtbt-2.0.103.ElTorito.288.img</TT
> as the boot image file.</P
><P
>The only down side of this process is that many older BIOSes do not support 2.88 MB floppy images on CD-ROMs. Most of those will boot to a <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> floppy.</P
><P
>An alternative is to use <A
HREF="http://syslinux.zytor.com/"
TARGET="_top"
>Syslinux</A
>. It is not dependent on a floppy diskette image, and you can build your own CD with a number of tools, such as <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, on it.</P
><P
>You may have to adjust the BIOS options to allow the computer to boot to CD-ROM drive. If you can't do that, either because the BIOS won't support booting to CD-ROM, or because you can't get into the BIOS, see <A
HREF="http://btmgr.webframe.org/"
TARGET="_top"
>Smart Boot Manager (SBM)</A
> as described in the <A
HREF="#RESOURCES"
>Resources</A
>.</P
><P
>One variant is to dispense with the tarballs in the first stage, and create a tarball of the entire system. When you build your restoration CD, put the monster tarball in the data directory of the CD. The scripts will pick that up and restore for you, combining the first and second stages. This eliminates a lot of the cruft related to permissions and ownership in <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> and <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
></P
><P
><EM
>Test</EM
> your CDs on the drive you will use at restoration time. If you find you need to hack the scripts, you can copy them to <TT
CLASS="FILENAME"
>/tmp</TT
>, usually a RAM drive, and edit them there. The scripts will run there. As a RAM disk is volatile, be sure to save your changes before you reboot!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN431"
>4.2.3. NFS</A
></H4
><P
>If you back up across your network to a backup server, you will have all the files on it you need. Set up the directory where you keep all your backups as an NFS export.</P
><P
>Then, on <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
>, do the following (tab completion is very nice here):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>mkdir /mnt/nfs</B
>
# <B
CLASS="COMMAND"
>/etc/init.d/portmap start</B
>
# <B
CLASS="COMMAND"
>mount server:/path/of/exportedfs /mnt/nfs</B
>
# <B
CLASS="COMMAND"
>cd /mnt/nfs/.../bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now restore as usual.</P
><P
>There are several advantages to NFS for this job: You don't have to worry about space on a CD-ROM or <A
HREF="http://www.iomega.com/zip/products/par100_250.html"
TARGET="_top"
><SPAN
CLASS="TRADEMARK"
>ZIP</SPAN
>&reg; drive</A
>. You can edit scripts on the server and they are preserved when you reboot the target.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN445"
>4.2.4. Multiple ZIP disks</A
></H4
><P
>By splitting up the two first stage scripts, <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> and <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, you could spread the first stage metadata across multiple ZIP disks.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN452"
>4.2.5. Excluding From First Stage Saving</A
></H4
><P
>There are time when you need to squeeze a few megabytes from the first stage data, especially when you are pushing the limit of your ZIP disk. The function <B
CLASS="COMMAND"
>crunch</B
> in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
> takes multiple parameters to feed to <B
CLASS="COMMAND"
>tar</B
>. It can also take the <B
CLASS="COMMAND"
>--exclude</B
> parameter. So, for example, you can exclude the <TT
CLASS="FILENAME"
>samba</TT
> and <TT
CLASS="FILENAME"
>X11</TT
> directories under <TT
CLASS="FILENAME"
>/etc</TT
> like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>crunch etc --exclude etc/samba --exclude etc/X11 etc</PRE
></FONT
></TD
></TR
></TABLE
><P
>Why those two? Because they're hard drive space hogs and we don't need them when booting after the first stage.</P
><P
>If you keep multiple kernels around, you can eliminate the modules for all of the kernels you won't boot to. Check your <TT
CLASS="FILENAME"
>lilo.conf</TT
> or <TT
CLASS="FILENAME"
>/boot/grub/menu.lst</TT
> to see which kernel you will use, and then check <TT
CLASS="FILENAME"
>/lib/modules</TT
> for module directories you can exclude.</P
><P
>How to find more good candidates for exclusion? List the target directories with <B
CLASS="COMMAND"
>ls -alSr</B
> for individual files, and <B
CLASS="COMMAND"
>du | sort -n</B
> for directories.</P
><P
>Another (probably neater) way to exclude directories is to put a complete list of directories into a file, then refer to it via the tar option <TT
CLASS="FILENAME"
>--exclude-from=FILENAME</TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INITRD"
>4.2.6. Initrd</A
></H4
><P
>If your system uses an initial RAM disk, or initrd, to boot, make sure that <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> creates the directory <TT
CLASS="FILENAME"
>/initrd</TT
>. The easiest way to do this is to ensure that it is included in the list of directories used in the directory creating loop toward the end.</P
><P
>Your system will probably use an initrd if it boots from a SCSI drive or has root on an ext3fs partition. Check <TT
CLASS="FILENAME"
>/etc/lilo.conf</TT
> or <TT
CLASS="FILENAME"
>/boot/grub/menu.lst</TT
> to see if it calls for one.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FIRSTSTAGERESTORE"
>5. First Stage Restore</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="BOOTING"
>5.1. Booting</A
></H3
><P
>The first thing to do is to verify that the hardware time is set correctly. Use the BIOS setup for this. How close to exact you have to set the time depends on your applications. For restoration, within a few minutes of exact time should be accurate enough. This will allow time-critical events to pick up where they left off when you finally launch the restored system.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="BOOTINGTOMSRTBT"
>5.1.1. tomsrtbt</A
></H4
><P
>Before booting <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, make sure your ZIP drive is installed on a parallel port, either <TT
CLASS="FILENAME"
>/dev/lp0</TT
> or <TT
CLASS="FILENAME"
>/dev/lp1</TT
>. The start-up software will load the parallel port ZIP drive driver for you.</P
><P
>The next step is to set the video mode. I usually like to see as much on the screen as I can. When the option to select a video mode comes, I use mode 6, 80 columns by 60 lines. Your hardware may or may not be able to handle high resolutions like that, so experiment with it.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="BOOTINGKNOPPIX"
>5.1.2. Knoppix</A
></H4
><P
>These instructions will probably work with other CD-ROM or USB pen Linuxes, but you may have to vary them to suit.</P
><P
>Before booting <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, make sure your ZIP drive (or substitute) is installed on a parallel port, either <TT
CLASS="FILENAME"
>/dev/lp0</TT
> or <TT
CLASS="FILENAME"
>/dev/lp1</TT
>. Knoppix does not load the parallel port ZIP drive driver for you. Instead, use the command <B
CLASS="COMMAND"
>modprobe ppa</B
> (as root) to install it.</P
><P
>Boot <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> as usual. I find it faster and more useful to boot to a console. At the boot menu, use the command <SPAN
CLASS="QUOTE"
>"knoppix 2"</SPAN
>. Then become the root user, with <B
CLASS="COMMAND"
>su -</B
>. For the password, just hit return.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="BOOTINGFINNIX"
>5.1.3. Finnix</A
></H4
><P
>One option for booting <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
> is the "toram" option, which lets you move the whole kazoo into RAM. That in turn should let you load another CD, with your first stage data, into the CD drive.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RESTORATION"
>5.2. Restoration</A
></H3
><P
>These instructions assume you are running <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. If you are using a different Linux for your restore system, you may have to adjust these instructions a bit. For example, you should always run these scripts as root even if some other user gives you the requisite privileges.</P
><P
>Once the restoration Linux has booted and you have a console, mount the ZIP drive. It is probably a good idea to mount it read only. On <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>mount /dev/sda1 /mnt -o ro</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Check to be sure it is there:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>ls -l /mnt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>On <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> or <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
>, you may want to make a directory under <TT
CLASS="FILENAME"
>/mnt</TT
> and mount it there, like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>mkdir /mnt/zip</B
>
# <B
CLASS="COMMAND"
>mount /dev/sda1 /mnt/zip -o ro</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now cd into the mounted device, and into the <TT
CLASS="FILENAME"
>bin</TT
> directory below it. On <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
>, for example:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>cd /mnt/zip/bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>The scripts assume you are in this directory, and call data files relative to it. At this point, you can run the restoration automatically or manually. Use the automated restore if you don't need to make any changes as you go along.</P
><P
>One consideration here is whether you have multiple hard drives. If your Linux installation mounts partitions on multiple hard drives, you must mount the root partition first. This is to ensure that mount point directories are created on the partition where they belong. The script <A
HREF="#FIRST.STAGE"
>first.stage</A
> will run the scripts to mount the drives in the order in which they are created. If you have created them (in the script <TT
CLASS="FILENAME"
>save.metadata</TT
>) in the order in which they cascade from root, the mounting process should work just fine.</P
><P
>If you have multiple hard drives, and they cross-mount, you are on your own. Either combine and edit the scripts to mount them in the correct order, or do it manually.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN539"
>5.2.1. Automated</A
></H4
><P
>The automatic process calls each of the manual scripts in proper order. It does not allow for manual intervention, say for creating file systems that this HOWTO does not support. To run the first stage restore automatically, enter the command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>first.stage</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to check for back blocks, add the <B
CLASS="COMMAND"
>-c</B
> option.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN546"
>5.2.2. Manually</A
></H4
><P
>Run the script(s) that will restore the partition information and create file systems. You may run them in any order, so long as they build dependencies in the correct order. You can read the script <A
HREF="#FIRST.STAGE"
>first.stage</A
> to get an idea of the order. e.g.:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./make.dev.hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to check for back blocks, add the <B
CLASS="COMMAND"
>-c</B
> option.</P
><P
>This script will:</P
><P
></P
><UL
><LI
><P
>Clean out the first 1024 bytes of the hard drive, killing off any existing partition table and master boot record (MBR).</P
></LI
><LI
><P
>Recreate the non-LVM partitions from the information gathered when you ran <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>.</P
></LI
><LI
><P
>Make ext2 and ext3 file systems on non-LVM partitions and Linux swap partitions as appropriate. If you provide the <B
CLASS="COMMAND"
>-c</B
> option to the script, it will also check for bad blocks.</P
></LI
><LI
><P
>Make some types of FAT partitions.</P
></LI
></UL
><P
>Now is a good time to check the geometry of the drive. Sometimes different versions of Linux pick up different geometries, so the geometry implicit in the file <TT
CLASS="FILENAME"
>dev.hdX</TT
> is incorrect. To force it to be correct on <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, edit <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.x</TT
></A
>. Use the -C, -H and -S options to fdisk to specify the cylnders, heads and sectors, respectively. Those you can get from the file <TT
CLASS="FILENAME"
>fdisk.hdX</TT
> in the root directory of the ZIP drive. Then re-run it.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you have other operating systems or file systems to restore, now is a good time to do so. When you've done that, reboot to your restoration Linux and continue your first stage restoration.</P
></TD
></TR
></TABLE
></DIV
><P
>If you have LVM volumes to restore, now is the time to run <TT
CLASS="FILENAME"
>make.lvs</TT
> and <TT
CLASS="FILENAME"
>mount.lvs</TT
>.</P
><P
>Now run the script(s) that create mount points and mount the partitions to them.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./mount.dev.hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Once you have created all your directories and mounted partitions to them, you can run the script <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./restore.metadata</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>This will restore the contents of the ZIP drive to the hard drive to give you a minimal bootable system.</P
><P
>You should see a directory of the ZIP disk's root directory, then a list of the archive files as they are restored. Tar on <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> will tell you that tar's block size is 20, and that's fine. You can ignore it. Be sure that lilo prints out its results:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Added linux *</PRE
></FONT
></TD
></TR
></TABLE
><P
>That will be followed by the output from a <SPAN
CLASS="QUOTE"
>"<B
CLASS="COMMAND"
>df -m</B
>"</SPAN
> command.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN594"
>5.2.3. Finishing Touches</A
></H4
><P
>If you normally boot directly to X, you could have some problems. To be safe, the first stage script changes the run level in <TT
CLASS="FILENAME"
>/target/etc/inittab</TT
> to 3. Note: different distributions use different run level schemes. 3 works on Red Hat derived distributions; it may not on others.</P
><P
>You can now gracefully reboot. Remove the medium from your boot drive if you haven't already done so, and give the computer the three fingered salute, or its equivalent:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>shutdown -r now</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>or</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>reboot</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>The computer will shut down and reboot.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SECONDSTAGERESTORATION"
>6. Second Stage Restoration</A
></H2
><P
>As the computer reboots, go back to the BIOS and verify that the clock is more or less correct.</P
><P
>Once you have verified the clock is correct, exit the BIOS and reboot to the hard drive. You can simply let the computer boot in its normal sequence. You will see a lot of error messages, mostly along the lines of <SPAN
CLASS="QUOTE"
>"I can't find blah! Waahhh!"</SPAN
> If you have done your homework correctly up until now, those error messages won't matter. You don't need linuxconf or apache to do what you need to do.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>As an alternative, you can boot to single user mode (at the lilo prompt, enter <B
CLASS="COMMAND"
>linux single</B
>), but you will have to configure your network manually and fire up sshd or whatever daemons you need to restore your system. How you do those things is very system specific.</P
></TD
></TR
></TABLE
></DIV
><P
>You should be able to log into a root console (no X, no users, sorry). You should now be able to use the network, for example to NFS mount the backup of your system.</P
><P
>If you did the two stage backup I suggested for Arkeia, you can now restore Arkeia's database and executables. You should be able to run</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>/etc/rc.d/init.d/arkeia start</PRE
></FONT
></TD
></TR
></TABLE
><P
>and start the server. If you have the GUI installed on another computer with X installed, you should now be able to log in to Arkeia on your tape server, and prepare your restoration.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>When you restore, read the documentation for your restoration programs carefully. For example, tar does not normally restore certain characteristics of files, like suid bits. File permissions are set by the user's umask. To restore your files exactly as you saved them, use tar's p option. Similarly, make sure your restoration software will restore everything exactly as you saved it.</P
></TD
></TR
></TABLE
></DIV
><P
>To restore the test computer:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>restore.all</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you used tar for your backup and restoration, and used the -k (keep old files, don't overwrite) option, you will see a lot of this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tar: usr/sbin/rpcinfo: Could not create file: File exists
tar: usr/sbin/zdump: Could not create file: File exists
tar: usr/sbin/zic: Could not create file: File exists
tar: usr/sbin/ab: Could not create file: File exists</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is normal, as tar is refusing to overwrite files you restored during the first stage of restoration.</P
><P
>Then reboot. On the way down, you will see a lot of error messages, such as <SPAN
CLASS="QUOTE"
>"no such pid."</SPAN
> This is a normal part of the process. The shutdown code is using the pid files from daemons that were running when the backup was made to shut down daemons that were not started on the last boot. Of course there's no such pid.</P
><P
>Your system should come up normally, with a lot fewer errors than it had before; ideally no errors. The acid test of how well your restore works on an RPM based system is to verify all packages. During the first stage backup, a verification was performed on the system, producing the file <TT
CLASS="FILENAME"
>rpmVa.txt</TT
>. Verify your system again, and compare the results to the one made earlier. E.g.:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -Va | sort +2 -t ' ' | uniq &#62; ~/foo.txt
diff /mnt/zip/metadata/rpmVa.txt ~/foo.txt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Prelinking error messages are normal and you can ignore them. Do not first run the command <B
CLASS="COMMAND"
>/etc/cron.daily/prelink</B
> to remove them. Doing so may introduce new errors in the verification results that will skew your results.</P
><P
>Some files, such as configuration and log files, will have changed in the normal course of things, and you should be able to mentally filter those out of the report. Emacs users should check out its ediff facilities.</P
><P
>Now you should be up and running. It is time to test your applications, especially those that run as daemons. The more sophisticated the application, the more testing you may need to do. If you have remote users, disable them from using the system, or make it <SPAN
CLASS="QUOTE"
>"read only"</SPAN
> while you test it. This is especially important for databases, to prevent making any corruption or data loss worse than it already might be.</P
><P
>If you normally boot to X, it was disabled as part of the first stage restoration. Test X before you re-enable it. Re-enable it by changing that one line in <TT
CLASS="FILENAME"
>/etc/inittab</TT
>. Find the line that looks like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>id:3:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
><P
>and change it to this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>id:5:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Or just run this on the target to change it back. Note: different distributions use different run level schemes. These values work on Red Hat derived distributions; they may not on others.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>sed -i s/id:.:initdefault:/id:5:initdefault:/g /etc/inittab</PRE
></FONT
></TD
></TR
></TABLE
><P
>You should now be ready for rock and roll -- and some aspirin and a couch.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DISTRIBUTIONSPECIFICNOTES"
>7. Distribution Specific Notes</A
></H2
><P
>Below are distribution notes from past experiences. If you have additional notes that you would like to add for other distributions, please forward them to me.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FEDORA3"
>7.1. Fedora</A
></H3
><P
>The scripts now reflect Fedora 7, so you should not have to make any changes to these <A
HREF="#THESCRIPTS"
>scripts</A
>.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>I tested the above on a fresh installation of FC3. I had problems with devices after booting when I worked with a system that had been upgraded from FC2 to FC3.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="KNOPPIX"
>7.2. Knoppix</A
></H3
><P
>I used to use <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>. <A
HREF="mailto:pon at iki dot fi"
TARGET="_top"
>Pasi Oja-Nisula</A
> reports:</P
><A
NAME="AEN660"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>For me the best thing about using Knoppix is that I don't need a specific boot medium for each machine, but I can use the same tools all the time. And hardware support in Knoppix is really great. I don't have that much experience with different platforms, but all the machines I've tried have worked fine, scsi drivers are found and so on.</P
><P
>I'm doing this recovery thing by copying the backups over the network to other machine. The restore involves booting the Knoppix cd, fetching the metadata.tar.gz from the network machine. Then make.dev, mount.dev, fetching the other tar.gz files, grub and reboot. Some typing involved but thanks to your scripts it's quite straighforward. Unless changing from ide to scsi or something, but even then it's not that difficult, since Linux is easy to restore to different hardware.</P
></BLOCKQUOTE
><P
>Let me add to that <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> detects USB devices for you, which is really nice. They make excellent (and roomier) substitutes for the ZIP drive.</P
><P
>Also see <A
HREF="http://www-106.ibm.com/developerworks/linux/library/l-knopx.html?ca=dgr-lnxw04Knoppix"
TARGET="_top"
><SPAN
CLASS="QUOTE"
>"System recovery with Knoppix"</SPAN
></A
>.</P
><P
>Do your restore as user <SPAN
CLASS="QUOTE"
>"root"</SPAN
> rather than as user <SPAN
CLASS="QUOTE"
>"knoppix"</SPAN
>. Otherwise you may get some directories and files owned by an oddball user or group. Also, for <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, we tar the first stage stuff saving numeric user &#38; group values instead of by name. The names may point to different numbers on knoppix, so we would be restoring the files with incorrect user and group IDs.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN672"
>7.3. Finnix</A
></H3
><P
><A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
> has some of the same advantages of Knoppix. In addition, it runs in command line mode with mouse support, which is great for the task at hand. It's small, under 100 MB as of this writing, so you can remaster it with your first stage data on it. It boots quickly. And it has LVM support. And Zile, a subset of Emacs. I am pleased with <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
> for this use, and it is now my standard first stage restoration Linux.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APPLICATIONSPECIFICNOTES"
>8. Application Specific Notes</A
></H2
><P
>Here are some notes about backing up particular applications.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LVM"
>8.1. Logical Volume Manager</A
></H3
><P
>Handling logical volumes turns out to be a bit of a trick: use the <A
HREF="http://www.finnix.org/"
TARGET="_top"
>Finnix</A
> distribution's startup code to turn LVM on and off. This results in distribution specific code for the first stage of restoration. It is generated in <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. To edit it, search <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> for <SPAN
CLASS="QUOTE"
>"Hideous"</SPAN
>.</P
><P
>LVM required the addition of two new LVM specific scripts, <A
HREF="#MAKE.LVS"
><B
CLASS="COMMAND"
>make.lvs</B
></A
> and <A
HREF="#MOUNT.LVS"
><B
CLASS="COMMAND"
>mount.lvs</B
></A
>. They are only generated and used if there are logical volumes present.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SELINUX"
>8.2. Selinux</A
></H3
><P
>Selinux is disabled on the test machines. <TT
CLASS="FILENAME"
>/selinux</TT
> is not backed up in any of these scripts. At a guess, you should probably disable selinux after the first stage restoration, and you will probably have some selinux specific tasks to perform before turning it back on.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="GRUB"
>8.3. GRUB</A
></H3
><P
>The default bootloader in <A
HREF="#FEDORA3"
>Fedora</A
> is the <A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>Grand Unified Bootloader (GRUB)</A
>. It has to run at the end of the first stage, or you won't be able to boot thereafter. To preserve it for first stage restoration, make the following changes:</P
><P
></P
><UL
><LI
><P
>Edit the penultimate stanza of <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># Now install the boot sector.
# chroot $target /sbin/lilo -C /etc/lilo.conf
chroot $target /sbin/grub-install /dev/hda</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Add the following stanza to <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># Grub requires these at installation time.
if [ -d  usr/share/grub ] ; then # Red Hat/Fedora
  crunch usr.share.grub usr/share/grub
fi
if [ -d  usr/lib/grub ] ; then # SuSE
  crunch usr.lib.grub usr/lib/grub
fi</PRE
></FONT
></TD
></TR
></TABLE
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TRIPWIRE"
>8.4. Tripwire</A
></H3
><P
>If you run Tripwire or any other application that maintains a database of file metadata, rebuild that database immediately after restoring.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SQUID"
>8.5. Squid</A
></H3
><P
>Squid is a HTTP proxy and cache. As such it keeps a lot of temporary data on the hard drive. There is no point in backing that up. Insert <SPAN
CLASS="QUOTE"
>"--exclude /var/spool/squid"</SPAN
> into the appropriate tar command in your second stage backup script. Then, get squid to rebuild its directory structure for you. Tack onto the tail end of the second stage restore script a command for squid to initialize itself. Here is how I did it over SSH in <A
HREF="#RESTORE"
><TT
CLASS="FILENAME"
>restore</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>ssh $target "mkdir /var/spool/squid ; chown squid:squid /var/spool/squid;\
      /usr/sbin/squid -z;touch /var/spool/squid/.OPB_NOBACKUP"</PRE
></FONT
></TD
></TR
></TABLE
><P
>The last command creates a file of length 0 called .OPB_NOBACKUP. This is for the benefit of <A
HREF="#ARKEIA"
>Arkeia</A
>, and tells Arkeia not to back up below this directory</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ARKEIA"
>8.6. Arkeia</A
></H3
><P
>These notes are based on testing with Arkeia 4.2.</P
><P
><A
HREF="http://www.arkeia.com/"
TARGET="_top"
>Arkeia</A
> is a backup and restore program that runs on a wide variety of platforms. You can use Arkeia as part of a bare metal restoration scheme, but there are two caveats.</P
><P
>The first is probably the most problematic, as absent any more elegant solution you have to hand select the directories to restore in the navigator at restoration time. The reason is that, apparently, Arkeia has no mechanism for not restoring files already present on the disk, nothing analogous to <B
CLASS="COMMAND"
>tar</B
>'s -p option. If you simply allow a full restore, the restore will crash as Arkeia over-writes a library which is in use at restore time, e.g. <TT
CLASS="FILENAME"
>lib/libc-2.1.1.so</TT
>. Hand selection of directories to restore is at best dicey, so I recommend against it.</P
><P
>The second caveat is that you have to back up the Arkeia data dictionary and/or programs. To do that, modify the <TT
CLASS="FILENAME"
>save.metatdata</TT
> script by adding Arkeia to the list of directories to save:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># arkeia specific:
tar cf - usr/knox | gzip -c &#62; $zip/arkeia.tar.gz</PRE
></FONT
></TD
></TR
></TABLE
><P
>You <EM
>must</EM
> back up the data dictionary this way because Arkeia does not back up the data dictionary. This is one of my complaints about Arkeia, and I have solved it in the past by saving the data dictionary to tape with <A
HREF="http://www.estinc.com/"
TARGET="_top"
>The TOLIS Group's BRU</A
>.</P
><P
>The data dictionary will be restored in the script <TT
CLASS="FILENAME"
>restore.metadata</TT
> automatically.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AMANDA"
>8.7. Amanda</A
></H3
><P
><A
HREF="http://www.amanda.org/"
TARGET="_top"
>Amanda</A
> (The Advanced Maryland Automatic Network Disk Archiver) works quite well with this set of scripts. Use the normal Amanda back-up process, and build your first stage data as usual. Amanda stores the data on tape in GNU tar or cpio format, and you can recover from individual files to entire backup images. The nice thing about recovering entire images is that you can then use variants on the scripts in this HOWTO to restore from the images, or direct from tape. I was able to restore my test machine with the directions from W. Curtis Preston's <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>. For more information on it, see the <A
HREF="#RESOURCES"
>Resources</A
>. The Amanda chapter from the book is <A
HREF="http://www.backupcentral.com/amanda.html"
TARGET="_top"
>on line</A
>.</P
><P
>I made two changes to the script <A
HREF="#RESTORE"
><TT
CLASS="FILENAME"
>restore</TT
></A
>. First, I changed it to accept a file name as an argument. Then, since Amanda's <B
CLASS="COMMAND"
>amrestore</B
> decompresses the data as it restores it, I rewrote it to cat the file into the pipe instead of decompressing it.</P
><P
>The resulting line looks like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>cat $file | ssh $target "umask 000 ; cd / ; tar -xpkf - "</PRE
></FONT
></TD
></TR
></TABLE
><P
>where <B
CLASS="COMMAND"
>$file</B
> is the script's argument, the image recovered from the tape by <B
CLASS="COMMAND"
>amrestore</B
>.</P
><P
>Since the command line arguments to <B
CLASS="COMMAND"
>tar</B
> prohibit over-writing, restore from images in the <EM
>reverse</EM
> of the order in which they were made. Restore most recent first.</P
><P
>Amanda does require setting ownership by hand if you back up the amanda data directory with <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>. Something like:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>chown -R amanda:disk /var/lib/amanda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You can also add that line to your scripts for second state restoration, such as <A
HREF="#RESTORE"
><TT
CLASS="FILENAME"
>restore</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NTFS"
>8.8. NTFS</A
></H3
><P
>OK, NTFS isn't an application. It is a file system used by Microsoft operating system Windows NT and its descendents, including Windows 2000 and Windows XP. You can back it up and restore to it from Linux with <B
CLASS="COMMAND"
>ntfsclone</B
>, one of the NTFS utilities in the ntfsprogs suite, available from <A
HREF="http://www.linux-ntfs.org/"
TARGET="_top"
>http://www.linux-ntfs.org/</A
>.</P
><P
>These scripts will create NTFS partitions, but will not put a file system on them. It is not clear from the docs whether <B
CLASS="COMMAND"
>ntfsclone</B
> will lay down a file system on a virgin partition or not.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SOMEADVICEFORDISASTERRECOVERY"
>9. Some Advice for Disaster Recovery</A
></H2
><P
>You should take your ZIP disk for each computer and the printouts you made, and place them in a secure location in your shop. You should store copies of these in your off-site backup storage location. The major purpose of off-site backup storage is to enable disaster recovery, and restoring each host onto replacement hardware is a part of disaster recovery.</P
><P
>You should also have several restoration Linux floppies or CD-ROMS, and possibly some ZIP drives in your off-site storage as well. Also, have copies of the rescue linux distribution on several of your computers so that they back each other up.</P
><P
>You should probably have copies of this HOWTO, with your site-specific annotations on it, with your backups and in your off-site backup storage.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WHATNOW"
>10. What Now?</A
></H2
><P
>This HOWTO results from experiments on one computer. No doubt you will find some directories or files you need to back up in your first stage backup. I have not dealt with saving and restoring X on the first stage, nor have I touched at all on processors other than AMD or Intel.</P
><P
>I would appreciate your feedback as you test and improve these scripts on your own computers. I also encourage vendors of backup software to document how to do a minimal backup of their products. I'd like to see the whole Linux community sleep just a little better at night.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TODO"
>10.1. To Do</A
></H3
><P
>Volunteers are most welcome. Check with me before you start on one of these in case someone else is working on it already.</P
><P
></P
><UL
><LI
><P
>We have no way to determine the label of a swap partition. This means that there is no way to provide the swap partition's label when restoring. We could assume that a system with a single swap partition (as indicated by fdisk) has the label used in the swap partition line in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>, but that only works on single hard drive systems, and could produce subtle errors in systems with multiple swap partitions.</P
><P
>The work-around is to add the label by hand by re-running <TT
CLASS="FILENAME"
>mkswap</TT
> with the -L option on it. Sigh.</P
></LI
><LI
><P
>A partition editor to adjust partition boundaries in the <TT
CLASS="FILENAME"
>dev.hdx</TT
> file. This will let users adjust partitions for a different hard drive, or the same one with different geometry, or to adjust partition sizes within the same hard drive. A GUI would probably be a good idea here. On the other tentacle, the FSF's <A
HREF="http://www.gnu.org/software/parted"
TARGET="_top"
><TT
CLASS="FILENAME"
>parted</TT
></A
> looks like it will fill part of the bill. It does re-size existing partitions, but with restrictions.</P
></LI
><LI
><P
><A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> currently only recognizes some FAT partitions, not all. Add code to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> to recognize others and make appropriate instructions to rebuild them in the output files.</P
></LI
><LI
><P
>For FAT12 or FAT16 partitions we do not format, write zeros into the partition so that Mess-DOS 6.x does not get confused. See the notes on <B
CLASS="COMMAND"
>fdisk</B
> for an explanation of the problem.</P
></LI
><LI
><P
>Translations into other (human) languages.</P
></LI
><LI
><P
>I've referred to Red Hat Package Manager (rpm) from time to time. What are the equivalent deb commands?</P
></LI
><LI
><P
>Modify the first stage backup code to only save the current kernel.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="THESCRIPTS"
>11. The Scripts</A
></H2
><P
>See the notes in the beginning of each script for a summary of what it does.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FIRSTSTAGE"
>11.1. First Stage</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="MAKE.FDISK"
>11.1.1. <TT
CLASS="FILENAME"
>make.fdisk</TT
></A
></H4
><P
>This script, run at backup time, creates scripts similar to <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
> and <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.x</TT
></A
>, below, for you to run at restore time. It also produces data files similar to <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> and <A
HREF="#DEV.HDA.SFD"
><TT
CLASS="FILENAME"
>dev.hda.sfd</TT
></A
>, below. The names of the scripts and data files produced depend on the device given this script as a parameter. Those script, run at restore time, build and mount the partitions on the hard drive. <TT
CLASS="FILENAME"
>make.fdisk</TT
> is called from <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, below.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /usr/bin/perl

# A perl script to create a script and input file for fdisk to
# re-create the partitions on the hard disk, and format the Linux and
# Linux swap partitions. The first parameter is the fully qualified
# path of the device of the hard disk, e.g. /dev/hda. The two
# resulting files are the script make.dev.x and the data file dev.x
# (where x is the hard drive described, e.g. hda, sdc). make.dev.x is
# run at restore time to rebuild hard drive x, prior to running
# restore.metadata. dev.x is the input file for fdisk.

# The directory tree where everything is put must already exist and be
# specified in the environment variable $zip.

# Time-stamp: &#60;2007-07-08 10:26:04 ccurley make.fdisk&#62;

# Copyright 2001 through the last date of modification Charles Curley
# except for the subroutine cut2fmt.

# cut2fmt Copyright (c) 1998 Tom Christiansen, Nathan Torkington and
# O'Reilly &#38; Associates, Inc.  Permission is granted to use this code
# freely EXCEPT for book publication.  You may use this code for book
# publication only with the explicit permission of O'Reilly &#38;
# Associates, Inc.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# In addition, as a special exception, Tom Christiansen, Nathan
# Torkington and O'Reilly &#38; Associates, Inc.  give permission to use
# the code of this program with the subroutine cut2fmt (or with
# modified versions of the subroutine cut2fmt that use the same
# license as the subroutine cut2fmt), and distribute linked
# combinations including the two.  You must obey the GNU General
# Public License in all respects for all of the code used other than
# the subroutine cut2fmt.  If you modify this file, you may extend
# this exception to your version of the file, but you are not
# obligated to do so.  If you do not wish to do so, delete this
# exception statement and the subroutine cut2fmt from your version.

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# Changes:

# 2007-06-10: In addition to scanning /etc/fstab for LVM partitions
# (logical volumes), we also check the device files in /dev. This is
# because some logical volumes may be mounted by label, and scanning
# fstab won't pick those up.

# 2007-05-22: Changes for FHS compliance. Removed commented out
# references to ZIP drives. N.B.: we now take the location of where to
# put things as an environment variable, $zip.

# 2006-04-15: Added support for partition type 0x12, "Compaq
# diagnostic". This type is used for so-called "hidden diagnostics"
# partitions, e.g. on Lenovo/IBM computers.

# 2006-04-08: Primitive LVM support. It is kludgy in that it uses
# first stage restoration distribution (finnix) specific code to turn
# LVM on and off, but otherwise seems to work.

# 2006-03-28: We have a problem if swap partitions have
# labels. There's no way to retrieve the label from a swap
# partition. If we have one &#38; only one swap partition, then we can
# pull it out of /etc/fstab. Otherwise the user is on her own. We scan
# fstab for swap mount points that have labels for their devices. If
# there is one and only one, we assume that's it, otherwise pass.

# 2005-10-29: We now provide the geometry as an argument to fdisk
# (which does not work on tomsrtbt). We also save data for sfdisk, and
# write out make.dev.xxx so that it will use sfdisk if it finds it.

# 2005-08-14: Due to experience on Knoppix, we now add the code to
# change the partition types to the end of the fdisk input file
# instead of right after creating the partition.

# 2004 04 10: fdisk v &#62; 2.11 has wider columns. Added code to select
# the appropriate cut string based on fdisk's version.

# 2004 04 09: Added support for Mandrake's idea of devfs. On Mandrake,
# everything is mounted with devfs. So the mount devices are buried
# deep in places like /dev/ide/host0/bus0/target0/lun0/part1 instead
# of places like /dev/hda1, where $DEITY intended they should be. We
# have to reverse from the long devfs device to the shorter old style
# that tomsrtbt uses. The alternative is to keep track in an array of
# which devfs device belongs to which short device.

# 2003 12 29: Changed the regex for detecting whether a file system is
# read-write in the code that builds the mount file(s). The old test
# does not work if mount returns multiple parameters in the 5th field,
# e.g. (rw,errors=remount-ro) on some debian systems. This regex
# assumes that the rw parameter is always listed first, which may not
# always be the case. If it fails, take out the '\('. Thanks to Pasi
# Oja-Nisula &#60;pon at iki dot fi&#62; for pointing this out.

# 2003 01 09: Added support for FAT32. We now create two scripts for
# each hard drive, make.dev.[as]dx and mount.dev.[as]dx. These create
# and make file systems on each partition, and make mount points and
# mount them.

# 2002 12 25: added support to handle W95 extended (LBA) (f) and W95
# FAT 32 partitions. I have tested this for primary but not logical
# partitions.

# 2002 09 08: Added minimal support for ext3fs. We now detect mounted
# ext3fs partitions &#38; rebuild but with no options. The detection
# depends on the command line "dumpe2fs &#60;device&#62; 2&#62;/dev/null | grep -i
# journal" producing no output for an ext2fs, and output (we don't
# care what) for an ext3fs.

# This could stand extension to support non-default ext3 options such
# as the type of journaling. Volunteers?

# 2002 07 25: Bad block checking is now a command line option (-c) at
# the time the product script is run.

# 2002 07 03: Corrected the mechanism for specifying the default
# drive.

# 2001 11 25: Changed the way mke2fs gets its bad block
# list. badblocks does not guess at the block size, so you have to get
# it (from dumpe2fs) and feed it to badblocks. It is simpler to just
# have mke2fs call badblocks, but you do loose the ability to have a
# writing test easily. -- C^2

# 2001 11 25: Changed the regex that extracts partition labels from
# the mount command. This change does not affect the results at all,
# it just makes it possible to use Emacs' perl mode to indent
# correctly. I just escaped the left bracket in the regex. -- C^2

# Discussion:

# fdisk will spit out a file of the form below if you run it as "fdisk
# -l".

# root@tester ~/bin $ fdisk -l /dev/hda

# Disk /dev/hda: 64 heads, 63 sectors, 1023 cylinders
# Units = cylinders of 4032 * 512 bytes

#    Device Boot    Start       End    Blocks   Id  System
# /dev/hda1             1         9     18112+  83  Linux
# /dev/hda2            10      1023   2044224    5  Extended
# /dev/hda5            10       368    723712+  83  Linux
# /dev/hda6           369       727    723712+  83  Linux
# /dev/hda7           728       858    264064+  83  Linux
# /dev/hda8           859       989    264064+  83  Linux
# /dev/hda9           990      1022     66496+  82  Linux swap

# What fdisk does not do is provide output suitable for later
# importing into fdisk, a la sfdisk. This script parses the output
# from fdisk and creates an input file for fdisk. Use the input file
# like so:

# fdisk /dev/hdx &#60; dev.hdx

# For the bare metal restore package, this script also builds a script
# that will execute the above command so you can run it from your zip
# disk. Because the bare metal restore scripts all are in /root/bin,
# the data file and script created by this script are also placed
# there. The same script also creates appropriate Linux file systems,
# either ext2fs, or Linux swap. There is limited support for FAT12,
# FAT16 and FAT32. For anything else, you're on your own.

# Note for FAT32: According to the MS KB, there are more than one
# reserved sectors for FAT32, usually 32, but it can vary. Do a search
# in M$'s KB for "boot sector" or BPB for the gory details. For more
# info than you really need on how boot sectors are used, see
# http://support.microsoft.com/support/kb/articles/Q140/4/18.asp

# You can also edit dev.x to change the sizes of partitions. Don't
# forget, if you change the size of a FAT partition across the 32MB
# boundary, you need to change the type as well! Run "fdisk /dev/hda"
# or some such, then the l command to see the available partition
# types. Then go ahead and edit dev.x appropriately. Also, when moving
# partition boundarys with hand edits, make sure you move both logical
# and extended partition boundaries appropriately.

# Bad block checking right now is a quick read of the partition. A
# writing check is also possible but more difficult. You have to run
# badblocks as a separate command, and pass the bad block list to
# mke2fs in a file (in /tmp, which is a ram disk). You also have to
# know how large the blocks are, which you learn by running
# dumpe2fs. It gets messy and I haven't done it yet. You probably
# don't need it for a new hard drive, but if you have had a hard drive
# crash on you and you are reusing it (while you are waiting for its
# replacement to come in, I presume), then I highly recommend it. Let
# me know how you do it.

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# cut2fmt figures out the format string for the unpack function we use
# to slice and dice the output from fdisk. From Christiansen and
# Torkington, Perl Cookbook 5.

sub cut2fmt {
    my (@positions) = @_;
    my $template    = '';
    my $lastpos     = 1;

    foreach $place (@positions) {
        $template .= "A" . ($place - $lastpos) . " ";
        $lastpos = $place;
    }

    $template .= "A*";
    return $template;
}


# Sub gpl, a subroutine to ship the GPL and other header information
# to the current output file.

sub gpl {
    my $FILE = shift;
    my $year = shift;

    print $FILE &#60;&#60;FINIS;

# Copyright $year through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

FINIS

}

sub getBootSector {
    my $infile = $_[0];
    my $outfile = $_[1];

    $systemcmd = "dd if=$infile of=$outfile bs=512 count=1 &#38;&#62; /dev/null ";
    system ($systemcmd);
}


# If we have one &#38; only one swap partition, then this must be
# it. Otherwise the user is on her own. We scan fstab for swap mount
# points that have labels for their devices. If there is one and only
# one, we assume that's it, otherwise pass.

sub getswaplabel {
    my $dev = $_[0];

    open (FSTAB, "&#60; /etc/fstab")
        or die "Couldn't fork: $!\n";
    while (defined (my $line = &#60;FSTAB&#62;)) {
        chop ($line);
        @fstabs = split (" ", $line);
        if (@fstabs[1] eq "swap") {
            $swaplabel = @fstabs[0];
            if ($swaplabel =~ /LABEL/) {
                $swaps++;
                $sl = substr ($swaplabel, 6);
            }
#           print ("\"@fstabs[0]\", \"@fstabs[1]\", \"$sl\", $swaps.\n");
            break;
        }
    }
    close (FSTAB);

#   print "label is $sl.\n";

    if ($swaps == 1) {
        $ret = "mkswap \$blockcheck -L $sl";
        $ret .= " $dev\n\n";
    } else {
        $ret = "mkswap \$blockcheck $dev\n\n";
    }

#   print ("Returning :$ret\n");

    return $ret;
}

# dolvm is a subroutine to handle LVM partitions. This is
# experimental....

$lvms = 0;          # true if we've been here before

sub dolvm {

#     print ("In dolvm ()...\n");

    if ($lvms == 0) {
        $lvms = 1;

        # Scan /etc/fstab for the logical volumes and write a script to
        # make file systems on them and another to mount 'em later on.

        $mklvs = open (MKLVS, "&#62; ${outputfilepath}bin/make.lvs")
            or die "Couldn't fork: $!\n";

        print MKLVS &#60;&#60;FINIS;
#! /bin/sh

# A script to create file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.
FINIS

        &#38;gpl (*MKLVS, "2006");


        print MKLVS &#60;&#60;FINIS;

export blockcheck=\$1;

if [ "\$blockcheck" != "-c" ] &#38;&#38; [ -n "\$blockcheck" ]
then
    echo "\${0}: Build file systems on logical volumes."
    echo "\${0}: -c: block check during file system making."
    exit 1;
fi

FINIS

        $mtlvs = open (MTLVS, "&#62; ${outputfilepath}bin/mount.lvs")
            or die "Couldn't fork: $!\n";

        print MTLVS &#60;&#60;FINIS;
#! /bin/sh

# A script to mount file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.
FINIS

        &#38;gpl (*MTLVS, "2007");


        # Now cycle through all the known logical volumes &#38; set them
        # up. N.B.: This has been tested on a machine with only one
        # LV. But it *should* work.

        $pvdisp = open (PVDISP, "pvdisplay -c |")
            or die ("Can't open LVM display.\n");
        while (defined (my $pv = &#60;PVDISP&#62;)) {
            chop ($pv);
#             print ("$pv\n");
            @pv = split (":", $pv);
            $uid = @pv[11];
            $pvname = @pv[1];
            $phv = @pv[0];
#             print ("pv $pvname has uid $uid.\n");

            # back up the LVM's lvm details. Get the config files.
            system ("vgcfgbackup -f ${outputfilepath}metadata/LVM.backs.$pvname $pvname");

            print (MKLVS "echo \"y\\n\" | pvcreate -ff --uuid \"$uid\"\\\n");
            print (MKLVS "    --restorefile ../metadata/lvm/backup/${pvname} $phv\n");
            print (MKLVS "vgcfgrestore --file ../metadata/LVM.backs.$pvname $pvname\n\n");
        }

        print (MKLVS "# Hideously disty dependent! turn on LVM.\n");
        print (MKLVS "if [ -e /etc/init.d/lvm ] ; then\n");
        print (MKLVS "    /etc/init.d/lvm start\nfi\n\n");

        # Now walk fstab in search of logical volumes. This is
        # necessary to pick up swap partitions, and it may pick up
        # others. We need fstab below to match the partitions up with
        # their mount points, so we keep the array around.

        %volsfound = ();
        open (FSTAB, "&#60; /etc/fstab")
            or die "Couldn't fork: $!\n";
        @fstab = &#60;FSTAB&#62;;
        foreach $line (@fstab) {
            @fstabs = split (" ", $line);
            if (@fstabs[0] =~ /VolGroup/ ) {
                #           print ("$line\n");
                if (@fstabs[2] eq "swap") {
                    print (MKLVS "echo\necho making LV @fstabs[0] a swap partition.\n");
                    print (MKLVS "mkswap \$blockcheck @fstabs[0]\n\n");
                } elsif (@fstabs[2] == "ext3") {
                    print (MKLVS "echo\necho making LV @fstabs[0], @fstabs[1],");
                    print (MKLVS " an ext3 partition.\n");
                    print (MKLVS "mke2fs -j \$blockcheck @fstabs[0]\n\n");

                    print (MTLVS "mkdir -p /target$fstabs[1]\n");
                    print (MTLVS "mount @fstabs[0] /target$fstabs[1]\n\n");
                    $volsfound{@fstabs[0]} = 3;
                } elsif (@fstabs[2] == "ext2") {
                    print (MKLVS "echo\necho making LV @fstabs[0], @fstabs[1],");
                    print (MKLVS " an ext2 partition.\n");
                    print (MKLVS "mke2fs \$blockcheck @fstabs[0]\n\n");

                    print (MTLVS "mkdir -p /target$fstabs[1]\n");
                    print (MTLVS "mount @fstabs[0] /target$fstabs[1]\n\n");
                    $volsfound{@fstabs[0]} = 2;
                } else {
                    print ("Opps, unknown type of logical volume, @fstabs[0]\n");
                }
            }
        }

#         print ("Volumes already found are: ");
#         while ( ($k, $v) = each %volsfound ) {
#             print ("$k ==&#62; $v ");
#         }
#         print ("\n");

        # Now walk the logical volume devices and pick up any
        # partitions formated ext3/ext2. This may result in duplicates
        # if the partitions have labels but are mounted by device name
        # rather than by label.

        opendir (DEVHANDLE, "/dev") or die ("Can't open /dev!!\n");
        while ( defined ($fname = readdir (DEVHANDLE))) {
            @fnames = (@fnames, $fname);
        }
        @sorted = sort (@fnames);
        foreach $fname (@sorted) {
            if ($fname =~ /^VolGroup/ &#38;&#38; -d "/dev/$fname") {
#                 print ("Inside /dev is $fname.\n");
                opendir (VOLHANDLE, "/dev/$fname")
                    or die ("Can't open /dev/$fname!!\n");
                while ( defined ($vname = readdir (VOLHANDLE))) {
                    @vnames = (@vnames, $vname);
                }
                @vsorted = sort (@vnames);
                foreach $vname (@vsorted) {
#                     print "/dev/$fname/$vname: " . $volsfound{"/dev/$fname/$vname"} . "\n";
                    if($vname ne "." &#38;&#38; $vname ne ".."
                       &#38;&#38; $volsfound{"/dev/$fname/$vname"} &#60; 1) {
#                         print ("Inside /dev/$fname is $vname.\n");
                        my $journal = 0;

                        # FIX ME: add tests to be sure it's a symlink
                        # to a block device.

                        # Is it extX?
                        open (DUMP, "dumpe2fs /dev/$fname/$vname 2&#62; /dev/null|");

                        @lines = &#60;DUMP&#62;;

                        if (scalar (@lines) &#62; 1) {

                            # If we've gotten here we have a valid
                            # ext[2|3] file system. Now prepare to
                            # spit out the commands to recreate
                            # it. Get the label, if any, and whether
                            # there is a journal or not.

                            foreach $_ (@lines) {
                                if (/Filesystem volume name:/) {
                                    $label = substr ($_, 26);
                                    chop ($label);
#                                     print ("\$label is \"$label\".\n");
                                }
                                if (/has_journal/) {
                                    $journal = 1;
                                }

                            }

                            # get the mount point from fstab so we can mount it.
                            foreach $fstab (@fstab) {
                                @fstabs = split (" ", $line);
                                if (@fstabs[0] eq "LABEL=$label" ) {
                                    $mountpoint = @fstabs[1];
#                                     print ("mount point is \"$mountpoint\".\n");
                                    last;
                                }
                            }
                            if (length ($label) ) {
                                $label = "-L \"" . $label . "\"";
                            }

                            if ($journal &#62; 0) {
                                print (MKLVS "echo\necho making LV /dev/$fname/$vname");
                                print (MKLVS " an ext3 partition.\n");
                                print (MKLVS "mke2fs -j $label \$blockcheck /dev/$fname/$vname\n\n");

                                print (MTLVS "mkdir -p /target$mountpoint\n");
                                print (MTLVS "mount /dev/$fname/$vname /target$mountpoint\n\n");
                            } else {
                                print (MKLVS "echo\necho making LV /dev/$fname/$vname");
                                print (MKLVS " an ext2 partition.\n");
                                print (MKLVS "mke2fs $label \$blockcheck /dev/$fname/$vname\n\n");

                                print (MTLVS "mkdir -p /target$mountpoint\n");
                                print (MTLVS "mount /dev/$fname/$vname /target$mountpoint\n\n");
                            }
                        }
                    }

                }
                closedir (VOLHANDLE);
            }
        }
        print (MTLVS "mount | grep -i \"/target\"\n");

        closedir (DEVHANDLE);

        close (FSTAB);
        close (MKLVS);
        close (MTLVS);

        chmod 0700, "${outputfilepath}bin/make.lvs";
        chmod 0700, "${outputfilepath}bin/mount.lvs";

        # Copy the LVM configuration to where we can get at it...
        system ("cp -rp /etc/lvm ${outputfilepath}metadata/");

    }

#     print ("Leaving dolvm ()...\n");

    return ($ret);
}


# Begin main line code.

# Provide a default device.

# print "\$ARGV[0] is $ARGV[0].\n";

$device = defined ($ARGV[0]) ? $ARGV[0] : "/dev/hda";

# Need to check to see if $device is a sym link. If it is, the mount
# point is the target of the link. (Mandrake) Otherwise we search for
# mount points on $device. Fedora, Red Hat.

if ( -l $device) {

    # It is a sym link. Get the target of the link, then make it into
    # an absolute path, preserving the numbering.

    $mountdev = '/dev/' . readlink ($device);
    $mountdev =~ s|ide/host(\d+)/bus(\d+)/target(\d+)/lun(\d+)/disc
        |ide/host\1/bus\2/target\3/lun\4|x;
} else {
    # not a sym link; just assign it.
    $mountdev = $device;
}

# print "Device is $device; mount device is $mountdev.\n";

# Prepare format string. Here are two format strings I have found
# useful. Here, column numbers are 1 based, i.e. the leftmost column
# is column 1, not column 0 as in Emacs.

# We select a format string according to fdisk's version.

$fdpid = open (FDVER, "fdisk -v |") or die "Couldn't fork: $!\n";
while (&#60;FDVER&#62;) {
    @_ = unpack ("A7 A*", $_);
    $fdver=$_[1];
    $fdver =~ s/[^\d.]//g; # strip non-numbers, non-periods, as in "2.12pre".
}

# print "fdisk version is $fdver\n";

if ($fdver &#60; 2.12) {
# fdisk to 2.11?? Red Hat, Fedora Core 1
    $fmt = cut2fmt (11, 19, 24, 34, 45, 49);
} else {
# fdisk 2.12 &#38; up?? Mandrake 10.0, Fedora Core 2
    $fmt = cut2fmt (12, 14, 26, 38, 50, 55);
}
# print "Format string is $fmt.\n";

# define fields in the array @_.
$dev = 0;
$bootable = 1;
$firstcyl = 2;
$lastcyl = 3;
$parttype = 5;
$partstring = 6;

$target = "\/target";

$outputfilename = $device;
$outputfilename =~ s/\//./g;
$outputfilename = substr ($outputfilename, 1, 100);

# $outputfilepath = "/root/bin/";
$outputfilepath = $ENV{"zip"} . "/";
# print "\$outputfilepath is ${outputfilepath}\n";

# Make a hash of the labels.
$mpid = open (MOUNT, "mount -l |") or die "Couldn't fork: $!\n";
while (&#60;MOUNT&#62;) {
    if ($_ =~ /^$mountdev/i) { # is this a line with a partition in it?
#       print $_;               # print it just for grins
        split;
        if ($_[6] ne "") {      # only process if there actually is a label
            $_[6] =~ s/[\[\]]//g; # strike [ and ].
            $labels{$_[0]} = $_[6];
#           print "The label of file device $_[0] is $labels{$_[0]}.\n";
        }


        # We only mount if it's ext2fs or ext3fs and read and write.

        if ($_[4] =~ /ext[23]/ and $_[5] =~ /\(rw/ ) {
            if ($_[0] =~ /ide/i) {

                # We have a devfs system, e.g. Mandrake. This code
                # converts back from the devfs designation to the old
                # /dev/hd* designation for tomsrtb. I have NOT checked
                # this out for drives other than /dev/hda. Also, this
                # code does not handle SCSI drives.

                if ( $_[0] =~ /target0/ &#38;&#38; $_[0] =~ /bus0/ ) {
                    $letter = 'a';
                } elsif ( $_[0] =~ /target1/ &#38;&#38; $_[0] =~ /bus0/) {
                    $letter = 'b';
                } elsif ( $_[0] =~ /target0/ &#38;&#38; $_[0] =~ /bus1/) {
                    $letter = 'c';
                } else {
                    $letter = 'd';
                }
                $_[0] =~ s|/ide/host\d+/bus\d+/target\d+/lun\d+/part|/hd|g;
                $_[0] =~ s/hd/hd$letter/;
            }
            $mountpoints{$_[2]} = $_[0];
#             print "$_[2] is the mountpoint for tomsrtbt";
#             print " device $mountpoints{$_[2]}.\n";
        }
    }
}
close (MOUNT);

# Get sfdisk output. If we have sfdisk at restore time (e.g. Knoppix),
# we'll use it.

system "sfdisk -d $device &#62; ${outputfilepath}metadata/${outputfilename}.sfd";

# Otherwise we'll use the output from fdisk, which may or may not be
# any more accurate.

$fpid = open (FDISK, "fdisk -l $device |") or die "Couldn't fork: $!\n";

open (OUTPUT, "&#62; ${outputfilepath}metadata/${outputfilename}")
    or die "Couldn't open output file ${outputfilepath}metadata/${outputfilename}.\n";

while (&#60;FDISK&#62;) {
    if ($_ =~ /^$device/i) {    # is this a line with a partition in it?
#       print $_;               # print it just for grins
        chop;                   # kill trailing \r
        @_ = unpack ($fmt, $_);

        # Now strip white spaces from cylinder numbers, white space &#38;
        # leading plus signs from partition type.
        @_[$firstcyl] =~ s/[ \t]+//;
        @_[$lastcyl] =~ s/[ \t]+//;
        @_[$parttype] =~ s/[+ \t]+//;

        $partnumber = substr(@_[$dev], 8, 10); # get partition number for this line
        # just for grins
#         print "  $partnumber, @_[$firstcyl], @_[$lastcyl],";
#         print " @_[$parttype], @_[$partstring]\n";

        # Here we start creating the input to recreate the partition
        # this line represents.

        print OUTPUT "n\n";
        if ($partnumber &#60; 5) {
            # primary Linux partition
            if (@_[$parttype] == 83) {
                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # Now detect if this is an ext3 (journaling)
                # partition. We do this using dumpe2fs to dump the
                # partition and grepping on "journal". If the
                # partition is ext2, there will be no output. If it is
                # ext3, there will be output, and we use that fact to
                # set a command line switch. The command line switch
                # goes into an associative array (hash) so we don't
                # have to remember to reset it to the null string when
                # we're done.

                $dpid = open (DUMPE2FS,
                              "dumpe2fs @_[$dev] 2&#62;/dev/null | grep -i journal |")
                    or die "Couldn't fork: $!\n";
                while (&#60;DUMPE2FS&#62;) {
#                   print "Dumpe2fs: $_";
                    $ext3{$_[$dev]} = "-j ";
                    last;
                }
                close (DUMPE2FS);

                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{$_[$dev]}\$blockcheck";
                    $format .= " -L $labels{@_[$dev]} @_[$dev]\n\n";
                } else {
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{$_[$dev]}\$blockcheck @_[$dev]\n\n";
                }

                # extended partition
            } elsif (@_[$parttype] == 5) {
                # print ("Creating Extended Partition.\n");
                print OUTPUT "e\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # extended partition, Win95 Ext'd (LBA)
            } elsif (@_[$parttype] eq "f") {
                # print ("Creating Extended LBA Partition.\n");
                print OUTPUT "e\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\nf\n";

                # primary Linux swap partition
            } elsif (@_[$parttype] == 82) {
                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n82\n";
                $format .= "echo\necho Making @_[$dev] a swap partition.\n";
                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "mkswap \$blockcheck -L $labels{@_[$dev]}";
                    $format .= " @_[$dev]\n\n";
                } else {
                    $format .= getswaplabel (@_[$dev]);
                }

                # Primary mess-dos partition. We don't handle hidden
                # partitions.

            } elsif ( @_[$parttype] == 1 || @_[$parttype] == 4 || @_[$parttype] == 6
                      || @_[$parttype] eq "b" || @_[$parttype] eq "c"
                      || @_[$parttype] eq "e" || @_[$parttype] eq "12" ) {
                # print ("Making DOS primary partition.\n");

                getBootSector (@_[$dev], "${outputfilepath}metadata/$outputfilename$partnumber");

                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
                $format .= "echo\necho formatting $checking@_[$dev]\n";
                $format .= "mkdosfs \$blockcheck";
                if ( @_[$parttype] == b || @_[$parttype] == c
                     || @_[$parttype] eq "12" ) {
                    # We have a W9x FAT32 partition. Add a command line switch.
                    $format .= " -F 32";
                }
                $format .= " @_[$dev]\n";
                $format .= "# restore FAT boot sector.\n";
                $format .= "dd if=$outputfilename$partnumber";
                $format .= " of=@_[$dev] bs=512 count=1\n\n";

            } elsif ( @_[$parttype] == "8e") {
                $format .= dolvm ();
            } else {
                # anything else partition
                print OUTPUT "p\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
            }

        } else {
            # logical Linux partition
            if (@_[$parttype] == 83) {
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # Now detect if this is an ext3 (journaling)
                # partition. We do this using dumpe2fs to dump the
                # partition and grepping on "journal". If the
                # partition is ext2, there will be no output. If it is
                # ext3, there will be output, and we use that fact to
                # set a command line switch. The command line switch
                # goes into an associative array (hash) so we don't
                # have to remember to reset it to the null string when
                # we're done.

                $dpid = open (DUMPE2FS,
                              "dumpe2fs @_[$dev] 2&#62;/dev/null | grep -i journal |")
                    or die "Couldn't fork: $!\n";
                while (&#60;DUMPE2FS&#62;) {
#                   print "Dumpe2fs: $_";
                    $ext3{$_[$dev]} = "-j ";
                    last;
                }
                close (DUMPE2FS);

                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{@_[$dev]}\$blockcheck";
                    $format .= " -L $labels{@_[$dev]} @_[$dev]\n\n";
                } else {
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{@_[$dev]}\$blockcheck @_[$dev]\n\n";
                }

                # logical Linux swap partition
            } elsif (@_[$parttype] == 82 ) {
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n82\n";
                $format .= "echo\necho Making @_[$dev] a swap partition.\n";
                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "mkswap \$blockcheck -L $labels{@_[$dev]}";
                    $format .= " @_[$dev]\n\n";
                } else {
                    $format .= getswaplabel (@_[$dev]);
                }

                # Logical mess-dos partition. We don't handle hidden
                # partitions.

            } elsif ( @_[$parttype] == 1 || @_[$parttype] == 4 || @_[$parttype] == 6
                      || @_[$parttype] eq "b" || @_[$parttype] eq "c"
                      || @_[$parttype] eq "e" || @_[$parttype] eq "12" ) {
#               print ("Making DOS logical partition.\n");

                getBootSector (@_[$dev], "${outputfilepath}metadata/$outputfilename$partnumber");

                print OUTPUT "l\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
                $format .= "echo\necho formatting $checking@_[$dev]\n";
                $format .= "mkdosfs \$blockcheck";
                if ( @_[$parttype] == b || @_[$parttype] == c
                     || @_[$parttype] eq "12" ) {
                    # We have a W9x FAT32 partition. Add a command line switch.
                    $format .= " -F 32";
                }
                $format .= " @_[$dev]\n";
                $format .= "# restore FAT boot sector.\n";
                $format .= "dd if=$outputfilename$partnumber";
                $format .= " of=@_[$dev] bs=512 count=1\n\n";

            } elsif ( @_[$parttype] == "8e") {
                $format .= dolvm ();
            } else {
                # anything else partition
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
            }
        }

        # handle bootable partitions
        if (@_[$bootable] =~ /\*/) {
            print OUTPUT "a\n$partnumber\n";
        }
    } else {
        # If we got here, the current line does not have a partition in it.

        # Get the geometry for fdisk. Force fdisk to use the current
        # geometry at restoration time. Comment this out for
        # tomstrbt's fdisk; it doesn't like it.

        if ($_ =~ /heads.*sectors.*cylinders/i) {
#           print $_;               # again, for grins.
            chop;
            @geometry = split (/ /, $_);
            $geometry = "-H $geometry[0] -S $geometry[2] -C $geometry[4]";
#           print $geometry;
        }
    }
}

# Append all the partition type changes, validate, and print out the
# results.

print OUTPUT "${typechanges}v\nw\n";

close (OUTPUT);
close (FDISK);


open (OUTPUT, "&#62; ${outputfilepath}bin/make.$outputfilename")
    or die "Couldn't open output file ${outputfilepath}bin/make.$outputfilename.\n";

print OUTPUT &#60;&#60;FINIS;
#! /bin/sh

# A script to restore the partition data of a hard drive and format
# the partitions. Created at bare metal backup time by the Perl script
# make.fdisk.
FINIS

&#38;gpl (*OUTPUT, "2001");

print OUTPUT &#60;&#60;FINIS;

swapoff -a
# Hideously disty dependent! Turn off LVM.
if [ -e /etc/init.d/lvm ] ; then
    /etc/init.d/lvm stop
fi

export blockcheck=\$1;

if [ "\$blockcheck" != "-c" ] &#38;&#38; [ -n "\$blockcheck" ]
then
    echo "\${0}: automated restore with no human interaction."
    echo "\${0}: -c: block check during file system making."
    exit 1;
fi

FINIS

# Clean the old partition table out. Turn off swap in case we're using
# it.

# print OUTPUT "dd if=/dev/zero of=$device bs=512 count=2\n\nsync\n\n";
print OUTPUT "dd if=/dev/zero of=$device bs=1024 count=2000\n\nsync\n\n";


# command for fdisk

$fdiskcmd .= "# see if we have sfdisk &#38; if so use it.\n";
$fdiskcmd .= "if which sfdisk ; then\n";
$fdiskcmd .= "  echo \"Using sfdisk.\"\n";
$fdiskcmd .= "  sfdisk $geometry $device &#60; ../metadata/${outputfilename}.sfd\n";
$fdiskcmd .= "else\n";
$fdiskcmd .= "  echo \"using fdisk.\"\n";
$fdiskcmd .= "  fdisk $geometry $device \&#60; ../metadata/$outputfilename\n";
$fdiskcmd .= "fi\n\nsync\n\n";


print OUTPUT $fdiskcmd;
print OUTPUT $format;

print OUTPUT "fdisk -l \"$device\"\n";

close (OUTPUT);

# Now build the script that will build the mount points on the root
# and other partitions.

open (OUTPUT, "&#62; ${outputfilepath}bin/mount.$outputfilename")
    or die "Couldn't open output file ${outputfilepath}bin/make.$outputfilename.\n";

print OUTPUT &#60;&#60;FINIS;
#! /bin/sh

# A script to create a minimal directory tree on the target hard drive
# and mount the partitions on it. Created at bare metal backup time by
# the Perl script make.fdisk.
FINIS

&#38;gpl (*OUTPUT, "2001");

print OUTPUT &#60;&#60;FINIS;

# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order. The root partition should
# be mounted first, then the rest in the order they cascade. If they
# cross mount, you'll have to handle that manually.

FINIS


# We have a hash of mount points and devices in %mountpoints. However,
# we have to process them such that directories are built on the
# appropriate target partition. E.g. where /usr/local is on its own
# partition, we have to mount /usr before we build /usr/local. We can
# ensure this by sorting them. Shorter mount point paths will be built
# first. We can't sort a hash directly, so we use an array.

# We build commands to create the appropriate mount points and then
# mount the partitions to the mount points. This is in preparation for
# untarring the contents of the ZIP disk, done in restore.metadata.

foreach $point ( sort keys %mountpoints) {
    print OUTPUT "\n# $point is the mountpoint for";
    print OUTPUT " tomsrtbt device $mountpoints{$point}.\n";
    print OUTPUT "mkdir -p $target$point\n";
    print OUTPUT "mount $mountpoints{$point} $target$point\n";
}

print OUTPUT "\nmount | grep -i \"/target\"\n";

close (OUTPUT);

# These scripts are dangerous &#38; should only be visible to root.

chmod 0700, "${outputfilepath}bin/make.$outputfilename";
chmod 0700, "${outputfilepath}bin/mount.$outputfilename";
chmod 0600, "${outputfilepath}metadata/${outputfilename}*";</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="MAKE.DEV.HDA"
>11.1.2. <TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
></H4
><P
>This script is a sample of the sort produced by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. It uses data files like <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
>, below. It builds partitions and puts file systems on some of them. This is the first script run at restore time.</P
><P
>If you are brave enough to edit <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> or <A
HREF="#DEV.HDA.SFD"
><TT
CLASS="FILENAME"
>dev.hda.sfd</TT
></A
> (q.v.), say, to add a new partition, you may need to edit this script as well.</P
><P
>If you want make.dev.hda to check for bad blocks when it puts a file system on the partitions, use a "-c" command line option.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore the partition data of a hard drive and format
# the partitions. Created at bare metal backup time by the Perl script
# make.fdisk.

# Copyright 2001 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: automated restore with no human interaction."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

dd if=/dev/zero of=/dev/hda bs=512 count=2

swapoff -a
sync

# see if we have sfdisk &#38; if so use it.
if which sfdisk ; then
  echo "Using sfdisk."
  sfdisk  -H 128 -S 63 -C 523 /dev/hda &#60; dev.hda.sfd
else
  echo "using fdisk."
  fdisk  -H 128 -S 63 -C 523 /dev/hda &#60; dev.hda
fi

sync

echo
echo formatting /dev/hda1
mkdosfs $blockcheck /dev/hda1
# restore FAT boot sector.
dd if=dev.hda1 of=/dev/hda1 bs=512 count=1

echo
echo formatting /dev/hda2
mke2fs -j $blockcheck -L /boot /dev/hda2

echo
echo formatting /dev/hda3
mke2fs -j $blockcheck -L / /dev/hda3

echo Making /dev/hda5 a swap partition.
mkswap $blockcheck /dev/hda5

fdisk -l "/dev/hda"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="MAKE.LVS"
>11.1.3. <TT
CLASS="FILENAME"
>make.lvs</TT
></A
></H4
><P
><TT
CLASS="FILENAME"
>make.lvs</TT
> is generated by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, but only if logical volumes are present. As the name suggests, it builds the logical volumes and makes file systems on them.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to create file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.

# Copyright 2006 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: Build file systems on logical volumes."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

export LVM_SYSTEM_DIR=$(pwd)/lvm.cfg

echo "y\n" | pvcreate -ff --uuid "CCmw0N-0We2-HzRS-jRZa-FkC7-NxTc-oAfvpX"\
     --restorefile lvm.cfg/archive/VolGroup00_*.vg   /dev/hda3
vgcfgrestore --file LVM.backs VolGroup00

# Hideously disty dependent!
if [ -e /etc/init.d/lvm ] ; then
     /etc/init.d/lvm start
fi

echo
echo making LV /dev/VolGroup00/LogVol00 an ext3 partition.
mke2fs -j $blockcheck /dev/VolGroup00/LogVol00

echo
echo making LV /dev/VolGroup00/LogVol02 an ext3 partition.
mke2fs -j $blockcheck /dev/VolGroup00/LogVol02

echo
echo making LV /dev/VolGroup00/LogVol01 a swap partition.
mkswap $blockcheck /dev/VolGroup00/LogVol01&#13;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="MOUNT.DEV.HDA"
>11.1.4. <TT
CLASS="FILENAME"
>mount.dev.hda</TT
></A
></H4
><P
>This script is a sample of the sort produced by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. It builds mount points and mounts partitions on them, making the target file system ready for restoring files. This is the second script run at restore time.</P
><P
>If you are brave enough to edit <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> (q.v.), say, to add a new partition, you may need to edit this script as well.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to create a minimal directory tree on the target hard drive
# and mount the partitions on it. Created at bare metal backup time by
# the Perl script make.fdisk.

# Copyright 2001 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order. The root partition should
# be mounted first, then the rest in the order they cascade. If they
# cross mount, you'll have to handle that manually.


# / is the mountpoint for tomsrtbt device /dev/hda3.
mkdir /target/
mount /dev/hda3 /target/

# /boot is the mountpoint for tomsrtbt device /dev/hda2.
mkdir /target/boot
mount /dev/hda2 /target/boot

mount | grep -i "/dev/hda"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="MOUNT.LVS"
>11.1.5. <TT
CLASS="FILENAME"
>mount.lvs</TT
></A
></H4
><P
><TT
CLASS="FILENAME"
>mount.lvs</TT
> is generated by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, but only if logical volumes are present. As the name suggests, it mounts the logical volumes ready for restoration.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to mount file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.

# Copyright 2006 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

mkdir -p /target/
mount /dev/VolGroup00/LogVol00 /target/

mkdir -p /target/home
mount /dev/VolGroup00/LogVol02 /target/home

mount | grep -i "/target"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DEV.HDA"
>11.1.6. <TT
CLASS="FILENAME"
>dev.hda</TT
></A
></H4
><P
>This data file is used at restore time if <B
CLASS="COMMAND"
>sfdisk</B
> is not present on the restoration Linux. It is fed to <B
CLASS="COMMAND"
>fdisk</B
> by the script <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>. It is produced at backup time by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. Those familiar with <B
CLASS="COMMAND"
>fdisk</B
> will recognize that each line is an <B
CLASS="COMMAND"
>fdisk</B
> command or value, such as a cylinder number. Thus, it is possible to change the partition sizes and add new partitions by editing this file. That's why the penultimate command is <B
CLASS="COMMAND"
>v</B
>, to verify the partition table before it is written.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>n
p
1
1
29
a
1
n
p
2
30
44
n
e
3
45
1023
n
l
45
944
n
l
945
1023
t
1
6
t
6
82
v
w</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DEV.HDA.SFD"
>11.1.7. <TT
CLASS="FILENAME"
>dev.hda.sfd</TT
></A
></H4
><P
>This data file is used at restore time if <B
CLASS="COMMAND"
>sfdisk</B
> is present on the restoration Linux system. It is fed to <B
CLASS="COMMAND"
>sfdisk</B
> by the script <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>. It is produced at backup time by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. Each line represents a partition. Thus, it is possible to change the partition sizes and add new partitions by editing this file.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># partition table of /dev/hda
unit: sectors

/dev/hda1 : start=       63, size=   116865, Id= 6, bootable
/dev/hda2 : start=   116928, size=   153216, Id=83
/dev/hda3 : start=   270144, size=   286272, Id=82
/dev/hda4 : start=   556416, size=  3568320, Id= 5
/dev/hda5 : start=   556479, size=  3568257, Id=83</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="SAVE.METADATA"
>11.1.8. <TT
CLASS="FILENAME"
>save.metadata</TT
></A
></H4
><P
>This is the first script to run as part of the backup process. It calls <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. If you have a SCSI hard drive or multiple hard drives to back up, edit the call to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> appropriately.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Recent kernels have incorporated a new ATA (IDE) hard drive driver, libata. Because of this, parallel ATA (PATA) drives now show up as SCSI drives, as serial ATA (SATA) have always done. However, not all rescue distributions (e.g. Finnix) use this new driver. There is a line toward the bottom of <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
> wich very carefully replaces "/dev/sda" with "/dev/hda". Use this as a template if you have multiple IDE hard drives. Comment it out or delete it if this is not an issue for you.</P
><P
>Note that there is no guaranteed mapping! Systems with multiple hard drives may have confusing mappings. Be sure to edit this line carefully. Check it if you add or remove a hard drive of any interface type to or from your system!</P
><P
>N.B: if you have libata IDE drive issues, the grub-install line at the end of <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> won't work. If it doesn't, use your rescue disk to do the same. Or burn and boot to the boot image that is made as part of this script. Boot to it and do the second state restore as usual. The second state restore should re-run <TT
CLASS="FILENAME"
>grub-install</TT
>.</P
></TD
></TR
></TABLE
></DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to save certain meta-data off to the boot partition. Useful for
# restoration.

# Time-stamp: &#60;2007-07-06 13:38:29 ccurley save.metadata&#62;

# Copyright 2000 through the last date of modification, Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# 2007-05-22: Changes for FHS compliance. Removed commented out
# references to ZIP drives. Added a line to deal with the fact that
# libata (in newer kernels) maps IDE drives to SCSI device names, but
# not all rescue distributions use libata. So we have to change the
# device names from SCSI to IDE, e.g. /dev/sda to /dev/hda.

# 2006-03-26: had a deprecated option in the sort options; fixed that.

# 2005-09-09: Added a line to create a boot disk ISO in the ZIP drive.

# 2005-08-30: Modernized sub-shell calls, a few other tweaks.

# 2005-07-29: Fedora Core 4 mods. Name of the directory to be saved
# has to be last. Also, we now specify --numeric-owner so as to avoid
# UID problems when using some live CD systems. And we now save to
# /var instead of a mounted ZIP disk.

# 2005-02-19: Fedora Core 3 mods.

# 2003 01 08: We now age the output from rpm -VA to make back
# comparisons easier.

# The loop that creates directories now has the -p option for mkdir,
# which means you can create parents on the fly if they don't already
# exist.

# initrd is now in the list of directories to create automatically.

# We now exclude more stuff when building the tarballs.

# 2002 07 01: Went to bzip2 to compress the archives, for smaller
# results. This is important in a 100MB ZIP disk. Also some general
# code cleanup.

# 2002 07 01: The function crunch will tar and bzip2 the
# archives. This is cleaner than the old code, and has better safety
# checking.


# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# Exclude: given a fully qualified path to an ambiguous file name,
# expand it to the base name plus, e.g. any version numbering in the
# base name. E.g. "/usr/lib/python*" becomes "python2.5" if that's
# what's in the directory. We then prepend "--exclude" and return
# it. Use it to prepare ambiguous excludes for crunch's benefit. If
# the file doesn't exist, we return nothing.

function exclude {

if [ -z "$1" ]; then            # 0 length parameter check.
   echo "-Parameter #1 is missing.-" # Also if no parameter is passed.
   exit 1
else
   if [ ! -e $1 ]; then
      return
   else
      local file=$1
      local target=$(ls -d $file)
      echo "--exclude ${target##/*/}"
   fi
fi
}


# Crunch: A function to compress the contents of a directory and put
# the archive onto the ZIP disk.

# The first parameter is the name of the archive file to be
# created. The backup location, $zip, will be prepended and the
# extension, "tar.bz2" will be appended.

# All following parameters will be taken as additional directories or
# files to be put into the archive.

function crunch {

if [ -z "$1" ] || [ -z "$2" ]	# Checks if parameter #1 or #2 is zero length.
then
   echo "-Parameter #1 or #2 is missing.-"  # Also if no parameter is passed.
   return 1
else
   local file=$1		# The archive file to create
   shift			# Discard the file name
   local dirs=$@		# The director[y|ies] to archive
   local tarcmd="tar --numeric-owner -cjf"	# The tar command.

   local tarit="$tarcmd  ${zip}/$data/$file.tar.bz2 $dirs"
   echo $tarit
   $tarit			# do it!!

   error=$?			# Preserve the exit code

   if [ $error != 0 ]		# Did we fail?
   then				# Yes
      echo "Tar failed with error $error"
      echo $tarcmd ${zip}/$data/$file.tar.bz2 $dirs
      exit $error		# return tar's exit code as ours
   fi

   return 0			# For error testing if needed.
fi
}

# Begin the main line code
export data="data";             # Name of the data directory in the archive
export today=$(date +%Y%m%d);   # Today's archive
export zip="/var/lib/bare.metal.recovery/${today}";

if [ -d ${zip} ] ; then
  rm -r ${zip}
fi
mkdir -p ${zip}/metadata ${zip}/bin ${zip}/data

NEW=${zip}/metadata/rpmVa.txt       # name for the rpm -Va output file.

# Now we save hard drive information. Run make.fdisk on each hard
# drive in the order in which it mounted from the root partition. That
# is, run it first on the hard drive with your root partition, then
# any hard drives that mount to the first hard drive, then any hard
# drives that mount to those. For example, if your root partition is
# on /dev/sdc, run "make.fdisk /dev/sdc" first.

# The reason for this is that make.fdisk produces a script to make
# mount points and then mount the appropriate partition to them during
# first stage restore. Mount points must be created on the partition
# where they will reside. The partitions must be mounted in this
# order. For example, if your /var and /var/ftp are both separate
# partitions, then you must mount /, create /var, then mount /var,
# then create /var/ftp. The order in which the script "first.stage"
# runs the mounting scripts is based on their time of creation.

# If necessary, put a line, "sleep 1" between calls to make.fdisk.

echo "Saving hard drive info"

# List all your hard drives here. Put them in the order you want
# things done at restore time.

for drive in sda ; do
  make.fdisk /dev/${drive}
  fdisk -l /dev/${drive} &#62; ${zip}/fdisk.${drive}
done

# back up RPM metadata

echo "Verifying RPMs."

rpm -Va | sort -t ' ' -k 3 | uniq &#62; ${NEW}

echo "Finished verifying RPMs."

echo -e "$(hostname) bare metal archive, created $(date)" &#62; ${zip}/README.txt
uname -a &#62;&#62; ${zip}/README.txt

# Preserve the release information. Tested with Red Hat/Fedora, should
# work with SuSE, Mandrake and other RPM based systems. Debian
# equivalent, anyone?

for releasefile in $(ls /etc/*release*) ; do
  # echo $releasefile
  if [ -e $releasefile ] &#38;&#38; [ ! -L $releasefile ] ; then
    cat $releasefile &#62;&#62; ${zip}/README.txt
  fi
done

echo "Building the ZIP drive backups."

# These are in case we need to refer to them while rebuilding. The
# rebuilding process should be mostly automated, but you never
# know....

ls -al /mnt &#62; ${zip}/ls.mnt.txt
ls -al / &#62; ${zip}/ls.root.txt
ls -al /var &#62; ${zip}/ls.var.txt

cd /

# Build our minimal archives on the ZIP disk. These appear to be
# required so we can restore later on.

crunch usr.lib $(exclude /usr/lib/perl*)\
  $(exclude /usr/lib/firefox*) $(exclude /usr/lib/gimp*) --exclude dri\
  --exclude xorg --exclude gconv usr/lib

# crunch usr.share --exclude icons --exclude selinux\
#  --exclude man --exclude doc --exclude locale --exclude X11\
#  --exclude fonts --exclude gnome --exclude foomatic\
#  --exclude gnome-applets --exclude man --exclude pixmaps usr/share
# crunch usr.share.locale /usr/share/locale/en_US/

# if [ -e /usr/share/fonts/default ]\
#   &#38;&#38; [ -e /usr/share/fonts/ISO8859-2 ]\
#   &#38;&#38; [ -e /usr/share/fonts/bitmap-fonts ]; then
#     crunch usr.share.fonts /usr/share/fonts/default /usr/share/fonts/ISO8859-2 \
#     /usr/share/fonts/bitmap-fonts
# fi

crunch root --exclude root/.cpan --exclude root/.mozilla --exclude root/down root
crunch boot boot
crunch etc --exclude etc/samba --exclude etc/X11 --exclude etc/gconf etc
crunch lib lib

crunch usr.sbin usr/sbin
# crunch usr.local usr/local
# crunch usr.libexec usr/libexec
crunch usr.kerberos usr/kerberos
crunch usr.bin --exclude usr/bin/emacs-x\
 --exclude usr/bin/emacsclient --exclude usr/bin/emacs-nox --exclude\
  usr/bin/gs --exclude usr/bin/pine $(exclude usr/bin/gimp-*)\
   --exclude usr/bin/doxygen --exclude usr/bin/postgres --exclude\
    usr/bin/gdb --exclude usr/bin/kmail --exclude usr/bin/splint\
	 --exclude usr/bin/odbctest --exclude usr/bin/php --exclude \
	 usr/bin/xchat --exclude usr/bin/gnucash --exclude usr/bin/pdfetex\
	  --exclude usr/bin/pdftex --exclude usr/bin/smbcacls\
	   --exclude usr/bin/evolution-calendar --exclude usr/bin/xpdf\
	    --exclude usr/bin/xmms usr/bin
crunch sbin sbin
crunch bin bin
crunch dev dev

# RH8. Fedora 1 puts them in /lib
# crunch kerberos usr/kerberos/lib/

# Now optional saves.

# arkeia specific:
# crunch arkeia usr/knox

# save these so we can use ssh for restore. *crack* for RH 7.0 login
# authentication.
# RH 8.0
# crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libssl* usr/lib/libcrypto*
# Fedora 1
# crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libwrap*\
#  usr/lib/libk* usr/lib/*krb5* /usr/lib/libgss*
# Fedora 3
# crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libwrap*\
#  usr/lib/libk* usr/lib/*krb5* usr/lib/libgss*
# Fedora 7
# crunch usr.lib usr/lib/*crack*\
#  usr/lib/libk* usr/lib/*krb5* usr/lib/libgss*

# Grub requires these at installation time.
crunch usr.share.grub usr/share/grub

# save the scripts we will use to restore.
cp -p /etc/bare.metal.recovery/* ${zip}/bin

echo "Testing our results."
find ${zip} -iname "*.bz2" | xargs bunzip2 -t

# Since we're doing system stuff anyway, make a boot disk ISO image
# suitable for burning. It uses the current kernel.

mkbootdisk --iso --device ${zip}/bootdisk.$(uname -r).iso $(uname -r)

# Recent kernels have incorporated a new ATA (IDE) hard drive
# driver. Because of this, parallel ATA drives now show up as SCSI
# drives, as serial ATA have always done. However, not all rescue
# distributions (e.g. finix) use this new driver. So the following
# line very carefully replaces "/dev/sda" with "/dev/hda". Use this as
# a template if you have multiple IDE hard drives.

# Note that there is no guaranteed mapping! Systems with multiple hard
# drives may have confusing mappings. Be sure to edit this line
# carefully. Check it if you add or remove a hard drive of any
# interface type to or from your system!

find ${zip} -type f | grep -v bz2$ | xargs sed -i 's|/dev/sda|/dev/hda|g'

du -hs ${zip}
df -m</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="RESTORE.METADATA"
>11.1.9. <TT
CLASS="FILENAME"
>restore.metadata</TT
></A
></H4
><P
>This script restores metadata from the ZIP disk as a first stage restore.</P
><P
> N.B: if you have libata IDE drive issues, the grub-install line at the end of this script won't work. If it doesn't, use your rescue disk to do the same.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore the meta-data from the ZIP disk. This runs under
# tomsrtbt only after partitions have been rebuilt, file systems made,
# and mounted. It also assumes the ZIP disk has already been
# mounted. Mounting the ZIP disk read only is probably a good idea.

# Time-stamp: &#60;2007-07-08 11:37:38 ccurley restore.metadata&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# 2007-07-08: We now force inittab to run level 3, which may be disty
# dependent. FHS compliance changes as well.

# 2005-08-03: We now use a relative path, so you can load from
# different places depending on the first stage system you are
# using. Also added some FC4 tricks, and some changes to better
# reproduce the permissions and ownerships.

# 2003 08 23: Oops: tar on tomsrtbt does not respect -p. Try setting
# umask to 0000 instead.

# 2003 02 13: Tar was not preserving permissions on restore. Fixed
# that.

# 2002 07 01: Went to bzip2 to compress the archives, for smaller
# results. This is important in a 100MB ZIP disk. Also some general
# code cleanup.

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

umask 0000

cd ..                           # Assume we are in /bin
zip=$(pwd)/data;              # Where we find the tarballs to restore.
target="/target";        # Where the hard drive to restore is mounted.

ls -lt $zip/*.bz2               # Warm fuzzies for the user.

cd $target

# Restore the archived metadata files.
for archive in $( ls $zip/*.bz2 ); do
  echo $archive
  ls -al $archive
  bzip2 -dc $archive | tar -xf -
done

# Build the mount points for our second stage restoration and other
# things.

# If you boot via an initrd, make sure you build a directory here so
# the kernel can mount the initrd at boot. tmp/.font-unix is for the
# xfs font server.

for dir in\
   back\
   dev\
   initrd\
   media\
   mnt/dosc\
   mnt/imports\
   mnt/nfs\
   mnt/zip\
   proc\
   selinux\
   sys\
   tmp/.font-unix\
   var/cache/yum\
   var/empty/sshd/etc\
   var/lib/bare.metal.recovery\
   var/lock/subsys\
   var/log\
   var/run\
   var/spool\
 ; do

  mkdir -p $target/$dir
done

for dir in mnt usr usr/share $(ls -d var/*) selinux usr/lib var\
  var/cache/yum var/lock/subsys var/run var/empty/sshd/etc\
  var/spool media ; do
  chmod go-w $target/$dir
done

# Set modes
chmod 0111 $target/var/empty/sshd
chown root:lock $target/var/lock
chmod 775 $target/var/lock
chmod 711 $target/var/empty/sshd
chmod 700 $target/var/lib/bare.metal.recovery

# For Fedora. First two for xfs.
# chroot $target chown xfs:xfs /tmp/.font-unix
# chmod 1777 $target/tmp/.font-unix # set the sticky bit.
chmod 1777 $target/tmp

# Now install the boot sector. N.B: if you have libata IDE drive
# issues, it won't work. If it doesn't, use your rescue disk to do the
# same.

# chroot $target /sbin/lilo -C /etc/lilo.conf
chroot $target /sbin/grub-install /dev/hda

# Set the system to boot to run level 3 regardless of the current run
# level. Be sure to set it back to the normal value.

sed -i s/id:.:initdefault:/id:3:initdefault:/g $target/etc/inittab

df -m</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="FIRST.STAGE"
>11.1.10. <TT
CLASS="FILENAME"
>first.stage</TT
></A
></H4
><P
>This script runs the entire first stage restore with no operator intervention.</P
><P
>If you want to check for bad blocks when it puts a file system on the partitions, use a "-c" command line option.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A master script to run the other, detailed scripts. Use this script
# only if you want no human intervention in the restore process. The
# only option is -c, which forces bad block checking during formatting
# of the partitions.

# Time-stamp: &#60;2007-07-06 13:31:08 ccurley first.stage&#62;

# Copyright 2002 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# 2005-08-07 We no longer assume the working directory. This is
# because the working directory will vary greatly according to which
# Linux disty you use and how you are doing your restoration.

export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: automated restore with no human interaction."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

for drive in $( ls make.dev.* ); do
    echo $drive$'\a'
    sleep 2
    ./$drive $blockcheck;
done

# If there are any LVM volumes, now is the time to restore them.

if [ -e make.lvs ] &#38;&#38; [ -e mount.lvs ]
then
    echo make.lvs$'\a'
    sleep 2
    ./make.lvs

    echo mount.lvs$'\a'
    ./mount.lvs
fi


# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order, which the loop below may
# not do. The root partition should be mounted first, then the rest in
# the order they cascade. If they cross mount, you'll have to handle
# that manually. If you have LVMs to deal with, that's a whole 'nother
# kettle of fish.

# The "ls -tr" will list the scripts in the order they are created, so
# it might be a good idea to create them (in the script save.metadata)
# in the order in which you should run them.

for drive in $( ls -tr mount.dev.* ); do
    echo $drive$'\a'
    sleep 2
    ./$drive;
done

./restore.metadata

# People who are really confident may comment this line in.
# reboot</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECONDSTAGE"
>11.2. Second Stage</A
></H3
><P
>These scripts run on the computer being backed up or restored.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="BACK.UP.ALL"
>11.2.1. <TT
CLASS="FILENAME"
>back.up.all</TT
></A
></H4
><P
>This script saves to another computer via an NFS mount. You can adapt it to save to tape drives or other media.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up the entire system to another computer's drive. To make this
# work, we need a convenient chunk of disk space on the remote computer we
# can nfs mount as /mnt/save.

# Time-stamp: &#60;2007-07-06 13:30:43 ccurley back.up.all&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/mnt/save"

# Make sure it's there
umount $save
mount $save

cd /

rm $save/tester.tar.old.gz
mv $save/tester.tar.gz $save/tester.tar.old.gz

# save everything except /mnt, /proc, and nfs mounted directories.

time tar cf - / --exclude /mnt --exclude /proc --exclude $save\
    | gzip -c &#62; $save/tester.tar.gz&#13;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="BACK.UP.ALL.SSH"
>11.2.2. <TT
CLASS="FILENAME"
>back.up.all.ssh</TT
></A
></H4
><P
>This script does exactly what <A
HREF="#BACK.UP.ALL"
><TT
CLASS="FILENAME"
>back.up.all</TT
></A
> does, but it uses SSH instead of NFS.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up the entire system to another computer's drive. To make this
# work, we need a convenient chunk of disk space on the remote
# computer. This version uses ssh to do its transfer, and compresses
# using bz2. This means this script has to know more about the other
# computer, which does not make for good modularization.

# Time-stamp: &#60;2007-07-06 13:30:54 ccurley back.up.all.ssh&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/backs/tester"
backup_server="charlesc"

# rotate the old backups. Do it all in one line to minimze authentication overhead.
ssh $backup_server "rm $save/tester.tar.old.bz2; mv $save/tester.tar.bz2 \
    $save/tester.tar.old.bz2"

# save everything except /mnt, /proc, and squid directories.

time tar cf - / --exclude /mnt --exclude /proc --exclude /var/spool/squid\
    | ssh $backup_server "bzip2 -9 &#62; $save/tester.tar.bz2"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="RESTORE.ALL"
>11.2.3. <TT
CLASS="FILENAME"
>restore.all</TT
></A
></H4
><P
>This is the restore script to use if you backed up using <A
HREF="#BACK.UP.ALL"
><TT
CLASS="FILENAME"
>back.up.all</TT
></A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data from an nfs mount. This is our final
# stage restore.

# Time-stamp: &#60;2007-07-06 13:36:23 ccurley restore.all&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

export save="/mnt/save"

mount $save

cd /
gunzip -dc $save/tester.tar.gz | tar -xpkf -

rm /var/run/*.pid

lilo</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="RESTORE.ALL.SSH"
>11.2.4. <TT
CLASS="FILENAME"
>restore.all.ssh</TT
></A
></H4
><P
>This is the restoration script to use if you used <A
HREF="#BACK.UP.ALL.SSH"
><TT
CLASS="FILENAME"
>back.up.all.ssh</TT
></A
> to back up.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data using ssh and bunzip2. This is
# our final stage restore.

# Copyright 2000 through the last date of modification Charles Curley.

# Time-stamp: &#60;2007-07-06 13:36:42 ccurley restore.all.ssh&#62;

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/backs/tester/"
backup_server="charlesc"

cd /

ssh $backup_server "cat $save/tester.tar.bz2" | bunzip2 | tar -xpkf -

rm /var/run/*.pid

lilo</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BACKUPSERVERSCRIPTS"
>11.3. Backup Server Scripts</A
></H3
><P
>The SSH scripts above have a possible security problem. If you run them on a firewall, the firewall has to have access via SSH to the backup server. In that case, a clever cracker might also be able to crack the backup server. It would be more secure to run backup and restore scripts on the backup server, and let the backup server have access to the firewall. That is what these scripts are for.</P
><P
>These scripts backup and restore the target completely, not just the stage one backup and restore. <TT
CLASS="FILENAME"
>get</TT
> backs up the bare metal archive separately so that you can make a CD-ROM ir NFS mount from it.</P
><P
>I use these scripts routinely.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="GET"
>11.3.1. <TT
CLASS="FILENAME"
>get</TT
></A
></H4
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up another computer's drive to this system. To make this work,
# we need a convenient chunk of disk space on this computer. This
# version uses ssh to do its transfer, and compresses using bz2. This
# version was developed so that the system to be backed up won't be
# authenticated to log onto the backup computer. This script is
# intended to be used on a firewall. You don't want the firewall to be
# authenticated to the backup system in case the firewall is cracked.

# Time-stamp: &#60;2007-07-06 13:31:40 ccurley get.tester&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# 2007-05-22: Changes for FHS compliance. Removed commented out
# references to ZIP drives. Now, if the archive does not exist on the
# client, we run save.metadata there.

# 2006-04-14: Use the script ../scripts/get.target to determine the
# host name. This makes the script more general, and maybe we can run
# it from one place &#38; determine the host name from the directory
# name. Also, we now test to see if old backups exist before deleting
# them.

# 2004 04 03: added /sys to the list of excludes. It is a read-only
# pseudo-file system like /proc.

# 2002 07 01: We now set the path on the target to the zip drive with
# a variable. This fixes a bug in the command to eject the zip disk.

# 2002 07 01: The zip disk archives are now in bzip2 format, so this
# script has been changed to reflect that.

# Get the host name of the computer to be backed up and other info.
. ../scripts/get.target

# The "--anchored" option is there to prevent --exclude from excluding
# all files with that name. E.g. we only want to exclude /sys, not
# some other sys elsewhere in the file system.

ssh $host "cd / ; tar -cf - --anchored --exclude media --exclude mnt\
 --exclude selinux --exclude sys --exclude proc --exclude var/spool/squid\
 --exclude var/cache/yum --exclude var/named/chroot/proc\
 --exclude var/lib/bare.metal.recovery * " | bzip2 -9 | cat &#62; $host.$DATE.tar.bz2

# if [ -e $host.dos.$DATE.old.tar.bz2 ] ; then
#     rm $host.dos.$DATE.old.tar.bz2
# fi

# echo Backing up $host dos to the backup server.
# ssh $host "cd / ; mount mnt/dosc ; tar -cf - mnt/dosc "\
# | bzip2 -9 | cat &#62; $host.dos.$DATE.tar.bz2

echo Testing the results.
find $host.$DATE* -iname "*.bz2" | xargs bunzip2 -t</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="RESTORE"
>11.3.2. <TT
CLASS="FILENAME"
>restore</TT
></A
></H4
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data to tester via ssh. This is our final
# stage restore.

# Time-stamp: &#60;2007-07-08 11:23:32 ccurley restore.tester&#62;

# Copyright 2000 Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# 2007-05-22: Changes for FHS compliance. Removed commented out
# references to ZIP drives.

# 2006-04-14: Use the script ../scripts/get.target to determine the
# host name. This makes the script more general, and maybe we can run
# it from one place &#38; determine the host name from the directory
# name.

# Get the host name of the computer to be backed up and other info.
. ../scripts/get.target

bunzip2 -dc $TARGET.tar.bz2 | ssh $host "umask 000 ; cd / ; tar -xpkf - "

# bunzip2 -dc $host.dos.$DATE.tar.bz2 | ssh $host "umask 000 ;\
# mount /mnt/dosc ; cd / ; tar -xpkf - "

# Note libata issue! We boot to /dev/sda, not /dev/hda, as IDE drives
# now show up as SCSI drives.

ssh $host "chown root:lock /var/lock ; grub-install /dev/sda"
# ; chown -R amanda:disk /var/lib/amanda</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="GET.TARGET"
>11.3.3. <TT
CLASS="FILENAME"
>get.target</TT
></A
></H4
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># -*- shell-script -*-

# Time-stamp: &#60;2007-07-06 13:31:22 ccurley get.target&#62;

# Copyright 2000 through the last date of modification, Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# How to determine the target: the directory structure is
# /..../back/hostname.OS.etc So we have to get the name of the
# directory. That gives us host name and OS.etc. From that we extract
# the host name.

path=`pwd`

target=${path##/*/}
host=${target%%.*}

# Run "info date" for more information.

DATE=`date +%Y%m%d`
# echo "Today's date is $DATE."

echo "\$target is $target. \$host is $host. Today's date is $DATE."

name=$0
echo "This is script $name"

if [ $(echo $name | grep -i get &#62; /dev/null) ] ; then
    # Do functions common to all restores.

    # Which archive do we restore and is this a valid target name?

    TARGET=$1

    if [ -z $TARGET ] ; then
        echo Please specify a target from one of:
        for dir in $(ls -d $host.*) ; do
            if [ -d $dir ] ; then
                echo -n "$dir "
            fi
        done
        exit 2;
    fi

    if [ -z $TARGET ] || [ ! -d $TARGET ] ; then
        echo $TARGET does not exist!
        exit 2;
    fi

    ssh $host rm -r /var/lib/rpm
else
    # Do functions common to all gets.

    # Where we will get the archives on the target.

    #zip=/mnt/zip
    export zip="/var/lib/bare.metal.recovery";

    # If it does not already exist, build the archive.

    ssh $host "if [ ! -d ${zip}/$DATE ] ; then echo Saving metadata... ; save.metadata ; fi"

    echo Backing up $host

    if [ -e $host.$DATE ] ; then
	    rm -r $host.$DATE
    fi

    echo Copying the bare metal recovery archive.

    # -r for recursive copy, -p to preserve times and permissions, -q
    # for quiet: no progress meter.

    scp -qpr $host:$zip/$DATE $host.$DATE

    du -hs $host.*

    echo Cleaning out old yum packages
    ssh $host "yum clean packages"

    echo Backing up $host to the backup server.

    if [ -e $host.$DATE.tar.bz2 ] ; then
        rm $host.$DATE.tar.bz2
    fi
fi</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MISC.FILES"
>11.4. Miscellaneous Files</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="INSTALL"
>11.4.1. <TT
CLASS="FILENAME"
>install</TT
></A
></H4
><P
>This little script just installs things and sets up a few directories. It would be a useful basis for an RPM or deb package. The placement of files is based on the <EM
><A
HREF="http://www.pathname.com/fhs/"
TARGET="_top"
>Filesystem Hierarchy Standard</A
></EM
>, version 2.3, announced on January 29, 2004.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to install the bare metal recovery scripts. With any luck,
# this will comply with the "Filesystem Hierarchy Standard",
# http://www.pathname.com/fhs/, version 2.3, announced on January 29,
# 2004.

# Time-stamp: &#60;2007-07-06 13:33:29 ccurley install&#62;

# Copyright 2007 through the last date of modification, Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# Where we put the archives ready for making CDs, etc.
mkdir -p /var/lib/bare.metal.recovery

# Keep them secure from pesky snooping users who don't need to be able
# to hack a copy of, say, /etc/shadow.
chmod 700 /var/lib/bare.metal.recovery

# Backup time executables.
cp -rp save.metadata make.fdisk /usr/sbin

# Save the recovery time executables we provide. The archiving
# programs look for them here and save them into the archives.
mkdir -p /etc/bare.metal.recovery
cp -rp first.stage restore.metadata /etc/bare.metal.recovery</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="RESOURCES"
>12. Resources</A
></H2
><P
>In no particular order. These are things you might want to investigate for yourself. A listing here should not be taken as an endorsement. In fact, in many case I have not used the product and cannot comment on it.</P
><P
></P
><UL
><LI
><P
><A
HREF="http://osdev.berlios.de/netboot.html"
TARGET="_top"
>Network-booting Your Operating System</A
> describes several techniques for booting across a network, using <A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>grub</A
> and some other tricks. I haven't tried it, but I have a sneaky suspicion that with an especially trained floppy diskette, you could get your entire first stage image onto the computer to be restored.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://btmgr.webframe.org/"
TARGET="_top"
>Smart Boot Manager (SBM)</A
> is an OS independent and full-featured boot manager with an easy-to-use user interface. There are some screen shots available."</SPAN
> It is essential if your BIOS will not allow you to boot to CD-ROM and you want to use a CD-ROM based Linux for Stage 1 recovery.</P
></LI
><LI
><P
><A
HREF="http://www.oreilly.com/catalog/unixbr/author.html"
TARGET="_top"
>W. Curtis Preston</A
>'s excellent <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>. This is the book that got me started on this bare metal recovery stuff. I highly recommend it; <A
HREF="http://www2.linuxjournal.com/lj-issues/issue78/3839.html"
TARGET="_top"
>read my review</A
>.</P
></LI
><LI
><P
>An old (2000) list of <A
HREF="http://www.fokus.gmd.de/linux/linux-distrib-small.html"
TARGET="_top"
>small Linux disties.</A
></P
></LI
><LI
><P
><A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, <SPAN
CLASS="QUOTE"
>"The most Linux on 1 floppy disk."</SPAN
> Tom also has links to other small disties.</P
></LI
><LI
><P
>The <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
>. See particularly the <SPAN
CLASS="QUOTE"
>"<I
CLASS="CITETITLE"
>LILO, Linux Crash Rescue HOW-TO</I
>."</SPAN
></P
></LI
><LI
><P
>The Free Software Foundation's <A
HREF="http://www.gnu.org/software/parted"
TARGET="_top"
><TT
CLASS="FILENAME"
>parted</TT
></A
> for editing (enlarging, shrinking, moving) partitions.</P
></LI
><LI
><P
><A
HREF="http://qtparted.sourceforge.net/"
TARGET="_top"
>QtParted</A
> looks to do the same thing with a GUI front end.</P
></LI
><LI
><P
><A
HREF="http://www.partimage.org/"
TARGET="_top"
>Partition Image</A
> for backing up partitions.</P
><P
>From the web page: <SPAN
CLASS="QUOTE"
>"Partition Image is a Linux/UNIX utility which saves partitions in many formats (see below) to an image file. The image file can be compressed in the GZIP/BZIP2 formats to save disk space, and split into multiple files to be copied on removable floppies (ZIP for example), .... The partition can be saved across the network since version 0.6.0."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://sourceforge.net/projects/bacula"
TARGET="_top"
>Bacula</A
> is a GLPled backup product which has bare metal recovery code inspired in part by this HOWTO.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://www.feyrer.de/g4u/"
TARGET="_top"
>g4u ('ghost for unix')</A
> is a NetBSD-based bootfloppy/CD-ROM that allows easy cloning of PC harddisks to deploy a common setup on a number of PCs using FTP. The floppy/CD offers two functions. First is to upload the compressed image of a local harddisk to a FTP server. Other is to restore that image via FTP, uncompress it and write it back to disk; network configuration is fetched via DHCP. As the harddisk is processed as a image, any filesystem and operating system can be deployed using g4u."</SPAN
></P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"We present <A
HREF="http://www.cs.utah.edu/flux/papers/frisbee-usenix03-base.html"
TARGET="_top"
>Frisbee</A
>, a system for saving, transferring, and installing entire disk images, whose goals are speed and scalability in a LAN environment. Among the techniques Frisbee uses are an appropriately-adapted method of filesystem-aware compression, a custom application-level reliable multicast protocol, and flexible application-level framing. This design results in a system which can rapidly and reliably distribute a disk image to many clients simultaneously. For example, Frisbee can write a total of 50 gigabytes of data to 80 disks in 34 seconds on commodity PC hardware. We describe Frisbee's design and implementation, review important design decisions, and evaluate its performance."</SPAN
></P
></LI
><LI
><P
>There are a number of USB key disties available. Check <A
HREF="http://www.distrowatch.com/"
TARGET="_top"
>DistroWatch</A
> for details.</P
></LI
><LI
><P
>CD-ROM based rescue kits. This is not intended to be an exhaustive list. If you know of one (or even something that pretends to be one), please <A
HREF="charlescurley at charlescurley dot com"
TARGET="_top"
>let me know</A
>. You may find more recent information at <A
HREF="http://www.distrowatch.com/"
TARGET="_top"
>DistroWatch</A
>.</P
><P
></P
><UL
><LI
><P
>Hugo Rabson's <A
HREF="http://www.microwerks.net/~hugo/"
TARGET="_top"
>Mondo</A
> <SPAN
CLASS="QUOTE"
>"... creates one or more bootable Rescue CD's (or tape+floppies) containing some or all of your filesystem. In the event of catastrophic data loss, you will be able to restore from bare metal."</SPAN
></P
></LI
><LI
><P
>The <A
HREF="http://crashrecovery.org/"
TARGET="_top"
>Crash Recovery Kit for Linux</A
></P
></LI
><LI
><P
><A
HREF="http://www-106.ibm.com/developerworks/linux/library/l-knopx.html?ca=dgr-lnxw04Knoppix"
TARGET="_top"
><SPAN
CLASS="QUOTE"
>"System recovery with Knoppix"</SPAN
></A
> is a good introduction to system recovery in general, and has some useful <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> links.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://emergencycd2.sourceforge.net/"
TARGET="_top"
>Cool Linux CD</A
> is live CD with Linux system. This used 2.4 kernel and some free and demo soft."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://www.sysresccd.org/index.en.php"
TARGET="_top"
>SystemRescueCd</A
><SPAN
CLASS="QUOTE"
>" is a linux system on a bootable cdrom for repairing your system and your data after a crash. It also aims to provide an easy way to carry out admin tasks on your computer, such as creating and editing the partitions of the hard disk. It contains a lot of system utilities (parted, partimage, fstools, ...) and basic ones (editors, midnight commander, network tools). It aims to be very easy to use: just boot from the cdrom, and you can do everything. The kernel of the system supports most important file systems (ext2/ext3, reiserfs, xfs, jfs, vfat, ntfs, iso9660), and network ones (samba and NFS)."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://syslinux.zytor.com/"
TARGET="_top"
>Syslinux</A
> builds boot code for floppy diskettes, CD-ROMs and Intel PXE (Pre-Execution Environment) images. It is not dependent on a floppy diskette image. You can build your own CDs with a number of tools, such as <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, on it.</P
></LI
><LI
><P
>In case you'd like to roll your own: <SPAN
CLASS="QUOTE"
>"<A
HREF="http://www.linux-live.org/"
TARGET="_top"
>Linux Live</A
> is a set of bash scripts which allows you to create [your] own LiveCD from every Linux distribution. Just install your favourite distro, remove all unnecessary files (for example man pages and all other files which are not important for you) and then download and run these scripts."</SPAN
></P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"The <A
HREF="http://www.linbox.com/en/ppart.html"
TARGET="_top"
>PPART CD</A
> allows you to generate system recovery bootable CD of previously saved hard disks."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://rescuecd.sourceforge.net/"
TARGET="_top"
> Timo's Rescue CD Set</A
>: <SPAN
CLASS="QUOTE"
>" This set is my approach for an easy way to generate a rescue system on a bootable cd, which can easily be adapted to the own needs. The project evolves more and more into a 'debian on cd' project, so it's not only possible to use the system as a rescuecd, it is also possible to install a whole debian system on cd."</SPAN
></P
></LI
><LI
><P
>The <A
HREF="http://www.frozentech.com/content/livecd.php"
TARGET="_top"
>List of Live CDs</A
> has more CD based disties.</P
></LI
></UL
></LI
></UL
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="APPENDIX1GFDL"
>A. GNU Free Documentation License</A
></H1
><P
>Version 1.1, March 2000</P
><A
NAME="AEN1092"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000  Free Software Foundation, Inc. 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL02"
>0. PREAMBLE</A
></H2
><P
>The purpose of this License is to make a manual, textbook, or other written document "free" in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially.  Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</P
><P
>This License is a kind of "copyleft", which means that derivative works of the document must themselves be free in the same sense.  It complements the GNU General Public License, which is a copyleft license designed for free software.</P
><P
>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does.  But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book.  We recommend this License principally for works whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL03"
>1. APPLICABILITY AND DEFINITIONS</A
></H2
><P
>This License applies to any manual or other work that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License.  The "Document", below, refers to any such manual or work.  Any member of the public is a licensee, and is addressed as "you".</P
><P
>A "Modified Version" of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</P
><P
>A "Secondary Section" is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (For example, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</P
><P
>The "Invariant Sections" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License.</P
><P
>The "Cover Texts" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License.</P
><P
>A "Transparent" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, whose contents can be viewed and edited directly and straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters.  A copy made in an otherwise Transparent file format whose markup has been designed to thwart or discourage subsequent modification by readers is not Transparent.  A copy that is not "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML designed for human modification. Opaque formats include PostScript, PDF, proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML produced by some word processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, "Title Page" means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL04"
>2. VERBATIM COPYING</A
></H2
><P
>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License.  You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute.  However, you may accept compensation in exchange for copies.  If you distribute a large enough number of copies you must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL05"
>3. COPYING IN QUANTITY</A
></H2
><P
>If you publish printed copies of the Document numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover.  Both covers must also clearly and legibly identify you as the publisher of these copies.  The front cover must present the full title with all words of the title equally prominent and visible.  You may add other material on the covers in addition.  Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</P
><P
>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a publicly-accessible computer-network location containing a complete Transparent copy of the Document, free of added material, which the general network-using public has access to download anonymously at no charge using public-standard network protocols.  If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL06"
>4. MODIFICATIONS</A
></H2
><P
>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it.  In addition, you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document).  You may use the same title as a previous version if the original publisher of that version gives permission.</P
></LI
><LI
><P
>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has less than five).</P
></LI
><LI
><P
>State on the Title page the name of the publisher of the Modified Version, as the publisher.</P
></LI
><LI
><P
>Preserve all the copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</P
></LI
><LI
><P
>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</P
></LI
><LI
><P
>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice.</P
></LI
><LI
><P
>Include an unaltered copy of this License.</P
></LI
><LI
><P
>Preserve the section entitled "History", and its title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page.  If there is no section entitled "History" in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on.  These may be placed in the "History" section.  You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</P
></LI
><LI
><P
>In any section entitled "Acknowledgements" or "Dedications", preserve the section's title, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</P
></LI
><LI
><P
>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles.  Section numbers or the equivalent are not considered part of the section titles.</P
></LI
><LI
><P
>Delete any section entitled "Endorsements".  Such a section may not be included in the Modified Version.</P
></LI
><LI
><P
>Do not retitle any existing section as "Endorsements" or to conflict in title with any Invariant Section.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant.  To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice.  These titles must be distinct from any other section titles.</P
><P
>You may add a section entitled "Endorsements", provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version.  Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity.  If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL07"
>5. COMBINING DOCUMENTS</A
></H2
><P
>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice.</P
><P
>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy.  If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number.  Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</P
><P
>In the combination, you must combine any sections entitled "History" in the various original documents, forming one section entitled "History"; likewise combine any sections entitled "Acknowledgements", and any sections entitled "Dedications".  You must delete all sections entitled "Endorsements."</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL08"
>6. COLLECTIONS OF DOCUMENTS</A
></H2
><P
>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</P
><P
>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL09"
>7. AGGREGATION WITH INDEPENDENT WORKS</A
></H2
><P
>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, does not as a whole count as a Modified Version of the Document, provided no compilation copyright is claimed for the compilation.  Such a compilation is called an "aggregate", and this License does not apply to the other self-contained works thus compiled with the Document, on account of their being thus compiled, if they are not themselves derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one quarter of the entire aggregate, the Document's Cover Texts may be placed on covers that surround only the Document within the aggregate.  Otherwise they must appear on covers around the whole aggregate.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL10"
>8. TRANSLATION</A
></H2
><P
>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4.  Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections.  You may include a translation of this License provided that you also include the original English version of this License.  In case of a disagreement between the translation and the original English version of this License, the original English version will prevail.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL11"
>9. TERMINATION</A
></H2
><P
>You may not copy, modify, sublicense, or distribute the Document except as expressly provided for under this License.  Any other attempt to copy, modify, sublicense or distribute the Document is void, and will automatically terminate your rights under this License.  However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL12"
>10. FUTURE REVISIONS OF THIS LICENSE</A
></H2
><P
>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.  See <A
HREF="http://www.gnu.org/copyleft/"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.</P
><P
>Each version of the License is given a distinguishing version number.  If the Document specifies that a particular numbered version of this License "or any later version" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GFDL13"
>11. How to use this License for your documents</A
></H2
><P
>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</P
><A
NAME="AEN1182"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
> Copyright (c)  YEAR  YOUR NAME. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with the Invariant Sections being LIST THEIR TITLES, with the Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. A copy of the license is included in the section entitled "GNU Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have no Invariant Sections, write "with no Invariant Sections" instead of saying which ones are invariant.  If you have no Front-Cover Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being LIST"; likewise for Back-Cover Texts.</P
><P
>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN410"
HREF="#AEN410"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>I emphasize copy because <B
CLASS="COMMAND"
>mkisofs</B
> will mung the file in the directory from which it makes the ISO image.</P
></TD
></TR
></TABLE
></BODY
></HTML
>