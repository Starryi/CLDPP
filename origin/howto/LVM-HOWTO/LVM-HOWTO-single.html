<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>LVM HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="This document describes how to build, install, and configure LVM for Linux. A basic description of LVM is also included. This version of the HowTo is for LVM 2 with device-mapper, as well as LVM 1.0.8."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idm1"></a>LVM HOWTO</h1></div><div><div class="author"><h3 class="author"><span class="firstname">AJ</span> <span class="surname">Lewis</span></h3><div class="affiliation"><div class="address"><p><br>
          <code class="email">&lt;<a class="email" href="mailto:alewis(at)rackable.com">alewis(at)rackable.com</a>&gt;</code><br>
        </p></div></div></div></div><div><p class="copyright">Copyright © 2002-2003 Sistina Software, Inc</p></div><div><p class="copyright">Copyright © 2004-2005 Red Hat, Inc</p></div><div><p class="copyright">Copyright © 2005-2006 Terrascale Technologies, Inc</p></div><div><p class="copyright">Copyright © 2006 Rackable Systems, Inc</p></div><div><div class="legalnotice"><a name="idm124"></a><p>
        Permission is granted to copy, distribute and/or modify
        this document under the terms of the GNU Free
        Documentation License, Version 1.2 published by the Free
        Software Foundation; with no Invariant Sections, no
        Front-Cover Texts and no Back-Cover Texts.  A copy of the
        license is included in the section entitled "GNU Free
        Documentation License".
      </p><p>
        This document is distributed in the hope that it will be
        useful, but WITHOUT ANY WARRANTY, either expressed or
        implied. While every effort has been taken to ensure the
        accuracy of the information documented herein, the
        author(s)/editor(s)/maintainer(s)/contributor(s) assumes
        NO RESPONSIBILITY for any errors, or for any damages,
        direct or consequential, as a result of the use of the
        information documented herein.
      </p></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.19</td><td align="left">2006-11-27</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Clarified full snapshot conditions in <a class="link" href="#snapshotintro" title="8. Snapshots">Section 8, &#8220;Snapshots&#8221;</a> and <a class="link" href="#snapbackcreate" title="4.1. Create the snapshot volume">Section 4.1, &#8220;Create the snapshot volume&#8221;</a> and added a note about resizing the origin of a snapshot;
          Fixed Rackable copyright;
          Fixed e-mail address
        </td></tr><tr><td align="left">Revision 0.18</td><td align="left">2006-11-27</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Clarify whole disk usage in <a class="link" href="#initdisks" title="1. Initializing disks or disk partitions">Section 1, &#8220;Initializing disks or disk partitions&#8221;</a>;
          Updated copyright;
          Updated e-mail address
      	</td></tr><tr><td align="left">Revision 0.17</td><td align="left">2005-10-03</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Added FAQ entry for max size of LVs in LVM2;
          Did some cleanup of "Recover physical volume metadata" section;
	  Updated e-mail address
        </td></tr><tr><td align="left">Revision 0.16</td><td align="left">2005-07-15</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Added lvm2 boot-time scripts info;
          Added "Recover physical volume metadata" section - thanks to
          Maximilian Attems for the patch
        </td></tr><tr><td align="left">Revision 0.15</td><td align="left">2005-06-09</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Removed references to xfs_freeze - it is no longer needed;
          Updated snapshots subsection in Anatomy of LVM section;
          Added a couple entries to the LVM2 FAQ;
          Fixed a couple typos
        </td></tr><tr><td align="left">Revision 0.14</td><td align="left">2004-10-06</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Added reference to lvm2_createinitrd in source tree;
          Adjusted lvcreate example slightly; Added 'vgchange -ay' in
          'Moving a volume group to another system' recipe
        </td></tr><tr><td align="left">Revision 0.13</td><td align="left">2004-08-16</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Clarify symlink farm description;
          Fix dm control device major number;
          Remove /boot from vg in small lvm setup example;
          Add notes about /boot and / on LVM;
          Remove outdated link;
        </td></tr><tr><td align="left">Revision 0.12</td><td align="left">2004-06-07</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated LVM2 FAQ entries
        </td></tr><tr><td align="left">Revision 0.11</td><td align="left">2004-05-03</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated LVM2 FAQ entries
        </td></tr><tr><td align="left">Revision 0.10</td><td align="left">2004-04-22</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          removed -print0 from find command after receiving
            reports that it doesn't work
        </td></tr><tr><td align="left">Revision 0.9</td><td align="left">2004-04-16</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Added -print0 to find command before piping
          it to cpio;
          Changed vgimport command line for LVM 2;
          Added ext3 to the ext2 resize section;
          Updated FAQ;
          Updated Links section
        </td></tr><tr><td align="left">Revision 0.8</td><td align="left">2004-02-25</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated CVS locations and FTP links;
          Added section on extending a JFS filesystem;
          Fixed typos - Ran aspell against document
        </td></tr><tr><td align="left">Revision 0.7</td><td align="left">2004-02-16</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated to include LVM 2 and device mapper information;
          Updated email addresses;
          Updated copyright;
          Added FAQ section;
          Added document license;
          Updated to docbook 4.2
        </td></tr><tr><td align="left">Revision 0.6</td><td align="left">2003-12-09</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated for LVM 1.0.8;
          fixed broken link;
          Clarified redhat init script section;
        </td></tr><tr><td align="left">Revision 0.5</td><td align="left">2003-02-10</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated Redhat initscript information for 7.0 and above;
          Added information on removing a partition table from a
          disk if pvcreate fails;
          Default PE size is 32MB now;
          Updated method for snapshotting under XFS.
        </td></tr><tr><td align="left">Revision 0.4</td><td align="left">2002-12-16</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated for LVM 1.0.6
        </td></tr><tr><td align="left">Revision 0.3</td><td align="left">2002-09-16</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          removed example pvmove from Command Operations section - we now
          just point to the more detailed recipe on pvmove that contains
          various warnings and such
        </td></tr><tr><td align="left">Revision 0.2</td><td align="left">2002-09-11</td><td align="left">ajl</td></tr><tr><td align="left" colspan="3">
          Updated for LVM 1.0.5 and converted to DocBook XML 4.1.2.
        </td></tr><tr><td align="left">Revision 0.1</td><td align="left">2002-04-28</td><td align="left">gf</td></tr><tr><td align="left" colspan="3">
          Initial conversion from Sistina's LaTeX source and import to
          tLDP in LinuxDoc format.
        </td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
        This document describes how to build, install, and configure
        LVM for Linux.  A basic description of LVM is also included.
        This version of the HowTo is for LVM 2 with device-mapper, as
        well as LVM 1.0.8.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#intro"> Introduction </a></span></dt><dd><dl><dt><span class="sect1"><a href="#latest_version">1. Latest Version</a></span></dt><dt><span class="sect1"><a href="#disclaimer">2. Disclaimer</a></span></dt><dt><span class="sect1"><a href="#contributors">3. Contributors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#whatislvm">1. What is LVM?</a></span></dt><dt><span class="chapter"><a href="#whatisvolman">2. What is Logical Volume Management?</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whywouldiwantit">1. Why would I want it?</a></span></dt><dt><span class="sect1"><a href="#benefitsoflvmsmall">2. Benefits of Logical Volume Management on a Small System</a></span></dt><dt><span class="sect1"><a href="#benefitsoflvmlarge">3. Benefits of Logical Volume Management on a Large System</a></span></dt></dl></dd><dt><span class="chapter"><a href="#anatomy">3. Anatomy of LVM</a></span></dt><dd><dl><dt><span class="sect1"><a href="#VG">1. volume group (VG)</a></span></dt><dt><span class="sect1"><a href="#PV">2. physical volume (PV)</a></span></dt><dt><span class="sect1"><a href="#LV">3. logical volume (LV)</a></span></dt><dt><span class="sect1"><a href="#PE">4. physical extent (PE)</a></span></dt><dt><span class="sect1"><a href="#LE">5. logical extent (LE)</a></span></dt><dt><span class="sect1"><a href="#tyingittogether">6. Tying it all together</a></span></dt><dt><span class="sect1"><a href="#mapmode">7. mapping modes (linear/striped)</a></span></dt><dt><span class="sect1"><a href="#snapshotintro">8. Snapshots</a></span></dt></dl></dd><dt><span class="chapter"><a href="#FAQ">4. Frequently Asked Questions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#lvm2faq">1. LVM 2 FAQ</a></span></dt><dt><span class="sect1"><a href="#lvm1faq">2. LVM 1 FAQ</a></span></dt></dl></dd><dt><span class="chapter"><a href="#getlvm">5. Acquiring LVM</a></span></dt><dd><dl><dt><span class="sect1"><a href="#downloadsource">1. Download the source</a></span></dt><dt><span class="sect1"><a href="#PublicCVS">2. Download the development source via CVS</a></span></dt><dt><span class="sect1"><a href="#beforebeginning">3. Before You Begin</a></span></dt><dt><span class="sect1"><a href="#initsetup">4. Initial Setup</a></span></dt><dt><span class="sect1"><a href="#checkoutsource">5. Checking Out Source Code</a></span></dt><dt><span class="sect1"><a href="#codeupdate">6. Code Updates</a></span></dt><dt><span class="sect1"><a href="#startproj">7. Starting a Project</a></span></dt><dt><span class="sect1"><a href="#hackingcode">8. Hacking the Code</a></span></dt><dt><span class="sect1"><a href="#conflicts">9. Conflicts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#buildkernelmods">6. Building the kernel modules</a></span></dt><dd><dl><dt><span class="sect1"><a href="#builddmmod">1. Building the device-mapper module</a></span></dt><dt><span class="sect1"><a href="#buildlvmmod">2. Build the LVM 1 kernel module</a></span></dt><dd><dl><dt><span class="sect2"><a href="#buildlvmpatch">2.1. Building a patch for your kernel</a></span></dt><dt><span class="sect2"><a href="#buildlvm1-2.2">2.2. Building the LVM module for Linux 2.2.17+</a></span></dt><dt><span class="sect2"><a href="#buildlvm1-2.4">2.3. Building the LVM modules for Linux 2.4</a></span></dt><dt><span class="sect2"><a href="#checkproc">2.4. Checking the proc file system</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#boot_scripts">7. LVM 1 Boot time scripts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#initscriptcaldera">1. Caldera</a></span></dt><dt><span class="sect1"><a href="#initscriptdebian">2. Debian</a></span></dt><dt><span class="sect1"><a href="#initscriptmandrake">3. Mandrake</a></span></dt><dt><span class="sect1"><a href="#initscriptredhat">4. Redhat</a></span></dt><dt><span class="sect1"><a href="#initscriptslackware">5. Slackware</a></span></dt><dt><span class="sect1"><a href="#initscriptsuse">6. SuSE</a></span></dt></dl></dd><dt><span class="chapter"><a href="#lvm2_boot">8.  LVM 2 Boot Time Scripts </a></span></dt><dt><span class="chapter"><a href="#buildlvm">9. Building LVM from the Source</a></span></dt><dd><dl><dt><span class="sect1"><a href="#makelvm1user">1. Make LVM library and tools</a></span></dt><dt><span class="sect1"><a href="#installlvm1user">2. Install LVM library and tools</a></span></dt><dt><span class="sect1"><a href="#removelvm1user">3. Removing LVM library and tools</a></span></dt></dl></dd><dt><span class="chapter"><a href="#trans1">10. Transitioning from previous versions of LVM to LVM 1.0.8</a></span></dt><dd><dl><dt><span class="sect1"><a href="#upgradelvm1">1. Upgrading to LVM 1.0.8 with a non-LVM root partition</a></span></dt><dt><span class="sect1"><a href="#upgradetolvmroot">2. Upgrading to LVM 1.0.8 with an LVM root partition and initrd</a></span></dt></dl></dd><dt><span class="chapter"><a href="#commontask">11. Common Tasks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#initdisks">1. Initializing disks or disk partitions</a></span></dt><dt><span class="sect1"><a href="#createvgs">2. Creating a volume group</a></span></dt><dt><span class="sect1"><a href="#activatevgs">3. Activating a volume group</a></span></dt><dt><span class="sect1"><a href="#removevgs">4. Removing a volume group</a></span></dt><dt><span class="sect1"><a href="#addpvstovg">5. Adding physical volumes to a volume group</a></span></dt><dt><span class="sect1"><a href="#removepvsfromvg">6. Removing physical volumes from a volume group</a></span></dt><dt><span class="sect1"><a href="#createlv">7. Creating a logical volume</a></span></dt><dt><span class="sect1"><a href="#removelv">8. Removing a logical volume</a></span></dt><dt><span class="sect1"><a href="#extendlv">9. Extending a logical volume</a></span></dt><dt><span class="sect1"><a href="#reducelv">10. Reducing a logical volume</a></span></dt><dt><span class="sect1"><a href="#migrateoffpv">11. Migrating data off of a physical volume</a></span></dt></dl></dd><dt><span class="chapter"><a href="#diskpart">12. Disk partitioning</a></span></dt><dd><dl><dt><span class="sect1"><a href="#multpartitions">1. Multiple partitions on the same disk</a></span></dt><dt><span class="sect1"><a href="#sundisklabels">2. Sun disk labels</a></span></dt></dl></dd><dt><span class="chapter"><a href="#recipes">13. Recipes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#recipethreescsi">1. Setting up LVM on three SCSI disks</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1056">1.1. Preparing the disks</a></span></dt><dt><span class="sect2"><a href="#idm1066">1.2. Setup a Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1078">1.3. Creating the Logical Volume</a></span></dt><dt><span class="sect2"><a href="#idm1085">1.4. Create the File System</a></span></dt><dt><span class="sect2"><a href="#idm1091">1.5. Test the File System</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipethreescsistripe">2. Setting up LVM on three SCSI disks with striping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1106">2.1. Preparing the disk partitions</a></span></dt><dt><span class="sect2"><a href="#idm1116">2.2. Setup a Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1128">2.3. Creating the Logical Volume</a></span></dt><dt><span class="sect2"><a href="#idm1138">2.4. Create the File System</a></span></dt><dt><span class="sect2"><a href="#idm1144">2.5. Test the File System</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipeadddisk">3. Add a new disk to a multi-disk SCSI system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1155">3.1. Current situation</a></span></dt><dt><span class="sect2"><a href="#idm1164">3.2. Prepare the disk partitions</a></span></dt><dt><span class="sect2"><a href="#idm1199">3.3. Add the new disks to the volume groups</a></span></dt><dt><span class="sect2"><a href="#idm1209">3.4. Extend the file systems</a></span></dt><dt><span class="sect2"><a href="#idm1221">3.5. Remount the extended volumes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Snapshots_Backup">4. Taking a Backup Using Snapshots</a></span></dt><dd><dl><dt><span class="sect2"><a href="#snapbackcreate">4.1. Create the snapshot volume</a></span></dt><dt><span class="sect2"><a href="#idm1243">4.2. Mount the snapshot volume</a></span></dt><dt><span class="sect2"><a href="#idm1253">4.3. Do the backup</a></span></dt><dt><span class="sect2"><a href="#idm1259">4.4. Remove the snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#RemoveADisk">5. Removing an Old Disk</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1272">5.1. Distributing Old Extents to Existing Disks in Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1291">5.2. Distributing Old Extents to a New Replacement Disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipemovevgtonewsys">6. Moving a volume group to another system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1325">6.1. Unmount the file system</a></span></dt><dt><span class="sect2"><a href="#idm1330">6.2. Mark the volume group inactive</a></span></dt><dt><span class="sect2"><a href="#idm1336">6.3. Export the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1342">6.4. Import the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1356">6.5. Activate the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1361">6.6. Mount the file system</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipesplitvg">7. Splitting a volume group</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1369">7.1. Determine free space</a></span></dt><dt><span class="sect2"><a href="#idm1375">7.2. Move data off the disks to be used</a></span></dt><dt><span class="sect2"><a href="#idm1388">7.3. Create the new volume group</a></span></dt><dt><span class="sect2"><a href="#idm1394">7.4. Remove remaining volume</a></span></dt><dt><span class="sect2"><a href="#idm1402">7.5. Create new logical volume</a></span></dt><dt><span class="sect2"><a href="#idm1408">7.6. Make a file system on the volume</a></span></dt><dt><span class="sect2"><a href="#idm1413">7.7. Mount the new volume</a></span></dt></dl></dd><dt><span class="sect1"><a href="#UpgradeRootToLVM">8. Converting a root filesystem to
        LVM 1</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1436">8.1. Boot single user</a></span></dt><dt><span class="sect2"><a href="#idm1440">8.2. Run Parted</a></span></dt><dt><span class="sect2"><a href="#idm1455">8.3. Reboot</a></span></dt><dt><span class="sect2"><a href="#idm1458">8.4. Verify kernel config options</a></span></dt><dt><span class="sect2"><a href="#idm1461">8.5. Adjust partition type</a></span></dt><dt><span class="sect2"><a href="#idm1471">8.6. Set up LVM 1 for the new scheme</a></span></dt><dt><span class="sect2"><a href="#idm1490">8.7. Create the Filesystem</a></span></dt><dt><span class="sect2"><a href="#idm1495">8.8. Update /etc/fstab</a></span></dt><dt><span class="sect2"><a href="#idm1500">8.9. Create an LVM 1 initial RAM disk</a></span></dt><dt><span class="sect2"><a href="#idm1505">8.10. Update /etc/lilo.conf</a></span></dt><dt><span class="sect2"><a href="#idm1513">8.11. Run LILO to write the new boot sector</a></span></dt><dt><span class="sect2"><a href="#idm1517">8.12. Reboot to lvm</a></span></dt><dt><span class="sect2"><a href="#idm1523">8.13. Add remainder of disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recovermetadata">9. Recover physical volume metadata</a></span></dt></dl></dd><dt><span class="appendix"><a href="#dangerousops">A. Dangerous Operations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#uuidfixer">1. Restoring the VG UUIDs using uuid_fixer</a></span></dt><dt><span class="sect1"><a href="#sharinglvm1">2. Sharing LVM volumes</a></span></dt></dl></dd><dt><span class="appendix"><a href="#ReportBug">B. Reporting Errors and Bugs</a></span></dt><dt><span class="appendix"><a href="#contactsandlinks">C. Contact and Links</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Maillists">1. Mail lists</a></span></dt><dt><span class="sect1"><a href="#Links">2. Links</a></span></dt></dl></dd><dt><span class="appendix"><a href="#gfdl">D. GNU Free Documentation License</a></span></dt><dd><dl><dt><span class="section"><a href="#gfdl-0">1. PREAMBLE</a></span></dt><dt><span class="section"><a href="#gfdl-1">2. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="section"><a href="#gfdl-2">3. VERBATIM COPYING</a></span></dt><dt><span class="section"><a href="#gfdl-3">4. COPYING IN QUANTITY</a></span></dt><dt><span class="section"><a href="#gfdl-4">5. MODIFICATIONS</a></span></dt><dt><span class="section"><a href="#gfdl-5">6. COMBINING DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-6">7. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-7">8. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="section"><a href="#gfdl-8">9. TRANSLATION</a></span></dt><dt><span class="section"><a href="#gfdl-9">10. TERMINATION</a></span></dt><dt><span class="section"><a href="#gfdl-10">11. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="section"><a href="#gfdl-addendum">12. ADDENDUM: How to use this License for
        your documents</a></span></dt></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a> Introduction </h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#latest_version">1. Latest Version</a></span></dt><dt><span class="sect1"><a href="#disclaimer">2. Disclaimer</a></span></dt><dt><span class="sect1"><a href="#contributors">3. Contributors</a></span></dt></dl></div><p>
      This is an attempt to collect everything needed to know to get LVM up
      and running. The entire process of getting, compiling, installing, and
      setting up LVM will be covered. Pointers to LVM configurations that
      have been tested with will also be included.  This version of the
      HowTo is for LVM 2 with device-mapper and LVM 1.0.8.
    </p><p>
      All previous versions of LVM are considered obsolete and are only kept
      for historical reasons.  This document makes no attempt to explain or
      describe the workings or use of those versions.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="latest_version"></a>1. Latest Version</h2></div></div></div><p>
        We will keep the latest version of this HowTo in the CVS with the
        other LDP Howtos.  You can get it by checking out
        ``LDP/howto/docbook/LVM-HOWTO.xml'' from the tLDP CVS server.
        You should always be able to get a human readable version of
        this HowTo from the 
        <a class="ulink" href="http://www.tldp.org/HOWTO/LVM-HOWTO.html" target="_top">
          http://www.tldp.org/HOWTO/LVM-HOWTO.html
        </a>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="disclaimer"></a>2. Disclaimer</h2></div></div></div><p>
        This document is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY, either expressed or implied. While every
        effort has been taken to ensure the accuracy of the information
        documented herein, the
        author(s)/editor(s)/maintainer(s)/contributor(s) assumes NO
        RESPONSIBILITY for any errors, or for any damages, direct or
        consequential, as a result of the use of the information documented
        herein.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contributors"></a>3. Contributors</h2></div></div></div><p>
        List of everyone who has put words into this file.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="ulink" href="mailto:alewis@redhat.com_NOSPAM" target="_top">AJ Lewis</a>
          </p></li><li class="listitem"><p>
            <a class="ulink" href="mailto:thornber@redhat.com_NOSPAM" target="_top">Joe Thornber</a>
          </p></li><li class="listitem"><p>
            <a class="ulink" href="mailto:pcaulfie@redhat.com_NOSPAM" target="_top">Patrick Caulfield</a>
          </p></li><li class="listitem"><p>
            <a class="ulink" href="mailto:agk@redhat.com_NOSPAM" target="_top">Alasdair Kergon</a>
          </p></li><li class="listitem"><p>
            <a class="ulink" href="mailto:jradmacher@gmx.de_NOSPAM" target="_top"> Jochen Radmacher
            </a> - JFS extend information
          </p></li></ul></div><p>
        Please notify the HowTo maintainer if you believe you should be
        listed above.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="whatislvm"></a>Chapter 1. What is LVM?</h1></div></div></div><p>
      LVM is a Logical Volume Manager for the Linux operating system.
      There are now two version of LVM for Linux:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            LVM 2 - The latest and greatest version of LVM for Linux.
          </p><p>
            LVM 2 is almost completely backward compatible with
            volumes created with LVM 1.  The exception to this is
            snapshots (You must remove snapshot volumes before
            upgrading to LVM 2)
          </p><p>
            LVM 2 uses the device mapper kernel driver.  Device mapper
            support is in the 2.6 kernel tree and there are patches
            available for current 2.4 kernels.
          </p></li><li class="listitem"><p>
            LVM 1 - The version that is in the 2.4 series kernel,
          </p><p>
            LVM 1 is a mature product that has been considered stable
            for a couple of years. The kernel driver for LVM 1 is
            included in the 2.4 series kernels, but this does not mean
            that your 2.4.x kernel is up to date with the latest
            version of LVM.  Look at the <a class="ulink" href="ftp://ftp.sistina.com/pub/LVM/1.0/README" target="_top">README</a>
            for the latest information about which kernels have the
            current code in them.
          </p></li></ul></div><p>
    </p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="whatisvolman"></a>Chapter 2. What is Logical Volume Management?</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whywouldiwantit">1. Why would I want it?</a></span></dt><dt><span class="sect1"><a href="#benefitsoflvmsmall">2. Benefits of Logical Volume Management on a Small System</a></span></dt><dt><span class="sect1"><a href="#benefitsoflvmlarge">3. Benefits of Logical Volume Management on a Large System</a></span></dt></dl></div><p>
      Logical volume management provides a higher-level view of the disk
      storage on a computer system than the traditional view of disks and
      partitions. This gives the system administrator much more flexibility
      in allocating storage to applications and users.
    </p><p>
      Storage volumes created under the control of the logical volume
      manager can be resized and moved around almost at will, although this
      may need some upgrading of file system tools.
    </p><p>
      The logical volume manager also allows management of storage volumes in
      user-defined groups, allowing the system administrator to deal with
      sensibly named volume groups such as "development" and "sales" rather
      than physical disk names such as "sda" and "sdb".
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whywouldiwantit"></a>1. Why would I want it?</h2></div></div></div><p>
        Logical volume management is traditionally associated with large
        installations containing many disks but it is equally suited to
        small systems with a single disk or maybe two.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="benefitsoflvmsmall"></a>2. Benefits of Logical Volume Management on a Small System</h2></div></div></div><p>
        One of the difficult decisions facing a new user installing Linux
        for the first time is how to partition the disk drive. The need to
        estimate just how much space is likely to be needed for system
        files and user files makes the installation more complex than is
        necessary and some users simply opt to put all their data into one
        large partition in an attempt to avoid the issue.
      </p><p>
        Once the user has guessed how much space is needed for /home /usr /
        (or has let the installation program do it) then is quite common
        for one of these partitions to fill up even if there is plenty of
        disk space in one of the other partitions.
      </p><p>
        With logical volume management, the whole disk would be allocated
        to a single volume group and logical volumes created to hold the /
        /usr and /home file systems. If, for example the /home logical
        volume later filled up but there was still space available on /usr
        then it would be possible to shrink /usr by a few megabytes and
        reallocate that space to /home.
      </p><p>
        Another alternative would be to allocate minimal amounts of space
        for each logical volume and leave some of the disk unallocated.
        Then, when the partitions start to fill up, they can be expanded as
        necessary.
      </p><p>
        As an example:
        
        Joe buys a PC with an 8.4 Gigabyte disk on it and installs Linux
        using the following partitioning system:
        </p><pre class="screen">
/boot    /dev/hda1     10 Megabytes
swap     /dev/hda2    256 Megabytes
/        /dev/hda3      2 Gigabytes
/home    /dev/hda4      6 Gigabytes
        </pre><p>
        This, he thinks, will maximize the amount of space available for all his MP3
        files.
      </p><p>
        Sometime later Joe decides that he want to install the latest
        office suite and desktop UI available but realizes that the root
        partition isn't large enough.  But, having archived all his MP3s
        onto a new writable DVD drive there is plenty of space on /home.
      </p><p>
        His options are not good:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            Reformat the disk, change the partitioning scheme and
            reinstall.
          </p></li><li class="listitem"><p>
            Buy a new disk and figure out some new partitioning scheme
            that will require the minimum of data movement.
          </p></li><li class="listitem"><p>
            Set up a symlink farm on / pointing to /home and install the new
            software on /home
          </p></li></ol></div><p>
        With LVM this becomes much easier:
      </p><p>
        Jane buys a similar PC but uses LVM to divide up the disk in a similar
        manner:
      </p><pre class="screen">
/boot     /dev/hda1        10 Megabytes
swap      /dev/vg00/swap   256 Megabytes
/         /dev/vg00/root     2 Gigabytes
/home     /dev/vg00/home     6 Gigabytes

         </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          boot is not included on the LV because bootloaders don't
          understand LVM volumes yet.  It's possible boot on LVM will
          work, but you run the risk of having an unbootable system.
        </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"> root on LV should be used by advanced users only 
        </h3><p>
          root on LVM requires an initrd image that activates the root
          LV.  If a kernel is upgraded without building the necessary
          initrd image, that kernel will be unbootable.  Newer
          distributions support lvm in their mkinitrd scripts as well
          as their packaged initrd images, so this becomes less of an
          issue over time.
        </p></div><p>
        When she hits a similar problem she can reduce the size of /home by
        a gigabyte and add that space to the root partition.
      </p><p>
        Suppose that Joe and Jane then manage to fill up the /home
        partition as well and decide to add a new 20 Gigabyte disk to their
        systems.
      </p><p>
        Joe formats the whole disk as one partition (/dev/hdb1) and moves
        his existing /home data onto it and uses the new disk as /home. But
        he has 6 gigabytes unused or has to use symlinks to make that disk
        appear as an extension of /home, say /home/joe/old-mp3s.
      </p><p>
        Jane simply adds the new disk to her existing volume group and
        extends her /home logical volume to include the new disk. Or, in
        fact, she could move the data from /home on the old disk to the new
        disk and then extend the existing root volume to cover all of the
        old disk.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="benefitsoflvmlarge"></a>3. Benefits of Logical Volume Management on a Large System</h2></div></div></div><p>
        The benefits of logical volume management are more obvious on large
        systems with many disk drives.
      </p><p>
        Managing a large disk farm is a time-consuming job, made
        particularly complex if the system contains many disks of different
        sizes.  Balancing the (often conflicting) storage requirements of
        various users can be a nightmare.
      </p><p>
        User groups can be allocated to volume groups and logical volumes
        and these can be grown as required. It is possible for the system
        administrator to "hold back" disk storage until it is required.  It
        can then be added to the volume(user) group that has the most
        pressing need.
      </p><p>
        When new drives are added to the system, it is no longer necessary
        to move users files around to make the best use of the new storage;
        simply add the new disk into an existing volume group or groups and
        extend the logical volumes as necessary.
      </p><p>
        It is also easy to take old drives out of service by moving the
        data from them onto newer drives - this can be done online, without
        disrupting user service.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="anatomy"></a>Chapter 3. Anatomy of LVM</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#VG">1. volume group (VG)</a></span></dt><dt><span class="sect1"><a href="#PV">2. physical volume (PV)</a></span></dt><dt><span class="sect1"><a href="#LV">3. logical volume (LV)</a></span></dt><dt><span class="sect1"><a href="#PE">4. physical extent (PE)</a></span></dt><dt><span class="sect1"><a href="#LE">5. logical extent (LE)</a></span></dt><dt><span class="sect1"><a href="#tyingittogether">6. Tying it all together</a></span></dt><dt><span class="sect1"><a href="#mapmode">7. mapping modes (linear/striped)</a></span></dt><dt><span class="sect1"><a href="#snapshotintro">8. Snapshots</a></span></dt></dl></div><p>
      This diagram gives a overview of the main elements in an LVM system:
      </p><pre class="screen">
+-- Volume Group --------------------------------+
|                                                |
|    +----------------------------------------+	 |
| PV | PE |  PE | PE | PE | PE | PE | PE | PE |	 |
|    +----------------------------------------+	 |
|      .       	  .    	     . 	      .	       	 |
|      .          .    	     .        .	         |
|    +----------------------------------------+	 |
| LV | LE |  LE | LE | LE | LE | LE | LE | LE |	 |
|    +----------------------------------------+	 |
|            .          .        .     	   .     |
|            . 	        .        .     	   .     |
|    +----------------------------------------+	 |
| PV | PE |  PE | PE | PE | PE | PE | PE | PE |	 |
|    +----------------------------------------+	 |
|                                                |
+------------------------------------------------+

         </pre><p>
    </p><p>
      Another way to look at is this (courtesy of 
      <a class="ulink" href="mailto:erik@bagfors.nu_NOSPAM" target="_top">Erik Bågfors</a>
      on the linux-lvm mailing list):
      </p><pre class="screen">
    hda1   hdc1      (PV:s on partitions or whole disks)                        
       \   /                                                                    
        \ /                                                                     
       diskvg        (VG)                                                       
       /  |  \                                                                  
      /   |   \                                                                 
  usrlv rootlv varlv (LV:s)
    |      |     |                                                              
 ext2  reiserfs  xfs (filesystems)                                        

         </pre><p>
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="VG"></a>1. volume group (VG)</h2></div></div></div><p>
        The Volume Group is the highest level abstraction used within the
        LVM.  It gathers together a collection of Logical Volumes and
        Physical Volumes into one administrative unit.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PV"></a>2. physical volume (PV)</h2></div></div></div><p>
        A physical volume is typically a hard disk, though it may well just
        be a device that 'looks' like a hard disk (eg. a software raid
        device).
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="LV"></a>3. logical volume (LV)</h2></div></div></div><p>
        The equivalent of a disk partition in a non-LVM system.  The LV is
        visible as a standard block device; as such the LV can contain a
        file system (eg. <code class="filename">/home</code>).
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PE"></a>4. physical extent (PE)</h2></div></div></div><p>
        Each physical volume is divided chunks of data, known as physical
        extents, these extents have the same size as the logical extents
        for the volume group.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="LE"></a>5. logical extent (LE)</h2></div></div></div><p>
        Each logical volume is split into chunks of data, known as logical
        extents.  The extent size is the same for all logical volumes in
        the volume group.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tyingittogether"></a>6. Tying it all together</h2></div></div></div><p>
        A concrete example will help:
      </p><p>
        Lets suppose we have a volume group called VG1, this volume group
        has a physical extent size of 4MB.  Into this volume group we
        introduce 2 hard disk partitions, /dev/hda1 and /dev/hdb1.  These
        partitions will become physical volumes PV1 and PV2 (more
        meaningful names can be given at the administrators discretion).
        The PV's are divided up into 4MB chunks, since this is the extent
        size for the volume group.  The disks are different sizes and we
        get 99 extents in PV1 and 248 extents in PV2.  We now can create
        ourselves a logical volume, this can be any size between 1 and 347
        (248 + 99) extents.  When the logical volume is created a mapping
        is defined between logical extents and physical extents, eg.
        logical extent 1 could map onto physical extent 51 of PV1, data
        written to the first 4 MB of the logical volume in fact be written
        to the 51st extent of PV1.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapmode"></a>7. mapping modes (linear/striped)</h2></div></div></div><p>
        The administrator can choose between a couple of general strategies
        for mapping logical extents onto physical extents:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="strong"><strong>Linear mapping</strong></span> will assign a
            range of PE's to an area of an LV in order eg., LE 1 - 99 map to
            PV1 and LE 100 - 347 map onto PV2.
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>Striped mapping</strong></span> will interleave
            the chunks of the logical extents across a number of physical
            volumes eg.,
            </p><pre class="screen">
1st chunk of LE[1] -&gt; PV1[1],

2nd chunk of LE[1] -&gt; PV2[1],

3rd chunk of LE[1] -&gt; PV3[1],

4th chunk of LE[1] -&gt; PV1[2],
            </pre><p>

            and so on.  In certain situations this strategy can
            improve the performance of the logical volume.  

            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"> LVM 1 Caveat </h3><p>
                LVs created using striping cannot be extended past
                the PVs they were originally created on in LVM 1.
              </p></div><p>

            In LVM 2, striped LVs can be extended by concatenating
            another set of devices onto the end of the first set.  So
            you can get into a situation where your LV is a 2 stripe
            set concatenated with a linear set concatenated with a 4
            stripe set.  Are you confused yet?

          </p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="snapshotintro"></a>8. Snapshots</h2></div></div></div><p>
        A wonderful facility provided by LVM is 'snapshots'.  This
        allows the administrator to create a new block device which
        presents an exact copy of a logical volume, frozen at some
        point in time.  Typically this would be used when some batch
        processing, a backup for instance, needs to be performed on
        the logical volume, but you don't want to halt a live system
        that is changing the data.  When the snapshot device has been
        finished with the system administrator can just remove the
        device.  This facility does require that the snapshot be made
        at a time when the data on the logical volume is in a
        consistent state - the VFS-lock patch for LVM1 makes sure that
        some filesystems do this automatically when a snapshot is
        created, and many of the filesystems in the 2.6 kernel do this
        automatically when a snapshot is created without patching.
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Full snapshot are automatically disabled</h3><p>
          If the snapshot logical volume becomes full it will be dropped
          (become unusable) so it is vitally important to allocate enough space.
          The amount of space necessary is dependent on the usage of the
          snapshot, so there is no set recipe to follow for this. If the
          snapshot size equals the origin size, it will never overflow.
        </p></div><p>
        LVM1 has read-only snapshots.  Read-only snapshots work by
        creating an <span class="emphasis"><em>exception table</em></span>, which is
        used to keep track of which blocks have been changed.  If a
        block is to be changed on the origin, it is first copied to
        the snapshot, marked as copied in the exception table, and
        then the new data is written to the original volume.
      </p><p>
        In LVM2, snapshots are read/write by default.  Read/write
        snapshots work like read-only snapshots, with the additional
        feature that if data is written to the snapshot, that block is
        marked in the exception table as used, and never gets copied
        from the original volume.  This opens up many new
        possibilities that were not possible with LVM1's read-only
        snapshots.  One example is to snapshot a volume, mount the
        snapshot, and try an experimental program that change files on
        that volume.  If you don't like what it did, you can unmount
        the snapshot, remove it, and mount the original filesystem in
        its place.  It is also useful for creating volumes for use
        with <a class="ulink" href="http://www.cl.cam.ac.uk/Research/SRG/netos/xen/" target="_top">Xen</a>.
        You can create a disk image, then snapshot it and modify the
        snapshot for a particular domU instance.  You can then create
        another snapshot of the original volume, and modify that one
        for a different domU instance.  Since the only storage used by
        a snapshot is blocks that were changed on the origin or the
        snapshot, the majority of the volume is shared by the domU's.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
	        With the current LVM2/device-mapper code, the origin can be
	        grown, but not shrunk.  With LVM1, you cannot resize the origin.
        </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"> LVM 1 -&gt; LVM 2 Upgrade Info </h3><p>
          Make sure to remove snapshot LVs before upgrading from
          LVM 1 to LVM 2.  (See <a class="xref" href="#lvm2faq" title="1. LVM 2 FAQ">Section 1, &#8220;LVM 2 FAQ&#8221;</a>)
        </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="FAQ"></a>Chapter 4. Frequently Asked Questions</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#lvm2faq">1. LVM 2 FAQ</a></span></dt><dt><span class="sect1"><a href="#lvm1faq">2. LVM 1 FAQ</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lvm2faq"></a>1. LVM 2 FAQ</h2></div></div></div><div class="qandaset"><a name="idm277"></a><dl><dt>1.1. <a href="#idm278">
              I have LVM 1 installed and running on my system.  How do
              I start using LVM 2?
            </a></dt><dt>1.2. <a href="#idm297">
              Do I need a special lvm2 kernel module?
            </a></dt><dt>1.3. <a href="#idm302">
              I get errors about
              /dev/mapper/control when I try to
              use the LVM 2 tools.  What's going on?
            </a></dt><dt>1.4. <a href="#idm325">
              Which commands and types of logical volumes are
              currently supported in LVM 2?
            </a></dt><dt>1.5. <a href="#idm337">
              Does LVM 2 use a different format from LVM 1 for it's
              ondisk representation of Volume Groups and Logical
              Volumes?
            </a></dt><dt>1.6. <a href="#idm342">
              Does LVM 2 support VGs and LVs created with LVM 1?
            </a></dt><dt>1.7. <a href="#idm347">
              Can I upgrade my LVM 1 based VGs and LVs to LVM 2 native
              format?
            </a></dt><dt>1.8. <a href="#idm352">
              I've upgraded to LVM 2, but the tools keep failing with out
              of memory errors.  What gives?
            </a></dt><dt>1.9. <a href="#idm358">
              I have my root partition on an LV in LVM 1.  How do I
              upgrade to LVM 2?  And what happened to lvmcreate_initrd?
            </a></dt><dt>1.10. <a href="#idm382">
              How resilient is LVM to a sudden renumbering of
              physical hard disks?
            </a></dt><dt>1.11. <a href="#idm390">
              I'm trying to fill my vg, and vgdisplay/vgs says that I
              have 1.87 GB free, but when I do an lvcreate vg -L1.87G
              it says "insufficient free extends".  What's going on?
            </a></dt><dt>1.12. <a href="#idm400">
              How are snapshots in LVM2 different from LVM1?
            </a></dt><dt>1.13. <a href="#idm406">
	      What is the maximum size of a single LV?
	    </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idm278"></a><a name="idm279"></a><p><b>1.1.</b></p></td><td align="left" valign="top"><p>
              I have LVM 1 installed and running on my system.  How do
              I start using LVM 2?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              Here's the Quick Start instructions :)
              </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Start by removing any snapshot LVs on the system.
                    These are not handled by LVM 2 and will prevent the
                    origin from being activated when LVM 2 comes up.
                  </p></li><li class="listitem"><p>
                    Make sure you have some way of booting the system
                    other than from your standard boot partition.  Have
                    the LVM 1 tools, standard system tools (mount) and
                    an LVM 1 compatible kernel on it in case you need to
                    get back and fix some things.
                  </p></li><li class="listitem"><p>
                    Grab the LVM 2 tools source and the device mapper
                    source and compile them.  You need to install the
                    device mapper library using <span class="quote">&#8220;<span class="quote">make
                      install</span>&#8221;</span> before compiling the LVM 2 tools.
                    Also copy the dm/scripts/devmap_mknod.sh script into
                    /sbin. I recommend only installing the 'lvm' binary
                    for now so you have access to the LVM 1 tools if you
                    need them.  If you have access to packages for LVM 2
                    and device-mapper, you can install those instead,
                    but beware of them overwriting your LVM 1 tool set.
                  </p></li><li class="listitem"><p>
                    Get a device mapper compatible kernel, either built
                    in or as a kernel module.
                  </p></li><li class="listitem"><p>
                    Figure out where LVM 1 was activated in your startup
                    scripts.  Make sure the device-mapper module is
                    loaded by that point (if you are using device mapper
                    as a module) and add '/sbin/devmap_mknod.sh; lvm
                    vgscan; lvm vgchange -ay' afterward.
                  </p></li><li class="listitem"><p>
                    Install the kernel with device mapper support in it.
                    Reboot.  If all goes well, you should be running with
                    lvm2.
                  </p></li></ol></div><p>  
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm297"></a><a name="idm298"></a><p><b>1.2.</b></p></td><td align="left" valign="top"><p>
              Do I need a special lvm2 kernel module?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              No.  You need device-mapper.  The lvm2 tools use
              device-mapper to interface with the kernel and do all
              their device mapping (hence the name device-mapper).  As
              long as you have device-mapper, you should be able to
              use LVM2.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm302"></a><a name="idm303"></a><p><b>1.3.</b></p></td><td align="left" valign="top"><p>
              I get errors about
              <code class="filename">/dev/mapper/control</code> when I try to
              use the LVM 2 tools.  What's going on?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              The primary cause of this is not having run the
              <span class="quote">&#8220;<span class="quote">dmsetup mknodes</span>&#8221;</span> after rebooting into a dm
              capable kernel.  This script generates the control node
              for device mapper.
            </p><p>
              If you don't have the <span class="quote">&#8220;<span class="quote">dmsetup mknodes</span>&#8221;</span>,
              don't despair! (Though you should probably upgrade to
              the latest version of device-mapper.)  It's pretty easy
              to create the <code class="filename">/dev/mapper/control</code>
              file on your own:
              </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Make sure you have the device-mapper module loaded
                    (if you didn't build it into your kernel).
                    </p></li><li class="listitem"><p>
                    Run
                    </p><pre class="screen"># cat /proc/misc | grep device-mapper | awk '{print $1}'</pre><p>
                    and note the number
                    printed.  (If you don't get any output, refer to
                    step 1.)
                  </p></li><li class="listitem"><p>
                    Run </p><pre class="screen"># mkdir /dev/mapper</pre><p> - if you
                    get an error saying
                    <code class="filename">/dev/mapper</code> already exists,
                    make sure it's a directory and move on.
                  </p></li><li class="listitem"><p>
                    Run 
                    </p><pre class="screen"># mknod /dev/mapper/control c 10 $number</pre><p>
                    where $number is the number printed in step 2.
                  </p></li></ol></div><p>
              You should be all set now!
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm325"></a><a name="idm326"></a><p><b>1.4.</b></p></td><td align="left" valign="top"><p>
              Which commands and types of logical volumes are
              currently supported in LVM 2?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              If you are using the stable 2.4 device mapper patch from
              the lvm2 tarball, all the major functionality you'd
              expect using lvm1 is supported with the lvm2 tools.
              (You still need to remove snapshots before upgrading
              from lvm1 to lvm2)
            </p><p>
              If you are using the version of device mapper in the 2.6
              kernel.org kernel series the following commands and LV
              types are not supported:
              </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> pvmove </p></li><li class="listitem"><p> snapshots </p></li></ul></div><p>
              The beginnings of support for these features are in the
              <a class="ulink" href="http://people.sistina.com/~thornber/dm/" target="_top">
              unstable device mapper patches</a> maintained by Joe
              Thornber.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm337"></a><a name="idm338"></a><p><b>1.5.</b></p></td><td align="left" valign="top"><p>
              Does LVM 2 use a different format from LVM 1 for it's
              ondisk representation of Volume Groups and Logical
              Volumes?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              Yes. LVM 2 uses lvm 2 format metadata.  This format is much
              more flexible than the LVM 1 format metadata, removing
              or reducing most of the limitations LVM 1 had.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm342"></a><a name="idm343"></a><p><b>1.6.</b></p></td><td align="left" valign="top"><p>
              Does LVM 2 support VGs and LVs created with LVM 1?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              Yes.  LVM 2 will activate and operate on VG and LVs created
              with LVM 1.  The exception to this is snapshots created with
              LVM 1 - these should be removed before upgrading.  Snapshots
              that remain after upgrading will have to be removed before
              their origins can be activated by LVM 2.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm347"></a><a name="idm348"></a><p><b>1.7.</b></p></td><td align="left" valign="top"><p>
              Can I upgrade my LVM 1 based VGs and LVs to LVM 2 native
              format?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p> 
              Yes. Use vgconvert to convert your VG and all LVs contained
              within it to the new lvm 2 format metadata. Be warned that it's
              not always possible to revert back to lvm 1 format metadata.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm352"></a><a name="idm353"></a><p><b>1.8.</b></p></td><td align="left" valign="top"><p>
              I've upgraded to LVM 2, but the tools keep failing with out
              of memory errors.  What gives?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              One possible cause of this is that some versions of LVM
              1 (The user that reported this bug originally was using
              Mandrake 9.2, but it is not necessarily limited to that
              distribution) did not put a UUID into the PV and VG
              structures as they were supposed to.  The most current
              versions of the LVM 2 tools automatically fill UUIDs in
              for the structures if they see they are missing, so you
              should grab a more current version and your problem
              should be solved.  If not, post to the <a class="link" href="#Maillists" title="1. Mail lists">linux-lvm mailing list</a>
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm358"></a><a name="idm359"></a><p><b>1.9.</b></p></td><td align="left" valign="top"><p>
              I have my root partition on an LV in LVM 1.  How do I
              upgrade to LVM 2?  And what happened to lvmcreate_initrd?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              Upgrading to LVM 2 is a bit trickier with root on LVM,
              but it's not impossible.  You need to queue up a kernel
              with device-mapper support and install the lvm2 tools
              (you might want to make a backup of the lvm 1 tools, or
              find a rescue disk with the lvm tools built in, in case
              you need them before you're done).  Then find a mkinitrd
              script that has support for your distro and lvm 2.
            </p><p>
              Currently, this is the list of mkinitrd scripts that I
              know support lvm2, sorted by distro:
              </p><div class="variablelist"><p class="title"><b>mkinitrd scripts with lvm 2 support</b></p><dl class="variablelist"><dt><span class="term">fedora</span></dt><dd><p>
                      The latest fedora core 2 <a class="ulink" href="http://distro.ibiblio.org/pub/linux/distributions/fedora/linux/core/development/i386/Fedora/RPMS/mkinitrd-3.5.21-1.i386.rpm" target="_top">mkinitrd</a>
                      handles lvm2, but it relies on a statically
                      built lvm binary from the latest lvm 2 tarball.
                    </p><p>
                      Redhat 9 users may be able to use this as well
                    </p></dd><dt><span class="term">Debian</span></dt><dd><p>
                      There is an unofficial version <a class="ulink" href="http://www.poochiereds.net/svn/lvm2/" target="_top">here</a>
                    </p></dd><dt><span class="term">Generic</span></dt><dd><p>
                      There is a version in the lvm2 source tree under
                      <code class="filename">scripts/lvm2_createinitrd/</code>.
                      See the documentation in that directory for more
                      details.
                    </p></dd></dl></div><p>
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm382"></a><a name="idm383"></a><p><b>1.10.</b></p></td><td align="left" valign="top"><p>
              How resilient is LVM to a sudden renumbering of
              physical hard disks?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              It's fine - LVM identifies PVs by UUID, not by device
              name.
            </p><p>
              Each disk (PV) is labeled with a UUID, which uniquely
              identifies it to the system.  'vgscan' identifies this
              after a new disk is added that changes your drive
              numbering.  Most distros run vgscan in the lvm startup
              scripts to cope with this on reboot after a hardware
              addition.  If you're doing a hot-add, you'll have to run
              this by hand I think.  On the other hand, if your vg is
              activated and being used, the renumbering should not
              affect it at all.  It's only the activation that needs
              the identifier, and the worst case scenario is that the
              activation will fail without a vgscan with a complaint
              about a missing PV.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                The failure or removal of a drive that LVM is
                currently using will cause problems with current use
                and future activations of the VG that was using it.
              </p></div></td></tr><tr class="question"><td align="left" valign="top"><a name="idm390"></a><a name="idm391"></a><p><b>1.11.</b></p></td><td align="left" valign="top"><p>
              I'm trying to fill my vg, and vgdisplay/vgs says that I
              have 1.87 GB free, but when I do an lvcreate vg -L1.87G
              it says "insufficient free extends".  What's going on?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              The 1.87 GB figure is rounded to 2 decimal places, so
              it's probably 1.866 GB or something.  This is a
              human-readable output to give you a general idea of how
              big the VG is.  If you want to specify an exact size,
              you must use extents instead of some multiple of bytes.
            </p><p>
              In the case of vgdisplay, use the Free PE count instead
              of the human readable capacity.
              </p><pre class="screen">
              Free  PE / Size          478 / 1.87 GB
                                       ^^^
              </pre><p>
              So, this would indicate that you should do run
              </p><pre class="screen">
# lvcreate vg -l478 </pre><p> Note that instead of an upper-case 'L',
              we used a lower-case 'l' to tell lvm to use extents
              instead of bytes.
            </p><p>
              In the case of vgs, you need to instruct it to tell you how many extents are available:
              </p><pre class="screen">
# vgs -o +vg_free_count,vg_extent_count
              </pre><p>
              This tell vgs to add the free extents and the total
              number of extents to the end of the vgs listing.  Use
              the free extent number the same way you would in the
              above vgdisplay case.
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm400"></a><a name="idm401"></a><p><b>1.12.</b></p></td><td align="left" valign="top"><p>
              How are snapshots in LVM2 different from LVM1?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              In LVM2 snapshots are read/write by default, whereas in
              LVM1, snapshots were only read-only.  See <a class="xref" href="#snapshotintro" title="8. Snapshots">Section 8, &#8220;Snapshots&#8221;</a> for more details
            </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm406"></a><a name="idm407"></a><p><b>1.13.</b></p></td><td align="left" valign="top"><p>
	      What is the maximum size of a single LV?
	    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
	      The answer to this question depends upon the CPU
	      architecture of your computer and the kernel you are a
	      running:
	      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
		    For 2.4 based kernels, the maximum LV size is 2TB.
		    For some older kernels, however, the limit was 1TB
		    due to signedness problems in the block layer.
		    Red Hat Enterprise Linux 3 Update 5 has fixes to
		    allow the full 2TB LVs.  Consult your distribution
		    for more information in this regard.
		  </p></li><li class="listitem"><p>
		    For 32-bit CPUs on 2.6 kernels, the maximum LV size is 16TB.
		  </p></li><li class="listitem"><p>
		    For 64-bit CPUs on 2.6 kernels, the maximum LV
		    size is 8EB. (Yes, that is a very large number.)
		  </p></li></ul></div><p>
	    </p></td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lvm1faq"></a>2. LVM 1 FAQ</h2></div></div></div><div class="qandaset"><a name="idm420"></a><dl><dt>2.1. <a href="#idm421">
              When will there be info here?
            </a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idm421"></a><a name="idm422"></a><p><b>2.1.</b></p></td><td align="left" valign="top"><p>
              When will there be info here?
            </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
              When people start submitting FAQ entries ;)
            </p></td></tr></tbody></table></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="getlvm"></a>Chapter 5. Acquiring LVM</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#downloadsource">1. Download the source</a></span></dt><dt><span class="sect1"><a href="#PublicCVS">2. Download the development source via CVS</a></span></dt><dt><span class="sect1"><a href="#beforebeginning">3. Before You Begin</a></span></dt><dt><span class="sect1"><a href="#initsetup">4. Initial Setup</a></span></dt><dt><span class="sect1"><a href="#checkoutsource">5. Checking Out Source Code</a></span></dt><dt><span class="sect1"><a href="#codeupdate">6. Code Updates</a></span></dt><dt><span class="sect1"><a href="#startproj">7. Starting a Project</a></span></dt><dt><span class="sect1"><a href="#hackingcode">8. Hacking the Code</a></span></dt><dt><span class="sect1"><a href="#conflicts">9. Conflicts</a></span></dt></dl></div><p>
      The first thing you need to do is get a copy of LVM.

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Download via FTP a tarball of LVM. </p></li><li class="listitem"><p>
            Download the source that is under active development via
            CVS 
          </p></li></ul></div><p>
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="downloadsource"></a>1. Download the source</h2></div></div></div><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <a class="ulink" href="ftp://sources.redhat.com/pub/dm/" target="_top">
                Device Mapper </a>
            </p></li><li class="listitem"><p>
              <a class="ulink" href="ftp://sources.redhat.com/pub/lvm2/" target="_top">
                LVM 2
              </a>
            </p><p>
              Make sure you also grab the device mapper
              source
            </p></li><li class="listitem"><p>
              <a class="ulink" href="ftp://sources.redhat.com/pub/lvm/current/" target="_top"> LVM
                1
              </a>
            </p></li></ul></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The LVM 1 kernel patch must be generated using the LVM 1 source.
          More information regarding this can be found in
          
          <a class="xref" href="#buildlvmmod" title="2. Build the LVM 1 kernel module">Section 2, &#8220;Build the LVM 1 kernel module&#8221;</a>
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PublicCVS"></a>2. Download the development source via CVS</h2></div></div></div><p>
        <span class="strong"><strong>Note:</strong></span> the state of code in the
        CVS repository fluctuates wildly.  It will contain bugs. Maybe ones
        that will crash LVM or the kernel.  It may not even compile.
        Consider it alpha-quality code.  You could lose data.  You have
        been warned.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beforebeginning"></a>3. Before You Begin</h2></div></div></div><p>
        To follow the development progress of LVM, subscribe to the
        LVM mailing lists, linux-lvm and the appropriate commit list
        (see <a class="xref" href="#Maillists" title="1. Mail lists">Section 1, &#8220;Mail lists&#8221;</a>).
      </p><p>
        To build LVM from the CVS sources, you
        <span class="strong"><strong>must</strong></span> have several GNU tools:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> the CVS client version 1.9 or better</p></li><li class="listitem"><p>GCC 2.95.2</p></li><li class="listitem"><p>GNU make 3.79</p></li><li class="listitem"><p>autoconf, version 2.13 or better</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initsetup"></a>4. Initial Setup</h2></div></div></div><p>
        To make life easier in the future with regards to updating the CVS
        tree create the file <code class="filename">$HOME/.cvsrc</code> and
        insert the following lines.  This configures useful defaults for
        the three most commonly used CVS commands.  Do this now before
        proceeding any further.
      </p><pre class="screen">
diff -u -b -B
checkout -P
update -d -P

         </pre><p>
        Also, if you are on a slow net link (like a dialup), you will want
        to add a line containing <code class="filename">cvs -z5</code> in this file.
        This turns on a useful compression level for all CVS commands.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkoutsource"></a>5. Checking Out Source Code</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="strong"><strong>Device Mapper library and
              tools</strong></span>
          </p><p> The device mapper library is required to build LVM 2.
          </p><p>
            The first time you download from cvs, you must login
            </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/dm login cvs
</strong></span>
            </pre><p>
          </p><p>
            The password is `cvs'.  The command outputs nothing if
            successful and an error message if it fails.  Only an
            initial login is required.  All subsequent CVS commands
            read the password stored in the file
            <code class="filename">$HOME/.cvspass</code> for authentication.
          </p><p>
            Use the following to check out a copy of the code
          </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/dm checkout device-mapper    
</strong></span>
          </pre><p>
            This will create a new directory
            <code class="filename">device-mapper</code> in your current
            directory containing the latest, up-to-the-minute
            device mapper code.
          </p></li><li class="listitem"><p> <span class="strong"><strong>LVM 2</strong></span>
          </p><p>
            The first time you download from cvs, you must login
            </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/lvm2 login cvs
</strong></span>
            </pre><p>
          </p><p>
            The password is `cvs'.  The command outputs nothing if
            successful and an error message if it fails.  Only an
            initial login is required.  All subsequent CVS commands
            read the password stored in the file
            <code class="filename">$HOME/.cvspass</code> for authentication.
          </p><p>
            Use the following to check out a copy of the code
          </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/lvm2 checkout LVM2    
</strong></span>
          </pre><p>
            This will create a new directory
            <code class="filename">LVM2</code> in your current
            directory containing the latest, up-to-the-minute
            LVM 2 code.
          </p></li><li class="listitem"><p> <span class="strong"><strong>LVM 1</strong></span>
          </p><p>
            The first time you download from cvs, you must login
            </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/lvm login cvs
</strong></span>
            </pre><p>
          </p><p>
            The password is `cvs'.  The command outputs nothing if
            successful and an error message if it fails.  Only an
            initial login is required.  All subsequent CVS commands
            read the password stored in the file
            <code class="filename">$HOME/.cvspass</code> for authentication.
          </p><p>
            Use the following to check out a copy of the code
          </p><pre class="screen">
<span class="command"><strong> # cvs -d :pserver:cvs@sources.redhat.com:/cvs/lvm checkout LVM  
</strong></span>
          </pre><p>
            This will create a new directory
            <code class="filename">LVM</code> in your current
            directory containing the latest, up-to-the-minute
            LVM 1 code.
          </p></li></ul></div><p>
        CVS commands work from <span class="emphasis"><em>anywhere</em></span> inside the
        source tree, and recurse downward.  So if you happen to issue an
        update from inside the `tools' subdirectory it will work fine, but
        only update the tools directory and it's subdirectories.  In the
        following command examples it is assumed that you are at the top of
        the source tree.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="codeupdate"></a>6. Code Updates</h2></div></div></div><p>
        Code changes are made fairly frequently in the CVS repository.
        Announcements of this are automatically sent to the lvm-commit
        list.
      </p><p>
        You can update your copy of the sources to match the master
        repository with the update command.  It is not necessary to check
        out a new copy.  Using update is significantly faster and simpler,
        as it will download only patches instead of entire files and update
        only those files that have changed since your last update.  It will
        automatically merge any changes in the CVS repository with any
        local changes you have made as well. Just cd to the directory you'd
        like to update and then type the following.
      </p><pre class="screen">
<span class="command"><strong> # cvs update </strong></span>
         </pre><p>
        If you did not specify a tag when you checked out the source, this
        will update your sources to the latest version on the main branch.
        If you specified a branch tag, it will update to the latest version
        on that branch.  If you specified a version tag, it will not do
        anything.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="startproj"></a>7. Starting a Project</h2></div></div></div><p>
        Discuss your ideas on the developers list before you start.
        Someone may be working on the same thing you have in mind or they
        may have some good ideas about how to go about it.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hackingcode"></a>8. Hacking the Code</h2></div></div></div><p>
        So, have you found a bug you want to fix?  Want to implement a
        feature from the TODO list?  Got a new feature to implement?
        Hacking the code couldn't be easier.  Just edit your copy of the
        sources.  No need to copy files to <code class="filename">.orig</code> or
        anything.  CVS has copies of the originals.
      </p><p>
        When you have your code in a working state and have tested as best
        you can with the hardware you have, generate a patch against the
        <span class="emphasis"><em>current</em></span> sources in the CVS repository.
      </p><pre class="screen">
<span class="command"><strong> # cvs update
 # cvs diff &gt; patchfile</strong></span>
         </pre><p>
        Mail the patch to the linux-lvm or dm-devel list (<a class="xref" href="#Maillists" title="1. Mail lists">Section 1, &#8220;Mail lists&#8221;</a>)
        with a description of what changes or additions you implemented.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conflicts"></a>9. Conflicts</h2></div></div></div><p>
        If someone else has been working on the same files as you have, you
        may find that there are conflicting modifications.  You'll discover
        this when you try to update your sources.
      </p><pre class="screen">
<span class="command"><strong> # cvs update </strong></span>
<code class="computeroutput">
 RCS file: LVM/tools/pvcreate.c,v
 retrieving revision 1.5
 retrieving revision 1.6
 Merging differences between 1.5 and 1.6 into pvcreate.c
 rcsmerge: warning: conflicts during merge
 cvs server: conflicts found in tools/pvcreate.c
 C tools/pvcreate.c
</code>
         </pre><p>
        Don't panic! Your working file, as it existed before the update, is
        saved under the filename <code class="filename">.#pvcreate.c.1.5</code>.
        You can always recover it should things go horribly wrong.  The
        file named `pvcreate.c' now contains 
        <span class="strong"><strong>both</strong></span> the old (i.e. your) version
        and new version of lines that conflicted.  You simply edit the file
        and resolve each conflict by deleting the unwanted version of the
        lines involved.
      </p><pre class="screen">
 &lt;&lt;&lt;&lt;&lt;&lt;&lt; pvcreate.c
    j++;
 =======
    j--;
 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.6

         </pre><p>
        Don't forget to delete the lines with all the ``&lt;'', ``='', and
        ``&gt;'' symbols.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="buildkernelmods"></a>Chapter 6. Building the kernel modules</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#builddmmod">1. Building the device-mapper module</a></span></dt><dt><span class="sect1"><a href="#buildlvmmod">2. Build the LVM 1 kernel module</a></span></dt><dd><dl><dt><span class="sect2"><a href="#buildlvmpatch">2.1. Building a patch for your kernel</a></span></dt><dt><span class="sect2"><a href="#buildlvm1-2.2">2.2. Building the LVM module for Linux 2.2.17+</a></span></dt><dt><span class="sect2"><a href="#buildlvm1-2.4">2.3. Building the LVM modules for Linux 2.4</a></span></dt><dt><span class="sect2"><a href="#checkproc">2.4. Checking the proc file system</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="builddmmod"></a>1. Building the device-mapper module</h2></div></div></div><p>
        Device mapper is in 2.6.9 and later, so you just need to make
        sure it is enabled either as a module or builtin to the
        kernel.  Look for /sys/class/misc/device-mapper or look in
        /proc/devices for a device-mapper entry to see if it is
        enabled.  If neither are there, try modprobe dm_mod, then
        check again.  For versions previous to 2.6.9, either you or
        your distro must patch the kernel to support it.  Check the
        <a class="ulink" href="http://sources.redhat.com/dm/" target="_top">device
        mapper</a> web page for more information.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buildlvmmod"></a>2. Build the LVM 1 kernel module</h2></div></div></div><p>
        To use LVM 1 you will have to build the LVM 1 kernel module
        (recommended), or if you prefer rebuild the kernel with the
        LVM 1 code statically linked into it.
      </p><p>
        Your Linux system is probably based on one of the popular
        distributions (eg., Red Hat, SuSE, Debian) in which case it
        is possible that you already have the LVM 1 module.  Check
        the version of the tools you have on your system.  You can do
        this by running any of the LVM command line tools with the
        '-h' flag.  Use <span class="command"><strong>pvscan -h</strong></span> if you don't
        know any of the commands.  If the version number listed at
        the top of the help listing is LVM 1.0.8, <span class="strong"><strong>use your current setup</strong></span> and avoid the
        rest of this section.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="buildlvmpatch"></a>2.1. Building a patch for your kernel</h3></div></div></div><p>
          In order to patch the linux kernel to support LVM 1.0.8, you must
          do the following:

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p> Unpack LVM 1.0.8 </p><pre class="screen">
<span class="command"><strong> # tar zxf lvm_1.0.8.tar.gz </strong></span>
                  </pre></li><li class="listitem"><p> Enter the root directory of that version. </p><pre class="screen">
<span class="command"><strong> # cd LVM/1.0.8 </strong></span>
                  </pre></li><li class="listitem"><p>  Run configure</p><pre class="screen">
<span class="command"><strong> # ./configure </strong></span>
                  </pre><p>
                You will need to pass the option
                <code class="option">--with-kernel_dir</code> to configure if your
                linux kernel source is not in 
                <code class="filename">/usr/src/linux</code>.
                (Run <span class="command"><strong>./configure --help</strong></span> to see all the
                options available)
              </p></li><li class="listitem"><p>  Enter the PATCHES directory</p><pre class="screen">
<span class="command"><strong> # cd PATCHES </strong></span>
                  </pre></li><li class="listitem"><p>  Run 'make'</p><pre class="screen">
<span class="command"><strong># make </strong></span>
                  </pre><p>
                You should now have a patch called
                <code class="filename">lvm-1.0.8-$KERNELVERSION.patch</code> in the
                patches directory.  This is the LVM kernel patch referenced
                in later sections of the howto.
              </p></li><li class="listitem"><p>  Patch the kernel</p><pre class="screen">
<span class="command"><strong> # cd /usr/src/linux ; patch -pX &lt; /directory/lvm-1.0.8-$KERNELVERSION.patch </strong></span>
                  </pre></li></ol></div><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="buildlvm1-2.2"></a>2.2. Building the LVM module for Linux 2.2.17+</h3></div></div></div><p>
          The 2.2 series kernel needs to be patched before you can start
          building, look elsewhere for instructions on how to patch your
          kernel.
        </p><p>
          Patches:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="strong"><strong>rawio patch</strong></span>
            </p><p>
              Stephen Tweedie's raw_io patch which can be found at
              <a class="ulink" href="http://www.kernel.org/pub/linux/kernel/people/sct/raw-io" target="_top">http://www.kernel.org/pub/linux/kernel/people/sct/raw-io</a>
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>lvm patch</strong></span>
            </p><p>
              The relevant LVM 1 patch which should be built out
              of the PATCHES sub-directory of the LVM
              distribution.  More information can be found in
              <a class="xref" href="#buildlvmpatch" title="2.1. Building a patch for your kernel">Section 2.1, &#8220;Building a patch for your kernel&#8221;</a>, Building a patch
              for your kernel.
            </p></li></ol></div><p>
          Once the patches have been correctly applied, you need to make sure
          that the module is actually built, LVM 1 lives under the block
          devices section of the kernel config, you should probably request
          that the LVM /proc information is compiled as well.
        </p><p>
          Build the kernel modules as usual.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="buildlvm1-2.4"></a>2.3. Building the LVM modules for Linux 2.4</h3></div></div></div><p>
          The 2.4 kernel comes with LVM 1 already included although
          you should check at the Sistina web site for updates,
          (eg. v2.4.9 kernels and earlier must have the <a class="link" href="#buildlvmpatch" title="2.1. Building a patch for your kernel">latest LVM 1 patch</a> applied ).
          When configuring your kernel look for LVM 1 under <span class="strong"><strong>Multi-device support (RAID and
            LVM)</strong></span>. LVM 1 can be compiled into the kernel or as
          a module. Build your kernel and modules and install then
          in the usual way. If you chose to build LVM as a module it
          will be called <code class="filename">lvm-mod.o</code>
        </p><p>
          If you want to use snapshots with ReiserFS, make sure you apply the
          <code class="filename">linux-2.4.x-VFS-lock</code> patch (there are copies
          of this in the 
          <code class="filename">LVM/1.0.8/PATCHES</code> directory.)
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="checkproc"></a>2.4. Checking the proc file system</h3></div></div></div><p>
          If your kernel was compiled with the /proc file system (most are)
          then you can verify that LVM is present by looking for a /proc/lvm
          directory. If this doesn't exist then you may have to load the
          module with the command 
        </p><pre class="screen">
<span class="command"><strong> # modprobe lvm-mod </strong></span>
         </pre><p>
          If <code class="filename"> /proc/lvm </code> still does not exist then check
          your kernel configuration carefully.
        </p><p>
          When LVM is active you will see entries in 
          <code class="filename">/proc/lvm</code> for all your physical volumes,
          volume groups and logical volumes. In addition
          there is a <span class="quote">&#8220;<span class="quote">file</span>&#8221;</span> called 
          <code class="filename">/proc/lvm/global</code> which gives a summary
          of the LVM status and also shows just which version of the LVM
          kernel you are using.
        </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="boot_scripts"></a>Chapter 7. LVM 1 Boot time scripts</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#initscriptcaldera">1. Caldera</a></span></dt><dt><span class="sect1"><a href="#initscriptdebian">2. Debian</a></span></dt><dt><span class="sect1"><a href="#initscriptmandrake">3. Mandrake</a></span></dt><dt><span class="sect1"><a href="#initscriptredhat">4. Redhat</a></span></dt><dt><span class="sect1"><a href="#initscriptslackware">5. Slackware</a></span></dt><dt><span class="sect1"><a href="#initscriptsuse">6. SuSE</a></span></dt></dl></div><p>
      Boot-time scripts are not provided as part of the LVM distribution,
      however these are quite simple to do for yourself.
    </p><p>
      The startup of LVM requires just the following two commands:
    </p><pre class="screen">
<span class="command"><strong> # vgscan
# vgchange -ay </strong></span>
      </pre><p>
      And the shutdown only one:
    </p><pre class="screen">
<span class="command"><strong> # vgchange -an</strong></span>
      </pre><p>
      Follow the instructions below depending on the distribution of
      Linux you are running.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptcaldera"></a>1. Caldera</h2></div></div></div><p>
        It is necessary to edit the file 
        <code class="filename">/etc/rc.d/rc.boot</code>.  Look for the line that
        says <span class="quote">&#8220;<span class="quote">Mounting local filesystems</span>&#8221;</span> and insert the
        vgscan and vgchange commands just before it.
      </p><p>
        You may also want to edit the file 
        <code class="filename">/etc/rc.d/init.d/halt</code> to deactivate the volume
        groups at shutdown. Insert the
        </p><pre class="screen">
<span class="command"><strong> vgchange -an </strong></span>
            </pre><p>
        command near the end of this file just after the filesystems are
        unmounted or mounted read-only, before the comment that says
        <span class="quote">&#8220;<span class="quote">Now halt or reboot</span>&#8221;</span>.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptdebian"></a>2. Debian</h2></div></div></div><p>
        If you download the Debian lvm tool package, an initscript should
        be installed for you.
      </p><p>
        If you are installing LVM from source, you will still need to build
        your own initscript:
      </p><p>
        Create a startup script in <code class="filename">/etc/init.d/lvm</code>
        containing the following:
        </p><pre class="screen">
#!/bin/sh

case "$1" in
  start)
	/sbin/vgscan
	/sbin/vgchange -ay
        ;;
  stop)
	/sbin/vgchange -an
        ;;
  restart|force-reload)
	;;
esac

exit 0
            </pre><p>
      </p><p>
        Then execute the commands
        </p><pre class="screen">
<span class="command"><strong>
 # chmod 0755 /etc/init.d/lvm
 # update-rc.d lvm start 26 S . stop 82 1 .
</strong></span>
            </pre><p>
        Note the dots in the last command.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptmandrake"></a>3. Mandrake</h2></div></div></div><p>
        No initscript modifications should be necessary for current
        versions of Mandrake.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptredhat"></a>4. Redhat</h2></div></div></div><p>
        For Redhat 7.0 and up, you should not need to modify any
        initscripts to enable LVM at boot time if LVM is built
        into the kernel.  If LVM is built as a module, it may be
        necessary to modify <code class="filename"> /etc/rc.d/rc.sysinit
        </code> to load the LVM module by adding
        <span class="quote">&#8220;<span class="quote">modprobe lvm-mod</span>&#8221;</span> before the section that
        reads:
        </p><pre class="screen"># LVM initialization, take 2 (it could be on top of RAID)
if [ -e /proc/lvm -a -x /sbin/vgchange -a -f /etc/lvmtab ]; then
        action $"Setting up Logical Volume Management:" /sbin/vgscan &amp;&amp;
        /sbin/vgchange -a y
        fi</pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            This init script fragment is from Red Hat 7.3 - other versions
            of Redhat may look slightly different.
          </p></div><p>

      </p><p>
        For versions of Redhat older than 7.0, it is necessary to edit the
        file <code class="filename">/etc/rc.d/rc.sysinit</code>.  Look for the line
        that says <span class="quote">&#8220;<span class="quote">Mount all other filesystems</span>&#8221;</span> and insert the
        vgscan and vgchange commands just before it.  You should be sure
        that your root file system is mounted read/write before you run the
        LVM commands.
      </p><p>
        You may also want to edit the file 
        <code class="filename">/etc/rc.d/init.d/halt</code> to deactivate the volume
        groups at shutdown. Insert the
        </p><pre class="screen">
vgchange -an
            </pre><p>
        command near the end of this file just after the filesystems are
        mounted read-only, before the comment that says <span class="quote">&#8220;<span class="quote">Now halt or
          reboot</span>&#8221;</span>.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptslackware"></a>5. Slackware</h2></div></div></div><p>
        Slackware 8.1 requires no updating of boot time scripts in order to
        make LVM work.
      </p><p>
        For versions previous to Slackware 8.1, you should apply the
        following patch to <code class="filename">/etc/rc.d/rc.S</code>
        </p><pre class="screen">
cd /etc/rc.d
cp -a rc.S rc.S.old
patch -p0 &lt; rc.S.diff
            </pre><p>
        (the cp part to make a backup in case).
      </p><pre class="screen">
----- snip snip file: rc.S.diff---------------
--- rc.S.or	Tue Jul 17 18:11:20 2001
+++ rc.S	Tue Jul 17 17:57:36 2001
@@ -4,6 +4,7 @@
 #
 # Mostly written by:  Patrick J. Volkerding, &lt;volkerdi@slackware.com&gt;
 #
+# Added LVM support &lt;tgs@iafrica.com&gt;

 PATH=/sbin:/usr/sbin:/bin:/usr/bin

@@ -28,19 +29,21 @@
   READWRITE=yes
 fi

+
 # Check the integrity of all filesystems
 if [ ! READWRITE = yes ]; then
-  /sbin/fsck -A -a
+  /sbin/fsck -a /
+  # Check only the root fs first, but no others
   # If there was a failure, drop into single-user mode.
   if [ ? -gt 1 ] ; then
     echo
     echo
-    echo "*******************************************************"
-    echo "*** An error occurred during the file system check. ***"
-    echo "*** You will now be given a chance to log into the  ***"
-    echo "*** system in single-user mode to fix the problem.  ***"
-    echo "*** Running 'e2fsck -v -y &lt;partition&gt;' might help.  ***"
-    echo "*******************************************************"
+    echo "************************************************************"
+    echo "*** An error occurred during the root file system check. ***"
+    echo "*** You will now be given a chance to log into the       ***"
+    echo "*** system in single-user mode to fix the problem.       ***"
+    echo "*** Running 'e2fsck -v -y &lt;partition&gt;' might help.       ***"
+    echo "************************************************************"
     echo
     echo "Once you exit the single-user shell, the system will reboot."
     echo
@@ -82,6 +85,44 @@
     echo -n "get into your machine and start looking for the problem. "
     read junk;
   fi
+  # okay / fs is clean, and mounted as rw
+  # This was an addition, limits vgscan to /proc thus
+  # speeding up the scan immensely.
+  /sbin/mount /proc
+
+  # Initialize Logical Volume Manager
+  /sbin/vgscan
+  /sbin/vgchange -ay
+
+  /sbin/fsck -A -a -R
+  #Check all the other filesystem, including the LVM's, excluding /
+
+  # If there was a failure, drop into single-user mode.
+  if [ ? -gt 1 ] ; then
+    echo
+    echo
+    echo "*******************************************************"
+    echo "*** An error occurred during the file system check. ***"
+    echo "*** You will now be given a chance to log into the  ***"
+    echo "*** system in single-user mode to fix the problem.  ***"
+    echo "*** Running 'e2fsck -v -y &lt;partition&gt;' might help.  ***"
+    echo "*** The root filesystem is ok and mounted readwrite ***"
+    echo "*******************************************************"
+    echo
+    echo "Once you exit the single-user shell, the system will reboot."
+    echo
+
+    PS1="(Repair filesystem) #"; export PS1
+    sulogin
+
+    echo "Unmounting file systems."
+    umount -a -r
+    mount -n -o remount,ro /
+    echo "Rebooting system."
+    sleep 2
+    reboot
+  fi
+
 else
   echo "Testing filesystem status: read-write filesystem"
   if cat /etc/fstab | grep ' / ' | grep umsdos 1&gt; /dev/null 2&gt; /dev/null ;
then
@@ -111,14 +152,16 @@
     echo -n "Press ENTER to continue. "
     read junk;
   fi
+
 fi

+
 # remove /etc/mtab* so that mount will create it with a root entry
 /bin/rm -f /etc/mtab* /etc/nologin /etc/shutdownpid

 # mount file systems in fstab (and create an entry for /)
 # but not NFS or SMB because TCP/IP is not yet configured
-/sbin/mount -a -v -t nonfs,nosmbfs
+/sbin/mount -a -v -t nonfs,nosmbfs,proc

 # Clean up temporary files on the /var volume:
 /bin/rm -f /var/run/utmp /var/run/*.pid /var/log/setup/tmp/*
--snip snip snip end of file---------------

         </pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initscriptsuse"></a>6. SuSE</h2></div></div></div><p>
        No changes should be necessary from 6.4 onward as LVM is included
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="lvm2_boot"></a>Chapter 8.  LVM 2 Boot Time Scripts </h1></div></div></div><p>

      For initrds, you should have:
      </p><pre class="screen">
      dmsetup mknodes
      vgscan --ignorelockingfailure
      vgchange -ay --ignorelockingfailure
      </pre><p>

      in the linuxrc to get the root LV activated before the root
      volume is accessed.

      Most distros seem to have this setup in their mkinitrd scripts
      now, and they also tend to have them in rc.sysinit or
      equivilant, so all volumes get activated on bootup.

    </p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="buildlvm"></a>Chapter 9. Building LVM from the Source</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#makelvm1user">1. Make LVM library and tools</a></span></dt><dt><span class="sect1"><a href="#installlvm1user">2. Install LVM library and tools</a></span></dt><dt><span class="sect1"><a href="#removelvm1user">3. Removing LVM library and tools</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="makelvm1user"></a>1. Make LVM library and tools</h2></div></div></div><p>
        Change into the LVM directory and do a 
        <span class="command"><strong>./configure</strong></span> followed
        by <span class="command"><strong>make</strong></span>. This will make all of the libraries and
        programs.
      </p><p>
        If the need arises you can change some options with the configure
        script.  Do a <span class="command"><strong>./configure --help</strong></span> to determine
        which options are supported.  Most of the time this will not be
        necessary.
      </p><p>
        There should be no errors from the build process.  If there are,
        see <a class="link" href="#ReportBug" title="Appendix B. Reporting Errors and Bugs">Reporting Errors and Bugs</a>
        on how to report this.
      </p><p>
        You are welcome to fix them and send us the patches too.
        Patches are generally sent to the <a class="link" href="#Maillists" title="1. Mail lists">linux-lvm</a> list.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="installlvm1user"></a>2. Install LVM library and tools</h2></div></div></div><p> 
        After the LVM source compiles properly, simply run 
        <span class="command"><strong>make install</strong></span> to install the LVM library and
        tools onto your system.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removelvm1user"></a>3. Removing LVM library and tools</h2></div></div></div><p>
        To remove the library and tools you just installed, run 
        <span class="command"><strong>make remove</strong></span>.  You must have the original source
        tree you used to install LVM to use this feature.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="trans1"></a>Chapter 10. Transitioning from previous versions of LVM to LVM 1.0.8</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#upgradelvm1">1. Upgrading to LVM 1.0.8 with a non-LVM root partition</a></span></dt><dt><span class="sect1"><a href="#upgradetolvmroot">2. Upgrading to LVM 1.0.8 with an LVM root partition and initrd</a></span></dt></dl></div><p>
      Transitioning from previous versions of LVM to LVM 1.0.8 should be
      fairly painless.  We have come up with a method to read in PV version
      1 metadata (LVM 0.9.1 Beta7 and earlier) as well as PV version 2
      metadata (LVM 0.9.1 Beta8 and LVM 1.0).
    </p><p>
      <span class="emphasis"><em>Warning:</em></span> New PVs initialized with LVM 1.0.8 are
      created with the PV version 1 on-disk structure.  This means that LVM
      0.9.1 Beta8 and LVM 1.0 cannot read or use PVs created with 1.0.8.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgradelvm1"></a>1. Upgrading to LVM 1.0.8 with a non-LVM root partition</h2></div></div></div><p>
        There are just a few simple steps to transition this setup, but it
        is still recommended that you backup your data before you try it.
        You have been warned.
        
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="strong"><strong>Build LVM kernel and modules</strong></span>
            </p><p>
              Follow the steps outlined in <a class="xref" href="#getlvm" title="Chapter 5. Acquiring LVM">Chapter 5, <i>Acquiring LVM</i></a> - 
              <a class="xref" href="#buildlvmmod" title="2. Build the LVM 1 kernel module">Section 2, &#8220;Build the LVM 1 kernel module&#8221;</a> for instructions on how to get
              and build the necessary kernel components of LVM.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>Build the LVM user tools</strong></span>
            </p><p>
              Follow the steps in 
              <a class="xref" href="#buildlvm" title="Chapter 9. Building LVM from the Source">Chapter 9, <i>Building LVM from the Source</i></a> to build and install the user tools
              for LVM.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>Setup your init scripts</strong></span>
            </p><p>
              Make sure you have the proper init scripts setup as per
              <a class="xref" href="#boot_scripts" title="Chapter 7. LVM 1 Boot time scripts">Chapter 7, <i>LVM 1 Boot time scripts</i></a>.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>Boot into the new kernel</strong></span>
            </p><p>
              Make sure your boot-loader is setup to load the new
              LVM-enhanced kernel and, if you are using LVM modules, put an
              <span class="command"><strong>insmod lvm-mod</strong></span> into your startup script OR
              extend <code class="filename">/etc/modules.conf</code> (formerly
              <code class="filename">/etc/conf.modules</code>) by adding
              </p><pre class="screen">
     alias block-major-58      lvm-mod
     alias char-major-109      lvm-mod
                  </pre><p>
              to enable modprobe to load the LVM module (don't forget to
              enable kmod).
            </p><p>
              Reboot and enjoy.
            </p></li></ol></div><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgradetolvmroot"></a>2. Upgrading to LVM 1.0.8 with an LVM root partition and initrd</h2></div></div></div><p>
        This is relatively straightforward if you follow the steps
        carefully.  It is recommended you have a good backup and a suitable
        rescue disk handy just in case.
      </p><p>
        The <span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> way of running an LVM root file system is
        to have a single non-LVM partition called 
        <code class="filename">/boot</code>
        which contains the kernel and initial RAM disk needed to start the
        system. The system I upgraded was as follows:
        </p><pre class="screen">
<span class="command"><strong> # df</strong></span>
<code class="computeroutput">
Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/rootvg/root        253871     93384    147380  39% /
/dev/hda1                17534     12944      3685  78% /boot
/dev/rootvg/home       4128448      4568   3914168   0% /home
/dev/rootvg/usr        1032088    332716    646944  34% /usr
/dev/rootvg/var         253871     31760    209004  13% /var
</code>
            </pre><p>
        <code class="filename">/boot</code>
        contains the old kernel and an initial RAM disk as well as the LILO
        boot files and the following entry in 
        <code class="filename">/etc/lilo.conf</code>
        </p><pre class="screen">
<span class="command"><strong> # ls /boot</strong></span>
<code class="computeroutput">
System.map                 lost+found              vmlinux-2.2.16lvm
map                        module-info	           boot.0300  
boot.b                     os2_d.b                 chain.b
initrd.gz                  
</code>
<span class="command"><strong> # tail /etc/lilo.conf</strong></span>
<code class="computeroutput">
image=/boot/vmlinux-2.2.16lvm
        label=lvm08
        read-only
        root=/dev/rootvg/root
        initrd=/boot/initrd.gz
        append="ramdisk_size=8192"
</code>
            </pre><p>

        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              <span class="strong"><strong>
                Build LVM kernel and modules
              </strong></span>
            </p><p>
              Follow the steps outlined in
              <a class="xref" href="#getlvm" title="Chapter 5. Acquiring LVM">Chapter 5, <i>Acquiring LVM</i></a> - <a class="xref" href="#buildlvmmod" title="2. Build the LVM 1 kernel module">Section 2, &#8220;Build the LVM 1 kernel module&#8221;</a>
              for instructions on how to get and build the necessary
              kernel components of LVM.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Build the LVM user tools
              </strong></span>
            </p><p>
              Follow the steps in
              <a class="xref" href="#buildlvmmod" title="2. Build the LVM 1 kernel module">Section 2, &#8220;Build the LVM 1 kernel module&#8221;</a> to build and install the user
              tools for LVM.
            </p><p>
              Install the new tools. Once you have done this you cannot
              do any LVM manipulation as they are not compatible with
              the kernel you are currently running.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Rename the existing initrd.gz
              </strong></span>
            </p><p>
              This is so it doesn't get overwritten by the new one
              </p><pre class="screen">
<span class="command"><strong># mv /boot/initrd.gz /boot/initrd08.gz</strong></span>
                     </pre><p>
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Edit <code class="filename">/etc/lilo.conf</code>
              </strong></span>
            </p><p>
              Make the existing boot entry point to the renamed file.
              You will need to reboot using this if something goes wrong
              in the next reboot. The changed entry will look something
              like this:
              </p><pre class="screen">
image=/boot/vmlinux-2.2.16lvm
        label=lvm08
        read-only
        root=/dev/rootvg/root
        initrd=/boot/initrd08.gz
        append="ramdisk_size=8192"
                     </pre><p>
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Run lvmcreate_initrd to create a new initial RAM disk
              </strong></span>
              </p><pre class="screen">
<span class="command"><strong># lvmcreate_initrd 2.4.9</strong></span>
                     </pre><p>
              Don't forget the put the new kernel version in there so
              that it picks up the correct modules.
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Add a new entry into /etc/lilo.conf
              </strong></span>
            </p><p>
              This new entry is to boot the new kernel with its new
              initrd.
              </p><pre class="screen">
image=/boot/vmlinux-2.4.9lvm
        label=lvm10
        read-only
        root=/dev/rootvg/root
        initrd=/boot/initrd.gz
        append="ramdisk_size=8192"
                     </pre><p>
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Re-run lilo
              </strong></span>
            </p><p>
              This will install the new boot block
              </p><pre class="screen">
<span class="command"><strong># /sbin/lilo</strong></span>
                     </pre><p>
            </p></li><li class="listitem"><p>
              <span class="strong"><strong>
                Reboot
              </strong></span>
            </p><p>
              When you get the LILO prompt select the new entry name (in
              this example lvm10) and your system should boot into Linux
              using the new LVM version.
            </p><p>
              If the new kernel does not boot, then simply boot the old
              one and try to fix the problem.  It may be that the new
              kernel does not have all the correct device drivers built
              into it, or that they are not available in the initrd.
              Remember that all device drivers (apart from LVM) needed
              to access the root device should be compiled into the
              kernel and not as modules.
            </p><p>
              If you need to do any LVM manipulation when booted back
              into the old version, then simply recompile the old tools
              and install them with
              </p><pre class="screen">
<span class="command"><strong># make install</strong></span>
                     </pre><p>
              If you do this, don't forget to install the new tools when
              you reboot into the new LVM version.
            </p></li></ol></div><p>

        When you are happy with the new system remember to change the
        ``default='' entry in your lilo.conf file so that it is the default
        kernel.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="commontask"></a>Chapter 11. Common Tasks</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#initdisks">1. Initializing disks or disk partitions</a></span></dt><dt><span class="sect1"><a href="#createvgs">2. Creating a volume group</a></span></dt><dt><span class="sect1"><a href="#activatevgs">3. Activating a volume group</a></span></dt><dt><span class="sect1"><a href="#removevgs">4. Removing a volume group</a></span></dt><dt><span class="sect1"><a href="#addpvstovg">5. Adding physical volumes to a volume group</a></span></dt><dt><span class="sect1"><a href="#removepvsfromvg">6. Removing physical volumes from a volume group</a></span></dt><dt><span class="sect1"><a href="#createlv">7. Creating a logical volume</a></span></dt><dt><span class="sect1"><a href="#removelv">8. Removing a logical volume</a></span></dt><dt><span class="sect1"><a href="#extendlv">9. Extending a logical volume</a></span></dt><dt><span class="sect1"><a href="#reducelv">10. Reducing a logical volume</a></span></dt><dt><span class="sect1"><a href="#migrateoffpv">11. Migrating data off of a physical volume</a></span></dt></dl></div><p>
      The following sections outline some common administrative tasks for an
      LVM system.  <span class="emphasis"><em>This is no substitute for reading the man
        pages.</em></span>
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initdisks"></a>1. Initializing disks or disk partitions</h2></div></div></div><p>
        Before you can use a disk or disk partition as a physical volume
        you will have to initialize it:
      </p><p>
        For entire disks:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Run pvcreate on the disk:
              </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/hdb</strong></span>
                     </pre><p>
              This creates a volume group descriptor at the start of
              disk.
              </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Not Recommended</h3><p>
	          Using the whole disk as a PV (as opposed to a partition spanning the whole disk) is not recommended because of the management issues it can create.  Any other OS that looks at the disk will not recognize the LVM metadata and display the disk as being free, so it is likely it will be overwritten.  LVM itself will work fine with whole disk PVs.
 	        </p></div><p>
            </p></li><li class="listitem"><p>
              If you get an error that LVM can't initialize a
              disk with a partition table on it, first make sure
              that the disk you are operating on is the correct
              one. If you are very sure that it is, run the
              following:
              </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">DANGEROUS</h3><p>
                  The following commands will destroy the
                  partition table on the disk being operated on.
                  Be very sure it is the correct disk.
                </p></div><p>
              </p><pre class="screen">
# dd if=/dev/zero of=/dev/diskname bs=1k count=1
# blockdev --rereadpt /dev/diskname
</pre><p>
            </p></li></ul></div><p>

        For partitions:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              When using LVM 1 on PCs with DOS partitions, set
              the partition type to 0x8e using fdisk or some
              other similar program.  This step is unnecessary
              on PPC systems or when using LVM 2.
            </p></li><li class="listitem"><p>
              Run pvcreate on the partition:
              </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/hdb1</strong></span>
              </pre><p>
              This creates a volume group descriptor at the start of
              the /dev/hdb1 partition.
            </p></li></ul></div><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createvgs"></a>2. Creating a volume group</h2></div></div></div><p>
        Use the 'vgcreate' program:
        </p><pre class="screen">
<span class="command"><strong># vgcreate my_volume_group /dev/hda1 /dev/hdb1 </strong></span>
        </pre><p>
        <span class="emphasis"><em>NOTE:</em></span> If you are using LVM 1 with
        devfs it is essential to use the full devfs name of the
        device rather than the symlinked name in <code class="filename">/dev</code>. So the above would be:
        </p><pre class="screen">
<span class="command"><strong># vgcreate my_volume_group /dev/ide/host0/bus0/target0/lun0/part1 \
                           /dev/ide/host0/bus0/target1/lun0/part1</strong></span>
        </pre><p>
        LVM 2 does not have this restriction.
      </p><p>
        You can also specify the extent size with this command if the
        default of 32MB is not suitable for you with the '-s' switch.  In
        addition you can put some limits on the number of physical or
        logical volumes the volume can have.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="activatevgs"></a>3. Activating a volume group</h2></div></div></div><p>
        After rebooting the system or running 
        <span class="command"><strong>vgchange -an</strong></span>, you will not be able to access
        your VGs and LVs.  To reactivate the volume group, run:
        </p><pre class="screen">
<span class="command"><strong># vgchange -a y my_volume_group</strong></span>
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removevgs"></a>4. Removing a volume group</h2></div></div></div><p>
        Make sure that no logical volumes are present in the volume group,
        see later section for how to do this.
      </p><p>
        Deactivate the volume group:
        </p><pre class="screen">
<span class="command"><strong># vgchange -a n my_volume_group</strong></span>
        </pre><p>
      </p><p>
        Now you actually remove the volume group:
        </p><pre class="screen">
<span class="command"><strong># vgremove my_volume_group</strong></span>
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="addpvstovg"></a>5. Adding physical volumes to a volume group</h2></div></div></div><p>
        Use 'vgextend' to add an initialized physical volume to an existing
        volume group.
        </p><pre class="screen">
<span class="command"><strong># vgextend my_volume_group /dev/hdc1</strong></span>
                                    ^^^^^^^^^ new physical volume
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removepvsfromvg"></a>6. Removing physical volumes from a volume group</h2></div></div></div><p>
        Make sure that the physical volume isn't used by any logical
        volumes by using then 'pvdisplay' command:
        </p><pre class="screen">
<span class="command"><strong># pvdisplay /dev/hda1</strong></span>
<code class="computeroutput">
--- Physical volume ---
PV Name               /dev/hda1
VG Name               myvg
PV Size               1.95 GB / NOT usable 4 MB [LVM: 122 KB]
PV#                   1
PV Status             available
Allocatable           yes (but full)
Cur LV                1
PE Size (KByte)       4096
Total PE              499
Free PE               0
Allocated PE          499
PV UUID               Sd44tK-9IRw-SrMC-MOkn-76iP-iftz-OVSen7
</code>
        </pre><p>
      </p><p>
        If the physical volume is still used you will have to migrate the
        data to another physical volume using pvmove.
      </p><p>
        Then use 'vgreduce' to remove the physical volume:
        </p><pre class="screen">
<span class="command"><strong># vgreduce my_volume_group /dev/hda1</strong></span>
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createlv"></a>7. Creating a logical volume</h2></div></div></div><p>
        To create a 1500MB linear LV named 'testlv' and its block
        device special '/dev/testvg/testlv':
        </p><pre class="screen">
<span class="command"><strong># lvcreate -L1500 -ntestlv testvg</strong></span>
        </pre><p>
      </p><p>
        To create a 100 LE large logical volume with 2 stripes and
        stripe size 4 KB.
        </p><pre class="screen">
<span class="command"><strong># lvcreate -i2 -I4 -l100 -nanothertestlv testvg</strong></span>
        </pre><p>
      </p><p>
        If you want to create an LV that uses the entire VG, use vgdisplay
        to find the <span class="quote">&#8220;<span class="quote">Total PE</span>&#8221;</span> size, then use that when
        running lvcreate.
        </p><pre class="screen">
<span class="command"><strong># vgdisplay testvg | grep "Total PE"</strong></span>
<code class="computeroutput">Total PE              10230</code>
<span class="command"><strong># lvcreate -l 10230 testvg -n mylv</strong></span>
        </pre><p>
        This will create an LV called 
        <span class="strong"><strong>mylv</strong></span> filling the
        <span class="strong"><strong>testvg</strong></span> VG.
      </p><p>
        If you want the logical volume to be allocated from a specific
        physical volume in the volume group, specify the PV or PVs at
        the end of the lvcreate command line.
        </p><pre class="screen">
<span class="command"><strong># lvcreate -L 1500 -ntestlv testvg /dev/sdg</strong></span>
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removelv"></a>8. Removing a logical volume</h2></div></div></div><p>
        A logical volume must be closed before it can be removed:
        </p><pre class="screen">
<span class="command"><strong># umount /dev/myvg/homevol
# lvremove /dev/myvg/homevol</strong></span>
<code class="prompt">lvremove -- do you really want to remove "/dev/myvg/homevol"? [y/n]: </code><em class="replaceable"><code>y</code></em>
<code class="computeroutput">lvremove -- doing automatic backup of volume group "myvg"
lvremove -- logical volume "/dev/myvg/homevol" successfully removed</code>
        </pre><p>
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extendlv"></a>9. Extending a logical volume</h2></div></div></div><p>
        To extend a logical volume you simply tell the lvextend command how
        much you want to increase the size. You can specify how much to
        grow the volume, or how large you want it to grow to:
        </p><pre class="screen">
<span class="command"><strong># lvextend -L12G /dev/myvg/homevol</strong></span>
<code class="computeroutput">lvextend -- extending logical volume "/dev/myvg/homevol" to 12 GB
lvextend -- doing automatic backup of volume group "myvg"
lvextend -- logical volume "/dev/myvg/homevol" successfully extended</code>
        </pre><p>
        will extend <code class="filename">/dev/myvg/homevol</code> to 12 Gigabytes.
      </p><p>
        </p><pre class="screen">
<span class="command"><strong># lvextend -L+1G /dev/myvg/homevol</strong></span>
<code class="computeroutput">lvextend -- extending logical volume "/dev/myvg/homevol" to 13 GB
lvextend -- doing automatic backup of volume group "myvg"
lvextend -- logical volume "/dev/myvg/homevol" successfully extended</code>
        </pre><p>
        will add another gigabyte to <code class="filename">/dev/myvg/homevol</code>.
      </p><p>
        After you have extended the logical volume it is necessary to
        increase the file system size to match. how you do this depends on
        the file system you are using.
      </p><p>
        By default, most file system resizing tools will increase the size
        of the file system to be the size of the underlying logical volume
        so you don't need to worry about specifying the same size for each
        of the two commands.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="strong"><strong>
              ext2/ext3
            </strong></span>
          </p><p>
            Unless you have patched your kernel with the ext2online
            patch it is necessary to unmount the file system before
            resizing it.  (It seems that the online resizing patch is
            rather dangerous, so use at your own risk)
            </p><pre class="screen">
   <span class="command"><strong># umount /dev/myvg/homevol/dev/myvg/homevol
   # resize2fs /dev/myvg/homevol
   # mount /dev/myvg/homevol /home</strong></span>
            </pre><p>
          </p><p>   
            If you don't have e2fsprogs 1.19 or later, you can download
            the ext2resize command from 
            <a class="ulink" href="http://ext2resize.sourceforge.net" target="_top">ext2resize.sourceforge.net</a>
            and use that:
            </p><pre class="screen">
   <span class="command"><strong># umount /dev/myvg/homevol/dev/myvg/homevol
   # ext2resize /dev/myvg/homevol
   # mount /dev/myvg/homevol /home</strong></span>
            </pre><p>
          </p><p>
            For ext2 there is an easier way. LVM 1 ships with a utility
            called e2fsadm which does the lvextend and resize2fs for you
            (it can also do file system shrinking, see the next section).

            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">LVM 2 Caveat</h3><p>
                There is currently no e2fsadm equivalent for
                LVM 2 and the e2fsadm that ships with LVM 1
                does not work with LVM 2.
              </p></div><p>

            so the single command
            </p><pre class="screen">
   <span class="command"><strong># e2fsadm -L+1G /dev/myvg/homevol</strong></span>
            </pre><p>
            is equivalent to the two commands:
            </p><pre class="screen">
   <span class="command"><strong># lvextend -L+1G /dev/myvg/homevol
   # resize2fs /dev/myvg/homevol</strong></span>
            </pre><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                You will still need to unmount the file system before
                running e2fsadm.
              </p></div><p>
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              reiserfs
            </strong></span>
          </p><p>
            Reiserfs file systems can be resized when mounted or
            unmounted as you prefer:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                  Online:
                  </p><pre class="screen">
   <span class="command"><strong># resize_reiserfs -f /dev/myvg/homevol</strong></span>
                  </pre><p>
                </p></li><li class="listitem"><p>
                  Offline:
                  </p><pre class="screen">
   <span class="command"><strong># umount /dev/myvg/homevol
   # resize_reiserfs /dev/myvg/homevol
   # mount -treiserfs /dev/myvg/homevol /home</strong></span>
                  </pre><p>
                </p></li></ul></div><p>
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              xfs
            </strong></span>
          </p><p>
            XFS file systems must be mounted to be resized and the
            mount-point is specified rather than the device name.
            </p><pre class="screen">
   <span class="command"><strong># xfs_growfs /home</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              jfs
            </strong></span>
          </p><p>
            Just like XFS the JFS file system must be mounted to be
	    resized and the mount-point is specified rather than the
	    device name.  You need at least Version 1.0.21 of the
	    jfs-utils to do this.
            </p><pre class="screen">
<span class="command"><strong># mount -o remount,resize /home</strong></span>
            </pre><p>
          </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Known Kernel Bug</h3><p>
              Some kernel versions have problems with this syntax
              (2.6.0 is known to have this problem). In this case you
              have to explicitly specify the new size of the
              filesystem in blocks.  This is extremely error prone as
              you <span class="emphasis"><em>must</em></span> know the blocksize of your
              filesystem and calculate the new size based on those
              units.
            </p><p>
              Example: If you were to resize a JFS file system to 4
              gigabytes that has 4k blocks, you would write:
              </p><pre class="screen">
<span class="command"><strong># mount -o remount,resize=1048576 /home</strong></span>
              </pre><p>
            </p></div></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reducelv"></a>10. Reducing a logical volume</h2></div></div></div><p>
        Logical volumes can be reduced in size as well as increased.
        However, it is <span class="emphasis"><em>very</em></span> important to remember to
        reduce the size of the file system or whatever is residing in the
        volume before shrinking the volume itself, otherwise you risk
        losing data.
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
            <span class="strong"><strong>
              ext2
            </strong></span>
          </p><p>
            If you are using LVM 1 with ext2 as the file system
            then you can use the e2fsadm command mentioned
            earlier to take care of both the file system and
            volume resizing as follows:
            </p><pre class="screen">
<span class="command"><strong># umount /home
# e2fsadm -L-1G /dev/myvg/homevol
# mount /home</strong></span>
            </pre><p>

            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">LVM 2 Caveat</h3><p>
                There is currently no e2fsadm equivalent for
                LVM 2 and the e2fsadm that ships with LVM 1
                does not work with LVM 2.
              </p></div><p>
            
          </p><p>
            If you prefer to do this manually you must know the new size
            of the volume in blocks and use the following commands:
            </p><pre class="screen">
<span class="command"><strong># umount /home
# resize2fs /dev/myvg/homevol 524288
# lvreduce -L-1G /dev/myvg/homevol
# mount /home</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              reiserfs
            </strong></span>
          </p><p>
            Reiserfs seems to prefer to be unmounted when shrinking
            </p><pre class="screen">
<span class="command"><strong># umount /home
# resize_reiserfs -s-1G /dev/myvg/homevol
# lvreduce -L-1G /dev/myvg/homevol
# mount -treiserfs /dev/myvg/homevol /home</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              xfs
            </strong></span>
          </p><p>
            There is no way to shrink XFS file systems.
          </p></li><li class="listitem"><p>
            <span class="strong"><strong>
              jfs
            </strong></span>
          </p><p>
            There is no way to shrink JFS file systems.
          </p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="migrateoffpv"></a>11. Migrating data off of a physical volume</h2></div></div></div><p>
        To take a disk out of service it must first have all of its active
        physical extents moved to one or more of the remaining disks in the
        volume group.  There must be enough free physical extents in the
        remaining PVs to hold the extents to be copied from the old disk.
        For further detail see <a class="xref" href="#RemoveADisk" title="5. Removing an Old Disk">Section 5, &#8220;Removing an Old Disk&#8221;</a>.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="diskpart"></a>Chapter 12. Disk partitioning</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#multpartitions">1. Multiple partitions on the same disk</a></span></dt><dt><span class="sect1"><a href="#sundisklabels">2. Sun disk labels</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multpartitions"></a>1. Multiple partitions on the same disk</h2></div></div></div><p>
        LVM allows you to create PVs (physical volumes) out of almost any
        block device so, for example, the following are all valid commands
        and will work quite happily in an LVM environment:
        </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/sda1
# pvcreate /dev/sdf
# pvcreate /dev/hda8
# pvcreate /dev/hda6
# pvcreate /dev/md1</strong></span>
        </pre><p>
      </p><p>
        In a <span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> production system it is recommended that
        only one PV exists on a single real disk, for the following
        reasons:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Administrative convenience
            </p><p>
              It's easier to keep track of the hardware in a system if
              each real disk only appears once. This becomes
              particularly true if a disk fails.
            </p></li><li class="listitem"><p>
              To avoid striping performance problems
            </p><p>
              LVM can't tell that two PVs are on the same physical disk,
              so if you create a striped LV then the stripes could be on
              different partitions on the same disk resulting in a
              <span class="strong"><strong>decrease</strong></span> in performance
              rather than an increase.
            </p></li></ul></div><p>

        However it may be desirable to do this for some reasons:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Migration of existing system to LVM
            </p><p>
              On a system with few disks it may be necessary to move
              data around partitions to do the conversion (see 
              <a class="xref" href="#UpgradeRootToLVM" title="8. Converting a root filesystem to LVM 1">Section 8, &#8220;Converting a root filesystem to
        LVM 1&#8221;</a>)
            </p></li><li class="listitem"><p>
              Splitting one big disk between Volume Groups
            </p><p>
              If you have a very large disk and want to have more than
              one volume group for administrative purposes then it is
              necessary to partition the drive into more than one area.
            </p></li></ul></div><p>
      </p><p>
        If you do have a disk with more than one partition and both of
        those partitions are in the same volume group, take care to specify
        which partitions are to be included in a logical volume when
        creating striped volumes.
      </p><p>
        The recommended method of partitioning a disk is to create a single
        partition that covers the whole disk. This avoids any nasty
        accidents with whole disk drive device nodes and prevents the
        kernel warning about unknown partition types at boot-up.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sundisklabels"></a>2. Sun disk labels</h2></div></div></div><p>
        You need to be especially careful on SPARC systems where the disks
        have Sun disk labels on them.
      </p><p>
        The normal layout for a Sun disk label is for the first partition
        to start at block zero of the disk, thus the first partition also
        covers the area containing the disk label itself.  This works fine
        for ext2 filesystems (and is essential for booting using SILO) but
        such partitions should not be used for LVM. This is because LVM
        starts writing at the very start of the device and will overwrite
        the disk label.
      </p><p>
        If you want to use a disk with a Sun disk label with LVM, make sure
        that the partition you are going to use starts at cylinder 1 or
        higher.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="recipes"></a>Chapter 13. Recipes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#recipethreescsi">1. Setting up LVM on three SCSI disks</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1056">1.1. Preparing the disks</a></span></dt><dt><span class="sect2"><a href="#idm1066">1.2. Setup a Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1078">1.3. Creating the Logical Volume</a></span></dt><dt><span class="sect2"><a href="#idm1085">1.4. Create the File System</a></span></dt><dt><span class="sect2"><a href="#idm1091">1.5. Test the File System</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipethreescsistripe">2. Setting up LVM on three SCSI disks with striping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1106">2.1. Preparing the disk partitions</a></span></dt><dt><span class="sect2"><a href="#idm1116">2.2. Setup a Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1128">2.3. Creating the Logical Volume</a></span></dt><dt><span class="sect2"><a href="#idm1138">2.4. Create the File System</a></span></dt><dt><span class="sect2"><a href="#idm1144">2.5. Test the File System</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipeadddisk">3. Add a new disk to a multi-disk SCSI system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1155">3.1. Current situation</a></span></dt><dt><span class="sect2"><a href="#idm1164">3.2. Prepare the disk partitions</a></span></dt><dt><span class="sect2"><a href="#idm1199">3.3. Add the new disks to the volume groups</a></span></dt><dt><span class="sect2"><a href="#idm1209">3.4. Extend the file systems</a></span></dt><dt><span class="sect2"><a href="#idm1221">3.5. Remount the extended volumes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Snapshots_Backup">4. Taking a Backup Using Snapshots</a></span></dt><dd><dl><dt><span class="sect2"><a href="#snapbackcreate">4.1. Create the snapshot volume</a></span></dt><dt><span class="sect2"><a href="#idm1243">4.2. Mount the snapshot volume</a></span></dt><dt><span class="sect2"><a href="#idm1253">4.3. Do the backup</a></span></dt><dt><span class="sect2"><a href="#idm1259">4.4. Remove the snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#RemoveADisk">5. Removing an Old Disk</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1272">5.1. Distributing Old Extents to Existing Disks in Volume Group</a></span></dt><dt><span class="sect2"><a href="#idm1291">5.2. Distributing Old Extents to a New Replacement Disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipemovevgtonewsys">6. Moving a volume group to another system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1325">6.1. Unmount the file system</a></span></dt><dt><span class="sect2"><a href="#idm1330">6.2. Mark the volume group inactive</a></span></dt><dt><span class="sect2"><a href="#idm1336">6.3. Export the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1342">6.4. Import the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1356">6.5. Activate the volume group</a></span></dt><dt><span class="sect2"><a href="#idm1361">6.6. Mount the file system</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recipesplitvg">7. Splitting a volume group</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1369">7.1. Determine free space</a></span></dt><dt><span class="sect2"><a href="#idm1375">7.2. Move data off the disks to be used</a></span></dt><dt><span class="sect2"><a href="#idm1388">7.3. Create the new volume group</a></span></dt><dt><span class="sect2"><a href="#idm1394">7.4. Remove remaining volume</a></span></dt><dt><span class="sect2"><a href="#idm1402">7.5. Create new logical volume</a></span></dt><dt><span class="sect2"><a href="#idm1408">7.6. Make a file system on the volume</a></span></dt><dt><span class="sect2"><a href="#idm1413">7.7. Mount the new volume</a></span></dt></dl></dd><dt><span class="sect1"><a href="#UpgradeRootToLVM">8. Converting a root filesystem to
        LVM 1</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1436">8.1. Boot single user</a></span></dt><dt><span class="sect2"><a href="#idm1440">8.2. Run Parted</a></span></dt><dt><span class="sect2"><a href="#idm1455">8.3. Reboot</a></span></dt><dt><span class="sect2"><a href="#idm1458">8.4. Verify kernel config options</a></span></dt><dt><span class="sect2"><a href="#idm1461">8.5. Adjust partition type</a></span></dt><dt><span class="sect2"><a href="#idm1471">8.6. Set up LVM 1 for the new scheme</a></span></dt><dt><span class="sect2"><a href="#idm1490">8.7. Create the Filesystem</a></span></dt><dt><span class="sect2"><a href="#idm1495">8.8. Update /etc/fstab</a></span></dt><dt><span class="sect2"><a href="#idm1500">8.9. Create an LVM 1 initial RAM disk</a></span></dt><dt><span class="sect2"><a href="#idm1505">8.10. Update /etc/lilo.conf</a></span></dt><dt><span class="sect2"><a href="#idm1513">8.11. Run LILO to write the new boot sector</a></span></dt><dt><span class="sect2"><a href="#idm1517">8.12. Reboot to lvm</a></span></dt><dt><span class="sect2"><a href="#idm1523">8.13. Add remainder of disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#recovermetadata">9. Recover physical volume metadata</a></span></dt></dl></div><p>
      This section details several different <span class="quote">&#8220;<span class="quote">recipes</span>&#8221;</span> for
      setting up lvm.  The hope is that the reader will adapt these recipes
      to their own system and needs.
    </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recipethreescsi"></a>1. Setting up LVM on three SCSI disks</h2></div></div></div><p>
        For this recipe, the setup has three SCSI disks that will be put
        into a logical volume using LVM.  The disks are at /dev/sda,
        /dev/sdb, and /dev/sdc.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1056"></a>1.1. Preparing the disks</h3></div></div></div><p>
          Before you can use a disk in a volume group you will have to
          prepare it:
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning!</h3><p>
            <span class="strong"><strong>
              The following will destroy any data on /dev/sda, /dev/sdb,
              and /dev/sdc
            </strong></span>
          </p></div><p>
          Run pvcreate on the disks
          </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/sda
# pvcreate /dev/sdb
# pvcreate /dev/sdc</strong></span>
          </pre><p>
          This creates a volume group descriptor area (VGDA) at the start
          of the disks.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1066"></a>1.2. Setup a Volume Group</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Create a volume group
              </p><pre class="screen">
<span class="command"><strong># vgcreate my_volume_group /dev/sda /dev/sdb /dev/sdc/</strong></span>
              </pre><p>
            </p></li><li class="listitem"><p>
              Run vgdisplay to verify volume group
              </p><pre class="screen">
<span class="command"><strong># vgdisplay</strong></span>
<code class="computeroutput"># vgdisplay
--- Volume Group ---
VG Name	              my_volume_group
VG Access             read/write
VG Status             available/resizable
VG #                  1
MAX LV                256
Cur LV                0
Open LV               0
MAX LV Size           255.99 GB
Max PV                256
Cur PV                3
Act PV                3
VG Size               1.45 GB
PE Size               4 MB
Total PE              372
Alloc PE / Size       0 / 0
Free  PE / Size       372/ 1.45 GB
VG UUID               nP2PY5-5TOS-hLx0-FDu0-2a6N-f37x-0BME0Y</code>
              </pre><p>
              The most important things to verify are that the first
              three items are correct and that the VG Size item is the
              proper size for the amount of space in all four of your
              disks.
            </p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1078"></a>1.3. Creating the Logical Volume</h3></div></div></div><p>
          If the volume group looks correct, it is time to create a
          logical volume on top of the volume group.
        </p><p>
          You can make the logical volume any size you like.  (It is
          similar to a partition on a non LVM setup.)  For this example we
          will create just a single logical volume of size 1GB on the
          volume group.  We will not use striping because it is not
          currently possible to add a disk to a stripe set after the
          logical volume is created.
          </p><pre class="screen">
<span class="command"><strong># lvcreate -L1G -nmy_logical_volume my_volume_group</strong></span>
<code class="computeroutput">lvcreate -- doing automatic backup of "my_volume_group"
lvcreate -- logical volume "/dev/my_volume_group/my_logical_volume" successfully created</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1085"></a>1.4. Create the File System</h3></div></div></div><p>
          Create an ext2 file system on the logical volume
          </p><pre class="screen">
<span class="command"><strong># mke2fs /dev/my_volume_group/my_logical_volume</strong></span>
<code class="computeroutput">mke2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
131072 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
9 block groups
32768 blocks per group, 32768 fragments per group
16384 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376

Writing inode tables: done
Writing superblocks and filesystem accounting information: done</code>
               </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1091"></a>1.5. Test the File System</h3></div></div></div><p>
          Mount the logical volume and check to make sure everything looks
          correct
          </p><pre class="screen">
<span class="command"><strong># mount /dev/my_volume_group/my_logical_volume /mnt
# df</strong></span>
<code class="computeroutput">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hda1              1311552    628824    616104  51% /
/dev/my_volume_group/my_logical_volume
                       1040132        20    987276   0% /mnt</code>
          </pre><p>
        </p><p>
          If everything worked properly, you should now have a logical
          volume with and ext2 file system mounted at 
          <code class="filename">/mnt</code>.
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recipethreescsistripe"></a>2. Setting up LVM on three SCSI disks with striping</h2></div></div></div><p>
        For this recipe, the setup has three SCSI disks that will be put
        into a logical volume using LVM.  The disks are at /dev/sda,
        /dev/sdb, and /dev/sdc.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          <span class="strong"><strong>
            It is not currently possible to add a disk to a
            striped logical volume in LVM 1.  Use LVM 2 with the
            lvm 2 format metadata if you wish to be able to do
            so able to do so.
          </strong></span>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1106"></a>2.1. Preparing the disk partitions</h3></div></div></div><p>
          Before you can use a disk in a volume group you will have to
          prepare it:
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning!</h3><p>
            <span class="strong"><strong>
              The following will destroy any data on /dev/sda, /dev/sdb,
              and /dev/sdc
            </strong></span>
          </p></div><p>
          Run pvcreate on the disks:
          </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/sda
# pvcreate /dev/sdb
# pvcreate /dev/sdc</strong></span>
          </pre><p>
          This creates a volume group descriptor area (VGDA) at the start
          of the disks.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1116"></a>2.2. Setup a Volume Group</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Create a volume group
              </p><pre class="screen">
<span class="command"><strong># vgcreate my_volume_group /dev/sda /dev/sdb /dev/sdc</strong></span>
              </pre><p>
            </p></li><li class="listitem"><p>
              Run vgdisplay to verify volume group
              </p><pre class="screen">
<span class="command"><strong># vgdisplay</strong></span>
<code class="computeroutput">--- Volume Group ---
VG Name	              my_volume_group
VG Access             read/write
VG Status             available/resizable
VG #                  1
MAX LV                256
Cur LV                0
Open LV               0
MAX LV Size           255.99 GB
Max PV                256
Cur PV                3
Act PV                3
VG Size               1.45 GB
PE Size               4 MB
Total PE              372
Alloc PE / Size       0 / 0
Free  PE / Size       372/ 1.45 GB
VG UUID               nP2PY5-5TOS-hLx0-FDu0-2a6N-f37x-0BME0Y</code>
              </pre><p>
              The most important things to verify are that the first
              three items are correct and that the VG Size item is the
              proper size for the amount of space in all four of your
              disks.
            </p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1128"></a>2.3. Creating the Logical Volume</h3></div></div></div><p>
          If the volume group looks correct, it is time to create a
          logical volume on top of the volume group.
        </p><p>
          You can make the logical volume any size you like (up to the
          size of the VG you are creating it on; it is similar to a
          partition on a non LVM setup).  For this example we will create
          just a single logical volume of size 1GB on the volume group.
          The logical volume will be a striped set using for the 4k stripe
          size.  This should increase the performance of the logical
          volume.
          </p><pre class="screen">
<span class="command"><strong># lvcreate -i3 -I4 -L1G -nmy_logical_volume my_volume_group</strong></span>
<code class="computeroutput">lvcreate -- rounding 1048576 KB to stripe boundary size 1056768 KB / 258 PE
lvcreate -- doing automatic backup of "my_volume_group"
lvcreate -- logical volume "/dev/my_volume_group/my_logical_volume" successfully created</code>
          </pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            If you create the logical volume with a '-i2' you will only
            use two of the disks in your volume group.  This is useful if
            you want to create two logical volumes out of the same
            physical volume, but we will not touch that in this recipe.
          </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1138"></a>2.4. Create the File System</h3></div></div></div><p>
          Create an ext2 file system on the logical volume
          </p><pre class="screen">
<span class="command"><strong># mke2fs /dev/my_volume_group/my_logical_volume</strong></span>
<code class="computeroutput">mke2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
132192 inodes, 264192 blocks
13209 blocks (5.00%) reserved for the super user
First data block=0
9 block groups
32768 blocks per group, 32768 fragments per group
14688 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376

Writing inode tables: done
Writing superblocks and filesystem accounting information: done</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1144"></a>2.5. Test the File System</h3></div></div></div><p>
          Mount the file system on the logical volume
          </p><pre class="screen">
<span class="command"><strong># mount /dev/my_volume_group/my_logical_volume /mnt</strong></span>
               </pre><p>
               and check to make sure everything looks correct
               </p><pre class="screen">
<span class="command"><strong># df</strong></span>
<code class="computeroutput">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/hda1              1311552    628824    616104  51% /
/dev/my_volume_group/my_logical_volume
                       1040132        20    987276   0% /mnt</code>
          </pre><p>
          If everything worked properly, you should now have a logical
          volume mounted at <code class="filename">/mnt</code>.  
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recipeadddisk"></a>3. Add a new disk to a multi-disk SCSI system</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1155"></a>3.1. Current situation</h3></div></div></div><p>
          A data centre machine has 6 disks attached as follows:
          </p><pre class="screen">
<span class="command"><strong># pvscan</strong></span>
<code class="computeroutput">pvscan -- ACTIVE   PV "/dev/sda"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdb"  of VG "sales" [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdc"  of VG "ops"   [1.95 GB / 44 MB free]
pvscan -- ACTIVE   PV "/dev/sdd"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sde1" of VG "ops"   [996 MB / 52 MB free]
pvscan -- ACTIVE   PV "/dev/sde2" of VG "sales" [996 MB / 944 MB free]
pvscan -- ACTIVE   PV "/dev/sdf1" of VG "ops"   [996 MB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdf2" of VG "dev"   [996 MB / 72 MB free]
pvscan -- total: 8 [11.72 GB] / in use: 8 [11.72 GB] / in no VG: 0 [0]</code>

<span class="command"><strong># df</strong></span>
<code class="computeroutput">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/dev/cvs           1342492    516468    757828  41% /mnt/dev/cvs
/dev/dev/users         2064208   2060036      4172 100% /mnt/dev/users
/dev/dev/build         1548144   1023041    525103  66% /mnt/dev/build
/dev/ops/databases     2890692   2302417    588275  79% /mnt/ops/databases
/dev/sales/users       2064208    871214   1192994  42% /mnt/sales/users
/dev/ops/batch         1032088    897122    134966  86% /mnt/ops/batch</code>
          </pre><p>
          As you can see the "dev" and "ops" groups are getting full so
          a new disk is purchased and added to the system. It becomes
          <code class="filename">/dev/sdg</code>.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1164"></a>3.2. Prepare the disk partitions</h3></div></div></div><p>
          The new disk is to be shared equally between ops and dev so
          it is partitioned into two physical volumes /dev/sdg1 and
          /dev/sdg2 :
          </p><pre class="screen">
<span class="command"><strong># fdisk /dev/sdg</strong></span>
<code class="computeroutput">
Device contains neither a valid DOS partition table, nor Sun or SGI
disklabel Building a new DOS disklabel. Changes will remain in memory
only, until you decide to write them. After that, of course, the
previous content won't be recoverable.</code>

<code class="prompt">Command (m for help): </code>n
<code class="computeroutput">Command action
   e   extended
   p   primary partition (1-4)</code>
p
<code class="prompt">Partition number (1-4): </code>1
<code class="prompt">First cylinder (1-1000, default 1):</code>
<code class="computeroutput">Using default value 1</code>
<code class="prompt">Last cylinder or +size or +sizeM or +sizeK (1-1000, default 1000): </code>500

<code class="prompt">Command (m for help): </code>n
<code class="computeroutput">Command action
   e   extended
   p   primary partition (1-4)</code>
p
<code class="prompt">Partition number (1-4): </code>2
<code class="prompt">First cylinder (501-1000, default 501):</code> 
<code class="computeroutput">Using default value 501</code>
<code class="prompt">Last cylinder or +size or +sizeM or +sizeK (501-1000, default 1000):</code> 
<code class="computeroutput">Using default value 1000</code>

<code class="prompt">Command (m for help): </code>t
<code class="prompt">Partition number (1-4): </code>1
<code class="prompt">Hex code (type L to list codes): </code>8e
<code class="computeroutput">Changed system type of partition 1 to 8e (Unknown)</code>

<code class="prompt">Command (m for help): </code>t
<code class="prompt">Partition number (1-4): </code>2
<code class="prompt">Hex code (type L to list codes): </code>8e
<code class="computeroutput">Changed system type of partition 2 to 8e (Unknown)</code>

<code class="prompt">Command (m for help): </code>w
<code class="computeroutput">The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: If you have created or modified any DOS 6.x partitions,
please see the fdisk manual page for additional information.
</code>
          </pre><p>
        </p><p>
          Next physical volumes are created on this partition:
          </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/sdg1</strong></span>
<code class="computeroutput">pvcreate -- physical volume "/dev/sdg1" successfully created</code>

<span class="command"><strong># pvcreate /dev/sdg2</strong></span>
<code class="computeroutput">pvcreate -- physical volume "/dev/sdg2" successfully created</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1199"></a>3.3. Add the new disks to the volume groups</h3></div></div></div><p>
          The volumes are then added to the dev and ops volume groups:
          </p><pre class="screen">
<span class="command"><strong># vgextend ops /dev/sdg1</strong></span>
<code class="computeroutput">vgextend -- INFO: maximum logical volume size is 255.99 Gigabyte
vgextend -- doing automatic backup of volume group "ops"
vgextend -- volume group "ops" successfully extended</code>

<span class="command"><strong># vgextend dev /dev/sdg2</strong></span>
<code class="computeroutput">vgextend -- INFO: maximum logical volume size is 255.99 Gigabyte
vgextend -- doing automatic backup of volume group "dev"
vgextend -- volume group "dev" successfully extended</code>

<span class="command"><strong># pvscan</strong></span>
<code class="computeroutput">pvscan -- reading all physical volumes (this may take a while...)
pvscan -- ACTIVE   PV "/dev/sda"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdb"  of VG "sales" [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdc"  of VG "ops"   [1.95 GB / 44 MB free]
pvscan -- ACTIVE   PV "/dev/sdd"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sde1" of VG "ops"   [996 MB / 52 MB free]
pvscan -- ACTIVE   PV "/dev/sde2" of VG "sales" [996 MB / 944 MB free]
pvscan -- ACTIVE   PV "/dev/sdf1" of VG "ops"   [996 MB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdf2" of VG "dev"   [996 MB / 72 MB free]
pvscan -- ACTIVE   PV "/dev/sdg1" of VG "ops"   [996 MB / 996 MB free]
pvscan -- ACTIVE   PV "/dev/sdg2" of VG "dev"   [996 MB / 996 MB free]
pvscan -- total: 10 [13.67 GB] / in use: 10 [13.67 GB] / in no VG: 0 [0]</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1209"></a>3.4. Extend the file systems</h3></div></div></div><p>
          The next thing to do is to extend the file systems so that the
          users can make use of the extra space.
        </p><p>
          There are tools to allow online-resizing of ext2 file systems
          but here we take the safe route and unmount the two file systems
          before resizing them:
          </p><pre class="screen">
<span class="command"><strong># umount /mnt/ops/batch
# umount /mnt/dev/users</strong></span>
          </pre><p>
        </p><p>
          We then use the e2fsadm command to resize the logical volume and
          the ext2 file system on one operation. We are using ext2resize
          instead of resize2fs (which is the default command for e2fsadm)
          so we define the environment variable E2FSADM_RESIZE_CMD to tell
          e2fsadm to use that command.
          </p><pre class="screen">
<span class="command"><strong># export E2FSADM_RESIZE_CMD=ext2resize
# e2fsadm /dev/ops/batch -L+500M</strong></span>
<code class="computeroutput">e2fsck 1.18, 11-Nov-1999 for EXT2 FS 0.5b, 95/08/09
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/ops/batch: 11/131072 files (0.0&lt;!--  non-contiguous), 4127/262144 blocks
lvextend -- extending logical volume "/dev/ops/batch" to 1.49 GB
lvextend -- doing automatic backup of volume group "ops"
lvextend -- logical volume "/dev/ops/batch" successfully extended

ext2resize v1.1.15 - 2000/08/08 for EXT2FS 0.5b
e2fsadm -- ext2fs in logical volume "/dev/ops/batch" successfully extended to 1.49 GB</code>


<span class="command"><strong># e2fsadm /dev/dev/users -L+900M</strong></span>
<code class="computeroutput">e2fsck 1.18, 11-Nov-1999 for EXT2 FS 0.5b, 95/08/09
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/dev/users: 12/262144 files (0.0% non-contiguous), 275245/524288 blocks
lvextend -- extending logical volume "/dev/dev/users" to 2.88 GB
lvextend -- doing automatic backup of volume group "dev"
lvextend -- logical volume "/dev/dev/users" successfully extended

ext2resize v1.1.15 - 2000/08/08 for EXT2FS 0.5b
e2fsadm -- ext2fs in logical volume "/dev/dev/users" successfully extended to 2.88 GB</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1221"></a>3.5. Remount the extended volumes</h3></div></div></div><p>
          We can now remount the file systems and see that the is plenty
          of space.
          </p><pre class="screen">
<span class="command"><strong># mount /dev/ops/batch
# mount /dev/dev/users
# df</strong></span>
<code class="computeroutput">Filesystem           1k-blocks      Used Available Use% Mounted on
/dev/dev/cvs           1342492    516468    757828  41% /mnt/dev/cvs
/dev/dev/users         2969360   2060036    909324  69% /mnt/dev/users
/dev/dev/build         1548144   1023041    525103  66% /mnt/dev/build
/dev/ops/databases     2890692   2302417    588275  79% /mnt/ops/databases
/dev/sales/users       2064208    871214   1192994  42% /mnt/sales/users
/dev/ops/batch         1535856    897122    638734  58% /mnt/ops/batch</code>
          </pre><p>
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Snapshots_Backup"></a>4. Taking a Backup Using Snapshots</h2></div></div></div><p>
        Following on from the previous example we now want to use the extra
        space in the "ops" volume group to make a database backup every
        evening. To ensure that the data that goes onto the tape is
        consistent we use an LVM snapshot logical volume.
      </p><p>
        A snapshot volume is a special type of volume that presents
        all the data that was in the volume at the time the snapshot
        was created.  For a more detailed description, see       
        <a class="xref" href="#snapshotintro" title="8. Snapshots">Section 8, &#8220;Snapshots&#8221;</a>, Snapshots.
        This means we
        can back up that volume without having to worry about data
        being changed while the backup is going on, and we don't have
        to take the database volume offline while the backup is taking
        place.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          In LVM1, this type of volume was read-only, but
          LVM2 creates read/write snapshots by default.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="snapbackcreate"></a>4.1. Create the snapshot volume</h3></div></div></div><p>
          There is a little over 500 Megabytes of free space in the "ops"
          volume group, so we will use all of it to allocate space for the
          snapshot logical volume.  A snapshot volume can be as large or a
          small as you like but it must be large enough to hold all the
          changes that are likely to happen to the original volume during
          the lifetime of the snapshot. So here, allowing 500 megabytes of
          changes to the database volume which should be plenty.
          </p><pre class="screen">
<span class="command"><strong># lvcreate -L592M -s -n dbbackup /dev/ops/databases </strong></span>
<code class="computeroutput">lvcreate -- WARNING: the snapshot must be disabled if it gets full
lvcreate -- INFO: using default snapshot chunk size of 64 KB for "/dev/ops/dbbackup"
lvcreate -- doing automatic backup of "ops"
lvcreate -- logical volume "/dev/ops/dbbackup" successfully created</code>

          </pre><p>
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Full snapshot are automatically disabled</h3><p>
            If the snapshot logical volume becomes full it will be dropped
            (become unusable) so it is vitally important to allocate enough space.
            The amount of space necessary is dependent on the usage of the
            snapshot, so there is no set recipe to follow for this. If the
            snapshot size equals the origin size, it will never overflow.
          </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1243"></a>4.2. Mount the snapshot volume</h3></div></div></div><p>
          We can now create a mount-point and mount the volume
          </p><pre class="screen">
<span class="command"><strong># mkdir /mnt/ops/dbbackup
# mount /dev/ops/dbbackup /mnt/ops/dbbackup</strong></span>
<code class="computeroutput">mount: block device /dev/ops/dbbackup is write-protected, mounting read-only</code>
          </pre><p>
        </p><p>
          If you are using XFS as the filesystem you will need to add the
          <code class="option">nouuid</code> option
          to the mount command:
          </p><pre class="screen">
<span class="command"><strong># mount /dev/ops/dbbackup /mnt/ops/dbbackup -onouuid,ro</strong></span>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1253"></a>4.3. Do the backup</h3></div></div></div><p>
          I assume you will have a more sophisticated backup strategy than
          this!
          </p><pre class="screen">
<span class="command"><strong># tar -cf /dev/rmt0 /mnt/ops/dbbackup</strong></span>
<code class="computeroutput">tar: Removing leading `/' from member names</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1259"></a>4.4. Remove the snapshot</h3></div></div></div><p>
          When the backup has finished you can now unmount the volume and
          remove it from the system. You should remove snapshot volume
          when you have finished with them because they take a copy of all
          data written to the original volume and this can hurt
          performance.
          </p><pre class="screen">
<span class="command"><strong># umount /mnt/ops/dbbackup
# lvremove /dev/ops/dbbackup </strong></span>
<code class="prompt">lvremove -- do you really want to remove "/dev/ops/dbbackup"? [y/n]: </code>y
<code class="computeroutput">lvremove -- doing automatic backup of volume group "ops"
              lvremove -- logical volume "/dev/ops/dbbackup" successfully removed</code>
          </pre><p>
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RemoveADisk"></a>5. Removing an Old Disk</h2></div></div></div><p>
        Say you have an old IDE drive on /dev/hdb.  You want to remove that
        old disk but a lot of files are on it.
      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Backup Your System</h3><p>
          You should always backup your system before attempting a pvmove
          operation.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1272"></a>5.1. Distributing Old Extents to Existing Disks in Volume Group</h3></div></div></div><p>
          If you have enough free extents on the other disks in the volume
          group, you have it easy.  Simply run
          </p><pre class="screen">
<span class="command"><strong># pvmove /dev/hdb</strong></span>
<code class="computeroutput">pvmove -- moving physical extents in active volume group "dev"
pvmove -- WARNING: moving of active logical volumes may cause data loss!</code>
<code class="prompt">pvmove -- do you want to continue? [y/n]</code> y
<code class="computeroutput">pvmove -- 249 extents of physical volume "/dev/hdb" successfully moved</code>
          </pre><p>
          This will move the allocated physical extents from /dev/hdb onto
          the rest of the disks in the volume group.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><span class="command"><strong>pvmove</strong></span> is Slow</h3><p>
            Be aware that pvmove is quite slow as it has to copy the
            contents of a disk block by block to one or more disks.  If you
            want more steady status reports from pvmove, use the
            <code class="option">-v</code> flag.
          </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1285"></a>5.1.1. Remove the unused disk</h4></div></div></div><p>
            We can now remove the old IDE disk from the volume group.
            </p><pre class="screen">
<span class="command"><strong># vgreduce dev /dev/hdb</strong></span>
<code class="computeroutput">vgreduce -- doing automatic backup of volume group "dev"
vgreduce -- volume group "dev" successfully reduced by physical volume:
vgreduce -- /dev/hdb</code>
            </pre><p>
            The drive can now be either physically removed when the
            machine is next powered down or reallocated to other users.
          </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1291"></a>5.2. Distributing Old Extents to a New Replacement Disk</h3></div></div></div><p>
          If you do not have enough free physical extents to distribute
          the old physical extents to, you will have to add a disk to the 
          volume group and move the extents to it.
        </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1294"></a>5.2.1. Prepare the disk</h4></div></div></div><p>
            First, you need to pvcreate the new disk to make it available
            to LVM.  In this recipe we show that you don't need to
            partition a disk to be able to use it.
            </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/sdf</strong></span>
<code class="computeroutput">pvcreate -- physical volume "/dev/sdf" successfully created</code>
            </pre><p>
          </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1300"></a>5.2.2. Add it to the volume group</h4></div></div></div><p>
            As developers use a lot of disk space this is a good volume
            group to add it into.
            </p><pre class="screen">
<span class="command"><strong># vgextend dev /dev/sdf</strong></span>
<code class="computeroutput">vgextend -- INFO: maximum logical volume size is 255.99 Gigabyte
vgextend -- doing automatic backup of volume group "dev"
vgextend -- volume group "dev" successfully extended</code>
            </pre><p>
          </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1306"></a>5.2.3. Move the data</h4></div></div></div><p>
            Next we move the data from the old disk onto the new one.
            Note that it is not necessary to unmount the file system
            before doing this.  Although it is *highly* recommended that
            you do a full backup before attempting this operation in case
            of a power outage or some other problem that may interrupt
            it. The pvmove command can take a considerable amount of time
            to complete and it also exacts a performance hit on the two
            volumes so, although it isn't necessary, it is advisable to
            do this when the volumes are not too busy.
            </p><pre class="screen">
<span class="command"><strong># pvmove /dev/hdb /dev/sdf</strong></span>
<code class="computeroutput">pvmove -- moving physical extents in active volume group "dev"
pvmove -- WARNING: moving of active logical volumes may cause data loss!</code>
<code class="prompt">pvmove -- do you want to continue? [y/n]</code> y
<code class="computeroutput">pvmove -- 249 extents of physical volume "/dev/hdb" successfully moved</code>
            </pre><p>
          </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1314"></a>5.2.4. Remove the unused disk</h4></div></div></div><p>
            We can now remove the old IDE disk from the volume group.
            </p><pre class="screen">
<span class="command"><strong># vgreduce dev /dev/hdb</strong></span>
<code class="computeroutput">vgreduce -- doing automatic backup of volume group "dev"
vgreduce -- volume group "dev" successfully reduced by physical volume:
vgreduce -- /dev/hdb</code>
            </pre><p>
            The drive can now be either physically removed when the
            machine is next powered down or reallocated to some other
            users.
          </p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recipemovevgtonewsys"></a>6. Moving a volume group to another system</h2></div></div></div><p>
        It is quite easy to move a whole volume group to another system if,
        for example, a user department acquires a new server. To do this we
        use the vgexport and vgimport commands.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          vgexport/vgimport is not necessary to move drives
          from one system to another.  It is an administrative policy
          tool to prevent access to volumes in the time it takes to
          move them.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1325"></a>6.1. Unmount the file system</h3></div></div></div><p>
          First, make sure that no users are accessing files on the active
          volume, then unmount it
          </p><pre class="screen">
<span class="command"><strong># unmount /mnt/design/users</strong></span>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1330"></a>6.2. Mark the volume group inactive</h3></div></div></div><p>
          Marking the volume group inactive removes it from the kernel and
          prevents any further activity on it.
          </p><pre class="screen">
<span class="command"><strong># vgchange -an design</strong></span>
<code class="computeroutput">vgchange -- volume group "design" successfully deactivated</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1336"></a>6.3. Export the volume group</h3></div></div></div><p>
          It is now necessary to export the volume group. This prevents it
          from being accessed on the ``old'' host system and prepares it
          to be removed.
          </p><pre class="screen">
<span class="command"><strong># vgexport design</strong></span>
<code class="computeroutput">vgexport -- volume group "design" successfully exported</code>
          </pre><p>
          When the machine is next shut down, the disk can be unplugged
          and then connected to it's new machine
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1342"></a>6.4. Import the volume group</h3></div></div></div><p>
          When plugged into the new system it becomes /dev/sdb so an
          initial pvscan shows:
          </p><pre class="screen">
<span class="command"><strong># pvscan</strong></span>
<code class="computeroutput">pvscan -- reading all physical volumes (this may take a while...)
pvscan -- inactive PV "/dev/sdb1"  is in EXPORTED VG "design" [996 MB / 996 MB free]
pvscan -- inactive PV "/dev/sdb2"  is in EXPORTED VG "design" [996 MB / 244 MB free]
pvscan -- total: 2 [1.95 GB] / in use: 2 [1.95 GB] / in no VG: 0 [0]</code>
          </pre><p>
          We can now import the volume group (which also activates it) and
          mount the file system.
        </p><p>
          If you are importing on an LVM 2 system, run:
          </p><pre class="screen">
<span class="command"><strong># vgimport design</strong></span>
<code class="computeroutput">  Volume group "vg" successfully imported</code>
          </pre><p>
        </p><p>
          If you are importing on an LVM 1 system, add the PVs that need to be imported:
          </p><pre class="screen">
<span class="command"><strong># vgimport design /dev/sdb1 /dev/sdb2</strong></span>
<code class="computeroutput">vgimport -- doing automatic backup of volume group "design"
vgimport -- volume group "design" successfully imported and activated</code>
          </pre><p>

        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1356"></a>6.5. Activate the volume group</h3></div></div></div><p>
          You must activate the volume group before you can access it.
          </p><pre class="screen">
<span class="command"><strong># vgchange -ay design</strong></span>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1361"></a>6.6. Mount the file system</h3></div></div></div><p>
          </p><pre class="screen">
<span class="command"><strong># mkdir -p /mnt/design/users
# mount /dev/design/users /mnt/design/users</strong></span>
          </pre><p>
          The file system is now available for use.
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recipesplitvg"></a>7. Splitting a volume group</h2></div></div></div><p>
        There is a new group of users "design" to add to the system. One
        way of dealing with this is to create a new volume group to hold
        their data.  There are no new disks but there is plenty of free
        space on the existing disks that can be reallocated.
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1369"></a>7.1. Determine free space</h3></div></div></div><p>
          </p><pre class="screen">
<span class="command"><strong># pvscan </strong></span>
<code class="computeroutput">pvscan -- reading all physical volumes (this may take a while...)
pvscan -- ACTIVE   PV "/dev/sda"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sdb"  of VG "sales" [1.95 GB / 1.27 GB free]
pvscan -- ACTIVE   PV "/dev/sdc"  of VG "ops"   [1.95 GB / 564 MB free]
pvscan -- ACTIVE   PV "/dev/sdd"  of VG "dev"   [1.95 GB / 0 free]
pvscan -- ACTIVE   PV "/dev/sde"  of VG "ops"   [1.95 GB / 1.9 GB free]
pvscan -- ACTIVE   PV "/dev/sdf"  of VG "dev"   [1.95 GB / 1.33 GB free]
pvscan -- ACTIVE   PV "/dev/sdg1" of VG "ops"   [996 MB / 432 MB free]
pvscan -- ACTIVE   PV "/dev/sdg2" of VG "dev"   [996 MB / 632 MB free]
pvscan -- total: 8 [13.67 GB] / in use: 8 [13.67 GB] / in no VG: 0 [0]</code>
          </pre><p>
          We decide to reallocate /dev/sdg1 and /dev/sdg2 to design so
          first we have to move the physical extents into the free areas
          of the other volumes (in this case /dev/sdf for volume group dev
          and /dev/sde for volume group ops).
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1375"></a>7.2. Move data off the disks to be used</h3></div></div></div><p>
          Some space is still used on the chosen volumes so it is
          necessary to move that used space off onto some others.
        </p><p>
          Move all the used physical extents from /dev/sdg1 to /dev/sde
          and from /dev/sdg2 to /dev/sdf
          </p><pre class="screen">
<span class="command"><strong># pvmove /dev/sdg1 /dev/sde</strong></span>
<code class="computeroutput">pvmove -- moving physical extents in active volume group "ops"
pvmove -- WARNING: moving of active logical volumes may cause data loss!</code>
<code class="prompt">pvmove -- do you want to continue? [y/n]</code> y
<code class="computeroutput">pvmove -- doing automatic backup of volume group "ops"
pvmove -- 141 extents of physical volume "/dev/sdg1" successfully moved</code>

<span class="command"><strong># pvmove /dev/sdg2 /dev/sdf</strong></span>
<code class="computeroutput">pvmove -- moving physical extents in active volume group "dev"
pvmove -- WARNING: moving of active logical volumes may cause data loss!</code>
<code class="prompt">pvmove -- do you want to continue? [y/n]</code> y
<code class="computeroutput">pvmove -- doing automatic backup of volume group "dev"
pvmove -- 91 extents of physical volume "/dev/sdg2" successfully moved</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1388"></a>7.3. Create the new volume group</h3></div></div></div><p>
          Now, split /dev/sdg2 from dev and add it into a new group called
          "design". it is possible to do this using vgreduce and vgcreate
          but the vgsplit command combines the two.
          </p><pre class="screen">
<span class="command"><strong># vgsplit dev design /dev/sdg2</strong></span>
<code class="computeroutput">vgsplit -- doing automatic backup of volume group "dev"
vgsplit -- doing automatic backup of volume group "design"
vgsplit -- volume group "dev" successfully split into "dev" and "design"</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1394"></a>7.4. Remove remaining volume</h3></div></div></div><p>
          Next, remove /dev/sdg1 from ops and add it into design.
          </p><pre class="screen">
<span class="command"><strong># vgreduce ops /dev/sdg1</strong></span>
<code class="computeroutput">vgreduce -- doing automatic backup of volume group "ops"
vgreduce -- volume group "ops" successfully reduced by physical volume:
vgreduce -- /dev/sdg1</code>

<span class="command"><strong># vgextend design /dev/sdg1</strong></span>
<code class="computeroutput">vgextend -- INFO: maximum logical volume size is 255.99 Gigabyte
vgextend -- doing automatic backup of volume group "design"
vgextend -- volume group "design" successfully extended</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1402"></a>7.5. Create new logical volume</h3></div></div></div><p>
          Now create a logical volume. Rather than allocate all of the
          available space, leave some spare in case it is needed
          elsewhere.
          </p><pre class="screen">
<span class="command"><strong># lvcreate -L750M -n users design</strong></span>
<code class="computeroutput">lvcreate -- rounding up size to physical extent boundary "752 MB"
lvcreate -- doing automatic backup of "design"
lvcreate -- logical volume "/dev/design/users" successfully created</code>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1408"></a>7.6. Make a file system on the volume</h3></div></div></div><pre class="screen">
<span class="command"><strong># mke2fs /dev/design/users</strong></span>
<code class="computeroutput">mke2fs 1.18, 11-Nov-1999 for EXT2 FS 0.5b, 95/08/09
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
96384 inodes, 192512 blocks
9625 blocks (5.00&lt;!-- ) reserved for the super user
First data block=0
6 block groups
32768 blocks per group, 32768 fragments per group
16064 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840

Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done</code>
        </pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1413"></a>7.7. Mount the new volume</h3></div></div></div><pre class="screen">
<span class="command"><strong># mkdir -p /mnt/design/users mount /dev/design/users /mnt/design/users/</strong></span>
        </pre><p> 
          It's also a good idea to add an entry for this file system in
          your /etc/fstab file as follows:
          </p><pre class="screen">
/dev/design/user
/mnt/design/users   ext2    defaults        1 2
          </pre><p>
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="UpgradeRootToLVM"></a>8. Converting a root filesystem to
        LVM 1</h2></div></div></div><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Backup Your System</h3><p>
          It is strongly recommended that you take a full backup of your
          system before attempting to convert to root on LVM 1.
        </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Upgrade Complications</h3><p>
          Having your root filesystem on LVM 1 can significantly complicate
          upgrade procedures (depending on your distribution) so it should
          not be attempted lightly.  Particularly, you must consider how
          you will insure that the LVM 1 kernel module (if you do not have
          LVM 1 compiled into the kernel) as well as the vgscan/vgchange
          tools are available before, during, and after the upgrade.
        </p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Recovery Complications</h3><p>
          Having your root filesystem on LVM 1 can significantly complicate
          recovery of damaged filesystems.  If you lose your initrd, it
          will be very difficult to boot your system.  You will need to
          have a recover disk that contains the kernel, LVM 1 module, and
          LVM 1 tools, as well as any tools necessary to recover a
          damaged filesystem.
          Be sure to make regular backups and have an up-to-date
          alternative boot method that allows for recovery of LVM 1. 
          
        </p></div><p>
        In this example the whole system was installed in a single root
        partition with the exception of /boot. The system had a 2 gig disk
        partitioned as:
        </p><pre class="screen">
/dev/hda1  /boot 
/dev/hda2  swap
/dev/hda3  /
        </pre><p>
      </p><p>
        The / partition covered all of the disk not used by /boot and swap.
        An important prerequisite of this procedure is that the root
        partition is less that half full (so that a copy of it can be
        created in a logical volume).  If this is not the case then a
        second disk drive should be used. The procedure in that case is
        similar but there is no need to shrink the existing root partition
        and /dev/hda4 should be replaced with (eg) /dev/hdb1 in the
        examples.
      </p><p>
        To do this it is easiest to use GNU parted. This software allows
        you to grow and shrink partitions that contain filesystems. It is
        possible to use resize2fs and fdisk to do this but GNU parted makes
        it much less prone to error.  It may be included in your
        distribution, if not you can download it from
        <a class="ulink" href="ftp://ftp.gnu.org/pub/gnu/parted" target="_top">ftp://ftp.gnu.org/pub/gnu/parted</a>.
      </p><p>
        Once you have parted on your system AND YOU HAVE BACKED THE SYSTEM
        UP:
      </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1436"></a>8.1. Boot single user</h3></div></div></div><p>
          Boot into single user mode (type <span class="command"><strong>linux S</strong></span> at
          the LILO prompt) This is important. Booting single-user ensures
          that the root filesystem is mounted read-only and no programs
          are accessing the disk.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1440"></a>8.2. Run Parted</h3></div></div></div><p>
          Run parted to shrink the root partition Do this so there is room
          on the disk for a complete copy of it in a logical volume. In
          this example a 1.8 gig partition is shrunk to 1 gigabyte
          This displays the sizes and names of the partitions on the disk
          </p><pre class="screen">
<span class="command"><strong># parted /dev/hda</strong></span>
<code class="prompt">(parted)</code> p
.
.
.
          </pre><p>
        </p><p>
          Now resize the partition:
          </p><pre class="screen">
<code class="prompt">(parted)</code> resize 3 145 999
          </pre><p>
          The first number here the partition number (hda3), the second is
          the same starting position that hda3 currently has. Do not
          change this.  The last number should make the partition around
          half the size it currently is.
        </p><p>
          Create a new partition
          </p><pre class="screen">
<code class="prompt">(parted)</code> mkpart primary ext2 1000 1999
          </pre><p>
          This makes a new partition to hold the initial LVM 1 data. It
          should start just beyond the newly shrunk hda3 and finish at the
          end of the disk.
        </p><p>
          Quit parted
          </p><pre class="screen">
<code class="prompt">(parted)</code> q
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1455"></a>8.3. Reboot</h3></div></div></div><p>
          Reboot the system
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1458"></a>8.4. Verify kernel config options</h3></div></div></div><p>
          Make sure that the kernel you are currently running works with
          LVM 1 and has CONFIG_BLK_DEV_RAM and CONFIG_BLK_DEV_INITRD set in
          the config file.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1461"></a>8.5. Adjust partition type</h3></div></div></div><p>
          Change the partition type on the newly created partition from
          Linux to LVM (8e).  Parted doesn't understand LVM 1 partitions so
          this has to be done using fdisk.
          </p><pre class="screen">
<span class="command"><strong># fdisk /dev/hda</strong></span>
<code class="prompt">Command (m for help): </code>t
<code class="prompt">Partition number (1-4): </code>4
<code class="prompt">Hex code (type L to list codes): </code>8e
<code class="computeroutput">Changed system type of partition 4 to 8e (Unknown)</code>
<code class="prompt">Command (m for help): </code>w
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1471"></a>8.6. Set up LVM 1 for the new scheme</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              Initialize LVM 1 (vgscan)
              </p><pre class="screen">
<span class="command"><strong># vgscan</strong></span>
              </pre><p>
            </p></li><li class="listitem"><p>
              Make the new partition into a PV
              </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/hda4</strong></span>
              </pre><p>
            </p></li><li class="listitem"><p>
              create a new volume group
              </p><pre class="screen">
<span class="command"><strong># vgcreate vg /dev/hda4</strong></span>
              </pre><p>
            </p></li><li class="listitem"><p>   
              Create a logical volume to hold the new root.
              </p><pre class="screen">
<span class="command"><strong># lvcreate -L250M -n root vg</strong></span>
              </pre><p>
            </p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1490"></a>8.7. Create the Filesystem</h3></div></div></div><p>
          Make a filesystem in the logical volume and copy the root files
          onto it.
          </p><pre class="screen">
<span class="command"><strong># mke2fs /dev/vg/root
# mount /dev/vg/root /mnt/
# find / -xdev | cpio -pvmd /mnt</strong></span>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1495"></a>8.8. Update /etc/fstab</h3></div></div></div><p>
          Edit /mnt/etc/fstab on the new root so that / is mounted on
          /dev/vg/root. For example:
          </p><pre class="screen">
  /dev/hda3       /    ext2       defaults 1 1
          </pre><p>
          becomes:
          </p><pre class="screen">
  /dev/vg/root    /    ext2       defaults 1 1
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1500"></a>8.9. Create an LVM 1 initial RAM disk</h3></div></div></div><pre class="screen">
<span class="command"><strong># lvmcreate_initrd</strong></span>
        </pre><p>
          Make sure you note the name that lvmcreate_initrd calls the
          initrd image.  It should be in /boot.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1505"></a>8.10. Update /etc/lilo.conf</h3></div></div></div><p>
          Add an entry in /etc/lilo.conf for LVM 1.
          This should look similar to the following:
          </p><pre class="screen">
  image   = /boot/KERNEL_IMAGE_NAME
  label   = lvm
  root    = /dev/vg/root
  initrd  = /boot/INITRD_IMAGE_NAME
  ramdisk = 8192
          </pre><p>
          Where KERNEL_IMAGE_NAME is the name of your LVM 1 enabled kernel,
          and INITRD_IMAGE_NAME is the name of the initrd image created by
          lvmcreate_initrd. The ramdisk line may need to be increased if
          you have a large LVM 1 configuration, but 8192 should suffice for
          most users. The default ramdisk size is 4096. If in doubt check
          the output from the lvmcreate_initrd command, the line that
          says:
          </p><pre class="screen">
lvmcreate_initrd -- making loopback file (6189 kB)
          </pre><p>
          and make the ramdisk the size given in brackets.
        </p><p>
          You should copy this new lilo.conf onto /etc in the new root fs
          as well.
          </p><pre class="screen">
<span class="command"><strong># cp /etc/lilo.conf /mnt/etc/</strong></span>
          </pre><p>
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1513"></a>8.11. Run LILO to write the new boot sector</h3></div></div></div><pre class="screen">
<span class="command"><strong># lilo</strong></span>
        </pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1517"></a>8.12. Reboot to lvm</h3></div></div></div><p> 
          Reboot - at the LILO prompt type "lvm"
          The system should reboot into Linux using the newly created
          Logical Volume.
        </p><p>
          If that worked then you should make lvm the default LILO boot
          destination by adding the line
          </p><pre class="screen">
default=lvm
          </pre><p>
          in the first section of /etc/lilo.conf
        </p><p>
          If it did not work then reboot normally and try to diagnose the
          problem. It could be a typing error in lilo.conf or LVM 1 not
          being available in the initial RAM disk or its kernel. Examine
          the message produced at boot time carefully.
        </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1523"></a>8.13. Add remainder of disk</h3></div></div></div><p>   
          Add the rest of the disk into LVM 1. When you are happy with this
          setup you can then add the old root partition to LVM 1 and spread
          out over the disk.
        </p><p>
          First set the partition type to 8e(LVM)
          </p><pre class="screen">
<span class="command"><strong># fdisk /dev/hda</strong></span>

<code class="prompt">Command (m for help): </code>t
<code class="prompt">Partition number (1-4): </code>3
<code class="prompt">Hex code (type L to list codes): </code>8e
<code class="computeroutput">Changed system type of partition 3 to 8e (Unknown)</code>
<code class="prompt">Command (m for help): </code>w
          </pre><p>
        </p><p>
          Convert it into a PV and add it to the volume group:
          </p><pre class="screen">
<span class="command"><strong># pvcreate /dev/hda3
# vgextend vg /dev/hda3</strong></span>
          </pre><p>
        </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="recovermetadata"></a>9. Recover physical volume metadata</h2></div></div></div><p>
        If you get the warning "incorrect metadata area header checksum"
	or something about not being able to find PV with UUID foo,
	you probably toasted the volume group descriptor area and lvm
	startup can't occur. 
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Only run on non-functional VG</h3><p>
        Don't do this on a properly working lvm.
        You need to specify the correct physical volume to 
	<span class="command"><strong>pvcreate</strong></span> or you may lose your data.
      </p></div><p>
	Extract the exact uuid for the PV that was overwritten from the file 
	<code class="filename">/etc/lvm/archive/VolumeGroupName_XXXXX.vg</code>.
	(Where XXXXX represents the number of the last known good archived lvm
	metadata).
      </p><p>
	 Use <span class="command"><strong>pvcreate</strong></span> to restore the metadata:
	 <span class="command"><strong>pvcreate --uuid "&lt;some_long_string&gt;" --restorefile /etc/lvm/archive/VolumeGroupName_XXXXX.vg &lt;PhysicalVolume&gt;</strong></span>
      </p><p>
	If you are lucky you'll find that the on-disk lvm metadata takes 
	at least so much space as what it was overwritten with. The above
	command has been know to recover a PV overwritten with mkswap.  If
	whatever overwrote the VGDA writes past that area, LVs may be affected.
	In this case, fsck might be able to fix the filesystem on the LV, or
	you may need more drastic measures to pull data off of it.  Contact
	your local friendly filesystem expert for help in that case.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="command"><strong>pvcreate</strong></span> only overwrites the lvm metadata
	areas on disk and doesn't touch the data areas (the logical
        volumes).
        </p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="dangerousops"></a>Appendix A. Dangerous Operations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#uuidfixer">1. Restoring the VG UUIDs using uuid_fixer</a></span></dt><dt><span class="sect1"><a href="#sharinglvm1">2. Sharing LVM volumes</a></span></dt></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
        Don't do this unless you're really sure of what you're doing.
        You'll probably lose all your data.
      </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="uuidfixer"></a>1. Restoring the VG UUIDs using uuid_fixer</h2></div></div></div><p>
        If you've upgraded LVM from previous versions to early 0.9 and
        0.9.1 versions of LVM and <span class="command"><strong>vgscan</strong></span> says 
        <code class="computeroutput">vgscan -- no volume groups found</code>,
        this is one way to fix it.
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Download the UUID fixer program from the contributor
            directory at Sistina.
          </p><p>
            It is located at
            <a class="ulink" href="ftp://ftp.sistina.com/pub/LVM/contrib/uuid_fixer-0.3-IOP10.tar.gz" target="_top">ftp://ftp.sistina.com/pub/LVM/contrib/uuid_fixer-0.3-IOP10.tar.gz"</a>
          </p></li><li class="listitem"><p>
            Extract <code class="filename">uuid_fixer-0.3-IOP10.tar.gz</code>
            </p><pre class="screen">
<span class="command"><strong># tar zxf uuid_fixer-0.3-IOP10.tar.gz</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            cd to uuid_fixer
            </p><pre class="screen">
<span class="command"><strong># cd uuid_fixer</strong></span>
            </pre><p>
          </p><p>
            You have one of two options at this point:
          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Use the prebuild binary (it is build for i386
                architecture).
              </p><p>
                Make sure you list all the PVs in the VG you are
                restoring, and follow the prompts
                </p><pre class="screen">
<span class="command"><strong># ./uuid_fixer </strong></span><em class="replaceable"><code>&lt;LIST OF ALL PVS IN VG TO BE RESTORED&gt;</code></em>
                </pre><p>
              </p></li><li class="listitem"><p>
                Build the uuid_builder program from source
              </p><p>
                Edit the Makefile with your favorite editor, and make
                sure LVMDIR points to your LVM source.
              </p><p>
                Then run make.
                </p><pre class="screen">
<span class="command"><strong># make</strong></span>
                </pre><p>
              </p><p>
                Now run uuid_fixer.  Make sure you list all the PVs in
                the VG you are restoring, and follow the prompts.
                </p><pre class="screen">
<span class="command"><strong># ./uuid_fixer </strong></span><em class="replaceable"><code>&lt;LIST OF ALL PVS IN VG TO BE RESTORED&gt;</code></em>
                </pre><p>
              </p></li></ol></div></li><li class="listitem"><p>
            Deactivate any active Volume Groups
            (<span class="emphasis"><em>optional</em></span>)
            </p><pre class="screen">
<span class="command"><strong># vgchange -an</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            Run vgscan
            </p><pre class="screen">
<span class="command"><strong># vgscan</strong></span>
            </pre><p>
          </p></li><li class="listitem"><p>
            Reactivate Volume Groups
            </p><pre class="screen">
<span class="command"><strong># vgchange -ay</strong></span>
            </pre><p>
          </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sharinglvm1"></a>2. Sharing LVM volumes</h2></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">LVM is not cluster aware</h3><p>
          Be very careful doing this, LVM is not currently cluster-aware
          and it is very easy to lose all your data.
        </p></div><p>  
        If you have a fibre-channel or shared-SCSI environment where more
        than one machine has physical access to a set of disks then you can
        use LVM to divide these disks up into logical volumes. If you want
        to share data you should really be looking at 
        <a class="ulink" href="http://www.sistina.com/gfs" target="_top">GFS</a> or other
        cluster filesystems.
      </p><p>
        The key thing to remember when sharing volumes is that all the LVM
        administration must be done on one node only and that all other
        nodes must have LVM shut down before changing anything on the admin
        node.  Then, when the changes have been made, it is necessary to
        run vgscan on the other nodes before reloading the volume groups.
        Also, unless you are running a cluster-aware filesystem (such as
        GFS) or application on the volume, only one node can mount each
        filesystem.  It is up to you, as system administrator to enforce
        this, LVM will not stop you corrupting your data.
      </p><p>
        The startup sequence of each node is the same as for a single-node
        setup with
        </p><pre class="screen">
vgscan
vgchange -ay
        </pre><p>
        in the startup scripts.
      </p><p>
        If you need to do <span class="strong"><strong>any</strong></span> changes to
        the LVM metadata (regardless of whether it affects volumes mounted
        on other nodes) you must go through the following sequence. In the
        steps below ``admin node'' is any arbitrarily chosen node in the
        cluster.
        </p><pre class="screen">
Admin node                   Other nodes
----------                   -----------
                             Close all Logical volumes (umount)
                             vgchange -an
&lt;make changes, eg lvextend&gt;
                             vgscan
                             vgchange -ay
        </pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">VGs should be active on the admin node</h3><p>
          You do not need to, nor should you, unload the VGs on
          the admin node, so this can be the node with the highest uptime
          requirement.
        </p></div><p>
        I'll say it again:  <span class="strong"><strong>Be very careful doing
          this</strong></span>
      </p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="ReportBug"></a>Appendix B. Reporting Errors and Bugs</h1></div></div></div><p>
      Just telling us that LVM did not work does not provide us with enough
      information to help you.  We need to know about your setup and the
      various components of your configuration.  The first thing you should
      do is check the
      <a class="ulink" href="http://lists.sistina.com/pipermail/linux-lvm/" target="_top">linux-lvm mailing list archives</a>
      to see if someone else has already reported the same bug.  If you do
      not find a bug report for a problem similar to yours you should
      collect as much of the following information as possible.  The list is
      grouped into three categories of errors.
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          For compilation errors:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Detail the specific version of LVM you have.  If you
              extracted LVM from a tarball give the name of the tar file
              and list any patches you applied.  If you acquired LVM
              from the Public CVS server, give the date and time you
              checked it out.
            </p></li><li class="listitem"><p>
              Provide the exact error message. Copy the lines
              of output before the actual error message as well
              as the lines after.  These lines occasionally
              give hints as to why the error occurred.
            </p></li><li class="listitem"><p>
              List the steps, in order, that produced the error.  Is the
              error reproducible?  If you start from a clean state does
              the same sequence of steps reproduce the error?
            </p></li></ol></div></li><li class="listitem"><p>
          For LVM errors:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Include all of the information requested in the
              compilation section.
            </p></li><li class="listitem"><p>
              Attach a short description of your hardware: types of
              machines and disks,  disks interface (SCSI, FC, NBD).  Any
              other tidbits about your hardware you feel is important.
            </p></li><li class="listitem"><p>
              The command lines used with LVM to produce the error.
            </p></li><li class="listitem"><p>
              A log file produced when running the offending commands.
              Make sure you have the following in your
              <code class="filename">/etc/lvm/lvm.conf</code> file:
              </p><pre class="screen">
log {
        file="/tmp/lvm2.log"
        level=7
        activation=1
}
              </pre><p>
            </p></li></ol></div></li><li class="listitem"><p>
          When LVM trips a panic trap:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Include all of the information requested in two sections
              above.
            </p></li><li class="listitem"><p>
              Provide the debug dump for the machine.  This is best
              accomplished if you are watching the console output of the
              computer over a serial link, since you can't very well
              copy and paste from a panic'd machine, and it is very easy
              to mistype something if you try to copy the output by
              hand. 
            </p></li></ol></div></li></ul></div><p>
      This can be a lot of information.  If you end up with more
      than a couple of files, tar and gzip them into a single
      archive.  Submit a link to where this file can be found to
      the appropriate mailing list (see <a class="xref" href="#Maillists" title="1. Mail lists">Section 1, &#8220;Mail lists&#8221;</a>) along with a short description of the
      error.  If you do not have a public web or ftp site that you
      can post the information to, you can try to submit the file
      to the list.
    </p></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="contactsandlinks"></a>Appendix C. Contact and Links</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#Maillists">1. Mail lists</a></span></dt><dt><span class="sect1"><a href="#Links">2. Links</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Maillists"></a>1. Mail lists</h2></div></div></div><p>
        Before you post to any of our lists please read the all of
        this document and check the archives to see if your
        question has already been answered.  Please post in text
        only to our lists, fancy formated messages are near
        impossible to read if someone else is not running a mail
        client that understands it.  Standard mailing list
        etiquette applies.  Incomplete questions or configuration
        data make it very hard for us to answer your questions.
      </p><div class="variablelist"><p class="title"><b>LVM Discussion Mailing Lists</b></p><dl class="variablelist"><dt><span class="term">linux-lvm</span></dt><dd><p>
              This list is aimed at user-related questions and comments.
              You may be able to get the answers you need from other
              people who have the same issues. Open discussion is
              encouraged.  Bug reports should be sent to this list.
            </p><p>
              Subscribe using the <a class="ulink" href="http://www.redhat.com/mailman/listinfo/linux-lvm" target="_top">web
                interface</a>.
            </p><p>
              Look at the <a class="ulink" href="http://www.redhat.com/archives/linux-lvm/" target="_top">
                archives</a>
            </p></dd><dt><span class="term">dm-devel</span></dt><dd><p>
              This list is not specifically for lvm, but since
              device mapper is used by LVM 2, it is mentioned
              here.
            </p><p>
              Subscribe using the <a class="ulink" href="http://www.redhat.com/mailman/listinfo/dm-devel" target="_top">web
                interface</a>.
            </p><p>
              Look at the <a class="ulink" href="http://www.redhat.com/archives/dm-devel/" target="_top">
                archives</a>
            </p></dd></dl></div><div class="variablelist"><p class="title"><b>LVM-Related Commit Lists</b></p><dl class="variablelist"><dt><span class="term">lvm2-commit</span></dt><dd><p>
              This list gets messages automatically whenever
              someone commits to the lvm2 cvs tree. Its main
              purpose is to keep up with the cvs tree.
            </p><p>
              Look at the <a class="ulink" href="http://sources.redhat.com/ml/lvm2-cvs/" target="_top">
                archives</a>
            </p></dd><dt><span class="term">lvm-commit</span></dt><dd><p>
              This list gets messages automatically whenever
              someone commits to the lvm cvs tree. Its main
              purpose is to keep up with the cvs tree.
            </p><p>
              Look at the <a class="ulink" href="http://sources.redhat.com/ml/lvm-cvs/" target="_top">
                archives</a>
            </p></dd><dt><span class="term">dm-commit</span></dt><dd><p>
              This list gets messages automatically whenever
              someone commits to the dm cvs tree. Its main
              purpose is to keep up with the cvs tree.
            </p><p>
              Look at the <a class="ulink" href="http://sources.redhat.com/ml/dm-cvs/" target="_top">
                archives</a>
            </p></dd></dl></div><div class="variablelist"><p class="title"><b>Discontinued Lists</b></p><dl class="variablelist"><dt><span class="term">lvm-devel</span></dt><dd><p>
              This list has been discontinued; please use
              linux-lvm for lvm development discussion.
            </p></dd><dt><span class="term">lvm-bugs</span></dt><dd><p>
              This list has been discontinued; Bug reports should be
              sent to the linux-lvm list.
            </p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Links"></a>2. Links</h2></div></div></div><p>
        LVM Links:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            The <a class="ulink" href="http://sources.redhat.com/lvm2/" target="_top">Logical
              Volume Manager</a> home page.
          </p></li><li class="listitem"><p>
            The <a class="ulink" href="http://sources.redhat.com/lvm/" target="_top">LVM
            1</a> home page.
          </p></li><li class="listitem"><p>
            The <a class="ulink" href="http://sources.redhat.com/dm/" target="_top">Device
              Mapper</a> home page.
          </p></li><li class="listitem"><p> 
            The <a class="ulink" href="ftp://sources.redhat.com/pub/lvm2/" target="_top">LVM
              2 ftp</a> site.
          </p></li><li class="listitem"><p>
            The <a class="ulink" href="ftp://sources.redhat.com/pub/lvm/" target="_top">LVM
              1 ftp</a> site.
          </p></li><li class="listitem"><p>
            The <a class="ulink" href="ftp://sources.redhat.com/pub/dm/" target="_top">Device
              Mapper ftp</a> site.
          </p></li></ul></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="gfdl"></a>Appendix D. GNU Free Documentation License</h1></div><div><h3 class="subtitle"><i>Version 1.2, November 2002</i></h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gfdl-0">1. PREAMBLE</a></span></dt><dt><span class="section"><a href="#gfdl-1">2. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="section"><a href="#gfdl-2">3. VERBATIM COPYING</a></span></dt><dt><span class="section"><a href="#gfdl-3">4. COPYING IN QUANTITY</a></span></dt><dt><span class="section"><a href="#gfdl-4">5. MODIFICATIONS</a></span></dt><dt><span class="section"><a href="#gfdl-5">6. COMBINING DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-6">7. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-7">8. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="section"><a href="#gfdl-8">9. TRANSLATION</a></span></dt><dt><span class="section"><a href="#gfdl-9">10. TERMINATION</a></span></dt><dt><span class="section"><a href="#gfdl-10">11. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="section"><a href="#gfdl-addendum">12. ADDENDUM: How to use this License for
        your documents</a></span></dt></dl></div><div class="blockquote"><a name="fsf-copyright"></a><blockquote class="blockquote"><p>Copyright (C) 2000,2001,2002 Free Software Foundation,
        Inc.  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
        Everyone is permitted to copy and distribute verbatim copies
        of this license document, but changing it is not
        allowed.</p></blockquote></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-0"></a>1. PREAMBLE</h2></div></div></div><p>The purpose of this License is to make a manual, textbook,
        or other functional and useful document "free" in the sense of
        freedom: to assure everyone the effective freedom to copy and
        redistribute it, with or without modifying it, either
        commercially or noncommercially.  Secondarily, this License
        preserves for the author and publisher a way to get credit for
        their work, while not being considered responsible for
        modifications made by others.</p><p>This License is a kind of "copyleft", which means that
        derivative works of the document must themselves be free in
        the same sense.  It complements the GNU General Public
        License, which is a copyleft license designed for free
        software.</p><p>We have designed this License in order to use it for
        manuals for free software, because free software needs free
        documentation: a free program should come with manuals
        providing the same freedoms that the software does.  But this
        License is not limited to software manuals; it can be used for
        any textual work, regardless of subject matter or whether it
        is published as a printed book.  We recommend this License
        principally for works whose purpose is instruction or
        reference.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-1"></a>2. APPLICABILITY AND DEFINITIONS</h2></div></div></div><p><a name="gfdl-doc"></a>This License applies to any manual or other
        work, in any medium, that contains a notice placed by the
        copyright holder saying it can be distributed under the terms
        of this License.  Such a notice grants a world-wide,
        royalty-free license, unlimited in duration, to use that work
        under the conditions stated herein.  The "Document", below,
        refers to any such manual or work.  Any member of the public
        is a licensee, and is addressed as "you".  You accept the
        license if you copy, modify or distribute the work in a way
        requiring permission under copyright law.</p><p><a name="gfdl-mod-ver"></a>A "Modified Version" of the Document
        means any work containing the Document or a portion of it,
        either copied verbatim, or with modifications and/or
        translated into another language.</p><p><a name="gfdl-secnd-sect"></a>A "Secondary Section" is a named
        appendix or a front-matter section of the Document that deals
        exclusively with the relationship of the publishers or authors
        of the Document to the Document's overall subject (or to
        related matters) and contains nothing that could fall directly
        within that overall subject.  (Thus, if the Document is in
        part a textbook of mathematics, a Secondary Section may not
        explain any mathematics.)  The relationship could be a matter
        of historical connection with the subject or with related
        matters, or of legal, commercial, philosophical, ethical or
        political position regarding them.</p><p><a name="gfdl-inv-sect"></a>The "Invariant Sections" are certain
        Secondary Sections whose titles are designated, as being those
        of Invariant Sections, in the notice that says that the
        Document is released under this License.  If a section does
        not fit the above definition of Secondary then it is not
        allowed to be designated as Invariant.  The Document may
        contain zero Invariant Sections.  If the Document does not
        identify any Invariant Sections then there are none.</p><p><a name="gfdl-cov-text"></a>The "Cover Texts" are certain short
        passages of text that are listed, as Front-Cover Texts or
        Back-Cover Texts, in the notice that says that the Document is
        released under this License.  A Front-Cover Text may be at
        most 5 words, and a Back-Cover Text may be at most 25
        words.</p><p><a name="gfdl-transparent"></a>A "Transparent" copy of the Document
        means a machine-readable copy, represented in a format whose
        specification is available to the general public, that is
        suitable for revising the document straightforwardly with
        generic text editors or (for images composed of pixels)
        generic paint programs or (for drawings) some widely available
        drawing editor, and that is suitable for input to text
        formatters or for automatic translation to a variety of
        formats suitable for input to text formatters.  A copy made in
        an otherwise Transparent file format whose markup, or absence
        of markup, has been arranged to thwart or discourage
        subsequent modification by readers is not Transparent.  An
        image format is not Transparent if used for any substantial
        amount of text.  A copy that is not "Transparent" is called
        "Opaque".</p><p>Examples of suitable formats for Transparent copies
        include plain ASCII without markup, Texinfo input format,
        LaTeX input format, SGML or XML using a publicly available
        DTD, and standard-conforming simple HTML, PostScript or PDF
        designed for human modification.  Examples of transparent
        image formats include PNG, XCF and JPG.  Opaque formats
        include proprietary formats that can be read and edited only
        by proprietary word processors, SGML or XML for which the DTD
        and/or processing tools are not generally available, and the
        machine-generated HTML, PostScript or PDF produced by some
        word processors for output purposes only.</p><p><a name="gfdl-title-page"></a>The "Title Page" means, for a printed
        book, the title page itself, plus such following pages as are
        needed to hold, legibly, the material this License requires to
        appear in the title page.  For works in formats which do not
        have any title page as such, "Title Page" means the text near
        the most prominent appearance of the work's title, preceding
        the beginning of the body of the text.</p><p><a name="gfdl-entitled"></a>A section "Entitled XYZ" means a named
        subunit of the Document whose title either is precisely XYZ or
        contains XYZ in parentheses following text that translates XYZ
        in another language.  (Here XYZ stands for a specific section
        name mentioned below, such as "Acknowledgements",
        "Dedications", "Endorsements", or "History".)  To "Preserve
        the Title" of such a section when you modify the Document
        means that it remains a section "Entitled XYZ" according to
        this definition.</p><p>The Document may include Warranty Disclaimers next to the
        notice which states that this License applies to the Document.
        These Warranty Disclaimers are considered to be included by
        reference in this License, but only as regards disclaiming
        warranties: any other implication that these Warranty
        Disclaimers may have is void and has no effect on the meaning
        of this License.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-2"></a>3. VERBATIM COPYING</h2></div></div></div><p>You may copy and distribute the Document in any medium,
        either commercially or noncommercially, provided that this
        License, the copyright notices, and the license notice saying
        this License applies to the Document are reproduced in all
        copies, and that you add no other conditions whatsoever to
        those of this License.  You may not use technical measures to
        obstruct or control the reading or further copying of the
        copies you make or distribute.  However, you may accept
        compensation in exchange for copies.  If you distribute a
        large enough number of copies you must also follow the
        conditions in section 3.
      </p><p>You may also lend copies, under the same conditions stated
        above, and you may publicly display copies.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-3"></a>4. COPYING IN QUANTITY</h2></div></div></div><p>If you publish printed copies (or copies in media that
        commonly have printed covers) of the Document, numbering more
        than 100, and the Document's license notice requires Cover
        Texts, you must enclose the copies in covers that carry,
        clearly and legibly, all these Cover Texts: Front-Cover Texts
        on the front cover, and Back-Cover Texts on the back cover.
        Both covers must also clearly and legibly identify you as the
        publisher of these copies.  The front cover must present the
        full title with all words of the title equally prominent and
        visible.  You may add other material on the covers in
        addition.  Copying with changes limited to the covers, as long
        as they preserve the title of the Document and satisfy these
        conditions, can be treated as verbatim copying in other
        respects.</p><p>If the required texts for either cover are too voluminous
        to fit legibly, you should put the first ones listed (as many
        as fit reasonably) on the actual cover, and continue the rest
        onto adjacent pages.</p><p>If you publish or distribute Opaque copies of the Document
        numbering more than 100, you must either include a
        machine-readable Transparent copy along with each Opaque copy,
        or state in or with each Opaque copy a computer-network
        location from which the general network-using public has
        access to download using public-standard network protocols a
        complete Transparent copy of the Document, free of added
        material.  If you use the latter option, you must take
        reasonably prudent steps, when you begin distribution of
        Opaque copies in quantity, to ensure that this Transparent
        copy will remain thus accessible at the stated location until
        at least one year after the last time you distribute an Opaque
        copy (directly or through your agents or retailers) of that
        edition to the public.</p><p>It is requested, but not required, that you contact the
        authors of the Document well before redistributing any large
        number of copies, to give them a chance to provide you with an
        updated version of the Document.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-4"></a>5. MODIFICATIONS</h2></div></div></div><p>You may copy and distribute a Modified Version of the
        Document under the conditions of sections 2 and 3 above,
        provided that you release the Modified Version under precisely
        this License, with the Modified Version filling the role of
        the Document, thus licensing distribution and modification of
        the Modified Version to whoever possesses a copy of it.  In
        addition, you must do these things in the Modified
        Version:</p><div class="orderedlist"><a name="gfdl-modif-cond"></a><ol class="orderedlist" type="A"><li class="listitem">Use in the Title Page (and on the covers,
            if any) a title distinct from that of the Document, and
            from those of previous versions (which should, if there
            were any, be listed in the History section of the
            Document).  You may use the same title as a previous
            version if the original publisher of that version gives
            permission.  </li><li class="listitem">List on the Title Page, as authors, one or
            more persons or entities responsible for authorship of the
            modifications in the Modified Version, together with at
            least five of the principal authors of the Document (all
            of its principal authors, if it has fewer than five),
            unless they release you from this requirement.
          </li><li class="listitem">State on the Title page the name of the
            publisher of the Modified Version, as the
            publisher.</li><li class="listitem">Preserve all the copyright notices of the
            Document.  </li><li class="listitem"> Add an appropriate copyright notice for
            your modifications adjacent to the other copyright
            notices.  </li><li class="listitem">Include, immediately after the copyright notices, a
            license notice giving the public permission to use the Modified
            Version under the terms of this License, in the form shown in the
            <a class="link" href="#gfdl-addendum" title="12. ADDENDUM: How to use this License for your documents">Addendum</a> below.
          </li><li class="listitem">Preserve in that license notice the full lists of
            Invariant Sections and required Cover Texts given in the Document's
            license notice.</li><li class="listitem">Include an unaltered copy of this License.
          </li><li class="listitem">Preserve the section Entitled "History",
            Preserve its Title, and add to it an item stating at least
            the title, year, new authors, and publisher of the
            Modified Version as given on the Title Page.  If there is
            no section Entitled "History" in the Document, create one
            stating the title, year, authors, and publisher of the
            Document as given on its Title Page, then add an item
            describing the Modified Version as stated in the previous
            sentence.  </li><li class="listitem">Preserve the network location, if any,
            given in the Document for public access to a Transparent
            copy of the Document, and likewise the network locations
            given in the Document for previous versions it was based
            on.  These may be placed in the "History" section.  You
            may omit a network location for a work that was published
            at least four years before the Document itself, or if the
            original publisher of the version it refers to gives
            permission.  </li><li class="listitem">For any section Entitled "Acknowledgements"
            or "Dedications", Preserve the Title of the section, and
            preserve in the section all the substance and tone of each
            of the contributor acknowledgements and/or dedications
            given therein.  </li><li class="listitem">Preserve all the Invariant Sections of the
            Document, unaltered in their text and in their titles.
            Section numbers or the equivalent are not considered part
            of the section titles.  </li><li class="listitem">Delete any section Entitled "Endorsements".
            Such a section may not be included in the Modified
            Version.  </li><li class="listitem">Do not retitle any existing section to be
            Entitled "Endorsements" or to conflict in title with any
            Invariant Section.  </li><li class="listitem">Preserve any Warranty Disclaimers.
          </li></ol></div><p>If the Modified Version includes new front-matter sections
        or appendices that qualify as Secondary Sections and contain
        no material copied from the Document, you may at your option
        designate some or all of these sections as invariant.  To do
        this, add their titles to the list of Invariant Sections in
        the Modified Version's license notice.  These titles must be
        distinct from any other section titles.</p><p>You may add a section Entitled "Endorsements", provided it
        contains nothing but endorsements of your Modified Version by
        various parties--for example, statements of peer review or
        that the text has been approved by an organization as the
        authoritative definition of a standard.</p><p>You may add a passage of up to five words as a Front-Cover
        Text, and a passage of up to 25 words as a Back-Cover Text, to
        the end of the list of Cover Texts in the Modified Version.
        Only one passage of Front-Cover Text and one of Back-Cover
        Text may be added by (or through arrangements made by) any one
        entity.  If the Document already includes a cover text for the
        same cover, previously added by you or by arrangement made by
        the same entity you are acting on behalf of, you may not add
        another; but you may replace the old one, on explicit
        permission from the previous publisher that added the old
        one.</p><p>The author(s) and publisher(s) of the Document do not by
        this License give permission to use their names for publicity
        for or to assert or imply endorsement of any Modified
        Version.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-5"></a>6. COMBINING DOCUMENTS</h2></div></div></div><p>You may combine the Document with other documents released
        under this License, under the terms defined in <a class="link" href="#gfdl-4" title="5. MODIFICATIONS">section 4</a> above for modified versions,
        provided that you include in the combination all of the
        Invariant Sections of all of the original documents,
        unmodified, and list them all as Invariant Sections of your
        combined work in its license notice, and that you preserve all
        their Warranty Disclaimers.</p><p>The combined work need only contain one copy of this
        License, and multiple identical Invariant Sections may be
        replaced with a single copy.  If there are multiple Invariant
        Sections with the same name but different contents, make the
        title of each such section unique by adding at the end of it,
        in parentheses, the name of the original author or publisher
        of that section if known, or else a unique number.  Make the
        same adjustment to the section titles in the list of Invariant
        Sections in the license notice of the combined work.</p><p>In the combination, you must combine any sections Entitled
        "History" in the various original documents, forming one
        section Entitled "History"; likewise combine any sections
        Entitled "Acknowledgements", and any sections Entitled
        "Dedications".  You must delete all sections Entitled
        "Endorsements".</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-6"></a>7. COLLECTIONS OF DOCUMENTS</h2></div></div></div><p>You may make a collection consisting of the Document and
        other documents released under this License, and replace the
        individual copies of this License in the various documents
        with a single copy that is included in the collection,
        provided that you follow the rules of this License for
        verbatim copying of each of the documents in all other
        respects.</p><p>You may extract a single document from such a collection,
        and distribute it individually under this License, provided
        you insert a copy of this License into the extracted document,
        and follow this License in all other respects regarding
        verbatim copying of that document.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-7"></a>8. AGGREGATION WITH INDEPENDENT WORKS</h2></div></div></div><p>A compilation of the Document or its derivatives with
        other separate and independent documents or works, in or on a
        volume of a storage or distribution medium, is called an
        "aggregate" if the copyright resulting from the compilation is
        not used to limit the legal rights of the compilation's users
        beyond what the individual works permit.  When the Document is
        included in an aggregate, this License does not apply to the
        other works in the aggregate which are not themselves
        derivative works of the Document.</p><p>If the Cover Text requirement of section 3 is applicable
        to these copies of the Document, then if the Document is less
        than one half of the entire aggregate, the Document's Cover
        Texts may be placed on covers that bracket the Document within
        the aggregate, or the electronic equivalent of covers if the
        Document is in electronic form.  Otherwise they must appear on
        printed covers that bracket the whole aggregate.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-8"></a>9. TRANSLATION</h2></div></div></div><p>Translation is considered a kind of modification, so you
        may distribute translations of the Document under the terms of
        section 4.  Replacing Invariant Sections with translations
        requires special permission from their copyright holders, but
        you may include translations of some or all Invariant Sections
        in addition to the original versions of these Invariant
        Sections.  You may include a translation of this License, and
        all the license notices in the Document, and any Warranty
        Disclaimers, provided that you also include the original
        English version of this License and the original versions of
        those notices and disclaimers.  In case of a disagreement
        between the translation and the original version of this
        License or a notice or disclaimer, the original version will
        prevail.</p><p>If a section in the Document is Entitled
        "Acknowledgements", "Dedications", or "History", the
        requirement (section 4) to Preserve its Title (section 1) will
        typically require changing the actual title.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-9"></a>10. TERMINATION</h2></div></div></div><p>You may not copy, modify, sublicense, or distribute the
        Document except as expressly provided for under this License.
        Any other attempt to copy, modify, sublicense or distribute
        the Document is void, and will automatically terminate your
        rights under this License.  However, parties who have received
        copies, or rights, from you under this License will not have
        their licenses terminated so long as such parties remain in
        full compliance.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-10"></a>11. FUTURE REVISIONS OF THIS LICENSE</h2></div></div></div><p>The Free Software Foundation may publish new, revised
        versions of the GNU Free Documentation License from time to
        time.  Such new versions will be similar in spirit to the
        present version, but may differ in detail to address new
        problems or concerns.  See
        http://www.gnu.org/copyleft/.</p><p>Each version of the License is given a distinguishing
        version number.  If the Document specifies that a particular
        numbered version of this License "or any later version"
        applies to it, you have the option of following the terms and
        conditions either of that specified version or of any later
        version that has been published (not as a draft) by the Free
        Software Foundation.  If the Document does not specify a
        version number of this License, you may choose any version
        ever published (not as a draft) by the Free Software
        Foundation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-addendum"></a>12. ADDENDUM: How to use this License for
        your documents</h2></div></div></div><p>To use this License in a document you have written,
        include a copy of the License in the document and put the
        following copyright and license notices just after the title
        page:</p><div class="blockquote"><a name="copyright-sample"></a><blockquote class="blockquote"><p> Copyright (c) YEAR YOUR
          NAME.  Permission is granted to copy, distribute and/or
          modify this document under the terms of the GNU Free
          Documentation License, Version 1.2 or any later version
          published by the Free Software Foundation; with no Invariant
          Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
          copy of the license is included in the section entitled "GNU
          Free Documentation License".  </p></blockquote></div><p>If you have Invariant Sections, Front-Cover Texts and Back-Cover
        Texts, replace the "with...Texts." line with this:</p><div class="blockquote"><a name="inv-cover-sample"></a><blockquote class="blockquote"><p> with the Invariant
          Sections being LIST THEIR TITLES, with the Front-Cover Texts
          being LIST, and with the Back-Cover Texts being LIST.
        </p></blockquote></div><p>If you have Invariant Sections without Cover Texts, or
        some other combination of the three, merge those two
        alternatives to suit the situation.</p><p>If your document contains nontrivial examples of program
        code, we recommend releasing these examples in parallel under
        your choice of free software license, such as the GNU General
        Public License, to permit their use in free software.</p></div></div></div></body></html>
