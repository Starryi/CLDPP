<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3. Avoiding Bounce Buffers</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="I/O Performance HOWTO"><link rel="up" href="index.html" title="I/O Performance HOWTO"><link rel="prev" href="ar01s02.html" title="2. Introduction"><link rel="next" href="ar01s04.html" title="4. Raw I/O Variable-Size Optimization Patch"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Avoiding Bounce Buffers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="OVERVIEW"></a>3. Avoiding Bounce Buffers</h2></div></div></div><p>This section provides information on applying and using the bounce buffer patch on the Linux 2.4 kernel. The bounce buffer patch, written by Jens Axboe, enables device drivers that support direct memory access (DMA) I/O  to high-address physical memory to avoid bounce buffers.</p><p>This document provides a brief overview on memory and addressing in the Linux kernel, followed by information on why and how to make use of the bounce buffer patch.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm40"></a>3.1. Memory and Addressing in the Linux 2.4 Kernel</h3></div></div></div><p>The Linux 2.4 kernel includes configuration options for specifying the amount of physical memory in the target computer.  By default, the configuration is limited to the amount of memory that can be directly mapped into the kernel's virtual address space starting at PAGE_OFFSET. On i386 systems the default mapping scheme limits kernel-mode addressability to the first gigabyte (GB) of physical memory, also known as low memory. Conversely, high memory is normally the memory above 1 GB. High memory is not directly accessible or permanently mapped by the kernel. Support for high memory is an option that is enabled during <a class="link" href="ar01s03.html#config" title="3.3. Locating the Patch">configuration of the Linux kernel</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm44"></a>3.2. The Problem with Bounce Buffers</h3></div></div></div><p>When DMA I/O is performed to or from high memory, an area is allocated in low memory known as a bounce buffer. When data travels between a device and high memory, it is first copied through the bounce buffer.</p><p>Systems with a large amount of high memory and intense I/O activity can create a large number of bounce buffers that can cause memory shortage problems. In addition, the excessive number of bounce buffer data copies can lead to performance degradation.</p><p>Peripheral component interface (PCI) devices normally address up to 4 GB of physical memory. When a bounce buffer is used for high memory that is below 4 GB, time and memory are wasted because the peripheral has the ability to address that memory directly. Using the bounce buffer patch can decrease, and possibly eliminate, the use of bounce buffers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="config"></a>3.3. Locating the Patch</h3></div></div></div><p> The latest version of the bounce buffer patch is <span class="emphasis"><em>block-highmem-all-18b.bz2</em></span>, and it is available from Andrea Arcangeli's -aa series kernels at 
 <a class="ulink" href="http://kernel.org/pub/linux/kernel/people/andrea/kernels/v2.4/" target="_top">http://kernel.org/pub/linux/kernel/people/andrea/kernels/v2.4/</a>.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm54"></a>3.3.1. Configuring the Linux Kernel to Avoid Bounce Buffers</h4></div></div></div><p>This section includes information on configuring the Linux kernel to avoid bounce buffers. The Linux Kernel-HOWTO at <a class="ulink" href="http://www.linuxdoc.org/HOWTO/Kernel-HOWTO.html" target="_top">http://www.linuxdoc.org/HOWTO/Kernel-HOWTO.html</a> explains the process of re-compiling the Linux kernel.</p><p>The following kernel configuration options are required to enable the bounce buffer patch:</p><p><span class="bold"><strong>Development Code</strong></span> - To enable the configurator to display the <code class="option">High I/O Support</code> option, select the <code class="option">Code maturity level options</code> category and specify "y" to <code class="option">Prompt for development and/or incomplete code/drivers</code>.</p><p><span class="bold"><strong>High Memory Support</strong></span> - To enable support for physical memory that is 			greater than 1 GB, select the <code class="option">Processor type and features</code> category, and select a value from the  <code class="option">High Memory Support</code> option.</p><p><span class="bold"><strong>High Memory I/O Support</strong></span> - To enable DMA I/O to physical 					addresses greater than 1 GB, select the  <code class="option">Processor type and features</code> category, and enter "y" 			to  the <code class="option">HIGHMEM I/O support</code> option. This configuration option is a new option introduced by the bounce buffer patch.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="enabled"></a>3.3.2. Enabled Device Drivers</h4></div></div></div><p>The bounce buffer patch provides the kernel infrastructure, as well as the SCSI and IDE mid-level driver modifications to support DMA I/O to high memory.  Updates for several device drivers to make use of the added support are also included with the patch.</p><p>If the bounce buffer patch is applied and you configure the kernel to support 						high memory I/O, many IDE configurations and the device drivers listed below					perform DMA I/O without the use of bounce buffers:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>aic7xxx_drv.o</td></tr><tr><td>aic7xxx_old.o</td></tr><tr><td>cciss.o</td></tr><tr><td>cpqarray.o</td></tr><tr><td>megaraid.o</td></tr><tr><td>qlogicfc.o</td></tr><tr><td>sym53c8xx.o</td></tr></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm85"></a>3.4. Modifying Your Device Driver to Avoid Bounce Buffers</h3></div></div></div><p>If your device drivers are not listed above in the 
<a class="link" href="ar01s03.html#enabled" title="3.3.2. Enabled Device Drivers">Enabled Device Drivers</a> section, and the device is capable of high-memory DMA I/O, you can modify your device driver to make use of the bounce buffer patch as follows. More information on rebuilding a Linux device driver is available at <a class="ulink" href="http://www.xml.com/ldd/chapter/book/index.html" target="_top">http://www.xml.com/ldd/chapter/book/index.html</a>.
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A.) For SCSI Adapter Drivers: set the <em class="structfield"><code>highmem_io</code></em> bit in the <em class="structfield"><code>Scsi_Host_Template</code></em>  structure. </p><p>B.) For IDE Adapter Drivers: set the <em class="structfield"><code>highmem</code></em>bit in the <em class="structfield"><code>ide_hwif_t</code></em> structure.</p></li><li class="listitem"><p>Call <em class="structfield"><code>pci_set_dma_mask(struct pci_dev *pdev, dma_addr_t mask)</code></em> to specify the address bits that the device can successfully use on DMA operations. </p><p>If DMA I/O can be supported with the specified mask, <em class="structfield"><code>pci_set_dma_mask()</code></em> will set <em class="structfield"><code>pdev-&gt;dma_mask</code></em> and return 0. For SCSI or IDE, the mask value will also be passed by the mid-level drivers to <em class="structfield"><code>blk_queue_bounce_limit(request_queue_t *q, u64 dma_addr)</code></em> so that bounce buffers are not created for memory directly addressable by the device. Drivers other than SCSI or IDE must call <em class="structfield"><code>blk_queue_bounce_limit()</code></em> directly. </p></li><li class="listitem"><p>Use <em class="structfield"><code>pci_map_page(dev, page, offset, size, direction)</code></em>, instead of <em class="structfield"><code>pci_map_single(dev, address, size, direction)</code></em> to map a memory region so that it is accessible by the peripheral device. <em class="structfield"><code>pci_map_page() </code></em> supports both high and low memory.</p><p>The <em class="structfield"><code>address </code></em> parameter for <em class="structfield"><code>pci_map_single()</code></em> correlates to the <em class="structfield"><code>page</code></em> and<em class="structfield"><code> offset </code></em> parameters for <em class="structfield"><code>pci_map_page()</code></em>. Use the <em class="structfield"><code>virt_to_page()</code></em> macro to convert an <em class="structfield"><code>address</code></em> to a <em class="structfield"><code>page </code></em> and <em class="structfield"><code>offset</code></em>. The <em class="structfield"><code>virt_to_page()</code></em> macro is defined by including pci.h. For example:</p><pre class="screen"><em class="structfield"><code>void *address;</code></em></pre><p>

</p><pre class="screen"><em class="structfield"><code>struct page *page;</code></em></pre><p>

</p><pre class="screen"><em class="structfield"><code>unsigned long offset;</code></em></pre><p>

</p><pre class="screen"><em class="structfield"><code>page = virt_to_page(address);</code></em></pre><p>

</p><pre class="screen"><em class="structfield"><code>offset = (unsigned long) address &amp; ~PAGE_MASK;</code></em></pre><p>Call <em class="structfield"><code>pci_unmap_page()</code></em> after the DMA I/O transfer is complete to remove the mapping established by <em class="structfield"><code>pci_map_page()</code></em>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><em class="structfield"><code>pci_map_single()</code></em> is implemented using <em class="structfield"><code>virt_to_bus()</code></em>. <em class="structfield"><code>virt_to_bus()</code></em> handles low memory addresses only. Drivers supporting high memory should no longer call <em class="structfield"><code>virt_to_bus()</code></em> or <em class="structfield"><code>bus_to_virt()</code></em>.</p></div></li><li class="listitem"><p>If your driver calls <em class="structfield"><code>pci_map_sg()</code></em> to map a scatter-gather DMA operation, your driver should set the <em class="structfield"><code>page</code></em> and <em class="structfield"><code>offset</code></em> fields instead of the <em class="structfield"><code>address</code></em> field of the <em class="structfield"><code>scatterlist</code></em> structure. Refer to step 3 for converting an <em class="structfield"><code>address</code></em> to a <em class="structfield"><code>page</code></em> and <em class="structfield"><code>offset</code></em>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If your driver is already using the PCI DMA API, continue to use <em class="structfield"><code>pci_map_page()				</code></em> or <em class="structfield"><code>pci_map_sg()</code></em> as appropriate. However, do not use the <em class="structfield"><code>address</code></em> field of the <em class="structfield"><code>scatterlist</code></em> structure.</p></div></li></ol></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. Introduction </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. Raw I/O Variable-Size Optimization Patch</td></tr></table></div></body></html>
