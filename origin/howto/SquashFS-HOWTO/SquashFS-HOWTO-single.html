<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>SquashFS HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="Abstract This HOWTO describes the usage of SquashFS - a highly-compressed read-only file system for Linux, which is intended for use in tiny-sized and embedded systems, and anywhere else you'd want to use a compressed file system. With this document, you'll learn how to prepare a SquashFS-ready Linux kernel, create a squashed file system and happily use it."><meta name="keywords" content="linux, squashfs, squashed, squash, compressed, filesystem, kernel, embedded, tiny"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="SquashFS-HOWTO"></a>SquashFS HOWTO</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Artemiy</span> <span class="othername">I.</span> <span class="surname">Pavlov</span></h3><div class="affiliation"><span class="orgname"><a class="ulink" href="http://www.sinevibes.com/" target="_top">Sinevibes</a><br></span><div class="address"><p></p></div></div></div><div class="author"><h3 class="author"><span class="firstname">Marco</span> <span class="othername"></span> <span class="surname">Cecchetti</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:mrc%20(dot)%20ildp%20(dot)%20com">mrc (dot) ildp (dot) com</a>&gt;</code></p></div></div></div></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.9</td><td align="left">2008-07-24</td><td align="left"></td></tr><tr><td align="left" colspan="3">Text corrections.
			</td></tr><tr><td align="left">Revision 1.8</td><td align="left">2008-01-06</td><td align="left"></td></tr><tr><td align="left" colspan="3">Changes according to SquashFS release 3.3. Some parts added.
			</td></tr><tr><td align="left">Revision 1.7</td><td align="left">2005-03-25</td><td align="left"></td></tr><tr><td align="left" colspan="3">Changes according to SquashFS release 2.1.
			</td></tr><tr><td align="left">Revision 1.6</td><td align="left">2004-11-10</td><td align="left"></td></tr><tr><td align="left" colspan="3">Changes according to SquashFS release 2.0.
			Text corrections.
			</td></tr><tr><td align="left">Revision 1.5</td><td align="left">2004-06-07</td><td align="left"></td></tr><tr><td align="left" colspan="3">Changes according to SquashFS release 2.0 alpha.
			Lots of description improvements and clarifications. Split 
			instructions for Linux kernels of 2.6.x (new) and 2.4.x series.
			</td></tr><tr><td align="left">Revision 1.1</td><td align="left">2004-05-22</td><td align="left"></td></tr><tr><td align="left" colspan="3">Changes according to SquashFS release 1.3r3.</td></tr><tr><td align="left">Revision 1.0</td><td align="left">2004-02-19</td><td align="left"></td></tr><tr><td align="left" colspan="3">Initial Release, reviewed by LDP.</td></tr><tr><td align="left">Revision 0.2</td><td align="left">2003-12-08</td><td align="left"></td></tr><tr><td align="left" colspan="3">Text corrections, license added.</td></tr><tr><td align="left">Revision 0.1</td><td align="left">2003-11-24</td><td align="left"></td></tr><tr><td align="left" colspan="3">Initial version. Instructions for SquashFS release 1.3r2.</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This HOWTO describes the usage of SquashFS - a highly-compressed 
		read-only file system for Linux, which is intended for use in tiny-sized and 
		embedded systems, and anywhere else you'd want to use a compressed file system.
		With this document, you'll learn how to prepare a SquashFS-ready
		Linux kernel, create a squashed file system and happily use it.
		</p></div></div><div><div class="abstract"><p class="title"><b>Home of this HOWTO</b></p><p>
		The SquashFS HOWTO lives at <a class="ulink" href="http://artemio.net/projects/linuxdoc/squashfs" target="_top">http://artemio.net/projects/linuxdoc/squashfs</a>.
		There you will always find the latest version of the document, and will be able to send
		your feedback.
		</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whatis">1. What is SquashFS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#intro">1.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#overview">1.2. Overview of SquashFS</a></span></dt><dt><span class="sect2"><a href="#makingclear">1.3. Making it clear</a></span></dt></dl></dd><dt><span class="sect1"><a href="#gettingready">2. Getting ready for SquashFS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#acquiring">2.1. Acquiring SquashFS</a></span></dt><dt><span class="sect2"><a href="#preparing">2.2. Preparing a SquashFS-capable kernel</a></span></dt><dt><span class="sect2"><a href="#tools">2.3. Compiling the SquashFS tools</a></span></dt><dt><span class="sect2"><a href="#debian">2.4. Installing SquashFS on Debian</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mksqoverview">3. The SquashFS tools exposed</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mksqusing">3.1. Using mksquashfs</a></span></dt><dt><span class="sect2"><a href="#mksqoptions">3.2. Command-line options</a></span></dt><dt><span class="sect2"><a href="#unsquashing">3.3. Using unsquashfs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#creatingandusing">4. Creating and using squashed file systems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#creating">4.1. Basic steps</a></span></dt><dt><span class="sect2"><a href="#squashing">4.2. Squashing file systems</a></span></dt><dt><span class="sect2"><a href="#tinyemb">4.3. Creating tiny/embedded systems</a></span></dt><dt><span class="sect2"><a href="#sqwrite">4.4. Making it writeble</a></span></dt></dl></dd><dt><span class="sect1"><a href="#acknowledgements">5. Acknowledgements</a></span></dt><dt><span class="sect1"><a href="#license">6. License</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatis"></a>1. What is SquashFS</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="intro"></a>1.1. Introduction</h3></div></div></div><p>
When creating tiny-sized and embedded Linux systems, every byte of the storage device (floppy, flash disk, etc.)
is very important, so compression is used everywhere possible. Also, compressed file systems are frequently needed
for archiving purposes. For huge public archives, as well as for personal media archives, this is essential.
</p><p>
SquashFS brings all this to a new level. It is a read-only file system that lets you compress whole file systems or
single directories, write them to other devices/partitions or to ordinary files, and then mount them directly (if
a device) or using a loopback device (if it is a file). The modular, compact system design of SquashFS is bliss.
For archiving purposes, SquashFS gives you a lot more flexibility and performance speed than a tarball archive.
</p><p>
SquashFS is distributed as a Linux kernel source patch (which enables SquashFS read support in your kernel),
the <span class="command"><strong>mksquashfs</strong></span> tool, which creates squashed file systems (in a file or on a block device) and
the <span class="command"><strong>unsquashfs</strong></span> tool, which extracts multiple files from an existing squashed file system.
</p><p>
The latest SquashFS release tree is 3.x, the former one was 2.x. This document
describes both these releases with proper notes given. For example, if some feature or 
parameter is different in these release trees, it will be written as follows: 
<span class="emphasis"><em>new value (3.x) or old value (2.x)</em></span>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="overview"></a>1.2. Overview of SquashFS</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Data, inodes and directories are compressed
</p></li><li class="listitem"><p>SquashFS stores full uid/gids (32 bits), and file creation time
</p></li><li class="listitem"><p>Files up to 2^64 bytes are supported; file systems can be up to 2^64 bytes
</p></li><li class="listitem"><p>Inode and directory data are highly compacted, and packed on byte
boundaries;  each compressed inode is on average 8 bytes in length
(the exact length varies on file type, i.e. regular file, directory,
symbolic link, and block/character device inodes have different sizes)
</p></li><li class="listitem"><p>SquashFS can use block sizes up to up to 64 Kb (2.x) and 1Mb (3.x). The default size is 128Kb (3.x), which achieves 
greater compression ratios than the normal 4K block size
</p></li><li class="listitem"><p>By the 2.x release it was introduced the concept of <span class="emphasis"><em>fragment blocks</em></span>:
an ability to join multiple files smaller than block size into a single
block, achieving greater compression ratios
</p></li><li class="listitem"><p>File duplicates are detected and removed
</p></li><li class="listitem"><p>Both big and little endian architectures are supported;  SquashFS can
mount file systems created on different byte-order machines
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="makingclear"></a>1.3. Making it clear</h3></div></div></div><p>
Now let's make sure any further discussions will be clearer
for you to understand.
The procedure of getting SquashFS working basically  
consists of the following steps:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Patching and recompiling the target Linux kernel to enable SquashFS support
</p></li><li class="listitem"><p>Compiling the <span class="command"><strong>mksquashfs </strong></span> and the <span class="command"><strong>unsquashfs </strong></span> tools 
</p></li><li class="listitem"><p>Creating a compressed file system with <span class="command"><strong>mksquashfs</strong></span>
</p></li><li class="listitem"><p>Testing: mounting a squashed file system to a temporary location
</p></li><li class="listitem"><p>Modifying the <code class="filename">/etc/fstab </code> or startup scripts of 
your target Linux system to mount the new squashed file system when needed
</p></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gettingready"></a>2. Getting ready for SquashFS</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="acquiring"></a>2.1. Acquiring SquashFS</h3></div></div></div><p>
The SquashFS home site is located at 
<a class="ulink" href="http://squashfs.sourceforge.net/" target="_top">http://squashfs.sourceforge.net/</a> 
- it contains news for the latest release and it's changelog, as well as general information 
about SquashFS. You can grab the latest version at the SquashFS
<a class="ulink" href="http://sourceforge.net/project/showfiles.php?group_id=63835" target="_top">project page</a>
at SourceForge.
</p><p>
Squashfs is also avaliable with LZMA compression at
<a class="ulink" href="http://www.squashfs-lzma.org/" target="_top">http://www.squashfs-lzma.org/</a>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="preparing"></a>2.2. Preparing a SquashFS-capable kernel</h3></div></div></div><p>
In order to read SquashFS, you need it supported in your kernel - just as if it was a 
<code class="filename">reiserfs</code> or <code class="filename">ext3</code> file system. You have to make sure 
there is an appropriate patch for your kernel version. It should be located in
<code class="filename">kernel-patches/linux-2.x.y</code> subdirectory of the SquashFS source tree. Also, remember 
that in most cases you will need a <span class="emphasis"><em>clean</em></span> (original) Linux kernel 
source from <a class="ulink" href="http://kernel.org/" target="_top">kernel.org</a>. If your kernel source is 
from a distro vendor, it may be already pre-patched with custom vendor patches, and patching 
with a SquashFS patch will almost surely not work, as SquashFS patches are made against 
<span class="emphasis"><em>original</em></span> Linux kernels. 
However some distributions make avaliable SquashFS-kernel-modules and SquashFS-tools packages from the repositories.
If you consider to use these packages from your distro, you don't need to patch your kernel or 
to build SquashFS tools from source. In such case, make sure to get the proper module for your kernel from the distro 
repositories. Please note that doing so you will have an easy installation step, but no control on 
kernel configuration parameters if you mind to use SquashFS for particular purposes (eg. for embedded systems).
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="patching"></a>2.2.1. Patching the kernel source</h4></div></div></div><p>
With a kernel source and a proper SquashFS patch present, all you have to do is 
(we'll assume that you have your Linux kernel source in <code class="filename">/usr/src/linux</code> and 
that you have the SquashFS source in <code class="filename">/usr/src/squashfs</code>):
</p><p>
Change to the SquashFS source directory and
copy the kernel patch (we'll assume it's named <code class="filename">squashfs-patch</code>) to 
<code class="filename">/usr/src/linux</code>.
</p><pre class="programlisting">
	bash# cd /usr/src/squashfs
	bash# cp linux-2.x.y/squashfs-patch /usr/src/linux
</pre><p>
Go to the linux kernel source directory <code class="filename">/usr/src/linux</code>:
</p><pre class="programlisting">
	bash# cd /usr/src/linux
</pre><p><span class="emphasis"><em>Note:</em></span> please remember that we will not be leaving this 
directory during all further kernel-related procedures, and all paths
will be given relative to <code class="filename">/usr/src/linux</code>.</p><p>Now patch the source with the SquashFS patch:</p><pre class="programlisting">
	bash# patch -p1 &lt; squashfs-patch
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="compiling1"></a>2.2.2. Compiling a 2.6.x kernel</h4></div></div></div><p>Cleanup and prepare the kernel source:</p><pre class="programlisting">
	bash# make distclean
	bash# make mrproper
</pre><p>Configure the kernel using your favourite method
(config/menuconfig/xconfig/gconfig):</p><pre class="programlisting">
	bash# make menuconfig
</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
In the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>File systems</em></span></span>&#8221;</span> section, 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Miscellaneous file systems</em></span></span>&#8221;</span> subsection, enable 
the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Squashed filesystem</em></span></span>&#8221;</span> option, whether as 
module or bundled with the kernel. It is only obligatory to compile SquashFS inside 
the kernel if you plan using squashed initial RAM disks (<span class="command"><strong>initrd</strong></span>). 
</p></li><li class="listitem"><p>
In the same subsection, <span class="command"><strong>"do NOT"</strong></span> enable the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Additional option for memory-constrained system</em></span></span>&#8221;</span>, unless
you are configuring your kernel for an embedded system.
</p></li><li class="listitem"><p>
If you would like to use a squashed initial RAM disk, enable the 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Initial RAM disk support</em></span></span>&#8221;</span>  in the 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Device drivers</em></span></span>&#8221;</span>  section, 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Block devices</em></span></span>&#8221;</span>  subsection.
</p></li><li class="listitem"><p>
If you want to be able to mount the squashed file system via a <span class="emphasis"><em>loopback device</em></span> in future, you should enable 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Loopback device support</em></span></span>&#8221;</span>  in the 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Device drivers</em></span></span>&#8221;</span>  section, 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Block devices</em></span></span>&#8221;</span>  subsection.
</p></li></ol></div><p>Now you may compile the kernel and modules:</p><pre class="programlisting">
	bash# make
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="compiling2"></a>2.2.3. Compiling a 2.4.x kernel</h4></div></div></div><p>Configure the kernel:</p><pre class="programlisting">
	bash# make menuconfig
</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
In the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>File systems</em></span></span>&#8221;</span>  section, enable 
the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Squashed filesystem</em></span></span>&#8221;</span>  option, whether as 
module or bundled with the kernel. It is only obligatory to compile SquashFS inside 
the kernel if you plan using squashed initial RAM disks (<span class="command"><strong>initrd</strong></span>). 
</p></li><li class="listitem"><p>
If you would like to use a squashed initial RAM disk, enable the 
<span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Initial RAM disk support</em></span></span>&#8221;</span>  in the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Block 
devices</em></span></span>&#8221;</span>  section.
</p></li><li class="listitem"><p>
If you want to be able to mount the squashed file system via a <span class="emphasis"><em>loopback 
device</em></span> in future, you should enable <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em> Loopback device 
support </em></span></span>&#8221;</span> in the <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Block devices </em></span></span>&#8221;</span>  section.
</p></li></ol></div><p>Now you may compile the kernel and modules:</p><pre class="programlisting">
	bash# make dep
	bash# make bzImage
	bash# make modules
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="installkernel"></a>2.2.4. Installing and testing the kernel</h4></div></div></div><p>It's time to install your new SquashFS-enabled kernel.
The instructions below are for installing and booting the kernel
on the host machine. You may want to install and test it on the
target system.
</p><p>We assume that the kernel was compiled for a x86 
architecture, and the compressed kernel image is located in the 
<code class="filename">arch/i386/boot/</code> subdirectory of the kernel tree. 
Now copy the kernel to the <code class="filename">/boot</code> directory (and name it 
<code class="filename">bzImage-sqsh</code> for convenience, if you like):</p><pre class="programlisting">
	bash# cp arch/i386/boot/bzImage /boot/bzImage-sqsh
</pre><p>
Don't forget to install the kernel modules
if you have any:
</p><pre class="programlisting">
	bash# make modules_install
</pre><p>
Modify your boot loader's configuration file to include your new kernel and install
(update) the boot loader. Now you may reboot with your new kernel. When it boots, check that 
everything went fine:
</p><pre class="programlisting">
	bash# cat /proc/filesystems
</pre><p>
Or, if you built SquashFS support as a kernel module:
</p><pre class="programlisting">
	bash# insmod squashfs
	bash# cat /proc/filesystems
</pre><p>
If you see the <code class="computeroutput">squashfs</code> line among other file systems,
this means you have successfully enabled SquashFS in your kernel.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tools"></a>2.3. Compiling the SquashFS tools</h3></div></div></div><p>
Now you need to compile <span class="command"><strong>mksquashfs</strong></span> - the tool for creating squashed file systems and the
<span class="command"><strong>unsquashfs</strong></span> which extracts files from an existing squashed file system.
</p><pre class="programlisting">
	bash# cd /usr/src/squashfs/squashfs-tools
</pre><p>
Compile and install the tools:
</p><pre class="programlisting">
	bash# make
	bash# cp mksquashfs /usr/sbin
	bash# cp unsquashfs /usr/sbin
</pre><p>
If everything went fine, typing <span class="command"><strong>mksquashfs</strong></span> or <span class="command"><strong>unsquashfs</strong></span> at the shell prompt should print the <span class="quote">&#8220;<span class="quote">usage</span>&#8221;</span> message.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="debian"></a>2.4. Installing SquashFS on Debian</h3></div></div></div><p>If you use Debian (or onother Linux distribution) you may want to get SquashFS module and tools from the distro repositories. With Debian you have to install the proper kernel module and the tools with the following commands:
</p><p>
(Assuming your architecture is x86)
</p><pre class="programlisting">
	bash# apt-get install squashfs-modules-2.6-486  squashfs-tools
</pre><p> Now load the squashfs module for the Linux kernel and if it was correctly loaded you should find it in the relative list
</p><pre class="programlisting">
	bash# modprobe squashfs
	
	bash# lsmod|grep squash
	squashfs               39620  0

	
</pre><p>
Then you have to add the squashfs module to /etc/modules if you need it loaded at boot time.
</p><pre class="programlisting">
	bash# echo squashfs &gt;&gt; /etc/modules
</pre><p>
Note that at the time of writing, the Debian packages (Etch. 4.0 r2) relates to squashfs 3.1 release. Some latest options and features of 3.2 release may be not supported. Look at the next section for details.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mksqoverview"></a>3. The SquashFS tools exposed</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mksqusing"></a>3.1. Using mksquashfs</h3></div></div></div><p>
<span class="command"><strong>mksquashfs</strong></span> is the tool for creating new squashed 
file systems, and for appending new data to existing squashed file 
systems. The general command-line format for <span class="command"><strong>mksquashfs</strong></span> is:
</p><pre class="programlisting">
	bash# mksquashfs source1 source2 ... destination [options]
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">source1</code>, <code class="filename">source2</code>, etc.: files and directories to be
added to the resulting file system, given with relative and/or absolute paths 
</p></li><li class="listitem"><p><code class="filename">destination</code>: a regular file (filesystem 
image file), or a block device (such as <code class="filename">/dev/fd0</code> or <code class="filename">/dev/hda3</code>)
where you want to have your squashed file system
</p></li></ul></div><p>

Notes for default <span class="command"><strong>mksquashfs</strong></span> behavior:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
When the new files are added to the new file system or appended to an existing one,
<span class="command"><strong>mksquashfs </strong></span> will automatically rename files with duplicate names:
if two or more files named <code class="filename">text</code> will appear in the same
resulting directory, the second file will be renamed to
<code class="filename">text_1</code>, third one to <code class="filename">text_2</code> and so on.
</p></li><li class="listitem"><p>
Duplicate files will be removed, so there will be only one physical instance
(By the SquashFS 2.x, you can disable the detection/removal of the duplicates
with the <span class="command"><strong>-no-duplicates </strong></span> option).
</p></li><li class="listitem"><p>
If <span class="emphasis"><em>destination </em></span> has a pre-existing SquashFS
file system on it, by default, the new <span class="emphasis"><em>source</em></span> items will be appended to
the existing root directory. Examine the options table below to force <span class="command"><strong>mksquashfs </strong></span> to overwrite the whole destination
and/or change the way new source items are added. 
</p></li><li class="listitem"><p>
If a single source file or directory is given, it becomes the root in a newly created file system. If two
or more source files and/or directories are given, they will all become sub-items in the root of
the new file system.
</p></li><li class="listitem"><p>
The resulting filesystem will be padded to a multiple of 4 Kb: this
is required for filesystems to be used on block devices. If you are very sure
you don't ned this, use the <span class="command"><strong>-nopad </strong></span> option to disable this
operation.
</p></li></ul></div><p>

</p><p>
See the next section for more details about all possible options.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mksqoptions"></a>3.2. Command-line options</h3></div></div></div><p>
All possible options for <span class="command"><strong>mksquashfs</strong></span> are shown in the table below.
</p><div class="table"><a name="idm317"></a><p class="title"><b>Table 1. Command-line options of the <span class="command">mksquashfs</span> tool</b></p><div class="table-contents"><table class="table" summary="Command-line options of the mksquashfs tool" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><span class="command"><strong>-2.0 </strong></span></td><td>force <span class="command"><strong>mksquashfs</strong></span> version 2.1 to create a version 2.0 
filesystem</td></tr><tr><td><span class="command"><strong>-all-root</strong></span> or <span class="command"><strong>-root-owned</strong></span></td><td>make all files in the target file system owned by root (UID=0, GID=0)</td></tr><tr><td><span class="command"><strong>-always-use-fragments</strong></span></td><td>divide all files greater than block size into fragments (by the version 2.x).
It will result in greater compression ratios</td></tr><tr><td><span class="command"><strong>-b [block size]</strong></span></td><td>use [block size] filesystem block size (32 Kbytes default for 2.x, 128 kbytes for 3.x) - this can be either 4096, 8192, 16384, 32768, 65536 or 131072</td></tr><tr><td><span class="command"><strong>-be</strong></span> or <span class="command"><strong>-le</strong></span></td><td>force a big or little endian file system, respectively</td></tr><tr><td><span class="command"><strong>-check-data</strong></span></td><td>enable additional file system checks</td></tr><tr><td><span class="command"><strong>-e [file1] ( [file2] ... )</strong></span></td><td>specify which files and/or directories to omit
from the new file system that is to be created</td></tr><tr><td><span class="command"><strong>-ef [file]</strong></span></td><td>specify a <code class="filename">file</code> which contains the list of
files/directories to exclude</td></tr><tr><td><span class="command"><strong>-force-gid [GID]</strong></span></td><td>set all group IDs in target file system to [GID]
(can be specified as a name or a number)</td></tr><tr><td><span class="command"><strong>-force-uid [UID]</strong></span></td><td>set all user IDs in target file system to [UID]
(can be specified as a name or a number)</td></tr><tr><td><span class="command"><strong>-info</strong></span></td><td>print files, their original size and compression ratio, as they are added to 
the file system</td></tr><tr><td><span class="command"><strong>-keep-as-directory</strong></span></td><td>if the source is a single directory, force this directory to be a subdirectory 
of the root in the created file system</td></tr><tr><td><span class="command"><strong>-noappend</strong></span></td><td>if the destination file/device already contains a squashed file system, 
overwrite it, rather than append the new data to an existing file system</td></tr><tr><td><span class="command"><strong>-no-duplicates</strong></span></td><td>do not detect/remove duplicate file names</td></tr><tr><td><span class="command"><strong>-noD</strong></span> or <span class="command"><strong>-noDataCompression</strong></span></td><td>do not compress the data</td></tr><tr><td><span class="command"><strong>-noF</strong></span> or <span class="command"><strong>-noFragmentCompression</strong></span></td><td>do not compress the fragments (avaliable by 2.x)</td></tr><tr><td><span class="command"><strong>-no-fragments</strong></span></td><td>do not generate fragment blocks (avaliable by 2.x, this will
produce almost the same filesystem as 1.x did)</td></tr><tr><td><span class="command"><strong>-noI</strong></span> or <span class="command"><strong>-noInodeCompression</strong></span></td><td>do not compress the inode table</td></tr><tr><td><span class="command"><strong>-nopad</strong></span></td><td>do not pad the resulting file system to a multiple of 4 KBytes</td></tr><tr><td><span class="command"><strong>-root-becomes [name]</strong></span></td><td>can be used while appending to a pre-existing squashed file system: it will make a new root, 
and [name] directory will contain all pre-existing files/directories
</td></tr><tr><td><span class="command"><strong>-version</strong></span></td><td>print the version, copyright and license message
</td></tr><tr><td><span class="command"><strong>-recover [name]</strong></span></td><td>recover filesystem data using recovery file [name] (3.3)
</td></tr><tr><td><span class="command"><strong>-no-recovery</strong></span></td><td>don't create a recovery file (3.3). 
</td></tr><tr><td><span class="command"><strong>-no-exports</strong></span></td><td>don't make avaliable file system to export via NFS (3.x)
</td></tr><tr><td><span class="command"><strong>-no-sparse</strong></span></td><td>don't check for sparse files (3.x)</td></tr><tr><td><span class="command"><strong>-processors [number]</strong></span></td><td>set the number of CPU to create file system. By default it will be used all avaliable processors (3.x)</td></tr><tr><td><span class="command"><strong>--read-queue [size]</strong></span></td><td>set input queue to [size] Mb.  (Default is 64 Mb)(3.x)</td></tr><tr><td><span class="command"><strong>-write-queue [size]</strong></span></td><td>set output queue to [size] Mb (3.x)</td></tr><tr><td><span class="command"><strong>-sort [sort_file]</strong></span></td><td>sort files relating to priorities in [sort_file] (3.x)</td></tr><tr><td><span class="command"><strong>-wildcards</strong></span></td><td>enable the extended shell wildcards to exclude directories/files (to be used with -e)</td></tr><tr><td><span class="command"><strong>-regex</strong></span></td><td>enable to use POSIX regular expressions (3.3)</td></tr></tbody></table></div></div><br class="table-break"><p>
In most cases, you should leave all compression/block options by default, as they allow 
<span class="command"><strong>mksquashfs</strong></span> to achieve the best possible compression ratios.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="unsquashing"></a>3.3. Using unsquashfs</h3></div></div></div><p>
<span class="command"><strong>unsquashfs</strong></span> is the tool for extracting data from squashed 
file systems. The general command-line format for <span class="command"><strong>unsquashfs</strong></span> is:
</p><pre class="programlisting">
unsquashfs [options] target [files/directories to extract]
</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
target is the squashed file system to extract.
</p></li></ul></div><p>
Notes for <span class="command"><strong>unsquashfs</strong></span> behavior:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> 
By not specifying any <span class="emphasis"><em>destination path</em></span>, unsquashfs extracts the compressed file system in the
<span class="emphasis"><em>./squashfs-root </em></span> directory.
</p></li><li class="listitem"><p> 
The tool does not extract a squashed file system on already exsisting directory
unless the <span class="command"><strong>-f</strong></span> option is specified.
</p></li><li class="listitem"><p>
You can specify on the command line, a multiple number of files/directories to extract and the items
to be extracted can be also be given in a file with <span class="command"><strong>-e [file]</strong></span> option.
</p></li></ul></div><p>
All possible options for <span class="command"><strong>unsquashfs</strong></span> are shown in the table below.
</p><div class="table"><a name="idm483"></a><p class="title"><b>Table 2. Command-line options of the <span class="command">unsquashfs</span> tool</b></p><div class="table-contents"><table class="table" summary="Command-line options of the unsquashfs tool" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><span class="command"><strong>-v[ersion] </strong></span></td><td>print the version, licence and copyright message
</td></tr><tr><td><span class="command"><strong>-i[nfo]</strong></span></td><td>print the files as they are extracted from the file system</td></tr><tr><td><span class="command"><strong>-l[ist]</strong></span></td><td>list the squashed file system without extracting files</td></tr><tr><td><span class="command"><strong>-li</strong></span></td><td>list files with theyr attributes as they are unsquashed (3.3)</td></tr><tr><td><span class="command"><strong>-ll</strong></span></td><td>list the squashed file system files with attributes without any extraction (3.3)</td></tr><tr><td><span class="command"><strong>-d[estination] path</strong></span></td><td>specify a destination path for unsquashed items</td></tr><tr><td><span class="command"><strong>-f[orce]</strong></span></td><td>if files exist overwrite them</td></tr><tr><td><span class="command"><strong>-s[tat]</strong></span></td><td>display file system's superblock informations (it can discover the file system version and the options used to compress it) (3.3)</td></tr><tr><td><span class="command"><strong>-e[f] [extract file]</strong></span></td><td>list of directories or files to extract (entries given one per line) (3.3)</td></tr><tr><td><span class="command"><strong>-r[egex]</strong></span></td><td>treat extract names as POSIX regular expressions (3.3)</td></tr></tbody></table></div></div><br class="table-break"><p>
Note that by 3.x release you can extract 1.x and 2.x squashed file system too.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creatingandusing"></a>4. Creating and using squashed file systems</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="creating"></a>4.1. Basic steps</h3></div></div></div><p>
In order to create a squashed file system out of a single directory 
(say, <code class="filename">/some/dir</code>), and output it to a regular file 
(thus, producing a file system image), you need to say only one magic phrase:
</p><pre class="programlisting">
	bash# mksquashfs /some/dir dir.sqsh
</pre><p>
<span class="command"><strong>mksquashfs</strong></span> will perform the squashing and print the resulting 
number of inodes and size of data written, as well as the average compression ratio. 
Now you have your <code class="filename">/some/dir</code> directory image in the
<code class="filename">dir.sqsh</code> file. You can now use the <span class="command"><strong>mount</strong></span> command 
to mount it using a loopback device:
</p><pre class="programlisting">
	bash# mkdir /mnt/dir
	bash# mount dir.sqsh /mnt/dir -t squashfs -o loop
</pre><p>
To check if you have what's expected:
</p><pre class="programlisting">
	bash# ls /mnt/dir
</pre><p>
If you want to output the file system directly into a device (say, your floppy at 
<code class="filename">/dev/fd0</code>):
</p><pre class="programlisting">
	bash# mksquashfs /some/dir /dev/fd0
</pre><p>
Then just <span class="command"><strong>mount</strong></span> the device:
</p><pre class="programlisting">
	bash# mount /dev/fd0 /mnt/floppy -t squashfs
</pre><p>
And check if it's okay:
</p><pre class="programlisting">
	bash# ls /mnt/floppy
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="squashing"></a>4.2. Squashing file systems</h3></div></div></div><p>
Operations described here correspond to most cases where a read-only compressed file 
system can be used, whether you want it to be on a block device or in a file. This 
could be anything from large FTP/HTTP-served archives that don't change often, to 
having a squashed <code class="filename">/usr</code> partition and anything alike
with these. 
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="squashing-ex1"></a>4.2.1. Example 1</h4></div></div></div><p>
Let's suppose you have a <code class="filename">/var/arch</code> directory with lots of files and
that you want to turn it into a squashed file system and keep it on your root partition
as a file (it will be a file system image that you will mount via a loopback device).
The operations needed to perform are as follows.
</p><p>
Squash the directory, then mount it via loopback to test it:
</p><pre class="programlisting">
	bash# mksquashfs /var/arch /var/arch.sqsh
	bash# mkdir /mnt/tmp
	bash# mount /var/arch.sqsh /mnt/tmp -t squashfs -o loop
	bash# ls /mnt/tmp
</pre><p>
If everything is as expected, make this file system mount automatically at boot time by
adding this line to your <code class="filename">/etc/fstab</code>:
</p><pre class="programlisting">
	/var/arch.sqsh	/var/arch	squashfs	ro,defaults	0 0
</pre><p>
Unmount the file system from the temporary mount point, and mount using it's fstab entry:
</p><pre class="programlisting">
	bash# umount /mnt/tmp
	bash# mount /var/arch
</pre><p>
Now just ensure that everything works fine:
</p><pre class="programlisting">
	bash# ls /var/arch
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="squashing-ex2"></a>4.2.2. Example 2</h4></div></div></div><p>
Say you have two hard disk partitions, <code class="filename">/dev/hda6</code> (which
is empty) and <code class="filename">/dev/hda7</code> (which is bigger than <code class="filename">/dev/hda6</code>,
mounted at <code class="filename">/var/arch</code>, contains some data and is full). Now, say you want to squash the <code class="filename">/dev/hda7</code> file system and move it to <code class="filename">/dev/hda6</code>, 
then use <code class="filename">/dev/hda7</code> for some other purposes. We will suppose you have
the following line in <code class="filename">/etc/fstab</code> (<span class="command"><strong>reiserfs</strong></span> is just an example file system
used on <code class="filename">/dev/hda7</code>):
</p><pre class="programlisting">
	/dev/hda7	/var/arch	reiserfs	defaults	0 0
</pre><p>
In the same fashion as with the previous example:
</p><pre class="programlisting">
	bash# mksquashfs /var/arch /var/arch.sqsh
	bash# mkdir /mnt/tmp
	bash# mount /var/arch.sqsh /mnt/tmp -t squashfs -o loop
	bash# ls /mnt/tmp
</pre><p>
If everything went fine, unmount <code class="filename">/dev/hda7</code> (if needed) and 
use <span class="command"><strong>dd</strong></span> to copy <code class="filename">/var/arch.sqsh</code>
to <code class="filename">/dev/hda6</code>:
</p><pre class="programlisting">
	bash# umount /dev/hda7
	bash# dd if=/var/arch.sqsh of=/dev/hda6
</pre><p>
Now change the line in <code class="filename">/etc/fstab</code> for <code class="filename">/dev/hda7</code> to:
</p><pre class="programlisting">
	/dev/hda6	/var/arch	squashfs	ro,defaults	0 0
</pre><p>
Mount the new file system and check to see if all went fine:
</p><pre class="programlisting">
	bash# mount /var/arch
	bash# ls /var/arch
</pre><p>
Don't forget to erase the unneeded file system image:
</p><pre class="programlisting">
	bash# rm /var/arch.sqsh
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="tinyemb"></a>4.3. Creating tiny/embedded systems</h3></div></div></div><p>
By saying "tiny/embedded", I mean Linux systems that are being built for
booting from floppy disks, IDE/USB flash disks, iso9660 CD-ROMs, small-sized hard drives and the like.
Whether you want to have your whole root file system on a single media (a single partition, a single floppy),
or have a modular system (several floppies or disk partitions), the procedure is almost identical.
Creating such Linux systems themselves is out of scope of this HOWTO - there are dedicated HOWTOs and guides
for this (like the <span class="emphasis"><em>Bootdisk HOWTO</em></span> and <span class="emphasis"><em>Linux From Scratch</em></span> - visit
<a class="ulink" href="http://www.tldp.org" target="_top">www.tldp.org</a> to retrieve these documents).
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sqflash"></a>4.3.1. Squashed file systems on floppy/flash/hard disks</h4></div></div></div><p>
In order to use SquashFS for creating Linux systems on small disks, you just have to follow
the usual steps for creating a minimal system, performing the following operations
at respective points:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
When developing a kernel for your system, make sure you enable SquashFS support
so it can mount squashed file systems
</p></li><li class="listitem"><p>
Use <span class="command"><strong>mksquashfs</strong></span> for creating read-only initial ram disks and/or root and/or other file systems
</p></li><li class="listitem"><p>
Don't forget to set file system types to <code class="filename">squashfs</code> in <code class="filename">/etc/fstab</code>
and/or the startup scripts of your system for mounting squashed file systems
</p></li></ol></div><p>
<span class="emphasis"><em>Floppy example</em></span>. Let's say you have your floppy system tree at
<code class="filename">/home/user/floppylinux</code> and you want to place the root file system on one
floppy and <code class="filename">/usr</code> on another. What you should do is:
</p><pre class="programlisting">
	bash# cd /home/user
	bash# mksquashfs floppylinux root.sqsh -e usr
	bash# mksquashfs floppylinux/usr usr.sqsh
</pre><p>
<span class="emphasis"><em>Note 1</em></span>: you can see here how we use the <span class="command"><strong>-e</strong></span>
option to exclude the <code class="filename">/usr</code> directory for root file system's image.
</p><p>
<span class="emphasis"><em>Note 2</em></span>: don't forget to specify <code class="filename">squashfs</code> in your root disk's
<code class="filename">/etc/fstab</code> or startup scripts when mounting the <code class="filename">/usr</code> file system.
</p><p>
Insert a root disk in your 3.5" floppy drive (I assume you have a lilo or grub on it, and, thus, a file system exists on this floppy,
and the root file system will reside under the <code class="filename">/boot</code> directory of this file system):
</p><pre class="programlisting">
	bash# mount /mnt/floppy
	bash# cp root.sqsh /mnt/floppy/boot
</pre><p>
When done, unmount the root floppy, change the floppy to a <code class="filename">/usr</code> disk and use <span class="command"><strong>dd</strong></span> to
transfer the <code class="filename">usr</code> file system:
</p><pre class="programlisting">
	bash# dd if=usr.sqsh of=/dev/fd0
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sqfloppy"></a>4.3.2. Squashed file systems on CD-ROMs</h4></div></div></div><p>
With SquashFS, you can compress large file systems that
will be used in live CDs (just as an example). For this purpose SquashFS is also used with UnionFS.

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Enable SquashFS in the linux kernel of the target system
</p></li><li class="listitem"><p>
Create a squashed root file system
</p></li><li class="listitem"><p>
Modify the <code class="filename">/etc/fstab</code> or startup scripts of the target system
to mount the squashd file system when you need it
</p></li></ol></div><p>

If you create a root file system out of a running Linux system,
use the <span class="command"><strong>-e</strong></span> option for <span class="command"><strong>mksquashfs</strong></span> to exclude
all pseudo-filesystems such as <code class="filename">/proc</code>, <code class="filename">/sys</code>
(on linux kernels after 2.5.x) and <code class="filename">/dev</code> 
(when using DevFS). Also, don't forget to add the file system image itself that is
being created with <span class="command"><strong>mksquashfs</strong></span> (I think you know the reasons
for these exclusions).

</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sqwrite"></a>4.4. Making it writeble</h3></div></div></div><p>
As mentioned, another interesting use for <span class="command"><strong>SquashFS</strong></span> is with <span class="command"><strong>Unionfs</strong></span> filesystem, which 
provides <span class="emphasis"><em>copy-on-write</em></span> semantics for the read-only file systems, enahancing the possibilities. (For unionfs you can 
look at <a class="ulink" href="http://www.filesystems.org/project-unionfs.html" target="_top">http://www.filesystems.org/project-unionfs.html</a>)
</p><p>
Just to make an example, you may want to make your /home/user squashed, to compress and backup your files without losing the possibility to apply changes or writing new files.
</p><p>
Create the <code class="filename">ro.fs</code> squashed file system and the <code class="filename">rw.fs</code> dir.
</p><pre class="programlisting">
bash# mksquashfs /home/user1 ro.fs
bash# mkdir /home/rw.fs
</pre><p>
Mount the squashed ro.fs file system using the loopback device 
</p><pre class="programlisting">
bash# mount -t squashfs ro.fs /mnt -o loop
</pre><p>
mount the unionfs file system, that makes <code class="filename">/mnt</code> and <code class="filename">/home/rw.fs</code> apparently merged under <code class="filename">/home/user1</code> location.
</p><pre class="programlisting">
bash# cd /home
bash# mount -t unionfs -o dirs=rw.fs=rw:/mnt=ro unionfs user1
</pre><p>
As you can see, now you can create new files in /home/user1.
</p><pre class="programlisting">
bash# cd /home/user1
bash# touch file1
bash# ls
</pre><p>
umount the unionfs and the squashfs file systems and list the content of /home/user1 and /home/rw.fs dir
</p><pre class="programlisting">
bash# cd ..
bash# umount /home/user1
bash# umount /mnt

bash# ls /home/user1
bash# ls /home/rw.fs 

</pre><p>
You can see that the new <code class="filename">file1</code> was created in <code class="filename">/home/rw.fs</code> 
</p><p>
When you want to add the new created files to the <span class="emphasis"><em>stable</em></span> and <span class="emphasis"><em>compressed</em></span> squashed file system, you have to add them to the exsisting one. 
</p><pre class="programlisting">
bash# mksquashfs /home/rw.fs /home/ro.fs
</pre><p>
Now, to mount your squashed user home directory at system startup, you
can do as follow:
</p><p>
Make squashfs and unionfs modules loaded at boot time.
</p><pre class="programlisting">
bash# echo squashfs &gt;&gt; /etc/modules
bash# echo unionfs &gt;&gt; /etc/modules
</pre><p>
Change the owner of the writeble branch to match user1.
</p><pre class="programlisting">
chown user1 /home/rw.fs
</pre><p>
Add these lines to /etc/fstab file to mount squashfs and unionfs 
at boot time.
</p><pre class="programlisting">
...
/home/ro.fs  /mnt squashfs loop 0 0
unionfs /home/user1 unionfs dirs=/home/rw.fs=rw:/mnt=ro 0 0
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="acknowledgements"></a>5. Acknowledgements</h2></div></div></div><p>
I would like to express my sincere thanks and immeasurable respect to:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Phillip Lougher - for his brilliant work under squashfs, for creating an exculsive
patch for linux-2.4.18, for his help with polishing this howto and answers to my mails
</p></li><li class="listitem"><p>
Tabatha Marshall at TLDP for helping me with bringing this HOWTO to the final 1.0 release
</p></li><li class="listitem"><p>
Everybody at <a class="ulink" href="http://www.tldp.org" target="_top">The Linux Documentation Project</a> for
their great work under all the HOWTOs and guides that helped me a lot with exploring and 
hacking Linux
</p></li><li class="listitem"><p>
All those at the TLDP mailing lists who helped me with getting started
</p></li><li class="listitem"><p>
Endless thanks and respect to everybody who develops open-source software
</p></li></ul></div><p>Artemiy I. Pavlov</p><p>
I want to thank Artemiy for his patience answering my emails, allowing me to work to this howto. I would express also my thanks and respect to everybody who is involved in free software</p><p>Marco Cecchetti</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="license"></a>6. License</h2></div></div></div><p>
This document may be used and distributed under the terms and conditions set forth in 
the Open Content licence. In short, this means that you can freely modify and re-distribute 
the HOWTO under the main condition that you keep the author and copyright the article along. 
The full text of the licence is available at <a class="ulink" href="http://www.opencontent.org/opl.shtml" target="_top">http://www.opencontent.org/opl.shtml</a>
</p></div></div></body></html>
