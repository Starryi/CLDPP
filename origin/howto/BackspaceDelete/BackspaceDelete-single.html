<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux Backspace/Delete mini-HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux <B
CLASS="KEYCAP"
>Backspace</B
>/<B
CLASS="KEYCAP"
>Delete</B
> mini-HOWTO</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN6"
>Sebastiano Vigna</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:vigna@acm.org"
>vigna@acm.org</A
>&#62;</CODE
></P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.6</TD
><TD
ALIGN="LEFT"
>19 Jan 2002</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Included many comments from Alex Boldt and Chung-Rui Kao.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.5</TD
><TD
ALIGN="LEFT"
>3 May 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Updated for new distros and the tput trick.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.4</TD
><TD
ALIGN="LEFT"
>7 December 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Updated for Red Hat 7.0 and Helix Gnome conflicts.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.3</TD
><TD
ALIGN="LEFT"
>18 October 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Name change.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.2</TD
><TD
ALIGN="LEFT"
>15 October 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Updated. Added "What If Nothing Works" section.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.1</TD
><TD
ALIGN="LEFT"
>13 September 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added tcsh fixes</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v1.0</TD
><TD
ALIGN="LEFT"
>5 September 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>First release</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#INTRO"
>Introduction</A
></DT
><DT
>2. <A
HREF="#ACTIONS"
>How Keys Are Turned Into Actions</A
></DT
><DT
>3. <A
HREF="#WHY"
>Why It Doesn't (Always) Work</A
></DT
><DT
>4. <A
HREF="#X"
>X</A
></DT
><DT
>5. <A
HREF="#WRITING"
>What You Should Do When Writing Applications</A
></DT
><DT
>6. <A
HREF="#SYSTEM"
>What You Should Do On Your System</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN209"
>What Needs to Be Done</A
></DT
><DT
>6.2. <A
HREF="#AEN270"
>How to Do It</A
></DT
><DT
>6.3. <A
HREF="#AEN343"
>Fixing for <SPAN
CLASS="APPLICATION"
>tcsh</SPAN
></A
></DT
></DL
></DD
><DT
>7. <A
HREF="#NOTWORK"
>What If Nothing Works</A
></DT
><DT
>8. <A
HREF="#MOREHACK"
>More Hacking</A
></DT
><DT
>9. <A
HREF="#CONCL"
>Conclusions</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="INTRO"
>1. Introduction</A
></H2
><P
>Every Linux user has been sooner or later trapped in a situation in
	 which having working <B
CLASS="KEYCAP"
>Backspace</B
> and <B
CLASS="KEYCAP"
>Delete</B
>
	 keys on the console and on X seemed impossible. This paper explains why
	 this happens and suggests solutions. The notions given here are essentially
	 distribution-independent: due to the widely different content of system
	 configuration files in each distribution, I will try to give the reader
	 enough knowledge to think up his/her own fixes, if necessary.</P
><P
>I assume that the <B
CLASS="KEYCAP"
>Backspace</B
> key should go back one
	 character and then erase the character under the cursor. On the other hand,
	 the <B
CLASS="KEYCAP"
>Delete</B
> key should delete the character under the
	 cursor, without moving it. If you think that the function of the two keys
	 should be exchanged, in spite of the fact that most keyboards feature an
	 arrow pointing to the <EM
>left</EM
> (<B
CLASS="KEYCAP"
>&#8592;</B
>)
	 on the <B
CLASS="KEYCAP"
>Backspace</B
> key, then this paper will not give you
	 immediate solutions, but certainly you may find the explanations given here
	 useful.</P
><P
>Another assumption is that the fixes should alter only local (user)
	 files. No standard part of the distribution should be altered. Finally,
	 this document discusses how to set up your system so that applications get
	 the right events. If an application decides to interpret such events in an
	 idiosyncratic way, the only possible fix is to reconfigure the
	 application.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Since the first release of this Mini-HOWTO things have become even
    more entangled. Different distributions of the same terminal emulator
    (e.g., <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> as provided by Red Hat
    7.0, Helix Code/Ximian or even Red Hat&#8805;7.1) generate different
    <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> sequences. Due to this mismatch, now the terminal
    databases correspond even less to the terminal emulators they are supposed
    to describe. To set a firm ground for the following discussion, we assume
    basically as correct settings the ones proposed in the <A
HREF="http://www.debian.org/doc/debian-policy/"
TARGET="_top"
>Debian keyboard
    policy</A
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ACTIONS"
>2. How Keys Are Turned Into Actions</A
></H2
><P
>When a key is pressed on the keyboard, a number of hardware and
	 software components cooperate so as to guarantee that the intended meaning
	 of the key (e.g., emitting a certain character) matches the actual
	 behaviour of the key. I will concentrate on the software side (as our
	 control on the hardware part is nonexistent), and in particular, for the
	 time being, on the events related to console output.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Hitting a key causes raw keyboard <I
CLASS="FIRSTTERM"
>scancodes</I
>
		  to be generated; these scancodes are then transformed in a
		  <I
CLASS="FIRSTTERM"
>keycode</I
>.  On an i386 system, usually the key
		  <B
CLASS="KEYCAP"
>Backspace</B
> emits <SPAN
CLASS="KEYCODE"
>14</SPAN
> and the key
		  <B
CLASS="KEYCAP"
>Delete</B
> emits <SPAN
CLASS="KEYCODE"
>111</SPAN
>.</P
></LI
><LI
><P
>The keycodes are translated by the keyboard library into a
		  <I
CLASS="FIRSTTERM"
>keyboard symbol (keysym)</I
> using the keyboard
		  definition loaded by the user. If you look into your keyboard database
		  (e.g., in <TT
CLASS="FILENAME"
>/lib/kbd/</TT
>), you'll discover several
		  definitions for different computers, different layouts and possibly
		  different interpretations of the same keys (e.g., one could desire that
		  the two <B
CLASS="KEYCAP"
>Alt</B
> keys really behave as distinct
		  modifiers). The Linux console keyboard layout assigns keysym
		  <SPAN
CLASS="KEYSYM"
>Delete</SPAN
> to keycode 14 and keysym
		  <SPAN
CLASS="KEYSYM"
>Remove</SPAN
> to keycode 111. This may seem strange, but the
		  Linux console emulates a VT100 terminal, and this is the way things
		  work in that realm.<A
NAME="AEN77"
HREF="#FTN.AEN77"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></P
></LI
><LI
><P
>Our journey has still to come to an end. Console applications
		  read <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> sequences, not keysyms. So the console
		  must read keysyms and translate them into <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>
		  sequences that suitably encode the keys. Of course, this operation must
		  be performed in a way that is understandable by applications. For
		  instance, on the Linux console the <SPAN
CLASS="KEYSYM"
>Delete</SPAN
> keysym is
		  mapped to the <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> code 127 (<CODE
CLASS="SYMBOL"
>DEL</CODE
>),
		  the <SPAN
CLASS="KEYSYM"
>Remove</SPAN
> keysym on a suitable escape sequence, and
		  the <SPAN
CLASS="KEYSYM"
>BackSpace</SPAN
> keysym to <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> code
		  8 (<CODE
CLASS="SYMBOL"
>BS</CODE
>).</P
></LI
><LI
><P
>Finally, we must in a sense roll back to what we had before and
		  translate the <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> sequences generated by each key
		  into a <I
CLASS="FIRSTTERM"
>key capability</I
>. This goal is reached by a
		  <I
CLASS="FIRSTTERM"
>terminal database</I
>, which contains, for each kind
		  of terminal, a reverse mapping from sequences of characters to key
		  capabilities (which are essentially a subset of the keysyms).<A
NAME="AEN95"
HREF="#FTN.AEN95"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Unfortunately, there are two <SPAN
CLASS="QUOTE"
>"standard"</SPAN
> terminal
			 databases, <SPAN
CLASS="APPLICATION"
>termcap</SPAN
> and
			 <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
>. Depending on your distribution,
			 you could be using either one of them, or the database could even
			 depend on the application. Our discussion will concentrate on the
			 more modern <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> database, but the
			 suggested fixes take both into consideration. </P
></TD
></TR
></TABLE
></DIV
><P
>For instance, on the Linux console <B
CLASS="KEYCAP"
>F1</B
> generates
		  an escape followed by <TT
CLASS="LITERAL"
>[[A</TT
>, which can be translated
		  to the capability <TT
CLASS="LITERAL"
>key_f1</TT
> by looking into the
		  terminal-database entry of the console (try <B
CLASS="COMMAND"
>infocmp
		  linux</B
> if you want to have a look at the entry). A very good
		  and thorough discussion of terminal databases can be found in
		  <ACRONYM
CLASS="ACRONYM"
>GNU</ACRONYM
>'s <SPAN
CLASS="APPLICATION"
>termcap</SPAN
>
		  manual. Usually Linux applications use the newer
		  <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> database, contained in the
		  <SPAN
CLASS="APPLICATION"
>ncurses</SPAN
> package.</P
><P
>Maybe at this point not surprisingly, the Linux console terminfo
		  entry maps <CODE
CLASS="SYMBOL"
>DEL</CODE
> to the <TT
CLASS="LITERAL"
>kbs</TT
>
		  (backspace key) capability, and escape followed by
		  <TT
CLASS="LITERAL"
>[3~</TT
> to the <TT
CLASS="LITERAL"
>kdch1</TT
>
		  (<SPAN
CLASS="QUOTE"
>"delete-one-char"</SPAN
> key) capability. Even if you could
        find strange that the <B
CLASS="KEYCAP"
>Backspace</B
> key emits a <CODE
CLASS="SYMBOL"
>DEL</CODE
>,
        the terminal database puts everything back into its right place, and correctly
        behaving applications will interpret <CODE
CLASS="SYMBOL"
>DEL</CODE
> as the capability
        <TT
CLASS="LITERAL"
>kbs</TT
>, thus deleting the character to the left of the cursor.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WHY"
>3. Why It Doesn't (Always) Work</A
></H2
><P
>I hope the basic problem is clear at this point: there is a
	 bottleneck between the keyboard and console applications, that is, the fact
	 that they can only communicate by <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> sequences. So
	 special keys must be first translated from keysyms to sequences, and then
	 from sequences to key capabilities. Since different consoles have different
	 ideas about what this translation can look like, we need a terminal
	 database. The system would work flawlessly, except for a small problem: it
	 is not always set up correctly, and not everyone uses it.
	 </P
><P
>Applications must have a way to know which database entry to use:
    this is accomplished by suitably setting the <CODE
CLASS="ENVAR"
>TERM</CODE
>
    environment variable. In some cases, there is a mismatch between the
    terminal emulator and the content of the database entry suggested by
    <CODE
CLASS="ENVAR"
>TERM</CODE
>.</P
><P
>Moreover, many applications <EM
>do not use</EM
> the
	 terminal database (or at least not all of it), and consider
	 <CODE
CLASS="SYMBOL"
>BS</CODE
> and <CODE
CLASS="SYMBOL"
>DEL</CODE
> <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> codes
	 with an intended meaning: thus, without looking at the database, they
	 assign them semantics (usually, of course, the semantics is removing the
	 character before or under the cursor). So now our beautiful scheme is
	 completely broken (as every Linux user is bitterly aware). For instance,
	 the <SPAN
CLASS="APPLICATION"
>bash</SPAN
> assumes that <CODE
CLASS="SYMBOL"
>DEL</CODE
>
	 should do a <SPAN
CLASS="ACTION"
>backward-delete-char</SPAN
>, that is,
	 backspace. Hence, on a fresh install the <B
CLASS="KEYCAP"
>Backspace</B
>
	 key works on the console as expected, but just because of two twists in a
	 row! Of course, the <B
CLASS="KEYCAP"
>Delete</B
> key does not work. This happens
	 because the <SPAN
CLASS="APPLICATION"
>bash</SPAN
> does not look into the terminal
	 database for the <TT
CLASS="LITERAL"
>kdch1</TT
> capability.</P
><P
>Just to illustrate how things have become entangled, consider the
	 <B
CLASS="COMMAND"
>fix_bs_and_del</B
> script provided with the Red Hat
	 distribution (and maybe others). It assigns on-the-fly the
	 <SPAN
CLASS="KEYSYM"
>BackSpace</SPAN
> keysym to the <B
CLASS="KEYCAP"
>Backspace</B
> key,
	 and the <SPAN
CLASS="KEYSYM"
>Delete</SPAN
> keysym to the <B
CLASS="KEYCAP"
>Delete</B
>
	 key. Now the shell works! Unfortunately, all programs relying on the
	 correct coupling of keysym generation and terminal database mappings are
	 now not working at all, as the <SPAN
CLASS="KEYSYM"
>Delete</SPAN
> keysym is mapped to
	 <CODE
CLASS="SYMBOL"
>DEL</CODE
>, and the latter to the <TT
CLASS="LITERAL"
>kbs</TT
> key
	 capability by the terminfo database, so in such programs both keys produce
	 backspacing.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="X"
>4. X</A
></H2
><P
>The situation under X is not really different. There is just a
	 different layer, that is, the X window system translates the scancodes into
	 its own keysyms, which are much more varied and precise than the console
	 ones, and feeds them into applications (by the way, this is the reason why
	 <SPAN
CLASS="APPLICATION"
>XEmacs</SPAN
> is not plagued by the problem: X
	 translates keycode 22 to keysym <SPAN
CLASS="KEYSYM"
>BackSpace</SPAN
> and keycode 107
	 to keysym <SPAN
CLASS="KEYSYM"
>Delete</SPAN
>, and then the user can easily assign to
	 those keysyms the desired behaviour). Of course, a terminal emulator
	 program (usually a VT100 emulator in the X world) must translate the
	 X keysyms into ASCII sequences, so we are again in our sore
	 business.</P
><P
>More in detail, usually <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> behaves
	 exactly like the console (i.e., it emits the same <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>
	 sequences), but, for instance, <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> in
	 Red Hat &#60;7.0 or &#8805;7.1 emits <CODE
CLASS="SYMBOL"
>BS</CODE
> for
	 <B
CLASS="KEYCAP"
>Backspace</B
> and <CODE
CLASS="SYMBOL"
>DEL</CODE
> for
	 <B
CLASS="KEYCAP"
>Delete</B
>. The real fun starts when you realise that by
	 default they use the <EM
>same</EM
> terminal-database entry, so
	 the fact that the <TT
CLASS="LITERAL"
>kbs</TT
> capability is associated to an
	 <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> <CODE
CLASS="SYMBOL"
>DEL</CODE
> makes all correctly behaving
	 applications produce the same behaviour for the <B
CLASS="KEYCAP"
>Backspace</B
>
	 and <B
CLASS="KEYCAP"
>Delete</B
> keys in
	 <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
>. The simple statement
	 <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;bash$ export TERM=gnome</PRE
></FONT
></TD
></TR
></TABLE
> can solve the problem in this case for
	 correctly behaving applications. Well, not always, because your system
	 could lack an entry in the terminal database named
	 <TT
CLASS="LITERAL"
>gnome</TT
>, in particular if it is not very up-to-date.</P
><P
>In any case, this is not always a solution: if, for instance, you
    have a Red Hat 7.0 distribution, your
    <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> behaves like a console. But
    beware: if you upgraded your desktop using the Helix distribution, then
    your <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> behaves like a pre-7.0 Red
    Hat.</P
><P
>Just to make easier the following discussion, let us define
    <I
CLASS="FIRSTTERM"
>standard</I
> a VT100 emulator behaving like the console,
    and <I
CLASS="FIRSTTERM"
>deviant</I
> one that emits <CODE
CLASS="SYMBOL"
>BS</CODE
> for
    <B
CLASS="KEYCAP"
>Backspace</B
> and <CODE
CLASS="SYMBOL"
>DEL</CODE
> for
    <B
CLASS="KEYCAP"
>Delete</B
>.<A
NAME="AEN188"
HREF="#FTN.AEN188"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>
    Thus, for instance, <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> has always been
    standard in the Debian distribution, while it switched a couple of times
    from standard to deviant and viceversa in Red Hat; the behaviour of
    <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> is even more erratic. See <A
HREF="#MOREHACK"
>Section 8</A
> for some information on how to turn a deviant terminal
    into a standard one.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WRITING"
>5. What You Should Do When Writing Applications</A
></H2
><P
>When you write a console application, be kind to the user and try to
	 understand what comes from the standard input using the following fallback
	 chain:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>open the right <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> entry, and try
		  to process the sequence so as to discover whether it has a particular
		  meaning on the current terminal; if so, use the
		  <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> semantics;</P
></LI
><LI
><P
>use the <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> intended meaning on line feeds,
		  newlines, tab characters and, of course, <CODE
CLASS="SYMBOL"
>BS</CODE
> and
		  <CODE
CLASS="SYMBOL"
>DEL</CODE
>. Crossing your finger could also be useful.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYSTEM"
>6. What You Should Do On Your System</A
></H2
><P
>Note again that the main issue that confuses people trying to fix
	 their system is that usually they are fixing thing in the wrong
	 place. Since the parts that work often just work by chance, trying to fix
	 the system assuming something is broken will often lead to change correct
	 settings into incorrect settings.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN209"
>6.1. What Needs to Be Done</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="DEVIANCE"
>6.1.1. Detecting Deviance</A
></H4
><P
>The first step towards a clean solution is to know exactly which
		  terminals are deviant and which not. Usually they all behave like the
		  console, and in this case the modifications to get everything working
		  are minimal. If, however, you have some deviant terminal (e.g., a
		  deviant version of <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
>), you will
		  have to treat it in a special way.</P
><P
>The following C one-liner
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;void main(void) {int c; while(c = getchar()) printf("%d 0x%02X\n", c, c);}</PRE
></FONT
></TD
></TR
></TABLE
>
may help you. Put the line into a file named <TT
CLASS="FILENAME"
>ascii.c</TT
>,
compile it with <B
CLASS="COMMAND"
>gcc ascii.c -o ascii</B
>, type
<B
CLASS="COMMAND"
>./ascii</B
> and press a key followed by <B
CLASS="KEYCAP"
>RETURN</B
>.
The program will display the decimal and hexadecimal codes of the
<ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
> sequence produced (you may want to do a <B
CLASS="COMMAND"
>stty
erase ^-</B
> first to get really all the codes). Now you can easily see
what <B
CLASS="KEYCAP"
>Backspace</B
> key does: if it emits a <CODE
CLASS="SYMBOL"
>DEL</CODE
>
(127), you have a standard emulator, if it emits a <CODE
CLASS="SYMBOL"
>BS</CODE
> (8) you have
a deviant one.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN226"
>6.1.2. Distinguishing Between Emulators</A
></H4
><P
>If you have some deviant terminal emulator, you must distinguish
		  it from the standard ones.  Theoretically, this should not be a problem
		  because there are different entries in the terminal database for
		  terminals with different sequences (the entry used depends on the value
		  of the <CODE
CLASS="ENVAR"
>TERM</CODE
> variable).</P
><P
>Here we take the approach that the <TT
CLASS="LITERAL"
>gnome</TT
> entry
        should be used for all deviant VT100 emulators, and the
        <TT
CLASS="LITERAL"
>xterm</TT
> entry for the standard ones. This is in line
        with several distributions (except a few cases like RedHat &#8804;5.0,
        where the <TT
CLASS="LITERAL"
>xterm</TT
> entry is deviant).</P
><P
>However, <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> uses by
        default the same entry as <SPAN
CLASS="APPLICATION"
>xterm</SPAN
>, so if one
        is deviant and the other one is not you will need to find a way to tell
        them apart. The option <TT
CLASS="LITERAL"
>termname</TT
> of
        <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> allows the user to set the
        <CODE
CLASS="ENVAR"
>TERM</CODE
> variable to a more sensible name. However, in older
        versions of <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> the option does
        not work. Moreover, sometimes it is not easy to modify the way
        <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> is started.</P
><P
>A good idea here is to exploit the fact that
		  <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> sets the
		  <CODE
CLASS="ENVAR"
>COLORTERM</CODE
> variable to
		  <TT
CLASS="LITERAL"
>gnome-terminal</TT
>. Thus, by adding a simple test to the
		  shell configuration files we can fix the <CODE
CLASS="ENVAR"
>TERM</CODE
>
		  variable.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN247"
>6.1.3. Fixing the Terminal Database</A
></H4
><P
>Our problem now is that the terminal database could lack a
		  <TT
CLASS="LITERAL"
>gnome</TT
> entry for deviant terminals (this happens on a
		  number of <SPAN
CLASS="APPLICATION"
>termcap</SPAN
> and
		  <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> versions). Recent
		  <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> databases have an entry
		  <TT
CLASS="LITERAL"
>gnome</TT
>, but, in any case, since
		  <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> behaves essentially like
		  <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> modulo our famous two keys, it is
		  possible to automagically generate a brand new correct entry.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN257"
>6.1.4. Fixing the Shell Behaviour</A
></H4
><P
>The <SPAN
CLASS="APPLICATION"
>readline</SPAN
> library used by the
		  <SPAN
CLASS="APPLICATION"
>bash</SPAN
> and by many other programs to read the
		  input line can be customized so to recognize specific sequences of
		  characters. The customization can also depend on the
		  <CODE
CLASS="ENVAR"
>TERM</CODE
> variable, so once we can distinguish terminals we
		  can do fine tuning of the keyboard.</P
><P
>Moreover, if you want <SPAN
CLASS="APPLICATION"
>less</SPAN
> and other
		  application that do raw line input to work correctly, you must convince
		  the shell that under a deviant terminal emulator the erase character is
		  <CODE
CLASS="SYMBOL"
>BS</CODE
>, and not <CODE
CLASS="SYMBOL"
>DEL</CODE
> (in the other case
		  the <B
CLASS="KEYCAP"
>Backspace</B
> key is already emitting
		  <CODE
CLASS="SYMBOL"
>DEL</CODE
>, so we do not have to do anything). This can be
		  done using the command <B
CLASS="COMMAND"
>stty</B
>.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN270"
>6.2. How to Do It</A
></H3
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>These fixes have some drawbacks. First, they work only for the
		  specified terminals. Second, in theory (but this is unlikely to happen)
		  they could confuse the <SPAN
CLASS="APPLICATION"
>readline</SPAN
> library on
		  other terminals. Both limitations are however mostly harmless.</P
></TD
></TR
></TABLE
></DIV
><P
>First of all, check with <B
CLASS="COMMAND"
>infocmp gnome</B
>
		whether you already have a <TT
CLASS="LITERAL"
>gnome</TT
> entry in your
		<SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> database (we will fix
		<SPAN
CLASS="APPLICATION"
>termcap</SPAN
> later). If the entry does not exist,
		the following command

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;bash$ tic &#60;(infocmp xterm |\
        sed 's/xterm|/gnome|/' |\
        sed 's/kbs=\\177,/kbs=^H,/' |\
        sed 's/kdch1=\\E\[3~,/kdch1=\\177,/')</PRE
></FONT
></TD
></TR
></TABLE
>

will create a correct one in <TT
CLASS="FILENAME"
>~/.terminfo</TT
>. If the same
command is launched by the root, it will generate the entry in the global
database (you can override this behaviour by setting <CODE
CLASS="ENVAR"
>TERMINFO</CODE
> to
<TT
CLASS="FILENAME"
>~/.terminfo</TT
>). Note that if your <TT
CLASS="LITERAL"
>xterm</TT
>
entry is already deviant (e.g., you have a Red Hat &#8804;5.0) the script will copy it unchanged, which is
exactly what we want.</P
><P
>Now, add the following snippet to
		<TT
CLASS="FILENAME"
>~/.inputrc</TT
><A
NAME="ADDINPUTRC"
HREF="#FTN.ADDINPUTRC"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;"\e[3~": delete-char</PRE
></FONT
></TD
></TR
></TABLE
>
      This line teaches the <SPAN
CLASS="APPLICATION"
>readline</SPAN
> library how to
      manage your standard <B
CLASS="KEYCAP"
>Delete</B
> key for standard emulators,
      and with a bit of luck it should not interfere with other
      terminals. However, now we must also explain to the library the meaning
      of the <CODE
CLASS="SYMBOL"
>DEL</CODE
> character on deviant terminals, for instance
      by adding
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;$if term=gnome
DEL: delete-char
Meta-DEL: kill-word
"\M-\C-?": kill-word
$endif</PRE
></FONT
></TD
></TR
></TABLE
>
      to <TT
CLASS="FILENAME"
>~/.inputrc</TT
>. If <SPAN
CLASS="APPLICATION"
>xterm</SPAN
>
      is deviant, too, you must add other three lines for it. On the other
      hand, if no terminal emulator is deviant this part is not needed. All
      these changes can be made global by altering the
      <TT
CLASS="FILENAME"
>/etc/inputrc</TT
> file.</P
><P
>Note that the conditional assignments make deviant terminal
		emulators work <EM
>given that the <CODE
CLASS="ENVAR"
>TERM</CODE
> variable is
		set correctly</EM
>. To guarantee this, there are a number of
		techniques.  First of all, since the default value of the
		<CODE
CLASS="ENVAR"
>TERM</CODE
> variable for
		<SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> is <TT
CLASS="LITERAL"
>xterm</TT
>, if
		all terminals are not deviant then we do nothing. If, however, a terminal
		that by default uses the <TT
CLASS="LITERAL"
>xterm</TT
> entry is deviant you
		must find a way to set the <CODE
CLASS="ENVAR"
>TERM</CODE
> variable correctly; assume
		for instance this is true of
		<SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
>.</P
><P
>The simplest way to obtain this effect is to start
      <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> with the argument
      <TT
CLASS="LITERAL"
>--termname=gnome</TT
>, for instance by suitably setting the
      command line in the launcher on the <ACRONYM
CLASS="ACRONYM"
>GNOME</ACRONYM
> panel. If
      however you have an old version, and this method does not work, you can
      add the lines
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;if [ "$COLORTERM" = "gnome-terminal" ]
then
    export TERM=gnome
fi</PRE
></FONT
></TD
></TR
></TABLE
>
to your <TT
CLASS="FILENAME"
>~/.bashrc</TT
> configuration file<A
NAME="AEN316"
HREF="#FTN.AEN316"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
>.  The assignment is executed
only under <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
>, and sets correctly the
<CODE
CLASS="ENVAR"
>TERM</CODE
> variable.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Setting the terminal to <TT
CLASS="LITERAL"
>gnome</TT
> could prevent
<B
CLASS="COMMAND"
>ls</B
> from using colours, as many versions of
<B
CLASS="COMMAND"
>ls</B
> do not know that
<SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> is colour capable. To avoid this
problem, create a configuration file <TT
CLASS="FILENAME"
>~/.dircolors</TT
> with
<B
CLASS="COMMAND"
>dircolors --print-database &#62;~/.dircolors</B
>, and add a line
<KBD
CLASS="USERINPUT"
>TERM=gnome</KBD
> to the configuration file.</P
></TD
></TR
></TABLE
></DIV
><P
>We will now generate on-the-fly a suitable
<SPAN
CLASS="APPLICATION"
>termcap</SPAN
> entry for deviant terminal emulators; this
can be done as follows, always in <TT
CLASS="FILENAME"
>~/.bashrc</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;if [ "$TERM" = "gnome" ]
then
    export TERMCAP=$(infocmp -C gnome | grep -v '^#' | \
                    tr '\n\t' '  ' | sed 's/\\  //g' | sed s/::/:/g)
fi</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Finally, we must explain to the terminal device which character is
      generated by the erase key. Since usually the erase key is expected to
      backspace, there is a nice trick taken from the Red Hat
      <TT
CLASS="FILENAME"
>/etc/bashrc</TT
> that works: add this to
      <TT
CLASS="FILENAME"
>~/.bashrc</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;KBS=$(tput kbs)
if [ ${#KBS} -eq 1 ]; then stty erase $KBS; fi</PRE
></FONT
></TD
></TR
></TABLE
>
It's a simple idea: we read from the terminal database the capability
<TT
CLASS="LITERAL"
>kbs</TT
>, and set the erase character to its value if it is a
single character (which happens in both standard and deviant terminals).</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Certain distributions could have fixes already in place in the
		  system-wide <TT
CLASS="FILENAME"
>/etc/inputrc</TT
> configuration file. In
		  this case you can eliminate redundant lines from your
		  <TT
CLASS="FILENAME"
>~/.inputrc</TT
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN343"
>6.3. Fixing for <SPAN
CLASS="APPLICATION"
>tcsh</SPAN
></A
></H3
><P
>In the case of the <SPAN
CLASS="APPLICATION"
>tcsh</SPAN
>, the fixes go
all in <TT
CLASS="FILENAME"
>~/.tcshrc</TT
>, and follow the same rationale as the ones for the
<SPAN
CLASS="APPLICATION"
>bash</SPAN
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;bindkey "^[[3~" delete-char

if ($?COLORTERM) then
   if ($COLORTERM == "gnome-terminal") then
      setenv TERM gnome
   endif
endif

if ($?TERM) then
   if ($TERM == "gnome") then
      setenv TERMCAP \
       "`infocmp -C gnome | grep -v '^#' | tr '\n\t' '  ' | sed 's/\\  //g' | sed s/::/:/g`"
      bindkey "^?" delete-char
      bindkey "^[^?" delete-word
      bindkey "\377" delete-word
   endif
endif

set KBS=`tput kbs`
if (${%KBS} == 1) then 
   stty erase $KBS
endif&#13;</PRE
></FONT
></TD
></TR
></TABLE
>
The second part must be replicated for every deviant terminal. Of course, if a
<SPAN
CLASS="APPLICATION"
>termcap</SPAN
> entry already exists it is not necessary to
generate it.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="NOTWORK"
>7. What If Nothing Works</A
></H2
><P
>The first thing to do is understanding which <ACRONYM
CLASS="ACRONYM"
>ASCII</ACRONYM
>
	 codes are produced by a certain key using the <A
HREF="#DEVIANCE"
>C
	 one-liner</A
>.</P
><P
>Once you know which sequences are produced, you must check the
	 current <SPAN
CLASS="APPLICATION"
>terminfo</SPAN
> entry with
	 <B
CLASS="COMMAND"
>infocmp</B
> (don't be scared by the amount of information
	 printed!) and be sure that the <TT
CLASS="LITERAL"
>kbs</TT
> and
	 <TT
CLASS="LITERAL"
>kdch1</TT
> capabilities correspond to the right sequences
	 (that is, the one produced by the respective keys). Moreover, you must
	 check with <B
CLASS="COMMAND"
>stty -a</B
> that the erase character is the one
	 emitted by the <B
CLASS="KEYCAP"
>Backspace</B
> key (note that
	 <TT
CLASS="LITERAL"
>^H</TT
> represent <CODE
CLASS="SYMBOL"
>BS</CODE
> whereas
	 <TT
CLASS="LITERAL"
>^?</TT
> represents <CODE
CLASS="SYMBOL"
>DEL</CODE
>).</P
><P
>If there is a mismatch, there can be several different reason: wrong
	 content of the <CODE
CLASS="ENVAR"
>TERM</CODE
> variable, wrong entry of the terminal
	 database, wrong terminal emulation under X. I hope at this point you have
	 enough information to dig the solution autonomously.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If different applications behave in different ways, it is likely
		that some of them are using the terminal database correctly, and some are
		not. Remember that the fact that the keys produce the right behaviour in
		a certain application does not mean that the application is using
		correctly the terminal database&#8212;they could work just by chance. If you
		want to have an independent check, you can try whether the
		<A
HREF="http://ne.dsi.unimi.it/"
TARGET="_top"
><B
CLASS="COMMAND"
>ne</B
></A
>
		editor works. <B
CLASS="COMMAND"
>ne</B
> uses all terminal capabilities,
		including <TT
CLASS="LITERAL"
>kbs</TT
> and <TT
CLASS="LITERAL"
>kdch1</TT
>, and uses
		intended meaning only as a last resource.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MOREHACK"
>8. More Hacking</A
></H2
><P
>So, you're not happy with the information you got. In this case,
	 there is even more hacking you can do on the Backspace/Delete issue, using
	 suitable commands that get or set the way X and the console handle
	 keys.</P
><P
>It could happen that, for some reason, what I said talking about
	 <A
HREF="#X"
>X</A
> is not true, that is, X does
	 <EM
>not</EM
> translate keycode 22 to keysym
	 <SPAN
CLASS="KEYSYM"
>BackSpace</SPAN
> and keycode 107 to keysym
	 <SPAN
CLASS="KEYSYM"
>Delete</SPAN
> (or even that, on your particular keyboard, the
	 keycodes associated to <B
CLASS="KEYCAP"
>Backspace</B
>/<B
CLASS="KEYCAP"
>Delete</B
>
	 are not 22 and 107). To be sure of that, you need to use
	 <B
CLASS="COMMAND"
>xev</B
>, a simple X application that will display the
	 keycode and keysym associated to the key you press. If anything goes wrong,
	 there are several ways you can fix the problem: the easy, temporary way is
	 to use <B
CLASS="COMMAND"
>xmodmap</B
>, a command that lets you change many
	 settings related to X keyboard handling. For instance,
<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>xmodmap -e "keycode 22 = BackSpace"
xmodmap -e "keycode 107 = Delete"</PRE
></FONT
></TD
></TR
></TABLE
>
    will set correctly the keysyms (assuming that 22 and 107 are the correct
    keycodes for you). In case you want to do some changes permanently, you can
    play with the resources <CODE
CLASS="VARNAME"
>vt100.backArrowKey</CODE
>,
    <CODE
CLASS="VARNAME"
>vt100.translations</CODE
> and <CODE
CLASS="VARNAME"
>ttyModes</CODE
> of
    <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> (and similar terminal applications) in the
configuration file <TT
CLASS="FILENAME"
>~/.Xdefaults</TT
>. One
    possibility, for instance, is
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>XTerm.VT100.Translations: \
        &#60;Key&#62;BackSpace: string(0x7F)\n\
        &#60;Key&#62;Delete:    string("\033[3~")</PRE
></FONT
></TD
></TR
></TABLE
>
	 You should take a look at the <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> man page for
	 more information.</P
><P
>The program that does for the console what <B
CLASS="COMMAND"
>xev</B
>
	 does for X is <B
CLASS="COMMAND"
>showkeys</B
>: it will dump the console
	 keycodes of the keys you press. Combining <B
CLASS="COMMAND"
>showkeys</B
> with
	 <B
CLASS="COMMAND"
>dumpkeys</B
>, which will print on standard output the
	 console keymap, you can easily fix mismatches between keycodes and
	 keysyms. Analogously to <B
CLASS="COMMAND"
>xmodmap</B
>,
	 <B
CLASS="COMMAND"
>loadkeys</B
> can then fix single associations, or load
	 entirely new console keymaps. With it, you can even change the string
	 associated to a given keysym. If you want to record these changes, you will
	 have to define a new keymap for the console (you should have a look at the
	 system keymaps, usually located in <TT
CLASS="FILENAME"
>/lib/kbd</TT
>).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONCL"
>9. Conclusions</A
></H2
><P
>The fixes suggested here should solve to a large extent the problem
	 of deleting text you wrote (however, they do not help in creating other
	 text <TT
CLASS="LITERAL"
>:)</TT
>).</P
><P
>There is a small bug in the whole setting: if you're using the
	 <CODE
CLASS="ENVAR"
>COLORTERM</CODE
> trick and you start
	 <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> from
	 <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
>, the former will get
	 <CODE
CLASS="ENVAR"
>TERM</CODE
> set to <TT
CLASS="LITERAL"
>gnome</TT
>. This inconvenience is,
	 of course, mostly harmless, and does not occur if you simply started
	 <SPAN
CLASS="APPLICATION"
>gnome-terminal</SPAN
> with <CODE
CLASS="ENVAR"
>TERM</CODE
> suitably
	 set.</P
><P
>Another nontrivial problem that essentially has no solution is the
    one concerning remote connections: if you connect to a host whose terminal
    database is incoherent with yours, you will have to set up things
    manually.</P
><P
>Finally, it should be noted that the fixes will not work for broken
	 applications (for instance, applications ignoring the
	 <TT
CLASS="LITERAL"
>kbs</TT
> key capability). There is little to do in this case,
	 as fixing for one broken application will likely break all well-behaving
	 ones.</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN77"
HREF="#AEN77"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This claim has been
		  asserted/disputed several times commenting this document. If you have
		  any definitive information on this subject, please write me.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN95"
HREF="#AEN95"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Some programs rely on the terminal driver for input line editing,
		  such as deleting characters or words. With <B
CLASS="COMMAND"
>stty</B
>, you
		  can tell the terminal driver what character it should use to delete the
		  character to the left of the cursor (the <I
CLASS="FIRSTTERM"
>erase</I
>
		  character). You can check your current settings with <B
CLASS="COMMAND"
>stty
		  -a</B
> and set them with <B
CLASS="COMMAND"
>stty erase
		  <TT
CLASS="REPLACEABLE"
><I
>character</I
></TT
></B
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN188"
HREF="#AEN188"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Also these definitions have been
    asserted/disputed several times commenting this document. If you have any
    definitive information on this subject, please write me.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.ADDINPUTRC"
HREF="#ADDINPUTRC"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>On older
		version of the <SPAN
CLASS="APPLICATION"
>bash</SPAN
>, you must remember to set
		<CODE
CLASS="ENVAR"
>INPUTRC</CODE
> suitably, for instance adding
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;export INPUTRC=~/.inputrc</PRE
></FONT
></TD
></TR
></TABLE
> to your
		<TT
CLASS="FILENAME"
>~/.profile</TT
> (or whichever file is read just by login
		shells).</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN316"
HREF="#AEN316"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>More
precisely, to the shell configuration file that is read in every shell, not
only in login shells. The right file depend on startup sequence of your
<SPAN
CLASS="APPLICATION"
>bash</SPAN
>.</P
></TD
></TR
></TABLE
></BODY
></HTML
>