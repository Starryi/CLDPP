<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>TCP Keepalive HOWTO</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="This document describes the TCP keepalive implementation in the linux kernel, introduces the overall concept and points to both system configuration and software development."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h2 class="title"><a name="TCP-Keepalive-HOWTO"></a>TCP Keepalive HOWTO</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Fabio</span> <span class="surname">Busatto</span></h3><div class="affiliation"><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:fabio.busatto@sikurezza.org">fabio.busatto@sikurezza.org</a>&gt;</code></p></div></div></div></div><div><p class="pubdate">2007-05-04</p></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.0</td><td align="left">2007-05-04</td><td align="left">FB</td></tr><tr><td align="left" colspan="3">First release, reviewed by TM.</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
        This document describes the TCP keepalive implementation in the linux
        kernel, introduces the overall concept and points to both system
        configuration and software development.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#copyright">1.1. Copyright and License</a></span></dt><dt><span class="sect2"><a href="#disclaimer">1.2. Disclaimer</a></span></dt><dt><span class="sect2"><a href="#credits">1.3. Credits / Contributors</a></span></dt><dt><span class="sect2"><a href="#feedback">1.4. Feedback</a></span></dt><dt><span class="sect2"><a href="#translations">1.5. Translations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#overview">2. TCP keepalive overview</a></span></dt><dd><dl><dt><span class="sect2"><a href="#whatis">2.1. What is TCP keepalive?</a></span></dt><dt><span class="sect2"><a href="#whyuse">2.2. Why use TCP keepalive?</a></span></dt><dt><span class="sect2"><a href="#checkdeadpeers">2.3. Checking for dead peers</a></span></dt><dt><span class="sect2"><a href="#preventingdisconnection">2.4. Preventing disconnection due to network inactivity</a></span></dt></dl></dd><dt><span class="sect1"><a href="#usingkeepalive">3. Using TCP keepalive under Linux</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuringkernel">3.1. Configuring the kernel</a></span></dt><dt><span class="sect2"><a href="#makepersistchanges">3.2. Making changes persistent to reboot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#programming">4. Programming applications</a></span></dt><dd><dl><dt><span class="sect2"><a href="#codeneeding">4.1. When your code needs keepalive support</a></span></dt><dt><span class="sect2"><a href="#setsockopt">4.2. The <code class="function">setsockopt</code> function call</a></span></dt><dt><span class="sect2"><a href="#examples">4.3. Code examples</a></span></dt></dl></dd><dt><span class="sect1"><a href="#addsupport">5. Adding support to third-party software</a></span></dt><dd><dl><dt><span class="sect2"><a href="#modifysource">5.1. Modifying source code</a></span></dt><dt><span class="sect2"><a href="#libkeepalive">5.2. <span class="application">libkeepalive</span>: library preloading</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>1. Introduction</h2></div></div></div><p>
    Understanding TCP keepalive is not necessary in most cases, but it's a
    subject that can be very useful under particular circumstances. You will
    need to know basic TCP/IP networking concepts, and the C programming
    language to understand all sections of this document.
  </p><p>
    The main purpose of this HOWTO is to describe TCP keepalive in detail and
    demonstrate various application situations. After some initial theory, the
    discussion focuses on the Linux implementation of TCP keepalive routines in
    the modern Linux kernel releases (2.4.x, 2.6.x), and how system
    administrators can take advantage of these routines, with specific
    configuration examples and tricks.
  </p><p>
    The second part of the HOWTO involves the programming interface exposed by
    the Linux kernel, and how to write TCP keepalive-enabled applications in the
    C language. Pratical examples are presented, and there is an introduction to
    the <code class="literal">libkeepalive</code> project, which permits legacy
    applications to benefit from keepalive with no code modification.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="copyright"></a>1.1. Copyright and License</h3></div></div></div><p>
      This document, TCP Keepalive HOWTO, is copyrighted (c) 2007 by Fabio
      Busatto. Permission is granted to copy, distribute and/or modify this
      document under the terms of the GNU Free Documentation License, Version
      1.1 or any later version published by the Free Software Foundation; with
      no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
      Texts. A copy of the license is available at
      <a class="ulink" href="http://www.gnu.org/copyleft/fdl.html" target="_top">
      http://www.gnu.org/copyleft/fdl.html</a>.
    </p><p>
      Source code included in this document is released under the terms of the
      GNU General Public License, Version 2 or any later version published by
      the Free Software Foundation. A copy of the license is available at
      <a class="ulink" href="http://www.gnu.org/copyleft/gpl.html" target="_top">
      http://www.gnu.org/copyleft/gpl.html</a>.
    </p><p>
      Linux is a registered trademark of Linus Torvalds.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="disclaimer"></a>1.2. Disclaimer</h3></div></div></div><p>
      No liability for the contents of this document can be accepted. Use the
      concepts, examples and information at your own risk. There may be errors
      and inaccuracies that could be damaging to your system. Proceed with
      caution, and although this is highly unlikely, the author does not take
      any responsibility.
    </p><p>
      All copyrights are held by their by their respective owners, unless
      specifically noted otherwise. Use of a term in this document should not be
      regarded as affecting the validity of any trademark or service mark.
      Naming of particular products or brands should not be seen as
      endorsements.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="credits"></a>1.3. Credits / Contributors</h3></div></div></div><p>
      This work is not especially related to any people that I should thank. But
      my life is, and my knowledge too: so, thanks to everyone that has
      supported me, prior to my birth, now, and in the future. Really.
    </p><p>
      A special thank is due to Tabatha, the patient woman that read my work and
      made the needed reviews.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="feedback"></a>1.4. Feedback</h3></div></div></div><p>
      Feedback is most certainly welcome for this document. Send your additions,
      comments and criticisms to the following email address:
      <code class="email">&lt;<a class="email" href="mailto:fabio.busatto@sikurezza.org">fabio.busatto@sikurezza.org</a>&gt;</code>.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="translations"></a>1.5. Translations</h3></div></div></div><p>
      There are no translated versions of this HOWTO at the time of publication.
      If you are interested in translating this HOWTO into other languages,
      please feel free to contact me. Your contribution will be very welcome.
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview"></a>2. TCP keepalive overview</h2></div></div></div><p>
    In order to understand what TCP keepalive (which we will just call
    keepalive) does, you need do nothing more than read the name: keep TCP
    alive. This means that you will be able to check your connected socket (also
    known as TCP sockets), and determine whether the connection is still up and
    running or if it has broken.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="whatis"></a>2.1. What is TCP keepalive?</h3></div></div></div><p>
      The keepalive concept is very simple: when you set up a TCP connection,
      you associate a set of timers. Some of these timers deal with the
      keepalive procedure. When the keepalive timer reaches zero, you send your
      peer a keepalive probe packet with no data in it and the ACK flag turned
      on. You can do this because of the TCP/IP specifications, as a sort of
      duplicate ACK, and the remote endpoint will have no arguments, as TCP is a
      stream-oriented protocol. On the other hand, you will receive a reply from
      the remote host (which doesn't need to support keepalive at all, just
      TCP/IP), with no data and the ACK set.
    </p><p>
      If you receive a reply to your keepalive probe, you can assert that the
      connection is still up and running without worrying about the user-level
      implementation. In fact, TCP permits you to handle a stream, not packets,
      and so a zero-length data packet is not dangerous for the user program.
    </p><p>
      This procedure is useful because if the other peers lose their connection
      (for example by rebooting) you will notice that the connection is broken,
      even if you don't have traffic on it. If the keepalive probes are not
      replied to by your peer, you can assert that the connection cannot be
      considered valid and then take the correct action.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="whyuse"></a>2.2. Why use TCP keepalive?</h3></div></div></div><p>
      You can live quite happily without keepalive, so if you're reading this,
      you may be trying to understand if keepalive is a possible solution for
      your problems. Either that or you've really got nothing more interesting
      to do instead, and that's okay too. :)
    </p><p>
      Keepalive is non-invasive, and in most cases, if you're in doubt, you can
      turn it on without the risk of doing something wrong. But do remember that
      it generates extra network traffic, which can have an impact on routers
      and firewalls.
    </p><p>
      In short, use your brain and be careful.
    </p><p>
      In the next section we will distinguish between the two target tasks for
      keepalive:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Checking for dead peers</p></li><li class="listitem"><p>Preventing disconnection due to network inactivity</p></li></ul></div><p>
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="checkdeadpeers"></a>2.3. Checking for dead peers</h3></div></div></div><p>
      Keepalive can be used to advise you when your peer dies before it is able
      to notify you. This could happen for several reasons, like kernel panic or
      a brutal termination of the process handling that peer. Another scenario
      that illustrates when you need keepalive to detect peer death is when the
      peer is still alive but the network channel between it and you has gone
      down. In this scenario, if the network doesn't become operational again,
      you have the equivalent of peer death. This is one of those situations
      where normal TCP operations aren't useful to check the connection status.
    </p><p>
      Think of a simple TCP connection between Peer A and Peer B: there is the
      initial three-way handshake, with one SYN segment from A to B, the SYN/ACK
      back from B to A, and the final ACK from A to B. At this time, we're in a
      stable status: connection is established, and now we would normally wait
      for someone to send data over the channel. And here comes the problem:
      unplug the power supply from B and instantaneously it will go down,
      without sending anything over the network to notify A that the connection
      is going to be broken. A, from its side, is ready to receive data, and has
      no idea that B has crashed. Now restore the power supply to B and wait for
      the system to restart. A and B are now back again, but while A knows about
      a connection still active with B, B has no idea. The situation resolves
      itself when A tries to send data to B over the dead connection, and B
      replies with an RST packet, causing A to finally to close the connection.
    </p><p>
      Keepalive can tell you when another peer becomes unreachable without the
      risk of false-positives. In fact, if the problem is in the network between
      two peers, the keepalive action is to wait some time and then retry,
      sending the keepalive packet before marking the connection as broken.
    </p><p>
      </p><pre class="screen">
    _____                                                     _____
   |     |                                                   |     |
   |  A  |                                                   |  B  |
   |_____|                                                   |_____|
      ^                                                         ^
      |---&gt;---&gt;---&gt;-------------- SYN --------------&gt;---&gt;---&gt;---|
      |---&lt;---&lt;---&lt;------------ SYN/ACK ------------&lt;---&lt;---&lt;---|
      |---&gt;---&gt;---&gt;-------------- ACK --------------&gt;---&gt;---&gt;---|
      |                                                         |
      |                                       system crash ---&gt; X
      |
      |                                     system restart ---&gt; ^
      |                                                         |
      |---&gt;---&gt;---&gt;-------------- PSH --------------&gt;---&gt;---&gt;---|
      |---&lt;---&lt;---&lt;-------------- RST --------------&lt;---&lt;---&lt;---|
      |                                                         |

      </pre><p>
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="preventingdisconnection"></a>2.4. Preventing disconnection due to network inactivity</h3></div></div></div><p>
      The other useful goal of keepalive is to prevent inactivity from
      disconnecting the channel. It's a very common issue, when you are behind a
      NAT proxy or a firewall, to be disconnected without a reason. This
      behavior is caused by the connection tracking procedures implemented in
      proxies and firewalls, which keep track of all connections that pass
      through them. Because of the physical limits of these machines, they can
      only keep a finite number of connections in their memory. The most common
      and logical policy is to keep newest connections and to discard old and
      inactive connections first.
    </p><p>
      Returning to Peers A and B, reconnect them. Once the channel is open, wait
      until an event occurs and then communicate this to the other peer. What if
      the event verifies after a long period of time? Our connection has its
      scope, but it's unknown to the proxy. So when we finally send data, the
      proxy isn't able to correctly handle it, and the connection breaks up.
    </p><p>
      Because the normal implementation puts the connection at the top of the
      list when one of its packets arrives and selects the last connection in
      the queue when it needs to eliminate an entry, periodically sending
      packets over the network is a good way to always be in a polar position
      with a minor risk of deletion.
    </p><p>
      </p><pre class="screen">
    _____           _____                                     _____
   |     |         |     |                                   |     |
   |  A  |         | NAT |                                   |  B  |
   |_____|         |_____|                                   |_____|
      ^               ^                                         ^
      |---&gt;---&gt;---&gt;---|----------- SYN -------------&gt;---&gt;---&gt;---|
      |---&lt;---&lt;---&lt;---|--------- SYN/ACK -----------&lt;---&lt;---&lt;---|
      |---&gt;---&gt;---&gt;---|----------- ACK -------------&gt;---&gt;---&gt;---|
      |               |                                         |
      |               | &lt;--- connection deleted from table      |
      |               |                                         |
      |---&gt;- PSH -&gt;---| &lt;--- invalid connection                 |
      |               |                                         |

      </pre><p>
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="usingkeepalive"></a>3. Using TCP keepalive under Linux</h2></div></div></div><p>
    Linux has built-in support for keepalive. You need to enable TCP/IP
    networking in order to use it. You also need <code class="literal">procfs</code>
    support and <code class="literal">sysctl</code> support to be able to configure the
    kernel parameters at runtime.
  </p><p>
    The procedures involving keepalive use three user-driven variables:

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
          <code class="varname">tcp_keepalive_time</code>
        </span></dt><dd><p>
            the interval between the last data packet sent (simple ACKs are not
            considered data) and the first keepalive probe; after the connection
            is marked to need keepalive, this counter is not used any further
          </p></dd><dt><span class="term">
          <code class="varname">tcp_keepalive_intvl</code>
        </span></dt><dd><p>
            the interval between subsequential keepalive probes, regardless of
            what the connection has exchanged in the meantime
          </p></dd><dt><span class="term">
          <code class="varname">tcp_keepalive_probes</code>
        </span></dt><dd><p>
            the number of unacknowledged probes to send before considering the
            connection dead and notifying the application layer
          </p></dd></dl></div><p>
  </p><p>
    Remember that keepalive support, even if configured in the kernel, is not
    the default behavior in Linux. Programs must request keepalive control for
    their sockets using the <code class="literal">setsockopt</code> interface. There are
    relatively few programs implementing keepalive, but you can easily add
    keepalive support for most of them following the instructions explained
    later in this document.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="configuringkernel"></a>3.1. Configuring the kernel</h3></div></div></div><p>
      There are two ways to configure keepalive parameters inside the kernel via
      userspace commands:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">procfs</code> interface</p></li><li class="listitem"><p><code class="literal">sysctl</code> interface</p></li></ul></div><p>
    </p><p>
      We mainly discuss how this is accomplished on the procfs interface because
      it's the most used, recommended and the easiest to understand. The sysctl
      interface, particularly regarding the <span class="citerefentry"><span class="refentrytitle">
      <code class="function">sysctl</code></span>(2)</span> syscall and not the <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>
      sysctl</strong></span></span>(8)</span>
      tool, is only here for the purpose of background knowledge.
    </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="procfsinterface"></a>3.1.1. The <code class="literal">procfs</code> interface</h4></div></div></div><p>
        This interface requires both <code class="literal">sysctl</code> and <code class="literal">
        procfs</code> to be built into the kernel, and <code class="literal">procfs
        </code> mounted somewhere in the filesystem (usually on <code class="filename">
        /proc</code>, as in the examples below). You can read the values for
        the actual parameters by <span class="quote">&#8220;<span class="quote">catting</span>&#8221;</span> files in <code class="filename">
        /proc/sys/net/ipv4/</code> directory:

        </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_time</code></strong>
  <code class="computeroutput">7200</code>

  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_intvl</code></strong>
  <code class="computeroutput">75</code>

  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_probes</code></strong>
  <code class="computeroutput">9</code>
        </pre></div><p>
      </p><p>
        The first two parameters are expressed in seconds, and the last is the
        pure number. This means that the keepalive routines wait for two hours
        (7200 secs) before sending the first keepalive probe, and then resend it
        every 75 seconds. If no ACK response is received for nine consecutive
        times, the connection is marked as broken.
      </p><p>
        Modifying this value is straightforward: you need to write new values
        into the files. Suppose you decide to configure the host so that
        keepalive starts after ten minutes of channel inactivity, and then send
        probes in intervals of one minute. Because of the high instability of
        our network trunk and the low value of the interval, suppose you also
        want to increase the number of probes to 20.
      </p><p>
        Here's how we would change the settings:

        </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>echo 600 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</code></strong>

  <code class="prompt"># </code><strong class="userinput"><code>echo 60 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl</code></strong>

  <code class="prompt"># </code><strong class="userinput"><code>echo 20 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes</code></strong>
        </pre></div><p>
      </p><p>
        To be sure that all succeeds, recheck the files and confirm these new
        values are showing in place of the old ones.
      </p><p>
        Remember that <code class="literal">procfs</code> handles special files, and you
        cannot perform any sort of operation on them because they're just an interface within the kernel space, not real
        files, so try your
        scripts before using them, and try to use simple access methods as in
        the examples shown earlier.
      </p><p>
        You can access the interface through the <span class="citerefentry"><span class="refentrytitle">
        <span class="command"><strong>sysctl</strong></span></span>(8)</span> tool, specifying what you want to read or write.

        </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>sysctl \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_time \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_intvl \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_probes</code></strong>
  <code class="computeroutput">net.ipv4.tcp_keepalive_time = 7200
  net.ipv4.tcp_keepalive_intvl = 75
  net.ipv4.tcp_keepalive_probes = 9</code>
        </pre></div><p>
      </p><p>
        Note that <code class="literal">sysctl</code> names are very close to <code class="literal">
        procfs</code> paths. Write is performed using the <code class="option">-w</code>
        switch of <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
        </span>(8)</span>:

        </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>sysctl -w \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_time=600 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_intvl=60 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_probes=20</code></strong>
  <code class="computeroutput">net.ipv4.tcp_keepalive_time = 600
  net.ipv4.tcp_keepalive_intvl = 60
  net.ipv4.tcp_keepalive_probes = 20</code>
        </pre></div><p>
      </p><p>
        Note that <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
        </span>(8)</span> doesn't use
        <span class="citerefentry"><span class="refentrytitle"><code class="function">sysctl</code></span>(2)</span> syscall, but reads and writes
        directly in the <code class="literal">procfs</code> subtree, so you will need
        <code class="literal">procfs</code> enabled in the kernel and mounted in the
        filesystem, just as you would if you directly accessed the files within
        the <code class="literal">procfs</code> interface. <span class="citerefentry"><span class="refentrytitle">
        <span class="command"><strong>Sysctl</strong></span></span>(8)</span> is just a different way to do the same thing.
      </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sysctlinterface"></a>3.1.2. The <code class="literal">sysctl</code> interface</h4></div></div></div><p>
        There is another way to access kernel variables: <span class="citerefentry"><span class="refentrytitle"><code class="function">sysctl</code></span>(2
        )</span> syscall. It can be useful when you don't
        have <code class="literal">procfs</code> available because the communication with
        the kernel is performed directly via syscall and not through the
        <code class="literal">procfs</code> subtree. There is currently no program that
        wraps this syscall (remember that <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>
        sysctl</strong></span></span>(8)</span>
        doesn't use it).
      </p><p>
        For more details about using <span class="citerefentry"><span class="refentrytitle"><code class="function">
        sysctl</code></span>(2)</span>
        refer to the manpage.
      </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="makepersistchanges"></a>3.2. Making changes persistent to reboot</h3></div></div></div><p>
      There are several ways to reconfigure your system every time it boots up.
      First, remember that every Linux distribution has its own set of init
      scripts called by <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>init</strong></span>
      </span>(8)</span>. The most common
      configurations include the <code class="filename">/etc/rc.d/</code> directory, or
      the alternative, <code class="filename">/etc/init.d/</code>. In any case, you can
      set the parameters in any of the startup scripts, because keepalive
      rereads the values every time its procedures need them. So if you change
      the value of <code class="varname">tcp_keepalive_intvl</code> when the connection is
      still up, the kernel will use the new value going forward.
    </p><p>
      There are three spots where the initialization commands should logically
      be placed: the first is where your network is configured, the second is
      the <code class="filename">rc.local</code> script, usually included in all
      distributions, which is known as the place where user configuration setups
      are done. The third place may already exist in your system. Referring back
      to the <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
      </span>(8)</span> tool, you can see
      that the <code class="option">-p</code> switch loads settings from the <code class="filename">
      /etc/sysctl.conf</code> configuration file. In many cases your init
      script already performs the <span class="command"><strong>sysctl</strong></span> <code class="option">-p</code>
      (you can <span class="quote">&#8220;<span class="quote">grep</span>&#8221;</span> it in the configuration directory for
      confirmation), and so you just have to add the lines in <code class="filename">
      /etc/sysctl.conf</code> to make them load at every boot. For more
      information about the syntax of <span class="citerefentry"><span class="refentrytitle"><code class="filename">
      sysctl.conf</code></span>(5)</span>, refer to the manpage.
    </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="programming"></a>4. Programming applications</h2></div></div></div><p>
    This section deals with programming code needed if you want to create
    applications that use keepalive. This is not a programming manual, and it
    requires that you have previous knowledge in C programming and in
    networking concepts. I consider you familiar with sockets, and with
    everything concerning the general aspects of your application.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="codeneeding"></a>4.1. When your code needs keepalive support</h3></div></div></div><p>
      Not all network applications need keepalive support. Remember that it is
      TCP keepalive support. So, as you can imagine, only TCP sockets can take
      advantage of it.
    </p><p>
      The most beautiful thing you can do when writing an application is to make
      it as customizable as possible, and not to force decisions. If you want to
      consider the happiness of your users, you should implement keepalive and
      let the users decide if they want to use it or not by using a
      configuration parameter or a switch on the command line.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="setsockopt"></a>4.2. The <code class="function">setsockopt</code> function call</h3></div></div></div><p>
      All you need to enable keepalive for a specific socket is to set the
      specific socket option on the socket itself. The prototype of the function
      is as follows:

      </p><pre class="synopsis">
  int <code class="function">setsockopt</code>(int s, int level, int optname,
                 const void *optval, socklen_t optlen)
      </pre><p>
    </p><p>
      The first parameter is the socket, previously created with the
      <span class="citerefentry"><span class="refentrytitle"><code class="function">socket</code></span>(2)</span>; the second one must be <code class="constant">
      SOL_SOCKET</code>, and the third must be <code class="constant">SO_KEEPALIVE
      </code>. The fourth parameter must be a boolean integer value,
      indicating that we want to enable the option, while the last is the size
      of the value passed before.
    </p><p>
      According to the manpage, <span class="returnvalue">0</span> is returned upon
      success, and <span class="returnvalue">-1</span> is returned on error (and
      <code class="varname">errno</code> is properly set).
    </p><p>
      There are also three other socket options you can set for keepalive when
      you write your application. They all use the <code class="constant">SOL_TCP</code>
      level instead of <code class="constant">SOL_SOCKET</code>, and they override
      system-wide variables only for the current socket. If you read without
      writing first, the current system-wide parameters will be returned.
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="constant">TCP_KEEPCNT</code>: overrides <code class="varname">
        tcp_keepalive_probes</code></p></li><li class="listitem"><p><code class="constant">TCP_KEEPIDLE</code>: overrides <code class="varname">
        tcp_keepalive_time</code></p></li><li class="listitem"><p><code class="constant">TCP_KEEPINTVL</code>: overrides <code class="varname">
        tcp_keepalive_intvl</code></p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="examples"></a>4.3. Code examples</h3></div></div></div><p>
      This is a little example that creates a socket, shows that keepalive is
      disabled, then enables it and checks that the option was effectively set.
    </p><div class="informalexample"><pre class="programlisting">
            /* --- begin of keepalive test program --- */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main(void);

int main()
{
   int s;
   int optval;
   socklen_t optlen = sizeof(optval);

   /* Create the socket */
   if((s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
      perror("socket()");
      exit(EXIT_FAILURE);
   }

   /* Check the status for the keepalive option */
   if(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; 0) {
      perror("getsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE is %s\n", (optval ? "ON" : "OFF"));

   /* Set the option active */
   optval = 1;
   optlen = sizeof(optval);
   if(setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen) &lt; 0) {
      perror("setsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE set on socket\n");

   /* Check the status again */
   if(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; 0) {
      perror("getsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE is %s\n", (optval ? "ON" : "OFF"));

   close(s);

   exit(EXIT_SUCCESS);
}

            /* ---  end of keepalive test program  --- */
    </pre></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="addsupport"></a>5. Adding support to third-party software</h2></div></div></div><p>
    Not everyone is a software developer, and not everyone will rewrite software
    from scratch if it lacks just one feature. Maybe you want to add keepalive
    support to an existing application because, though the author might not have
    thought it important, you think it will be useful.
  </p><p>
    First, remember what was said about the situations where you need keepalive.
    Now you'll need to address connection-oriented TCP sockets.
  </p><p>
    Since Linux doesn't provide the functionality to enable keepalive support
    via the kernel itself (as BSD-like operating systems often do), the only way
    is to perform the <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt
    </code></span>(2)</span> call
    after socket creation. There are two solutions:

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>source code modification of the original program</p></li><li class="listitem"><p><span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt</code>
        </span>(2)</span> injection using
         the library preloading technique</p></li></ul></div><p>
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="modifysource"></a>5.1. Modifying source code</h3></div></div></div><p>
      Remember that keepalive is not program-related, but socket-related, so if
      you have multiple sockets, you can handle keepalive for each of them
      separately. The first phase is to understand what the program does and
      then search the code for each socket in the program. This can be done
      using <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>grep</strong></span></span>(1)</span>, as follows:

      </p><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>grep 'socket *(' *.c</code></strong>
      </pre><p>
    </p><p>
      This will more or less show you all sockets in the code. The next step is
      to select only the right ones: you will need TCP sockets, so look for
      <code class="constant">PF_INET</code> (or <code class="constant">AF_INET</code>), <code class="constant">
      SOCK_STREAM</code> and <code class="constant">IPPROTO_TCP</code> (or more
      commonly, <code class="constant">0</code>) in the parameters of your socket list,
      and remove the non-matching ones.
    </p><p>
      Another way to create a socket is through <span class="citerefentry"><span class="refentrytitle">
      <code class="function">accept</code></span>(2)</span>. In this case, follow the TCP sockets identified and check
      if any of these is a listening socket: if positive, keep in mind that
      <span class="citerefentry"><span class="refentrytitle"><code class="function">accept</code></span>(2)</span> returns a socket descriptor, which
      must be inserted in your socket list.
    </p><p>
      Once you've identified the sockets you can proceed with changes. The most
      fast &amp; furious patch can be done by simply adding the <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt</code></span>(2
      )</span> function just after the socket creation block.
      Optionally, you may include additional calls in order to set the keepalive
      parameters if you don't like the system defaults. Please be careful when
      implementing error checks and handlers for the function, maybe by copying
      the style from the original code around it. Remember to set the <code class="varname">
      optval</code> to a non-zero value and to initialize the <code class="varname">optlen
      </code> before invoking the function.
    </p><p>
      If you have time or you think it would be really cool, try to add complete
      keepalive support to your program, including a switch on the command line
      or a configuration parameter to let the user choose whether or not to use
      keepalive.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="libkeepalive"></a>5.2. <span class="application">libkeepalive</span>: library preloading</h3></div></div></div><p>
      There are often cases where you don't have the ability to modify the
      source code of an application, or when you have to enable keepalive for
      all your programs, so patching and recompiling everything is not
      recommended.
    </p><p>
      The <span class="application">libkeepalive</span> project was born to help add
      keepalive support for applications since the Linux kernel doesn't provide
      the ability to do the same thing natively (like BSD does). The
      <span class="application">libkeepalive</span> project homepage is
      <a class="ulink" href="http://libkeepalive.sourceforge.net/" target="_top">
      http://libkeepalive.sourceforge.net/</a>
    </p><p>
      It consists of a shared library that overrides the socket system call in
      most binaries, without the need to recompile or modify them. The technique
      is based on the <em class="firstterm">preloading</em> feature of the
      <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>ld.so</strong></span></span>(8)</span> loader included in Linux, which
      allows you to force the loading of shared libraries with higher priority
      than normal. Programs usually use the <span class="citerefentry"><span class="refentrytitle">
      <code class="function">socket</code></span>(2)</span> function call located in the <code class="literal">glibc</code>
      shared library; with <span class="application">libkeepalive</span> you can wrap
      it and inject the <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt
      </code></span>(2)</span> just
      after the socket creation, returning a socket with keepalive already set
      to the main program. Because of the mechanisms used to inject the system
      call, this doesn't work when the socket function is statically compiled
      into the binary, as in a program linked with the <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>gcc</strong></span></span>(1
      )</span> flag <code class="option">-static</code>.
    </p><p>
      After downloading and installing <span class="application">libkeepalive</span>,
      you will able to add keepalive support to your programs without the
      prerequisite of being <code class="literal">root</code>, simply setting the <code class="envar">
      LD_PRELOAD</code> environment variable before executing the program. By
      the way, the superuser can also force the preloading with a global
      configuration, and the users can then decide to turn it off by setting the
      <code class="envar">KEEPALIVE</code> environment variable to <code class="constant">off</code>.
    </p><p>
      The environment is also used to set specific values for keepalive
      parameters, so you have the ability to handle each program differently,
      setting <code class="envar">KEEPCNT</code>, <code class="envar">KEEPIDLE</code> and <code class="envar">
      KEEPINTVL</code> before starting the application.
    </p><p>
      Here's an example of libkeepalive usage:

      </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt">$ </code><strong class="userinput"><code>test</code></strong>
  <code class="computeroutput">SO_KEEPALIVE is OFF</code>

  <code class="prompt">$ </code><strong class="userinput"><code>LD_PRELOAD=libkeepalive.so \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPCNT=20 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPIDLE=180 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPINTVL=60 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>test</code></strong>
  <code class="computeroutput">SO_KEEPALIVE is ON
  TCP_KEEPCNT   = 20
  TCP_KEEPIDLE  = 180
  TCP_KEEPINTVL = 60</code>
      </pre></div><p>
    </p><p>
      And you can use <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>strace</strong></span>
      </span>(1)</span> to understand what
      happens:
    </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt">$ </code><strong class="userinput"><code>strace test</code></strong>
  <code class="computeroutput">execve("test", ["test"], [/* 26 vars */]) = 0
  [..]
  open("/lib/libc.so.6", O_RDONLY)        = 3
  [..]
  socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
  getsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [0], [4]) = 0
  close(3)                                = 0
  [..]
  _exit(0)                                = ?</code>

  <code class="prompt">$ </code><strong class="userinput"><code>LD_PRELOAD=libkeepalive.so \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>strace test</code></strong>
  <code class="computeroutput">execve("test", ["test"], [/* 27 vars */]) = 0
  [..]
  open("/usr/local/lib/libkeepalive.so", O_RDONLY) = 3
  [..]
  open("/lib/libc.so.6", O_RDONLY)        = 3
  [..]
  open("/lib/libdl.so.2", O_RDONLY)       = 3
  [..]
  socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
  setsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPCNT, [20], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPIDLE, [180], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPINTVL, [60], 4) = 0
  [..]
  getsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPCNT, [20], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPIDLE, [180], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPINTVL, [60], [4]) = 0
  [..]
  close(3)                                = 0
  [..]
  _exit(0)                                = ?</code>
    </pre></div><p>
      For more information, visit the <span class="application">libkeepalive</span>
      project homepage: <a class="ulink" href="http://libkeepalive.sourceforge.net/" target="_top">
      http://libkeepalive.sourceforge.net/</a>
    </p></div></div></div></body></html>
