<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>8. Going Hardcore: Non-GUI Systems</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="The Mock Mainframe Mini-HOWTO"><link rel="up" href="index.html" title="The Mock Mainframe Mini-HOWTO"><link rel="prev" href="ar01s07.html" title="7. Life With Multiple Users"><link rel="next" href="ar01s09.html" title="9. Odds and Ends"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8. Going Hardcore: Non-GUI Systems</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s07.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s09.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm440"></a>8. Going Hardcore: Non-GUI Systems</h2></div></div></div><p>
As nice as KDE and Gnome are, they use system resources like popcorn. If
you are only starting an application, try a desktop that is more
lightweight such as <code class="literal">Blackbox</code>.  Though your distribution should set up the
basics for you, you will probably have to edit the configuration files (in
this case, the <code class="literal">Blackbox</code> menu file that is specified in <code class="literal">~/.blackbox</code>) for
each user. Also, make sure your users know how to work the environment. At
the very least, teach them that <code class="literal">CTRL-ALT-BACKSPACE</code> kills the X server.
</p><p>
But real men and women don't need a graphical user interface (GUI) at all:
They use a command shell such as <code class="literal">bash</code>.  Before X Windows gave us
graphics, the Free Software Foundation (FSF) had created the GNU tools that
are as rock steady as any piece of software on the planet. They are the
heart of every distribution, and without them, there would be no "Linux"
system (which is why "GNU/Linux" is the more percise term).  If you have no
choice but to get by with really weak hardware &#8212; we're talking anything
down to a 386SX here &#8212; you can dump X Windows altogether and get along
just fine. Even if you stick to GUIs, some basic knowledge of the shell
can help you get far more out of your system.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm449"></a>8.1. Why the Command Line Is Cool</h3></div></div></div><p>
Think of Linux on the command line as the Willow Rosenberg approach to
computers: Whereas GUIs are as spectacular as a punch on the nose by
vampire slayer Buffy Summers, even a little knowledge of the shell will let
you work nuanced magic of nearly unlimited power with little effort. True
fans of the TV series will realize that there is a warning implied here:
The power of the shell can become habit forming, if not downright
addictive, and you can destroy your whole system with no chance of recovery
if you mess things up. Using <code class="literal">bash</code> takes you as close to
the raw energies of your machine as you can get without using a C compiler,
and the danger rises accordingly.
</p><p>
It took Willow six years to become a witch powerful enough to end the
world, but it should take you a few weeks at most to become familiar with
the command line. Here are four paragraphs to help you decide if you want
to make the effort:
</p><p>
The power of the command line environment is rooted in its design
philosophy: Each tool is designed to do one job and one job only, but to do
that job superbly. Also, almost every tool can be connected to every other
tool to create processing chains with just a few commands. Since these
tools are (almost) all general purpose, you can solve just about any
problem with the right combination. With these same commands, you can write
little programs (<span class="emphasis"><em>shell scripts</em></span>) for everyday tasks. If you look closely
at the programs your distributor includes, you will see that a lot of the
are in <code class="literal">bash</code>. Other script languages such as Python or Perl might be more
powerful, but the command line is always included and has far less
overhead.
</p><p>
It is learning the individual tools of the CLI that is somewhat daunting.
A lot of commands have strange names that don't even pretend to be mnemonic
(the pattern scanning tool <code class="literal">awk</code> is named for its creators Aho, Kernighan,
and Weinberger), only make sense in a historical context (the <span class="emphasis"><em>tape
archiving utility</em></span> <code class="literal">tar</code> is now used to distribute compressed files), or
look like they are typos (<code class="literal">umount</code> instead of "unmount", <code class="literal">passwd</code> instead
of "password"). There can be dozens of options for each command, and they
can be just as cryptic. Because the system was written by hackers in the
true sense of the word who wanted the computer to get the job done and not
talk about it, the shell normally will not ask you for confirmation, even
if you tell it to delete every single file on your hard disk. This is where
the end of the world scenario from <span class="emphasis"><em>Buffy</em></span> comes in.
</p><p>
Once you <span class="emphasis"><em>have</em></span> mastered the basics of the shell, however, you will get
stuff done a lot faster, you will understand jokes such as <code class="literal">rm -rf
/bin/laden</code>, and you will develop a spring in your step and a glint in
your eye. This is why even people who are young enough to have been born
after the invention of the mouse develop a  tendency to use X Windows
merely as a comfortable way to open a lot of terminal windows (either
<code class="literal">xterm</code> or the less resource-hungry <code class="literal">rxvt</code>).
</p><p>
The CLI has just about every tool you'll need: <code class="literal">mutt</code> or <code class="literal">pine</code>
for email (real hard-core basket cases use <code class="literal">mail</code>) <code class="literal">w3m</code> or <code class="literal">lynx</code> for
surfing, and of course the legendary editors <code class="literal">vi</code> (more commonly <code class="literal">vim</code>
these days) or <code class="literal">emacs</code>. The obvious exception to this rule are programs
that let you view pictures. But then you probably aren't interested in that
sort of thing anyway, are you.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm478"></a>8.2. Setting Up Text Terminals</h3></div></div></div><p>
Basically, you have the same options for text terminals as you do with X
terminals. Everything is just a bit easier.
</p><p>
For example, you don't have to reboot if you are forced to use a different
operation system: Any program that lets you log in via <code class="literal">telnet</code> (on secure,
closed networks) or <code class="literal">ssh</code> (everywhere else) will do. Microsoft Windows
includes a <code class="literal">telnet</code> client that is best described as rudimentary; for
serious work, try a free Win32 implementation such as Simon Tathamt's
<a class="ulink" href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_top">PuTTY http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>. Apple users with Mac
OS X should have no problems with their clients.
</p><p>
The Linux Terminal Server Project also has a package for text terminals.
The hardware can be as basic as it gets: Go find yourself a 386DX (for
those of you who don't remember the Soviet Union or the first <code class="literal">Star Trek</code>
series: This is the original Pentium's grandaddy). The mainboard will
probably not have a PCI slot, so you'll need an ISA graphics card and an
ISA network card. These are so low down the hardware chain you might have
problems finding them, because they are being junked, not sold second hand.
</p><p>
There is no reason, though, why your computer has to be advanced enought to
understand the TCP/IP protocol and be part of your local network at all.
You can connect just about any computer to the serial port(s) of the mock
mainframe: For example, there is a Linux HOWTO for older Macs by Robert
Kiesling (<span class="emphasis"><em>The MacTerminal MINI-HOWTO</em></span>); in an article in
<a class="ulink" href="http://www.linuxgazette.com/issue70/arndt.html" target="_top">The Linux Gazette http://www.linuxgazette.com/issue70/arndt.html</a>, Matthias Arndt shows how
to convert an Atari ST into a terminal; Nicholas Petreley explains in
<a class="ulink" href="http://www.itworld.com/Comp/2384/LWD010511penguin2/" target="_top">IT World.com http://www.itworld.com/Comp/2384/LWD010511penguin2/</a> how to use your Palm
Pilot. If you can get it connected to the serial port, chances are you can
get it running on Linux. There are special cards with multiple serial ports
for larger setups. Of course, there is a HOWTO for that as well: <span class="emphasis"><em>The
Serial HOWTO</em></span> by David S.Lawyer.
</p><p>
You can also get special text terminals as individual machines.  David S.
Lawyer has written an extensive Linux HOWTO on the subject
(<span class="emphasis"><em>Text-Terminal-HOWTO</em></span>) that explains how they work, how you set them up,
and why you would want one.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm495"></a>8.3. Useful Shell Commands</h3></div></div></div><p>
To get you started on the shell, here are a few commands that are
especially useful if you are sharing a system. These very basic examples
were chosen to be useful to normal users.
</p><p>
<span class="strong"><strong>Play nice</strong></span>. The <code class="literal">nice</code> command is one of those things that would make the
world a better place if everybody used it more often, but nobody does. It
allows you to lower the <span class="emphasis"><em>scheduling priority</em></span> of a process so that less
important programs don't get in the way of the important ones.
</p><p>
For example, assume you have a WAV recording of your own voice as you sing
a song under the shower, and you want to convert it to the Ogg Vorbis
format to distribute to your fans on the Internet, all three of them. A
simple command to do this is
</p><pre class="screen">
         oggenc -o showersong.ogg showersong.wav
</pre><p>
Encoding music formats is a CPU intensive process, so performance will
drop. Now, if a few minutes more or less don't matter, just start the line
off with <code class="literal">nice</code>:
</p><pre class="screen">
         nice oggenc -o shower.ogg shower.wav
</pre><p>
Now the encoding will be run with a lower priority, but you will still have
to wait for it to finish before you can use the shell again. To have the
computer execute a command in the background, add an ampersand ("&amp;") to the
end of the line:
</p><pre class="screen">
         nice oggenc -o shower.ogg shower.wav &amp;
</pre><p>
The shell will respond by giving you a <span class="emphasis"><em>job number</em></span> and a <span class="emphasis"><em>process id</em></span>
(PID), and then will ask you for the next command.
</p><p>
The <code class="literal">nice</code> command is a good example of the power that was lost when
graphical interfaces became the default: There is no simple way to adjust
the priority of a process with a mouse-driven interface.
</p><p>
<span class="strong"><strong>Do it later.</strong></span> Another way to spread the load is to have an intensive
process start at a time when the system is not being used much. Depending
on who is on the system with you, this could be three  o'clock in the
morning or any time until two o'clock in the afternoon.
</p><p>
The <code class="literal">at</code> command lets you set a time to start a program or any other
process that can be run from the command line. To have our shower song
encoded at eight in the evening when you are out watching meaningful French
love films, you enter the command "at" followed by the time you want
execution to start, and then hit the <code class="literal">ENTER</code>. Then you type in the command
itself, followed by another <code class="literal">ENTER</code>, and finally a <code class="literal">CTRL-d</code> to finish the
sequence:
</p><pre class="screen">
         me@mycomputer:&gt; at 20:00
         warning: commands will be executed using /bin/sh
         &gt; nice oggenc -o shower.ogg shower.wav
         &gt; &lt;CTRL-d&gt;
         job 1 at 2003-09-28 20:00
</pre><p>
The <code class="literal">at</code> command accepts just about any time format: Americans get to use
their quaint "08:00pm" notation instead of "20:00", and there are a whole
set of shortcuts like <code class="literal">midnight</code>, <code class="literal">noon</code> or even <code class="literal">teatime</code>.  <code class="literal">at</code>
sends the output of the command to your mailbox.
</p><p>
<span class="strong"><strong>Do it when you are bored.</strong></span> A close relative of <code class="literal">at</code> uses system load, not
time of day to determine when a command should be run: <code class="literal">batch</code> saves the
execution for a time when the system load has fallen below a certain value
(to see what your system load currently is, run <code class="literal">uptime</code> from a shell or
<code class="literal">xload</code> under X Windows). The documentation gives this value as 0.8. The
syntax for <code class="literal">batch</code> is basically the same as for <code class="literal">at</code>, except that the time
field is optional.
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s07.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s09.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7. Life With Multiple Users </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 9. Odds and Ends</td></tr></table></div></body></html>
