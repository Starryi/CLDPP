<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3. The Individual Pieces</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="The Mock Mainframe Mini-HOWTO"><link rel="up" href="index.html" title="The Mock Mainframe Mini-HOWTO"><link rel="prev" href="ar01s02.html" title="2. Background"><link rel="next" href="ar01s04.html" title="4. The Terminals"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. The Individual Pieces</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm109"></a>3. The Individual Pieces</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm111"></a>3.1. The Mock Mainframe</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm113"></a>3.1.1. The Hardware</h4></div></div></div><p>
<span class="strong"><strong>Examining your needs.</strong></span> If the load that is going to be placed on the mock
mainframe is more or less constant and won't change too much over time, you
are in the wonderful position of being able to tailor your hardware to your
needs. This probably will let you get away with second-hand hardware, which
leaves you with more money for, say, a new surround sound system (or more
realistically, a new dish washer).
</p><p>
The simple way to find out just what you need is to throw together a
machine, just about <span class="emphasis"><em>any</em></span> machine, and then see how it performs under the
load it will actually be asked to bear. Then experiment a bit: Will the
computer start to swap if you take out half of the RAM, will it speed up if
you put in double the amount? See if you can get away with a slower
processor or a smaller hard disk. If you can, get feedback from your users.
</p><p>
These trial runs can take time and may seem like a lot of work. The idea
here is to fit the mock mainframe's hardware as exactly as possible to the
task at hand so you can use the rest of the hardware for other stuff. Also,
these trial runs can have surprising results. Most people have little
experience in building a system for more than one user, and tend to
overestimate the processor strength required while underestimating the
amount of memory they need.
</p><p>
For example, for our setup at home in 2003 &#8212; two people running
SuSE 8.2 and KDE 3.1 with a regular load of email clients, multiple browser
windows, chatting and music playback &#8212; an AMD Duron 1.0 GHz processor
turned out to be overkill. We ended up with a secondhand SMP mainboard with
two used Intel Pentium II Xeon 450 MHz CPUs (yes, Pentium "two"). Further
experiments showed that 512 MByte RAM was slightly too much RAM: 384 MByte
is fine, if you can live with the system going into swap once in a blue
moon.
</p><p>
<span class="strong"><strong>Multiple vs. single processors</strong></span> With more and more people working on one
computer at the same time, you'll start having moments when a single
processor machine seems to stall.  Also, if somebody's process goes berserk
and starts hogging the CPU, it can freeze the whole system. This is bad.
</p><p>
Decades of hardware marketing have produced computer users who reflexively
go out and buy a faster processor when things slow down. But even the
fastest CPU can't do more than one thing at once (we're ignoring tricks
like hyperthreading here), it is just somewhat better at faking it.  To really
do two things at the same time, you need more than one processor. Such
systems are usually referred to as "SMP"-computers, from <span class="emphasis"><em>symmetrical
nultiprocessing</em></span>. You can get them with eight processors or more (Intel
Pentium II Xeon, AMD Opteron, Intel Xeon) but in our price range, two CPU
(<span class="emphasis"><em>dual-processor</em></span>) systems are the most common.
</p><p>
More than one processor will go a long way towards keeping the system
responsive even when there are lots of processes running. What it will
<span class="emphasis"><em>not</em></span> do is make a single process run twice as fast as on a system with a
single processor of the same speed. One way to visualize this is to imagine
you are doing your laundry: Two washing machines will get the whole job
done in about half the time, but that does not mean that they now each spin
twice as fast; each load still takes just as long as before. Things are
actually more complicated, but this is a good rule of thumb.
</p><p>
Although processor speed might be important for gamers on the bleeding edge
or people who want to simulate nuclear explosions on their desktop machine,
the current clock speeds are simply perverse for normal use.  You can
usually get away with far slower processors than the market is trying to
force down your throat, especially if you have more than one CPU. This is a
good thing because SMP-mainboards are more expensive than normal,
single-processor boards, and then you still have to buy that second
processor. Keep in mind that more recent (AMD Opteron / Intel Xeon) SMP
systems can have expensive needs such as a special power supply and extra
large cases.
</p><p>
A multi-processor mainboard is not a must for a mock mainframe. But if you
find your system groaning under multiple users, adding processors might
give you a better deal than adding MHz.
</p><p>
(At the time of writing, there was also the problem of latency in the Linux
kernel. In the 2.4.x series, the kernel is not pre-emptable, so
occasionally a one-processor system will stall while something is happening
in the bowels of the operating system. The 2.6.x kernels are supposed to be
far more responsive, which would be the end of that problem and of this
paragraph,too).
</p><p>
<span class="strong"><strong>Storage: SCSI vs. IDE, RAID</strong></span>. You might want to take a look at using SCSI
instead of IDE for hard disks and other drives. One advantage of SCSI is
that you can connect more drives to one computer than the four you are
usually limited to with IDE. SCSI drives are also better at moving data
back and forth amongst themselves without bothering the processor. They are,
however, more expensive and can be louder. On smaller systems with few
users and low loads, you should be able to use IDE drives with no problem.
</p><p>
If you are going to build a system where it is important you don't loose
your data even between those regular backups you perform every night right
after you floss your teeth, you might want to consider a RAID (<span class="emphasis"><em>Redundant
Array of Inexpensive Disks</em></span>) setup. Very roughly speaking, a RAID setup
duplicates the data on more than one hard disk, so that if one drive
crashes, the others still have copies.
</p><p>
<span class="strong"><strong>Sane graphics.</strong></span> Most graphics cards cater to the game freak who has an
unlimited hunger for speed, speed, and more speed and the pocket depth to
match. An AGP graphics card with 128 MByte of RAM and dazzling 3D functions
is not necessarily a bad thing in a mock mainframe, but be sure that you
actually need it. A good used PCI card will usually do just fine for email
and surfing.
</p><p>
<span class="strong"><strong>Heat and Lightning.</strong></span> Beyond the normal hardware considerations mentioned
here, give some thought to the parts that protect your machine from threats
such as power surges or brown outs, or makes sure that everything stays
cool, or shields your drive bays from inquisitive little children with
popsicle sticks. A good modern mainboard has temperature alarms and all
sorts of other features to help you monitor your system's heath.
</p><p>
In summary:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
<span class="emphasis"><em>Think RAM before processor speed.</em></span> With more than one user, you'll be
    using more memory and less CPU time than you expect.
</li><li class="listitem">
<span class="emphasis"><em>Two slower processors can be better than one fast one.</em></span> A faster
    processor can switch between more than one task faster than a slow one,
    but two processors don't have to switch at all. This means you can use
    older hardware, which will almost always be less expensive even though
    you will need more of it.
</li><li class="listitem">
<span class="emphasis"><em>Consider SCSI and RAID.</em></span> SCSI instead of IDE gives you more drives on
    one machine, and they are able to play amongst themselves without
    processor supervision. However, SCSI drives are more expensive and make
    more noise. RAID helps protect your data from hard disk failure. Both
    are for more ambitious setups.
</li></ol></div><p>
When buying hardware for a mock mainframe, online auctioneers are your
friends. Whereas your local computer store will try to sell you the newest
fad, there is no shortage of previous-generation hardware at affordable
prices online.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idm151"></a>3.1.2. The Software</h4></div></div></div><p>
<span class="strong"><strong>Some background on X.</strong></span> The X Window System (<span class="emphasis"><em>X Windows</em></span> or just <span class="emphasis"><em>X</em></span> for
short) is the graphics layer that most Linux systems use. Almost all
current window managers &#8212; KDE, Gnome, Blackbox &#8212; sit on top of X, and
almost all variants of Unix use X.
</p><p>
X Windows has one important aspect that we make extended use of with the
mock mainframe: It is <span class="emphasis"><em>network transparent</em></span>. The software responsible for
controlling the input/output devices &#8212; screen(s), keyboard, and mouse &#8212;
can be on a different computer than the programs you are actually running.
With X, it is possible to sit in Beijing, China, with a 486DX and run your
programs on a supercomputer in Langley, Virginia.
</p><p>
This has a whole number of advantages. Graphics are hard work for a
computer; having them processed on a different machine than the program
they belong to takes a big load off of the central computer. They are not
so hard, however, that they can't be handled by an older processor. In the
distant past of computer technology, there were special machines called <span class="emphasis"><em>X
Terminals</em></span> that did nothing but display graphics.  Today, a spare computer
with an Intel PentiumPro or an AMD K6 with 300 MHz is enough.  This lets
you have one big, fat machine running the actual programs and a whole host
of cheap, small machines doing all the graphics.  Which is exactly what we
are looking for.
</p><p>
X Windows does have some drawbacks. It gobbles up a lot of bandwidth, so
you will want a fast network. Also, some of the terminology is strange. The
computer (or rather the software) that controls screen, mouse, and keyboard
is called the "X server", because it "serves" the actual program, which in
turn is called the "X client". In this text, we'll stick to "host" and
"terminals" to avoid confusion.
</p><p>
There are all kinds of good Linux HOWTOs about X Windows, so again we'll
just go through the basic steps and let you consult the special texts.  I'm
assuming that you already have X set up on the mock mainframe; your
distribution should handle that part for you.
</p><p>
First, we have to start the program that handles remote X logins. This is
<code class="literal">xdm</code> (<span class="emphasis"><em>X Display Manager</em></span>). Depending on your system and taste, you might
want to use the KDE version <span class="emphasis"><em>kdm</em></span> or Gnome version <code class="literal">gdm</code> instead; both have
nicer graphics and more features. Check the <span class="emphasis"><em>XDMCP Mini-HOWTO</em></span> by Thomas
Chao for more details.  Normally, you'll want <code class="literal">xdm</code> (or whatever) to start
up in the run level that you ususally use for graphics (for example, run
level 5 for SuSE 8.2).
</p><p>
Even when <code class="literal">xdm</code> is running, the mock mainframe should not let you connect
from the outside, which is good security. You distribution might let you
change this with a simple entry in one of its configuration files (for
example, SuSE 8.2 uses <code class="literal">/etc/sysconfig/displaymanager</code>). If you have to do
it the hard way, you will want to change <code class="literal">/etc/X11/xdm/xdm-config</code> and
<code class="literal">opt/kde3/share/config/kdm/kdmrc</code> if you are using <code class="literal">kdm</code>.
</p><p>
After all of this is done, you are ready to test the link.  Get a computer
you know has a functioning X system, boot it in console mode &#8212; <span class="emphasis"><em>not</em></span> in
graphics mode (runlevel 3 instead of 5 on SuSE systems, use <code class="literal">init 3</code> as
root from a shell). Log in and type
</p><pre class="screen">
        /usr/X11/bin/X -terminate -query &lt;host&gt;
</pre><p>
where "&lt;host&gt;" is the name or IP-address of the mock mainframe. You should
get the same X login prompt as if were sitting at the host machine.
</p><p>
Even if you have booted into graphical mode, you can try the following to force the X server to start a second display:
</p><pre class="screen">
        /usr/X11/bin/X :1 -terminate -query &lt;host&gt;
</pre><p>
This can be done from within a terminal program such as <code class="literal">xterm</code> on the running display. Note that by default, the first display is :0.
</p><p>
The rest of the text is written under the assumption that you will be using some standard distribution such as SuSE or RedHat or Gentoo for the mock mainframe. However, it should also be little trouble to adapt the Knoppix terminal server package (see <a class="ulink" href="http://www.knoppix.net" target="_top">http://www.knoppix.net Knoppix</a>) so that it boots right off a ramdisk.
</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s02.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. Background </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. The Terminals</td></tr></table></div></body></html>
