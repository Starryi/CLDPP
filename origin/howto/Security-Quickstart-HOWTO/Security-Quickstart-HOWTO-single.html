<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Security Quick-Start HOWTO for  Red Hat  Linux</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><META
NAME="KEYWORD"
CONTENT="Secure"><META
NAME="KEYWORD"
CONTENT="Security"><META
NAME="KEYWORD"
CONTENT="Services"><META
NAME="KEYWORD"
CONTENT="Firewall"><META
NAME="KEYWORD"
CONTENT="Intrusion"><META
NAME="KEYWORD"
CONTENT="Hacker"><META
NAME="KEYWORD"
CONTENT="Hacked"><META
NAME="KEYWORD"
CONTENT="Cracker"><META
NAME="KEYWORD"
CONTENT="Cracked"><META
NAME="KEYWORD"
CONTENT="owned"><META
NAME="KEYWORD"
CONTENT="Firewall"><META
NAME="KEYWORD"
CONTENT="ipchains"><META
NAME="KEYWORD"
CONTENT="iptables"><META
NAME="KEYWORD"
CONTENT="tcpwrappers"><META
NAME="KEYWORD"
CONTENT="portsentry"><META
NAME="KEYWORD"
CONTENT="virus"><META
NAME="KEYWORD"
CONTENT="trojan"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Security Quick-Start HOWTO for  Red Hat  Linux</A
></H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN5"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN6"
>Hal Burgiss</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:hal@foobox.net"
>hal@foobox.net</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
></DIV
><P
CLASS="PUBDATE"
>v. 1.2, 2002-07-21<BR></P
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v. 1.2</TD
><TD
ALIGN="LEFT"
>2002-07-21</TD
><TD
ALIGN="LEFT"
>Revised by: hb</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>A few small additions, and fix the usual broken links.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v. 1.1</TD
><TD
ALIGN="LEFT"
>2002-02-06</TD
><TD
ALIGN="LEFT"
>Revised by: hb</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>A few fixes, some additions and many touch-ups from the original.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v. 1.0</TD
><TD
ALIGN="LEFT"
>2001-11-07</TD
><TD
ALIGN="LEFT"
>Revised by: hb</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial Release.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN46"
></A
><P
> </P
><P
> </P
><P
> This document is a an overview of the basic steps required to 
 secure a Linux installation from intrusion. It is intended to be an
 introduction.  This is a Red Hat specific version of this
 document. &#13;</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#INTRO"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN54"
>Why me?</A
></DT
><DT
>1.2. <A
HREF="#AEN92"
>Notes</A
></DT
><DT
>1.3. <A
HREF="#AEN97"
>Copyright</A
></DT
><DT
>1.4. <A
HREF="#AEN105"
>Credits</A
></DT
><DT
>1.5. <A
HREF="#DISCLAIMER"
>Disclaimer</A
></DT
><DT
>1.6. <A
HREF="#AEN124"
>New Versions and Changelog</A
></DT
><DT
>1.7. <A
HREF="#AEN136"
>Feedback</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#FOREWORD"
>Foreword</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN168"
>The Optimum Configuration</A
></DT
><DT
>2.2. <A
HREF="#AEN176"
>Before We Start</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#SERVICES"
>Step 1: Which services do we really need?</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AUDIT"
>System Audit</A
></DT
><DT
>3.2. <A
HREF="#DANGER"
>The Danger Zone (or r00t m3 pl34s3)</A
></DT
><DT
>3.3. <A
HREF="#STOPSERVICES"
>Stopping Services</A
></DT
><DT
>3.4. <A
HREF="#EXCEPTIONS"
>Exceptions</A
></DT
><DT
>3.5. <A
HREF="#CONCLUSIONS"
>Summary and Conclusions for Step 1</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#UPDATES"
>Step 2: Updating</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN571"
>Summary and Conclusions for Step 2</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#FIREWALLS"
>Step 3: Firewalls and Setting Access Policies</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#STRATEGY"
>Strategy</A
></DT
><DT
>5.2. <A
HREF="#FILTERS"
>Packet Filters -- Ipchains and Iptables</A
></DT
><DT
>5.3. <A
HREF="#TCPWRAPPERS"
>Tcpwrappers (libwrap)</A
></DT
><DT
>5.4. <A
HREF="#PORTSENTRY"
>PortSentry</A
></DT
><DT
>5.5. <A
HREF="#PROXIES"
>Proxies</A
></DT
><DT
>5.6. <A
HREF="#INDAPPS"
>Individual Applications</A
></DT
><DT
>5.7. <A
HREF="#VERIFY"
>Verifying</A
></DT
><DT
>5.8. <A
HREF="#LOGGING"
>Logging</A
></DT
><DT
>5.9. <A
HREF="#WHERETOSTART"
>Where to Start</A
></DT
><DT
>5.10. <A
HREF="#SUMMARY3"
>Summary and Conclusions for Step 3</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#INTRUSION"
>Intrusion Detection</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#IDS"
>Intrusion Detection Systems (IDS)</A
></DT
><DT
>6.2. <A
HREF="#HACKED"
>Have I Been Hacked?</A
></DT
><DT
>6.3. <A
HREF="#RECLAIM"
>Reclaiming a Compromised System</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#GENERAL"
>General Tips</A
></DT
><DT
>8. <A
HREF="#APPENDIX"
>Appendix</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#SERVERSETC"
>Servers, Ports, and Packets</A
></DT
><DT
>8.2. <A
HREF="#PORTS"
>Common Ports</A
></DT
><DT
>8.3. <A
HREF="#NETSTAT"
>Netstat Tutorial</A
></DT
><DT
>8.4. <A
HREF="#THREATS"
>Attacks and Threats</A
></DT
><DT
>8.5. <A
HREF="#LINKS"
>Links</A
></DT
><DT
>8.6. <A
HREF="#TEXT"
>Editing Text Files</A
></DT
><DT
>8.7. <A
HREF="#NMAP"
>nmap</A
></DT
><DT
>8.8. <A
HREF="#SYSCTL"
>Sysctl Options</A
></DT
><DT
>8.9. <A
HREF="#SECUREALT"
>Secure Alternatives</A
></DT
><DT
>8.10. <A
HREF="#PFILTERS"
>Ipchains and Iptables Redux</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="INTRO"
>1. Introduction</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN54"
>1.1. Why me?</A
></H3
><P
> Who should be reading this document and why should the average Linux user
 care about security? Those new to Linux, or unfamiliar with the inherent
 security issues of connecting a Linux system to large networks like Internet
 should be reading. <SPAN
CLASS="QUOTE"
>"Security"</SPAN
> is a broad subject with many
 facets, and is covered in much more depth in other documents, books, and on
 various sites on the Web. This document is intended to be an introduction to
 the most basic concepts as they relate to Red Hat Linux, and as
 a starting point only. </P
><P
> <TT
CLASS="LITERAL"
>  <P
CLASS="LITERALLAYOUT"
><br>
Iptables&nbsp;Weekly&nbsp;Log&nbsp;Summary&nbsp;from&nbsp;Jul&nbsp;15&nbsp;04:24:13&nbsp;to&nbsp;Jul&nbsp;22&nbsp;04:06:00<br>
Blocked&nbsp;Connection&nbsp;Attempts:<br>
<br>
Rejected&nbsp;tcp&nbsp;packets&nbsp;by&nbsp;destination&nbsp;port<br>
<br>
port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count<br>
111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19<br>
53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12<br>
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9<br>
515&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9<br>
27374&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8<br>
443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6<br>
1080&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
1138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
<br>
<br>
Rejected&nbsp;udp&nbsp;packets&nbsp;by&nbsp;destination&nbsp;port<br>
<br>
port&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count<br>
137&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34<br>
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
>
 </TT
></P
><P
> The above is real, live data from a one week period for my home LAN.
 Much of the above would seem to be specifically targeted at Linux systems.
 Many of the targeted <SPAN
CLASS="QUOTE"
>"destination"</SPAN
> ports are used by well known
 Linux and Unix services, and all may be installed, and possibly
 even running, on your system. </P
><P
> The focus here will be on threats that are shared by all Linux users, whether
 a dual boot home user, or large commercial site. And we will take a few,
 relatively quick and easy steps that will make a typical home Desktop system
 or small office system running Red Hat Linux reasonably safe
 from the majority of outside threats. For those responsible for Linux systems
 in a larger or more complex environment, you'd be well advised to read this,
 and then follow up with additional reading suitable to your particular
 situation. Actually, this is probably good advice for everybody.&#13;</P
><P
> We will assume the reader knows little about Linux, networking, TCP/IP, 
 and the finer points of running a server Operating System like Linux. We 
 will also assume, for the sake of this document, that all local users are
 <SPAN
CLASS="QUOTE"
>"trusted"</SPAN
> users, and won't address physical or local network
 security issues in any detail. Again, if this is not the case, further
 reading is strongly recommended. 
 </P
><P
> The principles that will guide us in our quest are:&#13;</P
><P
> <P
></P
><UL
><LI
><P
>     There is no <SPAN
CLASS="APPLICATION"
>magic bullet</SPAN
>. There is no one 
     <EM
>single</EM
> thing we can do to make us secure. It is not that simple. 
   </P
></LI
><LI
><P
>    Security is a process that requires maintenance, not an objective to
    be reached.
   </P
></LI
><LI
><P
>     There is no 100% safe program, package or distribution. Just varying 
     degrees of insecurity. 
   </P
></LI
></UL
></P
><P
> The steps we will be taking to get there are:</P
><P
> <P
></P
><UL
><LI
><P
>    Step 1: Turn off, and perhaps uninstall, any and all unnecessary services.
   </P
></LI
><LI
><P
>    Step 2: Make sure that any services that are installed are updated and
    patched to the current, safe version -- <EM
>and then stay that
    way</EM
>. Every server application has potential exploits. Some have
    just not been found yet.
   </P
></LI
><LI
><P
>    Step 3: Limit connections to us from outside sources by implementing a
    firewall and/or other restrictive policies. The goal is to allow only the
    minimum traffic necessary for whatever our individual situation may be.
   </P
></LI
><LI
><P
>     Awareness. Know your system, and how to properly maintain and secure it.
     New vulnerabilities are found, and exploited, all the time. Today's
     secure system may have tomorrow's as yet unfound weaknesses. 
     
   </P
></LI
></UL
></P
><P
> If you don't have time to read everything, concentrate on Steps 1, 2, and 3. 
 This is where the meat of the subject matter is. The <A
HREF="#APPENDIX"
>Appendix</A
> has a lot of supporting information, which
 may be helpful, but may not be necessary for all readers.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN92"
>1.2. Notes</A
></H3
><P
> This is a Red Hat specific version of this document. The included examples 
 are compatible with Red Hat 7.0 and later. Actually, most examples should 
 work with earlier versions of Red Hat as well. Also, this document should be
 applicable to other distributions that are Red Hat derivatives, such as
 Mandrake, Conectiva, etc.&#13;</P
><P
> Overwhelmingly, the content of this document is not peculiar to Red Hat. The
 same rules and methodologies apply to other Linuxes. And indeed, to other
 Operating Systems as well. But each may have their own way of doing things -- 
 the file names and locations may differ, as may the system utilities that 
 we rely on. It is these differences that make this document a 
 <SPAN
CLASS="QUOTE"
>"Red Hat"</SPAN
> version.
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN97"
>1.3. Copyright</A
></H3
><P
> Security-Quickstart HOWTO for Red Hat Linux</P
><P
> Copyright © 2001 Hal Burgiss. </P
><P
> This document is free; you can redistribute it and/or modify it under the
 terms of the GNU General Public License as published by the Free Software
 Foundation; either version 2 of the License, or (at your option) any later
 version.</P
><P
> This document is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 details.</P
><P
> You can get a copy of the GNU GPL at <A
HREF="http://www.gnu.org/copyleft/gpl.html"
TARGET="_top"
>http://www.gnu.org/copyleft/gpl.html</A
>.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN105"
>1.4. Credits</A
></H3
><P
> Many thanks to those who helped with the production of this document.&#13;</P
><P
> <P
></P
><UL
><LI
><P
>    Bill Staehle, who has done a little bit of everything: ideas, editing, 
    encouragement, and suggestions, many of which have been incorporated. 
    Bill helped greatly with the content of this document.
    
   </P
></LI
><LI
><P
>     Others who have contributed in one way or another: Dave Wreski, Ian
     Jones, Jacco de Leeuw, and Indulis Bernsteins.
    </P
></LI
><LI
><P
>    Various posters on comp.os.linux.security, a great place to learn about 
    Linux and security.
   </P
></LI
><LI
><P
>    The Netfilter Development team for their work on
    <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> and connection tracking, state of the
    art tools with which to protect our systems. 
   
   </P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DISCLAIMER"
>1.5. Disclaimer</A
></H3
><P
> The author accepts no liability for the contents of this document. Use the
 concepts, examples and other content at your own risk. As this is a new
 document, there may be errors and inaccuracies. Hopefully these are few and
 far between. Corrections and suggestions are welcomed.&#13;</P
><P
> This document is intended to give the new user a starting point for securing
 their system while it is connected to the Internet. Please understand that
 there is no intention whatsoever of claiming that the contents of this
 document will necessarily result in an ultimately secure and worry-free
 computing environment. Security is a complex topic. This document just
 addresses some of the most basic issues that inexperienced users should be
 aware of. &#13;</P
><P
> The reader is encouraged to read other security related documentation and
 articles. And to stay abreast of security issues as they evolve. Security is
 not an objective, but an ongoing process.
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN124"
>1.6. New Versions and Changelog</A
></H3
><P
> The current official version can always be found at <A
HREF="http://www.tldp.org/HOWTO/Security-Quickstart-Redhat-HOWTO/"
TARGET="_top"
>http://www.tldp.org/HOWTO/Security-Quickstart-Redhat-HOWTO/</A
>.
 Pre-release versions can be found at <A
HREF="http://feenix.burgiss.net/ldp/quickstart-rh/"
TARGET="_top"
>http://feenix.burgiss.net/ldp/quickstart-rh/</A
>.&#13;</P
><P
> Other formats, including PDF, PS, single page HTML, may be found at 
 the Linux Documentation HOWTO index page: <A
HREF="http://tldp.org/docs.html#howto"
TARGET="_top"
>http://tldp.org/docs.html#howto</A
>.&#13;</P
><P
> Changelog:&#13;</P
><P
> Version 1.2: Clarifications on example firewall scripts, and small additions
 to 'Have I been Hacked'. Note on Zonealarm type applications. More on the use
 of <SPAN
CLASS="QUOTE"
>"chattr"</SPAN
> by script kiddies, and how to check for this. Other 
 small additions and clarifications.</P
><P
> Version 1.1: Various corrections, amplifications and numerous mostly small
 additions. Too many to list. Oh yea, learn to spell Red Hat correctly ;-)</P
><P
> Version 1.0: This is the initial release of this document. Comments 
 welcomed.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN136"
>1.7. Feedback</A
></H3
><P
> Any and all comments on this document are most welcomed. Please make sure you have
 the most current version before submitting corrections or suggestions! These
 can be sent to <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:hal@foobox.net"
>hal@foobox.net</A
>&#62;</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FOREWORD"
>2. Foreword</A
></H2
><P
> Before getting into specifics, let's try to briefly answer some questions
 about why we need to be concerned about security in the first place. &#13;</P
><P
> It is easy to see why an e-commerce site, an on-line bank, or a government 
 agency with sensitive documents would be concerned about security. But what
 about the average user? Why should even a Linux home Desktop user worry about
 security? &#13;</P
><P
> Anyone connected to the Internet is a target, plain and simple. It
 makes little difference whether you have a part-time dialup connection, or a
 full-time connection, though full-time connections make for bigger targets.
 Larger sites make for bigger targets too, but this does not let small users
 off the hook since the <SPAN
CLASS="QUOTE"
>"small user"</SPAN
> may be less skilled and thus
 an easier victim. 
  Red Hat, and Red Hat based distributions, tend to make for bigger 
  targets as well, since the installed user base is so large.&#13;</P
><P
> There are those out there that are scanning just for easy
 victims all the time. If you start logging unwanted connection attempts, 
 you will see this soon enough. There is little doubt that many of these
 attempts are maliciously motivated and the attacker, in some cases, is
 looking for Linux boxes to crack. Does someone on the other side of the globe
 really want to borrow my printer? &#13;</P
><P
> What do they want? Often, they just may want your computer, your IP
 address, and your bandwidth. Then they use you to either attack others, or
 possibly commit crimes or mischief and are hiding their true identity behind
 you. This is an all too common scenario. Commercial and high-profile sites
 are targeted more directly and have bigger worries, but we all face this type
 of common threat. &#13;</P
><P
> With a few reasonable precautions, Red Hat Linux can be very
 secure, and with all the available tools, makes for a fantastically fun and
 powerful Internet connection or server. Most successful break-ins are the
 result of ignorance or carelessness. &#13;</P
><P
> The bottom line is:&#13;</P
><P
> <P
></P
><UL
><LI
><P
>    Do you want control of your own system or not?
   </P
></LI
><LI
><P
>    Do you want to unwittingly participate in criminal activity?
   </P
></LI
><LI
><P
>    Do you want to be used by someone else?
   </P
></LI
><LI
><P
>     Do you want to risk losing your Internet connection?
   </P
></LI
><LI
><P
>    Do you want to have to go through the time consuming steps of reclaiming
    your system?
   </P
></LI
><LI
><P
>    Do you want to chance the loss of data on your system?
   </P
></LI
></UL
></P
><P
> These are all real possibilities, unless we take the appropriate
 precautions.&#13;</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>  If you are reading this because you have already been broken into, or
  suspect that you have, you cannot trust any of your system utilities to
  provide reliable information. And the suggestions made in the next several
  sections will not help you recover your system. Please jump straight to the
  <A
HREF="#HACKED"
>Have I been Hacked?</A
> section, and read that
  first.
 
 </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN168"
>2.1. The Optimum Configuration</A
></H3
><P
> Ideally, we would want one computer as a dedicated firewall and router. This 
 would be a bare bones installation, with <EM
>no</EM
> servers
 running, and only the required services and components installed. The rest of
 our systems would connect via this dedicated router/firewall system. If we
 wanted publicly accessible servers (web, mail, etc), these would be in a
 <SPAN
CLASS="QUOTE"
>"DMZ"</SPAN
> (De-militarized Zone). The router/firewall allows
 connections from outside to whatever services are running in the DMZ by
 <SPAN
CLASS="QUOTE"
>"forwarding"</SPAN
> these requests, but it is segregated from the rest
 of the internal network (aka LAN) otherwise. This leaves the rest of the
 internal network in fairly secure isolation, and relative safety. The
 <SPAN
CLASS="QUOTE"
>"danger zone"</SPAN
> is confined to the DMZ. 
 </P
><P
> But not everyone has the hardware to dedicate to this kind of installation.
 This would require a minimum of two computers. Or three, if you would be 
 running any publicly available servers (not a good idea initially). Or maybe
 you are just new to Linux, and don't know your way around well enough yet. So
 if we can't do the ideal installation, we will do the next best thing.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN176"
>2.2. Before We Start</A
></H3
><P
> Before we get to the actual configuration sections, a couple of notes. 
 </P
><P
> With Linux, there is always more than one way to perform any
task. For the purposes of our discussion, we will have to use as generic set
of tools as we can. Unfortunately, GUI tools don't lend themselves to this
type of documentation. So we will be using text based, command line tools for
the most part. Red Hat does provide various GUI utilities, feel free to
substitute those in appropriate places.
&#13;</P
><P
> The next several sections have been written such that you can perform the 
 recommended procedures as you read along. This is the
 <SPAN
CLASS="QUOTE"
>"Quick Start"</SPAN
> in the document title!</P
><P
> To get ready, what you will need for the configuration sections below:</P
><P
> <P
></P
><UL
><LI
><P
>    A text editor. There are many available. If you use a file manager 
    application  like <SPAN
CLASS="APPLICATION"
>gmc</SPAN
> or 
    <SPAN
CLASS="APPLICATION"
>nautilus</SPAN
>, it probably has a built in editor.
    This will be fine. <B
CLASS="COMMAND"
>pico</B
> and <B
CLASS="COMMAND"
>mcedit</B
>
    are two relatively easy to use editors if you don't already have a
    favorite. There is a quick guide to <A
HREF="#TEXT"
>Text
    editors</A
> in the Appendix that might help you get started. It is
    always a good idea to make a back up copy, before editing system
    configuration files.
   
   </P
></LI
><LI
><P
>     For non-GUI editors and some of the commands, you will also need a
     terminal window opened. <B
CLASS="COMMAND"
>xterm,</B
>
     <B
CLASS="COMMAND"
>rxvt,</B
> and <B
CLASS="COMMAND"
>gnome-terminal</B
> all will
     work, as well as others.
    </P
></LI
></UL
></P
><P
> We'll be using a hypothetical system here for examples with the hostname
 <SPAN
CLASS="QUOTE"
>"bigcat"</SPAN
>. Bigcat is a Linux desktop with a fresh install of the
 latest/greatest   Red Hat
  running. Bigcat has a full-time, direct Internet connection. Even if your
 installation is not so <SPAN
CLASS="QUOTE"
>"fresh"</SPAN
>, don't be deterred. Better late
 than never.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SERVICES"
>3. Step 1: Which services do we really need?</A
></H2
><P
> In this section we will see which services are running on our freshly installed
 system, decide which we really need, and do away with the rest. If you are
 not familiar with how servers and TCP connections work, you may want to read
 the section on <A
HREF="#SERVERSETC"
>servers and ports</A
> in the
 Appendix first. If not familiar with the <B
CLASS="COMMAND"
>netstat</B
> utility,
 you may want to read a quick <A
HREF="#NETSTAT"
>overview</A
> of it
 beforehand. There is also a section in the Appendix on <A
HREF="#PORTS"
>ports</A
>, and corresponding services. You may want to 
 look that over too.</P
><P
> Our goal is to turn off as many services as possible. If we can turn them 
 all off, or at least off to outside connections, so much the better. Some
 rules of thumb we will use to guide us:</P
><P
> <P
></P
><UL
><LI
><P
>   It is perfectly possible to have a fully functional Internet connection
   with no servers running that are accessible to outside connections. Not 
   only possible, but desirable in many cases. The principle here is that 
   you will never be successfully broken into via a port that is not opened 
   because no server is listening on it. No server == no port open == not
   vulnerable. At least to outside connections.
  </P
></LI
><LI
><P
>   If you don't recognize a particular service, chances are good you don't 
   really need it. We will assume that and so we'll turn it off. This may 
   sound dangerous, but is a good rule of thumb to go by. 
  </P
></LI
><LI
><P
>   Some services are just not intended to be run over the Internet -- even 
   if you decide it is something you really do need. We'll flag these
   as dangerous, and address these in later sections, should you decide 
   you do really need them, and there is no good alternative.
  </P
></LI
></UL
></P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AUDIT"
>3.1. System Audit</A
></H3
><P
> So what is really running on our system anyway? Let's not take anything for 
 granted about what <SPAN
CLASS="QUOTE"
>"should"</SPAN
> be running, or what we
 <SPAN
CLASS="QUOTE"
>"think"</SPAN
> is running.&#13;</P
><P
>  Which services get installed and started will vary greatly depending on
  which version of Red Hat, and which installation options were chosen. 
  Earlier releases were very much prone to start many services and then let 
  the user figure out which ones were needed, and which ones weren't. Recent 
  versions are much more cautious. But this makes providing a ready made list 
  of likely services impossible. Not to worry, as we shouldn't trust what is 
  <EM
>supposed</EM
> to be running anyway. What we need to do 
  is list for ourselves all running services. &#13;</P
><P
> Now open an <B
CLASS="COMMAND"
>xterm</B
>, and <B
CLASS="COMMAND"
>su</B
> to root.
 You'll need to widen the window wide so the lines do not wrap. Use this
 command: <TT
CLASS="LITERAL"
>netstat -tap |grep LISTEN</TT
>. This will give us a
 list of all currently running servers as indicated by the keyword
 <TT
CLASS="LITERAL"
>LISTEN</TT
>, along with the <SPAN
CLASS="QUOTE"
>"PID"</SPAN
> and
 <SPAN
CLASS="QUOTE"
>"Program Name"</SPAN
> that started each particular service.</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;# netstat -tap |grep LISTEN
  *:exec               *:*        LISTEN    988/inetd          
  *:login              *:*        LISTEN    988/inetd          
  *:shell              *:*        LISTEN    988/inetd          
  *:printer            *:*        LISTEN    988/inetd          
  *:time               *:*        LISTEN    988/inetd          
  *:x11                *:*        LISTEN    1462/X              
  *:http               *:*        LISTEN    1078/httpd          
  bigcat:domain        *:*        LISTEN    956/named           
  bigcat:domain        *:*        LISTEN    956/named           
  *:ssh                *:*        LISTEN    972/sshd            
  *:auth               *:*        LISTEN    388/in.identd
  *:telnet             *:*        LISTEN    988/inetd          
  *:finger             *:*        LISTEN    988/inetd
  *:sunrpc             *:*        LISTEN    1290/portmap
  *:ftp                *:*        LISTEN    988/inetd
  *:smtp               *:*        LISTEN    1738/sendmail: accepting connections 
  *:1694               *:*        LISTEN    1319/rpc.mountd
  *:netbios-ssn        *:*        LISTEN    422/smbd

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>  Red Hat 7.x and Mandrake 8.x and later users will have
 <TT
CLASS="LITERAL"
>xinetd</TT
> in place of <TT
CLASS="LITERAL"
>inetd</TT
>. Note the
 first three columns are cropped above for readability. If your list is as
 long as the example, you have some work ahead of you! It is highly unlikely
 that you really need anywhere near this number of servers running. </P
><P
> Please be aware that the example above is just one of many, many possible
 system configurations. Yours probably does look very different.</P
><P
> You don't understand what any of this is telling you? Hopefully then, you've
 read the <B
CLASS="COMMAND"
>netstat</B
> <A
HREF="#NETSTAT"
>tutorial</A
>
 in the Appendix, and understand how it works. Understanding exactly what each
 server is in the above example, and what it does, is beyond the scope of this
 document. You will have to check your system's documentation (e.g.
 Installation Guide, man pages, etc) if that service is important to you.  For
 example, does <SPAN
CLASS="QUOTE"
>"exec"</SPAN
>, <SPAN
CLASS="QUOTE"
>"login"</SPAN
>, and <SPAN
CLASS="QUOTE"
>"shell"</SPAN
> 
 sound important? Yes, but these are not what they may sound like. They 
 are actually <B
CLASS="COMMAND"
>rexec</B
>, <B
CLASS="COMMAND"
>rlogin</B
>, and
 <B
CLASS="COMMAND"
>rsh</B
>, the <SPAN
CLASS="QUOTE"
>"r"</SPAN
> (for remote) commands. These are 
 antiquated, unnecessary, and in fact, are very dangerous if exposed to the
 Internet.&#13;</P
><P
> Let's make a few quick assumptions about what is necessary and unnecessary,
 and therefore what goes and what stays on bigcat. Since we are running a
 desktop on bigcat, <SPAN
CLASS="APPLICATION"
>X11</SPAN
> of course needs to stay. If
 bigcat were a dedicated server of some kind, then X11 would be unnecessary. If
 there is a printer physically attached, the printer (lp) daemon should stay.
 Otherwise, it goes. Print servers may sound harmless, but are potential
 targets too since they can hold ports open. If we plan on logging
 <EM
>in to</EM
> bigcat <EM
>from</EM
> other hosts,
 sshd (Secure SHell Daemon) would be necessary. If we have Microsoft hosts on
 our LAN, we probably want <SPAN
CLASS="APPLICATION"
>Samba</SPAN
>, so
 <SPAN
CLASS="APPLICATION"
>smbd</SPAN
> should stay. Otherwise, it is completely
 unnecessary. Everything else in this example is optional and not required for
 a normally functioning system, and should probably go. See anything that you
 don't recognize? Not sure about? It goes!&#13;</P
><P
> To sum up: since bigcat is a desktop with a printer attached, we will 
 need <SPAN
CLASS="QUOTE"
>"x11"</SPAN
>, <SPAN
CLASS="QUOTE"
>"printer"</SPAN
>. bigcat is on a LAN with 
 MS hosts, and shares files and printing with them, so
 <SPAN
CLASS="QUOTE"
>"netbios-ssn"</SPAN
> (<B
CLASS="COMMAND"
>smbd</B
>) is desired. We will also
 need <SPAN
CLASS="QUOTE"
>"ssh"</SPAN
> so we can login from other machines. Everything else
 is unnecessary for this particular case. &#13;</P
><P
> Nervous about this? If you want, you can make notes of any changes you make
 or save the list of servers you got from <B
CLASS="COMMAND"
>netstat</B
>, with
 this command: <TT
CLASS="LITERAL"
>netstat -tap |grep LISTEN &#62; ~/services.lst</TT
>.
 That will save it your home directory with the name of
 <SPAN
CLASS="QUOTE"
>"services.lst"</SPAN
> for future reference.</P
><P
> This is to not say that the ones we have decided to keep are inherently safe.
 Just that we probably need these. So we will have to deal with these via
 firewalling or other means (addressed below).&#13;</P
><P
> It is worth noting that the <B
CLASS="COMMAND"
>telnet</B
> and
 <B
CLASS="COMMAND"
>ftp</B
> daemons in the above example are
 <EM
>servers</EM
>, aka <SPAN
CLASS="QUOTE"
>"listeners"</SPAN
>. These accept
 incoming connections to you. You do not need, or want, these just to use
 <B
CLASS="COMMAND"
>ftp</B
> or <B
CLASS="COMMAND"
>telnet</B
>
 <EM
>clients</EM
>. For instance, you can download files from an
 FTP site with just an <B
CLASS="COMMAND"
>ftp</B
> client. Running an
 <SPAN
CLASS="APPLICATION"
>ftp</SPAN
> server on your end is not required at all, and
 has serious security implications.
 </P
><P
> There may be individual situations where it is desirable to make exceptions
 to the conclusions reached above. See <A
HREF="#EXCEPTIONS"
>below</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DANGER"
>3.2. The Danger Zone (or r00t m3 pl34s3)</A
></H3
><P
> The following is a list of services that should <EM
>not</EM
> be
 run over the Internet. Either disable these (see below), uninstall, or if you
 really do need these services running locally, make sure they are the
 current, patched versions <EM
>and</EM
> that they are effectively
 firewalled. And if you don't have a firewall in place now, turn them off
 until it is up and verified to be working properly. These are potentially
 insecure by their very nature, and as such are prime cracker targets. &#13;</P
><P
> <P
></P
><UL
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>NFS</SPAN
> (Network File System) and related services,
   including <SPAN
CLASS="APPLICATION"
>nfsd</SPAN
>,
   <SPAN
CLASS="APPLICATION"
>lockd</SPAN
>, <SPAN
CLASS="APPLICATION"
>mountd</SPAN
>,
   <SPAN
CLASS="APPLICATION"
>statd</SPAN
>, <SPAN
CLASS="APPLICATION"
>portmapper</SPAN
>,
   etc. NFS is the standard Unix service for sharing file systems across a
   network. Great system for LAN usage, but dangerous over the Internet.
   And its completely unnecessary on a stand alone system.
  </P
></LI
><LI
><P
>   rpc.* services, Remote Procedure Call.*, typically NFS and NIS related (see
   above). 
  </P
></LI
><LI
><P
>   Printer services (<SPAN
CLASS="APPLICATION"
>lpd</SPAN
>).
  </P
></LI
><LI
><P
>   The so-called r* (for <SPAN
CLASS="QUOTE"
>"remote"</SPAN
>, i.e. Remote SHell) services:
   <SPAN
CLASS="APPLICATION"
>rsh</SPAN
>, <SPAN
CLASS="APPLICATION"
>rlogin</SPAN
>,
   <SPAN
CLASS="APPLICATION"
>rexec</SPAN
>, <SPAN
CLASS="APPLICATION"
>rcp</SPAN
> etc.
   Unnecessary, insecure and potentially dangerous, and better utilities are
   available if these capabilities are needed. <SPAN
CLASS="APPLICATION"
>ssh</SPAN
>
   will do everything these command do, and in a much more sane way. See the
   man pages for each if curious.  These will probably show in
   <B
CLASS="COMMAND"
>netstat</B
> output without the <SPAN
CLASS="QUOTE"
>"r"</SPAN
>:
   <B
CLASS="COMMAND"
>rlogin</B
> will be just <SPAN
CLASS="QUOTE"
>"login"</SPAN
>, etc.
  </P
></LI
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>telnet</SPAN
> server. There is no reason for this
   anymore. Use <SPAN
CLASS="APPLICATION"
>sshd</SPAN
> instead.
  </P
></LI
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>ftp</SPAN
> server. There are better, safer ways for
   most systems to exchange files like <B
CLASS="COMMAND"
>scp</B
> or 
   via <B
CLASS="COMMAND"
>http</B
> (see below). <SPAN
CLASS="APPLICATION"
>ftp</SPAN
> is a
   proper protocol only for someone who is running a dedicated ftp server, and
   who has the time and skill to keep it buttoned down. For everyone else, it is
   potentially big trouble. 
  </P
></LI
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>BIND</SPAN
> (<B
CLASS="COMMAND"
>named</B
>), DNS server
   package. With some work, this can be done without great risk, but is not
   necessary in many situations, and requires special handling no matter
   how you do it. See the sections on <A
HREF="#EXCEPTIONS"
>Exceptions</A
> and special handling for <A
HREF="#INDAPPS"
>individual applications</A
>. 
  </P
></LI
><LI
><P
>   Mail Transport Agent, aka <SPAN
CLASS="QUOTE"
>"MTA"</SPAN
>
   (<SPAN
CLASS="APPLICATION"
>sendmail</SPAN
>, <SPAN
CLASS="APPLICATION"
>exim</SPAN
>,
   <SPAN
CLASS="APPLICATION"
>postfix</SPAN
>, <SPAN
CLASS="APPLICATION"
>qmail</SPAN
>).
   Most installations on single computers will not really need this. If you are not
   going to be directly receiving mail from Internet hosts (as a designated MX
   box), but will rather use the POP server of your ISP, then it is not
   needed. You may however need this if you are receiving mail
   <EM
>directly</EM
> from other hosts on your LAN, but initially
   it's safer to disable this. Later, you can enable it over the local
   interface once your firewall and access policies have been implemented.
  
  </P
></LI
></UL
></P
><P
> This is not necessarily a definitive list. Just some common services that 
 are sometimes started on default  Red Hat   installations. And conversely, this does not imply that other
 services are inherently safe. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STOPSERVICES"
>3.3. Stopping Services</A
></H3
><P
> The next step is to find where each server on our kill list is being started. 
 If it is not obvious from the <B
CLASS="COMMAND"
>netstat</B
> output, use
 <B
CLASS="COMMAND"
>ps</B
>, <B
CLASS="COMMAND"
>find</B
>, <B
CLASS="COMMAND"
>grep</B
> or
 <B
CLASS="COMMAND"
>locate</B
> to find more information from the <SPAN
CLASS="QUOTE"
>"Program
 name"</SPAN
> or <SPAN
CLASS="QUOTE"
>"PID"</SPAN
> info in the last column. There is examples
 of this in the <A
HREF="#PID"
>Process Owner</A
> section in the
 <B
CLASS="COMMAND"
>netstat</B
> Tutorial of the Appendix. If the service name or
 port number do not look familiar to you, you might get a real brief
 explanation in your <TT
CLASS="FILENAME"
>/etc/services</TT
> file.</P
><P
> <B
CLASS="COMMAND"
>chkconfig</B
> is a very useful command for controlling
 services that are started via init scripts (see example below). Also, where
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> is used, it can control those services as
 well. <B
CLASS="COMMAND"
>chkconfig</B
> can tell us what services the system is
 configured to run, but not necessarily all services that are indeed actually 
 running. Or what services may be started by other means, e.g. from
 <TT
CLASS="FILENAME"
>rc.local</TT
>. It is a configuration tool, more than a 
 real time system auditing too.</P
><P
> Skeptical that we are going to break your system, and the pieces won't go 
 back together again? If so, take this approach: turn off everything listed 
 above in <SPAN
CLASS="QUOTE"
>"The Danger Zone"</SPAN
>, and run your system for a while. OK? 
 Try stopping one of the ones we found to be <SPAN
CLASS="QUOTE"
>"unnecessary"</SPAN
> above. 
 Then, run the system for a while. Keep repeating this process, until you get 
 to the bare minimum. If this works, then make the changes permanent (see
 below).</P
><P
> The ultimate objective is not just to stop the service now, but to make sure
 it is stopped permanently! So whatever steps you take here, be sure to check
 after your next reboot.</P
><P
> There are various places and ways to start system services. Let's look at the
 most common ways this is done, and is probably how your system works. System
 services are typically either started by <SPAN
CLASS="QUOTE"
>"init"</SPAN
> scripts, or by
 <B
CLASS="COMMAND"
>inetd</B
> (or its replacement <B
CLASS="COMMAND"
>xinetd</B
>) on
 most distributions. &#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INITS"
>3.3.1. Stopping Init Services</A
></H4
><P
> Init services are typically started automatically during the boot process, or
 during a runlevel change. There is a naming scheme that uses symlinks to
 determine which services are to be started, or stopped, at any given
 runlevel. The scripts themselves should be in
 <TT
CLASS="FILENAME"
>/etc/init.d/</TT
> (or possibly
 <TT
CLASS="FILENAME"
>/etc/rc.d/init.d/</TT
>  for older versions of
 Red Hat).  </P
><P
> You can get a listing of these scripts:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;  # ls -l /etc/rc.d/init.d/ | less 

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> To stop a running service now, as root:
 </P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # /etc/init.d/&#60;$SERVICE_NAME&#62; stop

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Where <SPAN
CLASS="QUOTE"
>"$SERVICE_NAME"</SPAN
> is the name of the init script, which is
 often, but not always, the same as the service name itself.  Older
 Red Hat versions may use the path <TT
CLASS="FILENAME"
>/etc/rc.d/init.d/</TT
>
 instead. &#13;</P
><P
> This only stops this particular service now. It will restart again on the 
 next reboot, or runlevel change, unless additional steps are taken. So this is 
 really a two step process for init type services.</P
><P
> <B
CLASS="COMMAND"
>chkconfig</B
> can be used to see what services are 
 started at each runlevel, and to turn off any unneeded services. To view 
 <EM
>all services</EM
> under its control, type this command
 in an <SPAN
CLASS="APPLICATION"
>xterm</SPAN
>:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 # chkconfig --list | less
 
 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> To view only the ones that are <SPAN
CLASS="QUOTE"
>"on"</SPAN
>:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 # chkconfig --list | grep "\bon\b" | less
 
 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The first column is the service name, and the remaining columns are the various 
 runlevels. We need generally only worry about runlevels 3 (boot
 to text console login) and 5 (boot straight to X11 login).
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> services won't have columns, since that 
 aspect would be controlled by <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> itself.&#13;</P
><P
> Examples of commands to turn services <SPAN
CLASS="QUOTE"
>"off"</SPAN
>:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 # chkconfig portmapper off
 # chkconfig nfs off
 # chkconfig telnet off
 # chkconfig rlogin off
 
 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Note that the last two are <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> services.
 A very easy and nifty tool to use! Red Hat also includes <B
CLASS="COMMAND"
>ntsysv</B
>
 and <B
CLASS="COMMAND"
>tksysv</B
> (GUI) for runlevel and service configuration.
 See the man pages for additional command line options.</P
><P
> Another option here is to uninstall a package if you know you do not need it. 
 This is a pretty sure-fire, permanent fix. This also alleviates the
 potential problem of keeping all installed packages updated and current (Step
 2).  
 <SPAN
CLASS="APPLICATION"
>RPM</SPAN
> makes it very easy to re-install a package 
 should you change your mind.
 </P
><P
> To uninstall packages with <SPAN
CLASS="APPLICATION"
>RPM</SPAN
>: &#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # rpm -ev telnet-server  rsh  rsh-server

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The above command would uninstall the <SPAN
CLASS="QUOTE"
>"telnet server"</SPAN
> package 
 (but not telnet client!), <SPAN
CLASS="QUOTE"
>"rsh"</SPAN
> client and <SPAN
CLASS="QUOTE"
>"rsh
 server"</SPAN
> packages in one command. Red Hat also includes
 <SPAN
CLASS="APPLICATION"
>gnorpm</SPAN
>, a GUI <SPAN
CLASS="APPLICATION"
>RPM</SPAN
> 
 management utility which can do this as well.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INETD"
>3.3.2. Inetd</A
></H4
><P
> <SPAN
CLASS="APPLICATION"
>Inetd</SPAN
> is called a <SPAN
CLASS="QUOTE"
>"super-daemon"</SPAN
> 
 because it is used to spawn sub-daemons. <B
CLASS="COMMAND"
>inetd</B
> itself will
 generally be started via init scripts, and will <SPAN
CLASS="QUOTE"
>"listen"</SPAN
> on the
 various ports as determined by which services are enable in its configuration
 file, <TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
>. Any service listed here will be 
 under the control of <B
CLASS="COMMAND"
>inetd</B
>. Likewise, any of the listening 
 servers in <B
CLASS="COMMAND"
>netstat</B
> output that list <SPAN
CLASS="QUOTE"
>"inetd"</SPAN
> 
 in the last column under <SPAN
CLASS="QUOTE"
>"Program Name"</SPAN
>, will have been started
 by <B
CLASS="COMMAND"
>inetd</B
>.  You will have to adjust the
 <B
CLASS="COMMAND"
>inetd</B
> configuration to stop these services.
 <B
CLASS="COMMAND"
>xinetd</B
> is an enhanced <B
CLASS="COMMAND"
>inetd</B
> replacement,
 and is configured differently (see next section below). &#13;</P
><P
> Below is a partial snippet from a typical <TT
CLASS="FILENAME"
>inetd.conf</TT
>. Any 
 service with a <SPAN
CLASS="QUOTE"
>"#"</SPAN
> at the beginning of the line is
 <SPAN
CLASS="QUOTE"
>"commented out"</SPAN
>, and thus ignored by <B
CLASS="COMMAND"
>inetd</B
>,
 and consequently disabled.</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;#
# inetd.conf  This file describes the services that will be available
#    through the INETD TCP/IP super server.  To re-configure
#    the running INETD process, edit this file, then send the
#    INETD process a SIGHUP signal.
#
# Version:  @(#)/etc/inetd.conf  3.10  05/27/93
#
# Authors:  Original taken from BSD UNIX 4.3/TAHOE.
#    Fred N. van Kempen, &#60;waltje@uwalt.nl.mugnet.org&#62;
#
# Modified for Debian Linux by Ian A. Murdock &#60;imurdock@shell.portal.com&#62;
#
# Echo, discard, daytime, and chargen are used primarily for testing.
#
# To re-read this file after changes, just do a 'killall -HUP inetd'
#
#echo  stream  tcp  nowait  root  internal
#echo  dgram  udp   wait    root  internal
#discard  stream  tcp  nowait  root  internal
#discard  dgram  udp   wait    root  internal
#daytime  stream tcp   nowait  root  internal
#daytime  dgram  udp   wait    root  internal
#chargen  stream tcp   nowait  root  internal
#chargen  dgram  udp   wait    root  internal
time  stream    tcp   nowait  root  internal
#
# These are standard services.
#
#ftp     stream  tcp   nowait  root  /usr/sbin/tcpd  in.ftpd -l -a
#telnet  stream  tcp   nowait  root  /usr/sbin/tcpd  in.telnetd
#
# Shell, login, exec, comsat and talk are BSD protocols.
#
#shell  stream  tcp  nowait  root  /usr/sbin/tcpd  in.rshd
#login  stream  tcp  nowait  root  /usr/sbin/tcpd  in.rlogind
#exec   stream  tcp  nowait  root  /usr/sbin/tcpd  in.rexecd
#comsat dgram   udp  wait    root  /usr/sbin/tcpd  in.comsat
#talk   dgram   udp  wait    root  /usr/sbin/tcpd  in.talkd
#ntalk  dgram   udp  wait    root  /usr/sbin/tcpd  in.ntalkd
#dtalk  stream  tcp  wait    nobody /usr/sbin/tcpd in.dtalkd
#
# Pop and imap mail services et al
#
#pop-2   stream  tcp     nowait  root    /usr/sbin/tcpd  ipop2d
pop-3    stream  tcp     nowait  root    /usr/sbin/tcpd  ipop3d
#imap    stream  tcp     nowait  root    /usr/sbin/tcpd  imapd
#
# The Internet UUCP service.
#
#uucp  stream tcp nowait uucp /usr/sbin/tcpd  /usr/lib/uucp/uucico -l
#

&#60;snip&#62;

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The above example has two services enabled: <B
CLASS="COMMAND"
>time</B
> and 
 <B
CLASS="COMMAND"
>pop3</B
>. To disable these, all we need is to open the 
 file with a text editor, comment out the two services with a
 <SPAN
CLASS="QUOTE"
>"#"</SPAN
>, save the file, and then restart <B
CLASS="COMMAND"
>inetd</B
>
 (as root): &#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; 
  # /etc/rc.d/init.d/inetd restart  

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Check your logs for errors, and run <B
CLASS="COMMAND"
>netstat</B
> again to 
 verify all went well.&#13;</P
><P
> A quicker way of getting the same information, using <B
CLASS="COMMAND"
>grep</B
>:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ grep  -v '^#' /etc/inetd.conf
 time     stream  tcp     nowait  root  internal
 pop-3    stream  tcp     nowait  root  /usr/sbin/tcpd  ipop3d

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Again, do you see anything there that you don't know what it is? Then in
 all likelihood you are not using it, and it should be disabled.&#13;</P
><P
> Unlike the init services configuration, this is a lasting change so only 
 the one step is required.</P
><P
> Let's expose one myth that gets tossed around: you shouldn't disable a 
 service by commenting out, or removing, entries from 
 <TT
CLASS="FILENAME"
>/etc/services</TT
>. This may have the desired effect 
 in some cases, but is not the right way to do it, and may interfere 
 with the normal operation of other system utilities. &#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XINETD"
>3.3.3. Xinetd</A
></H4
><P
><SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> is an <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> replacement with 
enhancements.  Red Hat includes <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> with 
7.0 and later releases.  It essentially serves the same purpose as 
<SPAN
CLASS="APPLICATION"
>inetd</SPAN
>, but the 
configuration is different. The configuration can be in the file 
<TT
CLASS="FILENAME"
>/etc/xinetd.conf</TT
>, or individual files in the directory 
<TT
CLASS="FILENAME"
>/etc/xinetd.d/</TT
>. 
 Configuration of individual services will be in the individual
files under <TT
CLASS="FILENAME"
>/etc/xinetd.d/*</TT
>. Turning off
<SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> services is done by either deleting the
corresponding configuration section, or file. Or by using your text editor and
simply setting <TT
CLASS="LITERAL"
>disable = yes </TT
> for the appropriate service.
 Or by using <B
CLASS="COMMAND"
>chkconfig</B
>.  Then, 
<SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> will need to be restarted. See <TT
CLASS="LITERAL"
>man
xinetd</TT
> and <TT
CLASS="LITERAL"
>man xinetd.conf</TT
> for syntax and
configuration options. A sample <B
CLASS="COMMAND"
>xinetd</B
> configuration:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # default: on
 # description: The wu-ftpd FTP server serves FTP connections. It uses \
 #       normal, unencrypted usernames and passwords for authentication.
 service ftp
 {
        disable                 = no
        socket_type             = stream
        wait                    = no
        user                    = root
        server                  = /usr/sbin/in.ftpd
        server_args             = -l -a
        log_on_success          += DURATION USERID
        log_on_failure          += USERID
        nice                    = 10
 }

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>You can get a quick list of enabled services:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ grep disable /etc/xinetd.d/* |grep no
 /etc/xinetd.d/finger:   disable = no
 /etc/xinetd.d/rexec:    disable = no
 /etc/xinetd.d/rlogin:   disable = no
 /etc/xinetd.d/rsh:      disable = no
 /etc/xinetd.d/telnet:   disable = no
 /etc/xinetd.d/wu-ftpd:  disable = no

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> At this point, the above output should raise some red flags. In the 
 overwhelming majority of systems, all the above can be disabled without any
 adverse impact. Not sure? Try it without that service. After disabling
 unnecessary services, then restart <B
CLASS="COMMAND"
>xinetd</B
>:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; 
  # /etc/rc.d/init.d/xinetd restart  

 </PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN472"
>3.3.4. When All Else Fails</A
></H4
><P
> OK, if you can't find the <SPAN
CLASS="QUOTE"
>"right"</SPAN
> way to stop a service, 
 or maybe a service is being started and you can't find how or where, 
 you can <SPAN
CLASS="QUOTE"
>"kill"</SPAN
> the process. To do this, you will need to know
 the PID (Process I.D.). This can be found with <B
CLASS="COMMAND"
>ps</B
>, 
 <B
CLASS="COMMAND"
>top</B
>, <B
CLASS="COMMAND"
>fuser</B
> or other system utilities.
 For <B
CLASS="COMMAND"
>top</B
> and <B
CLASS="COMMAND"
>ps</B
>, this will be the number
 in the first column. See the <A
HREF="#PID"
>Port and Process Owner</A
> 
 section in the Appendix for examples.
 </P
><P
> Example (as root):</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # kill 1163

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Then run <B
CLASS="COMMAND"
>top</B
> or <B
CLASS="COMMAND"
>ps</B
> again to verify 
 that the process is gone. If not, then:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # kill -KILL 1163

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Note the second <SPAN
CLASS="QUOTE"
>"KILL"</SPAN
> in there. This must be done either 
 by the user who owns the process, or root. Now go find where and how this 
 process got started ;-)&#13;</P
><P
> The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem can also be used to find out 
 more information about each process. Armed with the PID, we can find 
 the path to a mysterious process:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ /bin/ps ax|grep tcpgate
  921 ?   S    0:00        tcpgate

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # ls -l /proc/921/exe
 lrwxrwxrwx 1 root  root  0 July 21 12:11 /proc/921/exe -&#62; /usr/local/bin/tcpgate

 </PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXCEPTIONS"
>3.4. Exceptions</A
></H3
><P
> Above we used the criteria of turning off <EM
>all</EM
> unnecessary
 services. Sometimes that is not so obvious. And sometimes what may be 
 required for one person's configuration is not the same for another's. 
 Let's look at a few common services that fall in this category.
 </P
><P
> Again, our rule of thumb is if we don't need it, we won't run it. It's that
 simple. If we do need any of these, they are prime candidates for some 
 kind of restrictive policies via firewall rules or other mechanisms (see 
 below).</P
><P
> <P
></P
><UL
><LI
><P
>    <SPAN
CLASS="APPLICATION"
>identd</SPAN
> - This is a protocol that has been
    around for ages, and is often installed and running by default. It is used
    to provide a minimal amount of information about who is connecting to a
    server. But, it is not necessary in many cases. Where might you need it?
    Most IRC servers require it. Many mail servers use it, but don't really
    require it. Try your mail setup without it. If
    <SPAN
CLASS="APPLICATION"
>identd</SPAN
> is going to be a problem, it will
    be because there is a time out before the server starts sending or
    receiving mail. So mail should work fine without it, but may be slower. A
    few <SPAN
CLASS="APPLICATION"
>ftp</SPAN
> servers may require it. Most don't
    though.
     Older versions of Red Hat started
    <SPAN
CLASS="APPLICATION"
>identd</SPAN
> via <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>.
    Recent versions start this via init scripts. 
    
   </P
><P
>    If <SPAN
CLASS="APPLICATION"
>identd</SPAN
> is required, there are some 
    configuration options that can greatly reduce the information that is 
    revealed:

   </P
><P
>    <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>   
    /usr/sbin/in.identd in.identd -l -e -o -n -N
    
    </PRE
></FONT
></TD
></TR
></TABLE
>
   </P
><P
>    The <TT
CLASS="LITERAL"
>-o</TT
> flag tells <SPAN
CLASS="APPLICATION"
>identd</SPAN
> to
    not reveal the operating system type it is run on and to instead always
    return <SPAN
CLASS="QUOTE"
>"OTHER"</SPAN
>. The  <TT
CLASS="LITERAL"
>-e</TT
> flag tells identd
    to always return <SPAN
CLASS="QUOTE"
>"UNKNOWN-ERROR"</SPAN
> instead of the
    <SPAN
CLASS="QUOTE"
>"NO-USER"</SPAN
> or <SPAN
CLASS="QUOTE"
>"INVALID-PORT"</SPAN
> errors. The
    <TT
CLASS="LITERAL"
>-n</TT
> flag tells identd to  always  return  user numbers
    instead of user names, if you wish to keep the user names a secret. The
    <TT
CLASS="LITERAL"
>-N</TT
> flag makes identd check for the file
    <TT
CLASS="FILENAME"
>.noident</TT
> in the user's home directory for which the
    daemon is about to return a user name. It that  file  exists then the
    daemon will give the error <SPAN
CLASS="QUOTE"
>"HIDDEN-USER"</SPAN
> instead of the
    normal <SPAN
CLASS="QUOTE"
>"USERID"</SPAN
> response.

   </P
></LI
><LI
><P
>     Mail server (MTA's like <SPAN
CLASS="APPLICATION"
>sendmail</SPAN
>,
     <SPAN
CLASS="APPLICATION"
>qmail</SPAN
>, etc) - Often a fully functional mail
     server like <SPAN
CLASS="APPLICATION"
>sendmail</SPAN
> is installed by default.
     The only time that this is actually required is if you are hosting a
     domain, and receiving incoming mail directly. Or possibly, for exchanging
     mail on a LAN, in which case it does not need Internet exposure and can
     be safely firewalled. For your ISP's POP mail access, you don't need it
     even though this is a common configuration. One alternative here is to
     use <SPAN
CLASS="APPLICATION"
>fetchmail</SPAN
> for POP mail retrieval with the
     <TT
CLASS="LITERAL"
>-m</TT
> option to specify a local delivery agent:
     <TT
CLASS="LITERAL"
>fetchmail -m procmail</TT
> for instance works with no
     sendmail daemon running at all. Sendmail, can be handy to have running,
     but the point is, it is not required in many situations, and can be
     disabled, or firewalled safely.
   </P
></LI
><LI
><P
>    <SPAN
CLASS="APPLICATION"
>BIND</SPAN
> (named) - This often is installed by
    default, but is only really needed if you are an authoritative name server
    for a domain. If you are not sure what this means, then you definitely
    don't need it. BIND is probably the number one crack target on the
    Internet. <SPAN
CLASS="APPLICATION"
>BIND</SPAN
> is often used though in a
    <SPAN
CLASS="QUOTE"
>"caching"</SPAN
> only mode. This can be quite useful, but does not
    require full exposure to the Internet. In other words, it should be
    restricted or firewalled. See special handling of <A
HREF="#INDAPPS"
>individual applications</A
> below.
    
   </P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CONCLUSIONS"
>3.5. Summary and Conclusions for Step 1</A
></H3
><P
> In this section we learned how to identify which services are running 
 on our system, and were given some tips on how to determine which 
 services may be necessary. Then we learned how to find where the services
 were being started, and how to stop them. If this has not made sense, 
 now is a good time to re-read the above.</P
><P
> Hopefully you've already taken the above steps. Be sure to test your results 
 with <B
CLASS="COMMAND"
>netstat</B
> again, just to verify the desired end has 
 been achieved, and only the services that are really required are running.</P
><P
> It would also be wise to do this after the next reboot, anytime you upgrade 
 a package (to make sure a new configuration does not sneak in), and after 
 every system upgrade or new install. &#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="UPDATES"
>4. Step 2: Updating</A
></H2
><P
> OK, this section should be comparatively short, simple and straightforward
 compared to the above, but no less important.</P
><P
> The very first thing after a new install you should check 
  the errata notices at <A
HREF="http://redhat.com/errata/"
TARGET="_top"
>http://redhat.com/apps/errata/</A
>,
 and apply all relevant updates. Only a year old you say? That's a long
 time actually, and not current enough to be safe. Only a few months or few
 weeks? Check anyway. A day or two? Better safe than sorry. It is quite
 possible that security updates have been released during the pre-release
 phase of the development and release cycle. If you can't take this step,
 disable any publicly accessible services until you can.&#13;</P
><P
> Linux distributions are not static entities. They are updated with new, 
 patched packages as the need arises. The updates are just as important 
 as the original installation. Even more so, since they are fixes. Sometimes
 these updates are bug fixes, but quite often they are security fixes because
 some hole has been discovered. Such <SPAN
CLASS="QUOTE"
>"holes"</SPAN
> are
 <EM
>immediately</EM
> known to the cracker community, and they are
 quick to exploit them on a large scale. Once the hole is known, it is quite
 simple to get in through it, and there will be many out there looking for it.
 And Linux developers are also equally quick to provide fixes. Sometimes the
 same day as the hole has become known!&#13;</P
><P
> Keeping <EM
>all</EM
> installed packages current with your release 
 is one of the most important steps you can take in maintaining a secure
 system. It can not be emphasized enough that all installed packages should be
 kept updated -- not just the ones you use. If this is burdensome, consider
 uninstalling any unused packages. Actually this is a good idea anyway. &#13;</P
><P
> But where to get this information in a timely fashion? There are a number of
 web sites that offer the latest security news. There are also a number of
 mailing lists dedicated to this topic.   In fact, Red Hat has the <SPAN
CLASS="QUOTE"
>"watch"</SPAN
>
 list, just for this purpose at <A
HREF="https://listman.redhat.com/mailman/listinfo/redhat-watch-list"
TARGET="_top"
>https://listman.redhat.com/mailman/listinfo/redhat-watch-list</A
>. This is a very low 
 volume list by the way.  This is an excellent way to stay abreast of
 issues effecting your release, and is <EM
>highly
 recommended</EM
>. <A
HREF="http://linuxsecurity.com"
TARGET="_top"
>http://linuxsecurity.com</A
> is a good
 site for Linux only issues. They also have weekly newsletters available:
 <A
HREF="http://www.linuxsecurity.com/general/newsletter.html"
TARGET="_top"
>http://www.linuxsecurity.com/general/newsletter.html</A
>.
 </P
><P
> 
  Red Hat also has the <SPAN
CLASS="APPLICATION"
>up2date</SPAN
> utility 
 for automatically keeping your system(s) up to date ;-). See the man page 
 for details.&#13;</P
><P
> This is not a one time process -- it is ongoing. It is important to stay 
 current. So watch those security notices. And subscribe to 
   that 
 security mailing list today! If you have cable modem, DSL, or other 
 full time connection, there is no excuse not to do this religiously. 
 All distributions make this easy enough!
 </P
><P
> One last note: any time a new package is installed, there is also a 
 chance that a new or revised configuration has been installed as well. 
 Which means that if this package is a server of some kind, it may be 
 enabled as a result of the update. This is bad manners, but it can 
 happen, so be sure to run <SPAN
CLASS="APPLICATION"
>netstat</SPAN
> or 
 comparable to verify your system is where you want it after any 
 updates or system changes. In fact, do it periodically even if there are no
 such changes.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN571"
>4.1. Summary and Conclusions for Step 2</A
></H3
><P
> It is very simple: make sure your Linux installation is current. Check 
   the Red Hat errata  
 for what updated packages may be available. There is nothing 
 wrong with running an older release, just so the packages in it are 
 updated according to what   Red Hat 
 has made available since the initial release. At least as long as 
   Red Hat  is still supporting
 the release and updates are still being provided.  For instance,
 Red Hat has stopped providing updates for 5.0 and 5.1, but still does for
 5.2.
 </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FIREWALLS"
>5. Step 3: Firewalls and Setting Access Policies</A
></H2
><P
> So what is a <SPAN
CLASS="QUOTE"
>"firewall"</SPAN
>? It's a vague term that can mean
 anything that acts as a protective barrier between us and the outside world.
 This can be a dedicated system, or a specific application that provides this
 functionality. Or it can be a combination of components, including various
 combinations of hardware and software. Firewalls are built from 
 <SPAN
CLASS="QUOTE"
>"rules"</SPAN
> that are used to define what is allowed to enter and
 exit a given system or network. Let's look at some of the possible components
 that are readily available for Linux, and how we might implement a reasonably
 safe firewalling strategy.&#13;</P
><P
> In Step 1 above, we have turned off all services we don't need. In our 
 example, there were a few we still needed to have running. In this 
 section, we will take the next step here and decide which we need to leave
 open to the world. And which we might be able to restrict in some way. If we can
 block them all, so much the better, but this is not always practical.&#13;</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="STRATEGY"
>5.1. Strategy</A
></H3
><P
> What we want to do now is restrict connections and traffic so that we only 
 allow the minimum necessary for whatever our particular situation is. In
 some cases we may want to block all incoming <SPAN
CLASS="QUOTE"
>"new"</SPAN
> connection
 attempts. Example: we want to run <SPAN
CLASS="APPLICATION"
>X</SPAN
>, but don't
 want anyone from outside to access it, so we'll block it completely from 
 outside connections.  In other situations, we may want to limit, or restrict,
 incoming connections to trusted sources only. The more restrictive, the
 better. Example: we want to <B
CLASS="COMMAND"
>ssh</B
> into our system from
 outside, but we only ever do this from our workplace. So we'll limit
 <B
CLASS="COMMAND"
>sshd</B
> connections to our workplace address range. There are
 various ways to do this, and we'll look at the most common ones. 
 </P
><P
> We also will not want to limit our firewall to any one application. There is 
 nothing wrong with a <SPAN
CLASS="QUOTE"
>"layered"</SPAN
> defense-in-depth approach. Our
 front line protection will be a packet filter -- either
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> or <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>
 (see below). Then we can use additional tools and mechanisms to reinforce 
 our firewall.
 </P
><P
> We will include some brief examples. Our rule of thumb will be to deny
 everything as the default policy, then open up just what we need. We'll try
 to keep this as simple as possible since it can be an involved and complex
 topic, and just stick to some of the most basic concepts. See the 
 <A
HREF="#LINKS"
>Links section</A
> for further reading on this
 topic.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FILTERS"
>5.2. Packet Filters -- Ipchains and Iptables</A
></H3
><P
> <SPAN
CLASS="QUOTE"
>"Packet filters"</SPAN
> (like <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>) 
 have the ability to look at individual packets, and make decisions based 
 on what they find. These can be used for many purposes. One common purpose
 is to implement a firewall.</P
><P
> Common packet filters on Linux are <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> which
 is standard with 2.2 kernels, and <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> which
 is available with the more recent 2.4 kernels.
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> has more advanced packet filtering
 capabilities and is recommended for anyone running a 2.4 kernel. But either
 can be effective for our purposes. <SPAN
CLASS="APPLICATION"
>ipfwadm</SPAN
> is 
 a similar utility for 2.0 kernels (not discussed here).
 </P
><P
> If constructing your own <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> or
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> firewall rules seems a bit daunting,
 there are various sites that can automate the process. See the 
 <A
HREF="#LINKS"
>Links section</A
>. Also the included examples may be
 used as a starting point. 
  
  As of Red Hat 7.1, Red Hat is providing init scripts 
 for <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, 
 and <SPAN
CLASS="APPLICATION"
>gnome-lokkit</SPAN
> for generating a very basic
 set of firewall rules (<A
HREF="#LOKKIT"
>see below</A
>).  This may be
 adequate, but it is still recommended to know the proper syntax and 
 how the various mechanisms work as such tools rarely do more than a 
 few very simple rules.&#13;</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>  Various examples are given below. These are presented for illustrative 
  purposes to demonstrate some of the concepts being discussed here. 
  While they might also be useful as a starting point for your own 
  script, please note that they are not meant to be all encompassing.
  You are strongly encouraged to understand how the scripts work, so 
  you can create something even more tailored for your own situation.
 </P
><P
>  The example scripts are just protecting inbound connections to one interface 
  (the one connected to the Internet). This may be adequate for many simple
  home type situations, but, conversely, this approach is not adequate for 
  <EM
>all</EM
> situations! 
 </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="IPCHAINS"
>5.2.1. ipchains</A
></H4
><P
> <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> can be used with either 2.2 or 2.4
 kernels. When <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> is in place, it checks
 every packet that moves through the system. The packets move across different
 <SPAN
CLASS="QUOTE"
>"chains"</SPAN
>, depending where they originate and where they are
 going. Think of <SPAN
CLASS="QUOTE"
>"chains"</SPAN
> as rule sets. In advanced
 configurations, we could define our own custom chains. The three default
 built-in chains are <TT
CLASS="LITERAL"
>input</TT
>, which is incoming traffic,
 <TT
CLASS="LITERAL"
>output</TT
>, which is outgoing traffic, and
 <TT
CLASS="LITERAL"
>forward</TT
>, which is traffic being forwarded from one
 interface to another (typically used for <SPAN
CLASS="QUOTE"
>"masquerading"</SPAN
>).
 Chains can be manipulated in various ways to control the flow of traffic in
 and out of our system. Rules can be added at our discretion to achieve 
 the desired result.&#13;</P
><P
> At the end of every <SPAN
CLASS="QUOTE"
>"chain"</SPAN
> is a <SPAN
CLASS="QUOTE"
>"target"</SPAN
>. The 
 target is specified with the <TT
CLASS="LITERAL"
>-j</TT
> option to the command. The
 target is what decides the fate of the packet and essentially terminates that
 particular chain. The most common targets are mostly self-explanatory:
 <TT
CLASS="LITERAL"
>ACCEPT</TT
>, <TT
CLASS="LITERAL"
>DENY</TT
>,
 <TT
CLASS="LITERAL"
>REJECT</TT
>, and <TT
CLASS="LITERAL"
>MASQ</TT
>.
 <TT
CLASS="LITERAL"
>MASQ</TT
> is for <SPAN
CLASS="QUOTE"
>"ipmasquerading"</SPAN
>.
 <TT
CLASS="LITERAL"
>DENY</TT
> and <TT
CLASS="LITERAL"
>REJECT</TT
> essentially do the
 same thing, though in different ways. Is one better than the other? That is
 the subject of much debate, and depends on other factors that are beyond the
 scope of this document. For our purposes, either should suffice.
 </P
><P
> <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> has a very flexible configuration. Port 
 (or port ranges), interfaces, destination address, source address can be
 specified, as well as various other options. The man page explains these 
 details well enough that we won't get into specifics here.</P
><P
> Traffic entering our system from the Internet, enters via the
 <TT
CLASS="LITERAL"
>input</TT
> chain. This is the one that we need as tight as we
 can make it.</P
><P
> Below is a brief example script for a hypothetical system. We'll let the
 comments explain what this script does. Anything starting with a 
 <SPAN
CLASS="QUOTE"
>"#"</SPAN
> is a comment. <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> rules 
 are generally incorporated into shell scripts, using shell variables to 
 help implement the firewalling logic.&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;#!/bin/sh
#
# ipchains.sh
#
# An example of a simple ipchains configuration. 
#
# This script allows ALL outbound traffic, and denies 
# ALL inbound connection attempts from the outside.
#
###################################################################
# Begin variable declarations and user configuration options ######
#
IPCHAINS=/sbin/ipchains
# This is the WAN interface, that is our link to the outside world.
# For pppd and pppoe users.
# WAN_IFACE="ppp0"
WAN_IFACE="eth0"

## end user configuration options #################################
###################################################################

# The high ports used mostly for connections we initiate and return
# traffic.
LOCAL_PORTS=`cat /proc/sys/net/ipv4/ip_local_port_range |cut -f1`:\
`cat /proc/sys/net/ipv4/ip_local_port_range |cut -f2`

# Any and all addresses from anywhere.
ANYWHERE="0/0"

# Let's start clean and flush all chains to an empty state.
$IPCHAINS -F  

# Set the default policies of the built-in chains. If no match for any 
# of the rules below, these will be the defaults that ipchains uses.
$IPCHAINS -P forward DENY
$IPCHAINS -P output ACCEPT
$IPCHAINS -P input DENY 

# Accept localhost/loopback traffic.
$IPCHAINS -A input -i lo -j ACCEPT

# Get our dynamic IP now from the Inet interface. WAN_IP will be our
# IP address we are protecting from the outside world. Put this
# here, so default policy gets set, even if interface is not up
# yet.
WAN_IP=`ifconfig $WAN_IFACE |grep inet |cut -d : -f 2 |cut -d \  -f 1`

# Bail out with error message if no IP available! Default policy is 
# already set, so all is not lost here.
[ -z "$WAN_IP" ] &#38;&#38; echo "$WAN_IFACE not configured, aborting." &#38;&#38; exit 1

# Accept non-SYN TCP, and UDP connections to LOCAL_PORTS. These are
# the high, unprivileged ports (1024 to 4999 by default). This will
# allow return connection traffic for connections that we initiate
# to outside sources. TCP connections are opened with 'SYN' packets.
$IPCHAINS -A input -p tcp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS ! -y -j ACCEPT 

# We can't be so selective with UDP since that protocol does not
# know about SYNs.
$IPCHAINS -A input -p udp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS -j ACCEPT 

## ICMP (ping)
#
# ICMP rules, allow the bare essential types of ICMP only. Ping
# request is blocked, ie we won't respond to someone else's pings,
# but can still ping out. 
$IPCHAINS -A input  -p icmp  --icmp-type echo-reply \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPCHAINS -A input  -p icmp  --icmp-type destination-unreachable \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPCHAINS -A input  -p icmp  --icmp-type time-exceeded \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT

###################################################################
# Set the catchall, default rule to DENY, and log it all. All other
# traffic not allowed by the rules above, winds up here, where it is
# blocked and logged. This is the default policy for this chain
# anyway, so we are just adding the logging ability here with '-l'.
# Outgoing traffic is allowed as the default policy for the 'output'
# chain. There are no restrictions on that.

$IPCHAINS -A input -l -j DENY

echo "Ipchains firewall is up `date`."

##-- eof ipchains.sh

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> To use the above script would require that it is executable (i.e. 
 <TT
CLASS="LITERAL"
>chmod +x ipchains.sh</TT
>), and run by root to build the
 chains, and hence the firewall. &#13;</P
><P
> To summarize what this example did was to start by setting some shell 
 variables in the top section, to be used later in the script. Then we set
 the default rules (ipchains calls these <SPAN
CLASS="QUOTE"
>"policies"</SPAN
>) of denying
 all inbound and forwarded traffic, and of allowing all our own outbound
 traffic. We had to open some holes in the high, unprivileged ports so
 that we could have return traffic from connections that bigcat initiates to
 outside addresses. If we connect to someone's web server, we want that HTML
 data to be able to get back to us, for instance. The same applies to other
 network traffic. We then allowed a few specific types of the ICMP protocol
 (most are still blocked). We are also logging any inbound traffic that
 violates any of our rules so we know who is doing what. Notice that we are
 only using IP address here, not hostnames of any kind. This is so that 
 our firewall works, even in situation where there may be DNS failures. 
 Also, to prevent any kind of DNS spoofing.&#13;</P
><P
> See the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> man page for a full explanation 
 of syntax. The important ones we used here are:&#13;</P
><A
NAME="AEN653"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-A input</TT
>: Adds a rule to the
   <SPAN
CLASS="QUOTE"
>"input"</SPAN
> chain. The default chains are input, output, and forward.
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-p udp</TT
>: This rule only applies to the
   <SPAN
CLASS="QUOTE"
>"UDP"</SPAN
> <SPAN
CLASS="QUOTE"
>"protocol"</SPAN
>. The <TT
CLASS="LITERAL"
>-p</TT
> 
   option can be used with tcp, udp or icmp protocols.
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-i $WAN_IFACE</TT
>: This rule applies to the specified
   interface only, and applies to whatever chain is referenced (input, output,
   or forward).
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-s &#60;IP address&#62;</TT
> [port]: This rule only
   applies to the source address as specified. It can optionally have a port
   (e.g. 22) immediately afterward, or port range, e.g. 1023:4999. 
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-d &#60;IP address&#62;</TT
> [port]: This rule only
   applies to the destination address as specified. Also, it may include port or
   port range.
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-l</TT
> : Any packet that hits a rule with this option
   is logged (lower case <SPAN
CLASS="QUOTE"
>"L"</SPAN
>). 
  </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    <TT
CLASS="LITERAL"
>-j ACCEPT</TT
>: Jumps to the <SPAN
CLASS="QUOTE"
>"ACCEPT"</SPAN
> 
   <SPAN
CLASS="QUOTE"
>"target"</SPAN
>. This effectively terminates this chain 
   and decides the ultimate fate for this particular packet, which in this 
   example is to <SPAN
CLASS="QUOTE"
>"ACCEPT"</SPAN
> it. The same is 
   true for other <TT
CLASS="LITERAL"
>-j</TT
> targets like <TT
CLASS="LITERAL"
>DENY</TT
>.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></BLOCKQUOTE
><P
> By and large, the order in which command line options are specified is not
 significant. The chain name (e.g. <TT
CLASS="LITERAL"
>input</TT
>) must come first
 though.&#13;</P
><P
> Remember in Step 1 when we ran <B
CLASS="COMMAND"
>netstat</B
>, we had
 both X and print servers running among other things. We don't want these
 exposed to the Internet, even in a limited way. These are still happily
 running on bigcat, but are now safe and sound behind our
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> based firewall. You probably have other
 services that fall in this category as well.&#13;</P
><P
> The above example is a simplistic all or none approach. We allow all our own
 outbound traffic (not necessarily a good idea), and block all inbound
 connection attempts from outside. It is only protecting one interface, and 
 really just the inbound side of that interface. It would more than likely
 require a bit of fine tuning to make it work for you. For a more advanced set
 of rules, see the <A
HREF="#PFILTERS"
>Appendix</A
>. And you might
 want to read <A
HREF="http://tldp.org/HOWTO/IPCHAINS-HOWTO.html"
TARGET="_top"
>http://tldp.org/HOWTO/IPCHAINS-HOWTO.html</A
>.&#13;</P
><P
> Whenever you have made changes to your firewall, you should verify its
 integrity. One step to make sure your rules seem to be doing what you 
 intended, is to see how <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> has interpreted 
 your script. You can do this by opening your <SPAN
CLASS="APPLICATION"
>xterm</SPAN
> 
 very wide, and issuing the following command:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # ipchains -L -n -v | less

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The output is grouped according to chain. You should also find a way to scan
 yourself (see the <A
HREF="#VERIFY"
>Verifying section</A
> below). And
 then keep an eye on your logs to make sure you are blocking what is
 intended.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="IPTABLES"
>5.2.2. iptables</A
></H4
><P
> <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> is the next generation packet filter for
 Linux, and requires a 2.4 kernel. It can do everything
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> can, but has a number of noteworthy
 enhancements. The syntax is similar to <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> in
 many respects. See the man page for details.&#13;</P
><P
> The most noteworthy enhancement is <SPAN
CLASS="QUOTE"
>"connection tracking"</SPAN
>, also
 known as <SPAN
CLASS="QUOTE"
>"stateful inspection"</SPAN
>. This gives
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> more knowledge of the state of each
 packet. Not only does it know if the packet is a TCP or UDP packet, or
 whether it has the SYN or ACK flags set, but also if it is part of an existing
 connection, or related somehow to an existing connection. The implications 
 for firewalling should be obvious.&#13;</P
><P
> The bottom line is that it is easier to get a tight firewall with
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, than with
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>. So this is the recommended way to go.
 </P
><P
> Here is the same script as above, revised for
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>:&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;#!/bin/sh
#
# iptables.sh
#
# An example of a simple iptables configuration. 
#
# This script allows ALL outbound traffic, and denies 
# ALL inbound connection attempts from the Internet interface only.
#
###################################################################
# Begin variable declarations and user configuration options ######
#
IPTABLES=/sbin/iptables
# Local Interfaces
# This is the WAN interface that is our link to the outside world.
# For pppd and pppoe users.
# WAN_IFACE="ppp0"
WAN_IFACE="eth0"
#

## end user configuration options #################################
###################################################################

# Any and all addresses from anywhere.
ANYWHERE="0/0"

# This module may need to be loaded:
modprobe ip_conntrack_ftp

# Start building chains and rules #################################
#
# Let's start clean and flush all chains to an empty state.
$IPTABLES -F  

# Set the default policies of the built-in chains. If no match for any 
# of the rules below, these will be the defaults that IPTABLES uses.
$IPTABLES -P FORWARD DROP
$IPTABLES -P OUTPUT ACCEPT
$IPTABLES -P INPUT DROP

# Accept localhost/loopback traffic.
$IPTABLES -A INPUT -i lo -j ACCEPT

## ICMP (ping)
#
# ICMP rules, allow the bare essential types of ICMP only. Ping
# request is blocked, ie we won't respond to someone else's pings,
# but can still ping out.
$IPTABLES -A INPUT  -p icmp  --icmp-type echo-reply \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPTABLES -A INPUT  -p icmp  --icmp-type destination-unreachable \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPTABLES -A INPUT  -p icmp  --icmp-type time-exceeded \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT

###################################################################
# Set the catchall, default rule to DENY, and log it all. All other
# traffic not allowed by the rules above, winds up here, where it is
# blocked and logged. This is the default policy for this chain
# anyway, so we are just adding the logging ability here with '-j
# LOG'. Outgoing traffic is allowed as the default policy for the
# 'output' chain. There are no restrictions on that.

$IPTABLES -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A INPUT -m state --state NEW -i ! $WAN_IFACE -j ACCEPT
$IPTABLES -A INPUT -j LOG -m limit --limit 30/minute --log-prefix "Dropping: "

echo "Iptables firewall is up `date`."

##-- eof iptables.sh

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The same script logic is used here, and thus this does pretty much the same
 exact thing as the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> script in the
 previous section. There are some subtle differences as to syntax. Note the
 case difference in the chain names for one (e.g. INPUT vs input). Logging is
 handled differently too. It has its own <SPAN
CLASS="QUOTE"
>"target"</SPAN
> now
 (<TT
CLASS="LITERAL"
>-j LOG</TT
>), and is much more flexible.&#13;</P
><P
> There are some very fundamental differences as well, that might not be so
 obvious. Remember this section from the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> 
 script:</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;# Accept non-SYN TCP, and UDP connections to LOCAL_PORTS. These are the high,
# unprivileged ports (1024 to 4999 by default). This will allow return
# connection traffic for connections that we initiate to outside sources.
# TCP connections are opened with 'SYN' packets. We have already opened 
# those services that need to accept SYNs for, so other SYNs are excluded here
# for everything else.
$IPCHAINS -A input -p tcp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS ! -y -j ACCEPT 

# We can't be so selective with UDP since that protocol does not know 
# about SYNs.
$IPCHAINS -A input -p udp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS -j ACCEPT 

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> We jumped through hoops here with <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> so 
 that we could restrict unwanted, incoming connections as much as possible. A
 bit of a kludge, actually.&#13;</P
><P
> That section is missing from the <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> version. 
 It is not needed as connection tracking handles this quite nicely, and then
 some. This is due to the <SPAN
CLASS="QUOTE"
>"statefulness"</SPAN
> of
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>. It knows more about each packet than 
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>. For instance, it knows whether the 
 packet is part of a <SPAN
CLASS="QUOTE"
>"new"</SPAN
> connection, or an
 <SPAN
CLASS="QUOTE"
>"established"</SPAN
> connection, or a <SPAN
CLASS="QUOTE"
>"related"</SPAN
>
 connection. This is the so-called <SPAN
CLASS="QUOTE"
>"stateful inspection"</SPAN
> of 
 connection tracking.&#13;</P
><P
> There are many, many features of <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> that 
 are not touched on here. For more reading on the Netfilter project and
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, see <A
HREF="http://netfilter.samba.org"
TARGET="_top"
>http://netfilter.samba.org</A
>. 
 And for a more advanced set of rules, see the <A
HREF="#PFILTERS"
>Appendix</A
>. &#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="LOKKIT"
>5.2.3. Red Hat Firewall Configuration Tools</A
></H4
><P
> Red Hat has not included firewall configuration tools until 7.1, when 
 the GUI utility <B
CLASS="COMMAND"
>gnome-lokkit</B
> started being bundled. 
 <B
CLASS="COMMAND"
>gnome-lokkit</B
> does a minimalist set of rules for 
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> only. Explicit support for 
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> configuration is not an option, despite 
 the fact that the default kernel is 2.4.&#13;</P
><P
> <B
CLASS="COMMAND"
>gnome-lokkit</B
> is an option on non-upgrade installs, and
 can also be run as a stand-alone app any time after installation. It will ask
 a few simple questions, and dump the resulting rule-set into
 <TT
CLASS="FILENAME"
>/etc/sysconfig/ipchains</TT
>.&#13;</P
><P
> As mentioned, this is a fairly minimalist set of rules, and possibly a 
 sufficient starting point. An example
 <TT
CLASS="FILENAME"
>/etc/sysconfig/ipchains</TT
> created by
 <B
CLASS="COMMAND"
>gnome-lokkit</B
>:&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13; # Firewall configuration written by lokkit
 # Manual customization of this file is not recommended.
 # Note: ifup-post will punch the current nameservers through the
 #       firewall; such entries will *not* be listed here.
 :input ACCEPT
 :forward ACCEPT
 :output ACCEPT
 -A input -s 0/0 -d 0/0 80 -p tcp -y -j ACCEPT
 -A input -s 0/0 -d 0/0 25 -p tcp -y -j ACCEPT
 -A input -s 0/0 -d 0/0 22 -p tcp -y -j ACCEPT
 -A input -s 0/0 -d 0/0 23 -p tcp -y -j ACCEPT
 -A input -s 0/0 -d 0/0 -i lo -j ACCEPT
 -A input -s 0/0 -d 0/0 -i eth1 -j ACCEPT
 -A input -s 127.0.0.1 53 -d 0/0 -p udp -j ACCEPT
 -A input -s 0/0 -d 0/0 -p tcp -y -j REJECT
 -A input -s 0/0 -d 0/0 -p udp -j REJECT

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This is in a format that can be read by the
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> command
 <B
CLASS="COMMAND"
>ipchains-restore</B
>. Consequently, a new or modified set or
 rules can be generated with the <B
CLASS="COMMAND"
>ipchains-save</B
>, and
 redirecting the output to this file. <B
CLASS="COMMAND"
>ipchains-restore</B
> is
 indeed how the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> init script processes
 this file. So for this to work, the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>
 service must be activated: &#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # chkconfig ipchains on

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Conversely, if you want to roll your own <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>
 rules instead, you should make sure the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>
 init service is disabled. There is also an
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> init script, that works much the same as
 the <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> version. There is just no support
 from <B
CLASS="COMMAND"
>gnome-lokkit</B
> at this time.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TCPWRAPPERS"
>5.3. Tcpwrappers (libwrap)</A
></H3
><P
> <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> provides much the same desired results
 as <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> above, though works quite differently.
 <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> actually intercepts the connection
 attempt, then examines its configurations files, and decides whether to
 accept or reject the request. <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> 
 controls access at the application level, rather than the socket level 
 like <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> and <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>.
 This can be quite effective, and is a standard component on most Linux
 systems.&#13;</P
><P
> <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> consists of the configuration 
 files <TT
CLASS="FILENAME"
>/etc/hosts.allow</TT
> and
 <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
>. The functionality is provided by the 
 <SPAN
CLASS="APPLICATION"
>libwrap</SPAN
> library. &#13;</P
><P
> <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> first looks to see if access is
 permitted in <TT
CLASS="FILENAME"
>/etc/hosts.allow</TT
>, and if so, access is
 granted. If not in <TT
CLASS="FILENAME"
>/etc/hosts.allow</TT
>, the file
 <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
> is then checked to see if access is
 <EM
>not</EM
> allowed. If so, access is denied. Else,
 <EM
>access is granted</EM
>.  For this reason,
 <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
> should contain only one uncommented
 line, and that is: <TT
CLASS="LITERAL"
>ALL: ALL</TT
>. Access should then be
 permitted through entries in <TT
CLASS="FILENAME"
>/etc/hosts.allow</TT
>, where
 specific services are listed, along with the specific host addresses allowed
 to access these services. While hostnames can be used here, use of hostnames
 opens the limited possibility for name spoofing.&#13;</P
><P
> <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> is commonly used to protect services
 that are started via <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> (or 
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>). But also any program 
 that has been compiled with <SPAN
CLASS="APPLICATION"
>libwrap</SPAN
> support, can 
 take advantage of it. Just don't assume that all programs have built in 
 <SPAN
CLASS="APPLICATION"
>libwrap</SPAN
> support -- they do not. In fact, most 
 probably don't. So we will only use it in our examples here to protect
 services start via <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>. And then rely on our
 packet filtering firewall, or other mechanism, to protect non-(x)inetd
 services.&#13;</P
><P
> Below is a small snippet from a typical <TT
CLASS="FILENAME"
>inetd.conf</TT
> file:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # Pop and imap mail services et al
 #
 #pop-2   stream  tcp     nowait  root    /usr/sbin/tcpd ipop2d
 #pop-3   stream  tcp     nowait  root    /usr/sbin/tcpd ipop3d
 #imap    stream  tcp     nowait  root    /usr/sbin/tcpd imapd
 #

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The second to last column is the <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
>
 daemon -- <B
CLASS="COMMAND"
>/usr/sbin/tcpd</B
>. Immediately after is the daemon
 it is protecting. In this case, <SPAN
CLASS="APPLICATION"
>POP</SPAN
> and
 <SPAN
CLASS="APPLICATION"
>IMAP</SPAN
> mail servers. Your distro probably has 
 already done this part for you. For the few applications that have built-in
 support for <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> via the
 <SPAN
CLASS="APPLICATION"
>libwrap</SPAN
> library, specifying the daemon as above 
 is not necessary.&#13;</P
><P
> We will use the same principles here: default policy is to deny everything,
 then open holes to allow the minimal amount of traffic necessary.&#13;</P
><P
> So now with your text editor, <B
CLASS="COMMAND"
>su</B
> to root and open
 <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
>. If it does not exist, then create 
 it. It is just a plain text file. We want the following line:
 </P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; ALL: ALL

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> If it is there already, fine. If not, add it in and then save and close file.
 Easy enough. <SPAN
CLASS="QUOTE"
>"ALL"</SPAN
> is one of the keywords that
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> understands. The format is
 <TT
CLASS="LITERAL"
>$SERVICE_NAME : $WHO</TT
>, so we are denying all connections to
 all services here. At least all services that are using
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
>. Remember, this will primarily be
 <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> services. See <TT
CLASS="LITERAL"
>man 5
 hosts_access</TT
> for details on the syntax of these files. Note the
 <SPAN
CLASS="QUOTE"
>"5"</SPAN
> there!&#13;</P
><P
> Now let's open up just the services we need, as restrictively as we can, 
 with a brief example:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; ALL: 127.0.0.1
 sshd,ipop3d: 192.168.1.
 sshd: .myworkplace.com, hostess.mymomshouse.com 

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The first line allows all <SPAN
CLASS="QUOTE"
>"localhost"</SPAN
> connections. 
 You will need this. The second
 allows connections to the <SPAN
CLASS="APPLICATION"
>sshd</SPAN
> and 
 <SPAN
CLASS="APPLICATION"
>ipop3d</SPAN
> services from IP addresses that start with
 <TT
CLASS="LITERAL"
>192.168.1.</TT
>, in this case the private address range for
 our hypothetical home LAN. Note the trailing <SPAN
CLASS="QUOTE"
>"."</SPAN
>. It's
 important. The third line allows connections to only our
 <SPAN
CLASS="APPLICATION"
>sshd</SPAN
> daemon from any host associated with
 <TT
CLASS="LITERAL"
>.myworkplace.com</TT
>. Note the leading <SPAN
CLASS="QUOTE"
>"."</SPAN
> in
 this example. And then also, the single host
 <TT
CLASS="LITERAL"
>hostess.mymomshouse.com</TT
>. In summary, localhost and all
 our LAN connections have access to any and all tcpwrappered services on
 bigcat. But only our workplace addresses, and our mother can use
 <SPAN
CLASS="APPLICATION"
>sshd</SPAN
> on bigcat from outside connections. Everybody
 else is denied by the default policy in <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
>.
 </P
><P
> The types of wild cards above (<TT
CLASS="LITERAL"
>.myworkplace.com</TT
> and 
 <TT
CLASS="LITERAL"
>192.168.1.</TT
>) are not supported by
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>,
 or most other Linux applications for that matter. Also, 
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> can use hostnames in place of 
 IP addresses which is quite handy in some situations. This does 
 not work with <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and 
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>. &#13;</P
><P
> You can test your <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> configuration 
 with the included <B
CLASS="COMMAND"
>tcpdchk</B
> utility (see the man page). Note
 that at this time this does not work with <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>,
 and may not even be included in this case.&#13;</P
><P
> There is nothing wrong with using both <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
>
 and a packet filtering firewall like <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>. In
 fact, it is recommended to use a <SPAN
CLASS="QUOTE"
>"layered"</SPAN
> approach. This 
 helps guard against accidental misconfigurations. In this case, each 
 connection will be tested by the packet filter rules first, then 
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
>. &#13;</P
><P
> Remember to make backup copies before editing system configuration files, 
 restart the daemon afterward, and then check the logs for error messages.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="XINETD2"
>5.3.1. xinetd</A
></H4
><P
> As mentioned, <A
HREF="http://www.xinetd.org"
TARGET="_top"
>xinetd</A
> is an
 enhanced <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> , and replaces
 <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> as of Red Hat 7.0. It has much of the
 same functionality, with some notable enhancements. One is that
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> support  be
  is  compiled in, eliminating the need for explicit references to
 <B
CLASS="COMMAND"
>tcpd</B
>. Which means <TT
CLASS="FILENAME"
>/etc/hosts.allow</TT
>
 and <TT
CLASS="FILENAME"
>/etc/hosts.deny</TT
> are automatically in effect. 
 
 </P
><P
> Some of <SPAN
CLASS="APPLICATION"
>xinetd's</SPAN
> other enhancements: specify 
 IP address to listen on, which is a very effective method of access control;
 limit the rate of incoming connections and the total number of simultaneous
 connections; limit services to specific times of day. See the 
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> and <SPAN
CLASS="APPLICATION"
>xinetd.conf</SPAN
>
 man pages for more details.&#13;</P
><P
> The syntax is quite different though. An example from 
 <TT
CLASS="FILENAME"
>/etc/xinetd.d/tftp</TT
>:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; service tftp
 {
        socket_type     = dgram
        bind            = 192.168.1.1
        instances       = 2
        protocol        = udp
        wait            = yes
        user            = nobody
        only_from       = 192.168.1.0
        server          = /usr/sbin/in.tftpd
        server_args     = /tftpboot
        disable         = no
 }

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Notice the <TT
CLASS="LITERAL"
>bind</TT
> statement. We are only listening on, 
 or <SPAN
CLASS="QUOTE"
>"binding"</SPAN
> to, the private, LAN interface here. No outside
 connections can be made since the outside port is not even opened. We are
 also only accepting connections from <TT
CLASS="LITERAL"
>192.168.1.0</TT
>, our LAN.
 For <SPAN
CLASS="APPLICATION"
>xinetd's</SPAN
> purposes, this denotes any IP
 address beginning with <SPAN
CLASS="QUOTE"
>"192.168.1"</SPAN
>. Note that the syntax is different
 from <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>. The <TT
CLASS="LITERAL"
>server</TT
>
 statement in this case is the <B
CLASS="COMMAND"
>tftp</B
> daemon,
 <B
CLASS="COMMAND"
>in.tftpd</B
>. Again, this assumes that
 <SPAN
CLASS="APPLICATION"
>libwrap/tcpwrappers</SPAN
> support is compiled into
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>. The <TT
CLASS="LITERAL"
>user</TT
> running the
 daemon will be <SPAN
CLASS="QUOTE"
>"nobody"</SPAN
>. Yes, there is a user account called
 <SPAN
CLASS="QUOTE"
>"nobody"</SPAN
>, and it is wise to run such daemons as non-root users
 whenever possible. Lastly, the <TT
CLASS="LITERAL"
>disable</TT
> statement is
 <SPAN
CLASS="APPLICATION"
>xinetd's</SPAN
> way of turning services on or off. In
 this case, it is <SPAN
CLASS="QUOTE"
>"on"</SPAN
>. This is on here only as an example. Do
 NOT run <SPAN
CLASS="APPLICATION"
>tftp</SPAN
> as a public service as it is unsafe.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PORTSENTRY"
>5.4. PortSentry</A
></H3
><P
> <A
HREF="http://www.psionic.org/products/portsentry.html"
TARGET="_top"
>Portsentry</A
> 
 works quite differently than the other tools discussed so far. 
 <SPAN
CLASS="APPLICATION"
>Portsentry</SPAN
> does what its name implies -- 
 it guards ports. <SPAN
CLASS="APPLICATION"
>Portsentry</SPAN
> is configured with the
 <TT
CLASS="FILENAME"
>/etc/portsentry/portsentry.conf</TT
> file.
 </P
><P
> Unlike the other applications discussed above, it does this by actually
 becoming the listening server on those ports. Kind of like baiting a trap.
 Running <TT
CLASS="LITERAL"
>netstat -taup</TT
> as root while
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> is running, will show
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> as the <TT
CLASS="LITERAL"
>LISTENER</TT
> on
 whatever ports <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> is configured for. If
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> senses a connection attempt, it blocks
 it completely. And then goes a step further and blocks the route to that host
 to stop all further traffic. Alternately, <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>
 or <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> can be used to block the host
 completely. So it makes an excellent tool to stop port scanning of a range of
 ports.
 </P
><P
> But <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> has limited flexibility as to 
 whether it allows a given connection. It is pretty much all or nothing. You
 can define specific IP addresses that it will ignore in 
 <TT
CLASS="FILENAME"
>/etc/portsentry/portsentry.ignore</TT
>. But you cannot allow
 selective access to individual ports. This is because only one server can 
 bind to a particular port at the same time, and in this case that is 
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> itself. So it has limited usefulness as a
 stand-alone firewall. As part of an overall firewall strategy, yes, it can
 be quite useful. For most of us, it should not be our first line of defense,
 and we should only use it in conjunction with other tools.
 </P
><P
> Suggestion on when <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> might be useful:</P
><P
></P
><UL
><LI
><P
>  
  As a second layer of defense, behind either
  <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> or <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>. 
  Packet filtering will catch the packets first, so that anything that gets 
  to <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> would indicate a misconfiguration.
  Do not use in conjunction with <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> services --
  it won't work. They will butt heads.
 </P
></LI
><LI
><P
>  
  As a way to catch full range ports scans. Open a pinhole or two in the 
  packet filter, and let <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> catch these 
  and re-act accordingly. 
 </P
></LI
><LI
><P
>  
  If you are <EM
>very sure</EM
> you have no exposed public servers
  at all, and you just want to know who is up to what. But do not assume 
  anything about what <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> is protecting. 
  By default it does not watch all ports, and may even leave some very 
  commonly probed ports open. So make sure you configure it accordingly.
  And make sure you have tested and verified your set up first, and that
  nothing is exposed. 
 
 </P
></LI
></UL
><P
> All in all, the packet filters make for a better firewall.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROXIES"
>5.5. Proxies</A
></H3
><P
> The dictionary defines <SPAN
CLASS="QUOTE"
>"proxy"</SPAN
> as <SPAN
CLASS="QUOTE"
>"the authority or power
 to act on behalf of another"</SPAN
>. This pretty well describes software proxies as
 well. It is an intermediary in the connection path. As an example, if we
 were using a web proxy like <SPAN
CLASS="QUOTE"
>"squid"</SPAN
> (<A
HREF="http://www.squid-cache.org/"
TARGET="_top"
>http://www.squid-cache.org/</A
>), 
 every time we browse to a web site, we
 would actually be connecting to our locally running <SPAN
CLASS="APPLICATION"
>squid</SPAN
> server.
 Squid in turn, would relay our request to the ultimate, real destination. And
 then <SPAN
CLASS="APPLICATION"
>squid</SPAN
> would relay the web pages back to us. It is
 a go-between. Like <SPAN
CLASS="QUOTE"
>"firewalls"</SPAN
>, a <SPAN
CLASS="QUOTE"
>"proxy"</SPAN
> can refer
 to either a specific application, or a dedicated server which runs a proxy
 application. &#13;</P
><P
> Proxies can perform various duties, not all of which have much to do with
 security. But the fact that they are an intermediary, makes them a good place
 to enforce access control policies, limit direct connections through a
 firewall, and control how the network behind the proxy looks to the Internet.
 So this makes them strong candidates to be part of an overall firewall
 strategy. And, in fact, are sometimes used instead of packet filtering
 firewalls. Proxy based firewalls probably make more sense where many users
 are behind the same firewall. And it probably is not high on the list of
 components necessary for home based systems. &#13;</P
><P
> Configuring and administering proxies can be complex, and is beyond the scope of
 this document. The Firewall and Proxy Server HOWTO, <A
HREF="http://tldp.org/HOWTO/Firewall-HOWTO.html  "
TARGET="_top"
>http://tldp.org/HOWTO/Firewall-HOWTO.html</A
>, has examples 
 of setting up proxy firewalls. Squid usage is discussed at 
<A
HREF="http://squid-docs.sourceforge.net/latest/html/book1.htm"
TARGET="_top"
>http://squid-docs.sourceforge.net/latest/html/book1.htm</A
>
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INDAPPS"
>5.6. Individual Applications</A
></H3
><P
> Some servers may have their own access control features. You should check 
 this for each server application you run. We'll only look at a few of the
 common ones in this section. Man pages, and other application specific
 documentation, is your friend here. This should be done whether you have
 confidence in your firewall or not. Again, <SPAN
CLASS="APPLICATION"
>layers</SPAN
>
 of protection is always best. &#13;</P
><P
> <P
></P
><UL
><LI
><P
>    <SPAN
CLASS="APPLICATION"
>BIND</SPAN
> - a very common package that provides name
    server functionality. The daemon itself is <SPAN
CLASS="QUOTE"
>"named"</SPAN
>. This only 
    requires full exposure to the Internet if you are providing DNS look ups 
    for one or more domains to the rest of the world. If you are not sure what
    this means, <EM
>you do not need, or want</EM
>, it exposed. For
    the overwhelming majority of us this is the case. It is a very common
    crack target. 

   </P
><P
>    But it may be installed, and can be useful in a caching only mode. This 
    does not require full exposure to the Internet. Limit the interfaces 
    on which it <SPAN
CLASS="QUOTE"
>"listens"</SPAN
> by editing
    <TT
CLASS="FILENAME"
>/etc/named.conf</TT
> (random example shown):
   </P
><P
>    <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 options {
   directory "/var/named";
   listen-on { 127.0.0.1; 192.168.1.1; };
   version "N/A";
 };
   
    </PRE
></FONT
></TD
></TR
></TABLE
>
   </P
><P
>     The <SPAN
CLASS="QUOTE"
>"listen-on"</SPAN
> statement is what limits where named 
     listens for DNS queries. In this example, only on localhost and bigcat's
     LAN interface. There is no port open for the rest of the world. It just
     is not there. Restart <B
CLASS="COMMAND"
>named</B
> after making changes.
   </P
></LI
><LI
><P
>   X11 can be told not to allow TCP connections by using the
   <TT
CLASS="LITERAL"
>-nolisten tcp</TT
> command line option. If using 
   <B
CLASS="COMMAND"
>startx</B
>, you can make this automatic by placing 
   <TT
CLASS="LITERAL"
>alias startx="startx -- -nolisten tcp"</TT
> in your
   <TT
CLASS="FILENAME"
>~/.bashrc</TT
>, or the system-wide file, 
   <TT
CLASS="FILENAME"
>/etc/bashrc</TT
>, with your text editor. If using 
   <SPAN
CLASS="APPLICATION"
>xdm</SPAN
> (or variants such as
   <SPAN
CLASS="APPLICATION"
>gdm</SPAN
>, <SPAN
CLASS="APPLICATION"
>kdm</SPAN
>, etc), 
   this option would be specified in
   <SPAN
CLASS="APPLICATION"
>/etc/X11/xdm/Xservers</SPAN
> (or comparable) as 
   <TT
CLASS="LITERAL"
>:0 local /usr/bin/X11/X -nolisten tcp</TT
>. 
   <SPAN
CLASS="APPLICATION"
>gdm</SPAN
> actually uses 
   <TT
CLASS="FILENAME"
>/etc/X11/gdm/gdm.conf</TT
>.
   
  </P
><P
>   If using <SPAN
CLASS="APPLICATION"
>xdm</SPAN
> (or comparable) to start X 
   automatically at boot, <TT
CLASS="FILENAME"
>/etc/inittab</TT
> can 
   be modified as: <TT
CLASS="LITERAL"
>xdm -udpPort 0</TT
>, to further 
   restrict connections. This is typically near the bottom of 
   <TT
CLASS="FILENAME"
>/etc/inittab</TT
>.
  </P
></LI
><LI
><P
>   Recent versions of <SPAN
CLASS="APPLICATION"
>sendmail</SPAN
> can be told to 
   listen only on specified addresses:

  </P
><P
>   <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # SMTP daemon options
 O DaemonPortOptions=Port=smtp,Addr=127.0.0.1, Name=MTA

   </PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>   The above excerpt is from <TT
CLASS="FILENAME"
>/etc/sendmail.cf</TT
> which can
   be carefully added with your text editor. The
   <TT
CLASS="FILENAME"
>sendmail.mc</TT
> directive is:
  </P
><P
>   <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 dnl This changes sendmail to only listen on the loopback device 127.0.0.1
 dnl and not on any other network devices.
 DAEMON_OPTIONS(`Port=smtp,Addr=127.0.0.1, Name=MTA')

   </PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>  In case you would prefer to build a new <TT
CLASS="FILENAME"
>sendmail.cf</TT
>,
  rather than edit the existing one. Other mail server daemons likely have
  similar configuration options. Check your local documentation.
   As of Red Hat 7.1, <SPAN
CLASS="APPLICATION"
>sendmail</SPAN
> has 
  compiled in support for <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> as well.
 
  </P
></LI
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>SAMBA</SPAN
> connections can be restricted in 
   <TT
CLASS="FILENAME"
>smb.conf</TT
>:
  </P
><P
>   <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; bind interfaces = true
 interfaces = 192.168.1. 127.
 hosts allow = 192.168.1. 127.

   </PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>   This will only open, and allow, connections from localhost (127.0.0.1), 
   and the local LAN address range. Adjust the LAN address as needed.

  </P
></LI
><LI
><P
>   The <SPAN
CLASS="APPLICATION"
>CUPS</SPAN
> print daemon can be told where 
   to listen for connections. Add to <TT
CLASS="FILENAME"
>/etc/cups/cupsd.conf</TT
>:
  </P
><P
>   <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; Listen 192.168.1.1:631

   </PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>   This will only open a port at the specified address and port number.
  </P
></LI
><LI
><P
>   <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> can force daemons to listen only 
   on a specified address with its <SPAN
CLASS="QUOTE"
>"bind"</SPAN
> configuration
   directive. For instance, an internal LAN interface address. 
   See <TT
CLASS="LITERAL"
>man xinetd.conf</TT
> for this and other syntax. 
   There are various other control mechanisms as well.

  </P
></LI
></UL
></P
><P
> As always, anytime you make system changes, backup the configuration file
 first, restart the appropriate daemon afterward, and then check the
 appropriate logs for error messages.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="VERIFY"
>5.7. Verifying</A
></H3
><P
> The final step after getting your firewall in place, is to verify that it 
 is doing what you intended. You would be wise to do this anytime you make 
 even minor changes to your system configuration. </P
><P
> So how to do this? There are several things you can do.</P
><P
> For our packet filters like <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and 
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, we can list all our rules, chains, 
 and associated activity with <TT
CLASS="LITERAL"
>iptables -nvL | less</TT
>
 (substitute <B
CLASS="COMMAND"
>ipchains</B
> if appropriate). Open 
 your xterm as wide as possible to avoid wrapping long lines. </P
><P
> This should give you an idea if your chains are doing what you think they 
 should. You may want to perform some of the on-line tasks you normally do 
 first: open a few web pages, send and retrieve mail, etc. This will, of 
 course, not give you any information on <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> or 
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
>. <B
CLASS="COMMAND"
>tcpdchk</B
> can 
 be used to verify <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> configuration 
 (except with <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>).&#13;</P
><P
> And then, scan yourself. <SPAN
CLASS="APPLICATION"
>nmap</SPAN
> is the scanning 
 tool of choice and  
  is included with recent Red Hat releases, or from 
 <A
HREF="http://www.insecure.org/nmap/nmap_download.html"
TARGET="_top"
>http://www.insecure.org/nmap/nmap_download.html</A
>. <SPAN
CLASS="APPLICATION"
>nmap</SPAN
> is very 
 flexible, and essentially is a <SPAN
CLASS="QUOTE"
>"port prober"</SPAN
>. In other words, 
 it looks for open ports, among other things. See the
 <SPAN
CLASS="APPLICATION"
>nmap</SPAN
> man page for details.
 </P
><P
> If you do run <SPAN
CLASS="APPLICATION"
>nmap</SPAN
> against yourself (e.g. 
 <TT
CLASS="LITERAL"
>nmap localhost</TT
>), this should tell you what ports are 
 open -- and <EM
>visible locally</EM
> only! Which hopefully by now, is
 quite different from what can be seen from the outside. So, scan yourself,
 and then find a trusted friend, or site (see the <A
HREF="#LINKS"
>Links
 section</A
>), to scan you from the outside. Make sure you are not
 violating your ISPs Terms of Service by port scanning. It may not be allowed,
 even if the intentions are honorable. Scanning from outside is the best way
 to know how the rest of the world sees you. This should tell you how well
 that firewall is working. See the <A
HREF="#NMAP"
>nmap</A
> section in
 the Appendix for some examples on <SPAN
CLASS="APPLICATION"
>nmap</SPAN
> usage.
 </P
><P
> One caveat on this: some ISPs may filter some ports, and you will not know
 for sure how well your firewall is working. Conversely, they make it look 
 like certain ports are open by using web, or other, proxies. The scanner 
 may see the web proxy at port 80 and mis-report it as an open port on your 
 system.  &#13;</P
><P
> Another option is to find a website that offers <EM
>full
 range</EM
> testing. <A
HREF="http://www.hackerwhacker.com"
TARGET="_top"
>http://www.hackerwhacker.com</A
> is
 one such site. Make sure that any such site is not just scanning a relatively
 few well known ports.&#13;</P
><P
> Repeat this procedure with every firewall change, every system upgrade or new
 install, and when any key components of your system changes.&#13;</P
><P
> You may also want to enable logging all the denied traffic. At least 
 temporarily. Once the firewall is verified to be doing what you think it 
 should, and if the logs are hopelessly overwhelming, you may want to disable
 logging. &#13;</P
><P
> If relying on <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
> at all, please read the 
 documentation. Depending on your configuration it will either drop the 
 route to the scanner, or implement a 
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>/<SPAN
CLASS="APPLICATION"
>iptables</SPAN
> rule
 doing the same thing. Also, since it <SPAN
CLASS="QUOTE"
>"listens"</SPAN
> on the 
 specified ports, all those ports will show as <SPAN
CLASS="QUOTE"
>"open"</SPAN
>. A false
 alarm in this case.
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOGGING"
>5.8. Logging</A
></H3
><P
> Linux does a lot of logging. Usually to more than one file. It is not always
 obvious what to make of all these entries -- good, bad or indifferent? Firewall 
 logs tend to generate a fair amount of each. Of course, you are wanting to 
 stop only the <SPAN
CLASS="QUOTE"
>"bad"</SPAN
>, but you will undoubtedly catch some
 harmless traffic as well. The 'net has a lot of background noise. &#13;</P
><P
> In many cases, knowing the intentions of an incoming packet are almost
 impossible. Attempted intrusion? Misbehaved protocol? Mis-typed IP address?
 Conclusions can be drawn based on factors such as destination port, source
 port, protocol, and many other variables. But there is no substitute for
 experience in interpreting firewall logs. It is a black art in many cases.&#13;</P
><P
> So do we really need to log? And how much should we be trying to log? Logging
 is good in that it tells us that the firewall is functional. Even if we
 don't understand much of it, we know it is doing <SPAN
CLASS="QUOTE"
>"something"</SPAN
>.
 And if we have to, we can dig into those logs and find whatever data might be
 called for.
 </P
><P
> On the other hand, logging can be bad if it is so excessive, it is difficult
 to find pertinent data, or worse, fills up a partition. Or if we over re-act
 and take every last entry as an all out assault. Some perspective is a great
 benefit, but something that new users lack almost by definition. Again, once
 your firewall is verified, and you are perplexed or overwhelmed, home
 desktop users may want to disable as much logging as possible. Anyone with
 greater responsibilities should log, and then find ways to extract the
 pertinent data from the logs by filtering out extraneous information.&#13;</P
><P
> Not sure where to look for log data?   The two logs to keep an eye on are
 <TT
CLASS="FILENAME"
>/var/log/messages</TT
> and <TT
CLASS="FILENAME"
>/var/log/secure</TT
>.
 There may be other application specific logs, depending on what you have 
 installed, or using. <SPAN
CLASS="APPLICATION"
>FTP</SPAN
>, for instance, logs 
 to <TT
CLASS="FILENAME"
>/var/log/xfer</TT
> on Red Hat.&#13;</P
><P
> <SPAN
CLASS="APPLICATION"
>Portsentry</SPAN
> and <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> 
 do a certain amount of logging that is not adjustable.
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> has logging enhancements that can be turned
 on. Both <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, on the other hand, are very flexible as
 to what is logged. </P
><P
> For <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> the <TT
CLASS="LITERAL"
>-l</TT
> option can
 be added to any rule. <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> uses the
 <TT
CLASS="LITERAL"
>-j LOG</TT
> target, and requires its own, separate rule instead.
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> goes a few steps further and allows
 customized log entries, and rate limiting. See the man page. Presumably, we 
 are more interested in logging blocked traffic, so we'd confine logging to 
 only our <TT
CLASS="LITERAL"
>DENY</TT
> and <TT
CLASS="LITERAL"
>REJECT</TT
> rules.&#13;</P
><P
> So whether you log, and how much you log, and what you do with the logs, is
 an individual decision, and probably will require some trial and error so
 that it is manageable. A few auditing and analytical tools can be quite 
 helpful:&#13;</P
><P
> Some tools that will monitor your logs for you and notify you when necessary. 
 These likely will require some configuration, and trial and error, to make
 the most out of them: &#13;</P
><P
> <P
></P
><UL
><LI
><P
>   A nice log entry analyzer for <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and
   <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> from Manfred Bartz: <A
HREF="http://www.logi.cc/linux/NetfilterLogAnalyzer.php3"
TARGET="_top"
>http://www.logi.cc/linux/NetfilterLogAnalyzer.php3</A
>.
   What does all that stuff mean anyway?
  
  </P
></LI
><LI
><P
>  
   <SPAN
CLASS="APPLICATION"
>LogSentry</SPAN
> (formerly <SPAN
CLASS="APPLICATION"
>logcheck</SPAN
>) is available from 
   <A
HREF="http://www.psionic.org/products/logsentry.html"
TARGET="_top"
>http://www.psionic.org/products/logsentry.html</A
>,
   the same group that is responsible for
   <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
>. <SPAN
CLASS="APPLICATION"
>LogSentry</SPAN
>
   is an all purpose log monitoring tool with a flexible configuration, that
   handles multiple logs. 
  </P
></LI
><LI
><P
>   <A
HREF="http://freshmeat.net/projects/firelogd/"
TARGET="_top"
>http://freshmeat.net/projects/firelogd/</A
>, the Firewall Log Daemon from Ian Jones, is designed to 
   watch, and send alerts on <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> or 
   <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> logs data.
   
  </P
></LI
><LI
><P
>   <A
HREF="http://freshmeat.net/projects/fwlogwatch/"
TARGET="_top"
>http://freshmeat.net/projects/fwlogwatch/</A
> by  Boris Wesslowski, is a similar idea, but supports 
   more log formats.
   
   </P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WHERETOSTART"
>5.9. Where to Start</A
></H3
><P
> Let's take a quick look at where to run our firewall scripts from.</P
><P
> <SPAN
CLASS="APPLICATION"
>Portsentry</SPAN
> can be run as an init process, like
 other system services. It is not so important when this is done.
 <SPAN
CLASS="APPLICATION"
>Tcpwrappers</SPAN
> will be automatically be invoked by
 <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> or <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>, so not
 to worry there either.
 </P
><P
> But the packet filtering scripts will have to be started somewhere. And many 
 scripts will have logic that uses the local IP address. This will mean that 
 the script must be started after the interface has come up and been assigned
 an IP address. Ideally, this should be immediately after the interface is up.
 So this depends on how you connect to the Internet. Also, for protocols like 
 <SPAN
CLASS="APPLICATION"
>PPP</SPAN
> or <SPAN
CLASS="APPLICATION"
>DHCP</SPAN
> that may 
 be dynamic, and get different IP's on each re-connect, it is best to have 
 the scripts run by the appropriate daemon.
 </P
><P
>  Red Hat uses 
  <TT
CLASS="FILENAME"
>/etc/ppp/ip-up.local</TT
> for any user defined, local
 PPP configuration.  If this file does not exist, create it, and 
 make it executable (<TT
CLASS="LITERAL"
>chmod +x</TT
>). Then with your text editor, 
 add a reference to your firewall script.&#13;</P
><P
> For <SPAN
CLASS="APPLICATION"
>DHCP</SPAN
>, it depends on which client. 
 <B
CLASS="COMMAND"
>dhcpcd</B
> will execute 
 <B
CLASS="COMMAND"
>/etc/dhcpcd/dhcpcd-&#60;interface&#62;.exe</B
> (e.g.
 dhcpcd-eth0.exe) whenever a lease is obtained or renewed. So this is where to
 put a reference to your firewall script. For
 <B
CLASS="COMMAND"
>pump</B
> (the default on Red Hat), the main
 configuration file is <TT
CLASS="FILENAME"
>/etc/pump.conf</TT
>.
 <B
CLASS="COMMAND"
>Pump</B
> will run whatever script is defined by the
 <SPAN
CLASS="QUOTE"
>"script"</SPAN
> statement any time there is a new or renewed lease:&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13; script /usr/local/bin/ipchains.sh

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> If you have a static IP address (i.e. it never changes), the placement is not
 so important and should be <EM
>before</EM
> the interface comes
 up!</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SUMMARY3"
>5.10. Summary and Conclusions for Step 3</A
></H3
><P
> In this section we looked at various components that might be used to
 construct a <SPAN
CLASS="QUOTE"
>"firewall"</SPAN
>. And learned that a firewall is as  
 much a strategy and combination of components, as it is any one particular 
 application or component. We looked at a few of the most commonly available 
 applications that can be found on most, if not all, Linux systems. This is 
 not a definitive list.</P
><P
> This is a lot of information to digest at all at one time and expect anyone 
 to understand it all. Hopefully this can used as a starting point, and 
 used for future reference as well. The packet filter firewall examples can be
 used as starting points as well. Just use your text editor, cut and paste
 into a file with an appropriate name, and then run <TT
CLASS="LITERAL"
>chmod
 +x</TT
> against it to make it executable. Some minor editing of the
 variables may be necessary. Also look at the <A
HREF="#LINKS"
>Links</A
> section for sites and utilities that can be
 used to generate a custom script. This may be a little less daunting.&#13;</P
><P
> Now we are done with Steps 1, 2 and 3. Hopefully by now you have already
 instituted some basic measures to protect your system(s) from the various and
 sundry threats that lurk on networks. If you haven't implemented any of the
 above steps yet, now is a good time to take a break, go back to the top, and
 have at it. The most important steps are the ones above.
 </P
><P
> A few quick conclusions...</P
><P
> <SPAN
CLASS="QUOTE"
>"What is best <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>, 
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
>, <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
>, 
 or <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
>?"</SPAN
> The quick answer is that 
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> can do more than any of the others. So 
 if you are using a 2.4 kernel, use 
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>. Then,
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> if using a 2.2 kernel. The long answer is
 <SPAN
CLASS="QUOTE"
>"it just depends on what you are doing and what the objective
 is"</SPAN
>. Sorry. The other tools all have some merit in any given
 situation, and all can be effective in the right situation. &#13;</P
><P
> <SPAN
CLASS="QUOTE"
>"Do I really need all these packages?"</SPAN
> No, but please combine
 more than one approach, and please follow all the above recommendations.
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> by itself is good, but in conjunction
 with some of the other approaches, we are even stronger. Do not rely on any
 single mechanism to provide a security blanket. <SPAN
CLASS="QUOTE"
>"Layers"</SPAN
> of
 protection is always best. As is sound administrative practices. The best
 <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> script in the world is but one piece of
 the puzzle, and should not be used to hide other system weaknesses.&#13;</P
><P
> <SPAN
CLASS="QUOTE"
>"If I have a small home LAN, do I need to have a firewall on each
 computer?"</SPAN
> No, not necessary as long as the LAN gateway has a properly
 configured firewall. Unwanted traffic should be stopped at that point. And as
 long as this is working as intended, there should be no unwanted traffic on
 the LAN. But, by the same token, doing this certainly does no harm. And on
 larger LANs that might be mixed platform, or with untrusted users, it would
 be advisable.&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INTRUSION"
>6. Intrusion Detection</A
></H2
><P
> This section will deal with how to get early warning, how to be alerted 
 after the fact, and how to clean up from intrusion attempts.
 </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IDS"
>6.1. Intrusion Detection Systems (IDS)</A
></H3
><P
> Intrusion Detection Systems (IDS for short) are designed to catch what might
 have gotten past the firewall. They can either be designed to catch an 
 active break-in attempt in progress, or to detect a successful break-in 
 after the fact. In the latter case, it is too late to prevent any damage, but
 at least we have early awareness of a problem. There are two basic types of
 IDS: those protecting networks, and those protecting individual hosts.&#13;</P
><P
> For host based IDS, this is done with utilities that monitor the filesystem
 for changes. System files that have changed in some way, but should not
 change -- unless we did it -- are a dead give away that something is amiss.
 Anyone who gets in, and gets root, will presumably make changes to the system
 somewhere. This is usually the very first thing done. Either so he can get
 back in through a backdoor, or to launch an attack against someone else. In
 which case, he has to change or add files to the system. &#13;</P
><P
> This is where tools like tripwire (<A
HREF="http://www.tripwire.org"
TARGET="_top"
>http://www.tripwire.org</A
>) play a role.
  Tripwire is included beginning with Red Hat 7.0. 
 Such tools monitor various aspects of the filesystem, and compare them against a
 stored database. And can be configured to send an alert if
 <EM
>any</EM
> changes are detected. Such tools should only be 
 installed on a known <SPAN
CLASS="QUOTE"
>"clean"</SPAN
> system. &#13;</P
><P
> For home desktops and home LANs, this is probably not an absolutely necessary
 component of an overall security strategy. But it does give peace of mind, and
 certainly does have its place. So as to priorities, make sure the Steps 1, 2
 and 3 above are implemented and verified to be sound, before delving into
 this.&#13;</P
><P
> We can
 get somewhat the same results with <TT
CLASS="LITERAL"
>rpm -Va</TT
>, which will
 verify all packages, but without all the same functionality. For instance, it
 will not notice new files added to most directories. Nor will it detect 
 files that have had the extended attributes changed (e.g. <TT
CLASS="LITERAL"
>chattr +i</TT
>, 
 man <B
CLASS="COMMAND"
>chattr</B
> and man <B
CLASS="COMMAND"
>lsattr</B
>). For this to
 be helpful, it needs to be done after a clean install, and then each time any
 packages are upgraded or added. Example:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 # rpm -Va &#62; /root/system.checked

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Then we have a stored system snapshot that we can refer back to. &#13;</P
><P
> Another idea is to run <B
CLASS="COMMAND"
>chkrootkit</B
>
 (<A
HREF="http://www.chkrootkit.org/"
TARGET="_top"
>http://www.chkrootkit.org/</A
>)
 as a weekly cron job. This will detect common <SPAN
CLASS="QUOTE"
>"rootkits"</SPAN
>. &#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HACKED"
>6.2. Have I Been Hacked?</A
></H3
><P
> Maybe you are reading this because you've noticed something <SPAN
CLASS="QUOTE"
>"odd"</SPAN
> 
 about your system, and are suspicious that someone was gotten in? This can be
 a clue. </P
><P
> The first thing an intruder typically does is install a <SPAN
CLASS="QUOTE"
>"rootkit"</SPAN
>. 
 There are many prepackaged rootkits available on the Internet. 
 The rootkit is essentially a script, or set of scripts, that makes quick work
 of modifying the system so the intruder is in control, and he is well hidden.
 He does this by installing modified binaries of common system utilities and
 tampering with log files. Or by using special kernel modules that achieve
 similar results. So common commands like <B
CLASS="COMMAND"
>ls</B
> may be
 modified so as to not show where he has his files stored. Clever! &#13;</P
><P
> A well designed rootkit can be quite effective. Nothing on the system can
 really be trusted to provide accurate feedback. Nothing! But sometimes the
 modifications are not as smooth as intended and give hints that something is
 not right. Some things that <EM
>might</EM
> be warning signs:</P
><P
> <P
></P
><UL
><LI
><P
>  
   <B
CLASS="COMMAND"
>Login</B
> acts weird. Maybe no one can login. Or only 
   root can login. Any <B
CLASS="COMMAND"
>login</B
> weirdness at all should be
   suspicious. Similarly, any weirdness with adding or changing passwords.
  </P
><P
>   Wierdness with other system commands (e.g. <B
CLASS="COMMAND"
>top</B
> or
   <B
CLASS="COMMAND"
>ps</B
>) should be cause for concern as well. 
  </P
></LI
><LI
><P
>   System utilities are slower, or awkward, or show strange and unexpected 
   results. Common utilities that might be modified are: <B
CLASS="COMMAND"
>ls</B
>, 
   <B
CLASS="COMMAND"
>find</B
>, <B
CLASS="COMMAND"
>who</B
>, <B
CLASS="COMMAND"
>w</B
>, 
   <B
CLASS="COMMAND"
>last</B
>, <B
CLASS="COMMAND"
>netstat</B
>,
   <B
CLASS="COMMAND"
>login</B
>, <B
CLASS="COMMAND"
>ps</B
>, <B
CLASS="COMMAND"
>top</B
>.
   This is not a definitive list!
  </P
></LI
><LI
><P
>   Files or directories named <SPAN
CLASS="QUOTE"
>"..."</SPAN
> or <SPAN
CLASS="QUOTE"
>".. "</SPAN
> 
   (dot dot space). A sure bet in this case. Files with haxor looking 
   names like <SPAN
CLASS="QUOTE"
>"r00t-something"</SPAN
>.
  </P
></LI
><LI
><P
>   Unexplained bandwidth usage, or connections. Script kiddies have a fondness 
   for IRC, so such connections should raise a red flag.
  </P
></LI
><LI
><P
>   Logs that are missing completely, or missing large sections. Or a sudden 
   change in <B
CLASS="COMMAND"
>syslog</B
> behavior.  
  </P
></LI
><LI
><P
>    Mysterious open ports, or processes. 
  </P
></LI
><LI
><P
>    Files that cannot be deleted or moved. Some rootkits use 
    <B
CLASS="COMMAND"
>chattr</B
> to make files <SPAN
CLASS="QUOTE"
>"immutable"</SPAN
>, 
    or not changable. This kind of change will not show up with
    <B
CLASS="COMMAND"
>ls</B
>, or <B
CLASS="COMMAND"
>rpm -V</B
>, so the files look
    normal at first glance. See the man pages for <B
CLASS="COMMAND"
>chattr</B
>
    and <B
CLASS="COMMAND"
>lsattr</B
> on how to reverse this. Then see the next
    section below on restoring your system as the jig is up at this point.
  </P
><P
>    This is becoming a more and more common script kiddie trick. In fact, one 
    quick test to run on a suspected system (as root):
  </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  /usr/bin/lsattr `echo $PATH | tr ':' ' '` | grep i--
  </PRE
></FONT
></TD
></TR
></TABLE
><P
>   This will look for any <SPAN
CLASS="QUOTE"
>"immutable"</SPAN
> files in root's
   <TT
CLASS="LITERAL"
>PATH</TT
>, which is almost surely a sign of trouble since 
   no standard distributions ship files in this state. If the above command 
   turns up <EM
>anything at all</EM
>, then plan on completely
   restoring the system (see below). A quick sanity check:
  </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  # chattr +i /bin/ps
  # /usr/bin/lsattr `echo $PATH | tr ':' ' '` | grep "i--"
    ---i---------- /bin/ps
  # chattr -i /bin/ps
  </PRE
></FONT
></TD
></TR
></TABLE
><P
>   This is just to verify the system is not tampered with to the point that
   <B
CLASS="COMMAND"
>lsattr</B
> is completely unreliable. The third line is 
   <EM
>exactly</EM
> what you should see. 
  </P
></LI
><LI
><P
>   Indications of a <SPAN
CLASS="QUOTE"
>"sniffer"</SPAN
>, such as log messages of an 
   interface entering <SPAN
CLASS="QUOTE"
>"promiscuous"</SPAN
> mode.
  </P
></LI
><LI
><P
>   Modifications to <TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
>, 
   <TT
CLASS="FILENAME"
>rc.local</TT
>, <TT
CLASS="FILENAME"
>rc.sysint</TT
> or
   <TT
CLASS="FILENAME"
>/etc/passwd</TT
>. Especially, any additions. Try 
   using <B
CLASS="COMMAND"
>cat</B
> or <B
CLASS="COMMAND"
>tail</B
> to view these 
   files. Additions will most likely be appended to the end. Remember though
   such changes may not be <SPAN
CLASS="QUOTE"
>"visible"</SPAN
> to any system tools. 
  </P
></LI
></UL
></P
><P
> Sometimes the intruder is not so smart and forgets about root's 
 <TT
CLASS="FILENAME"
>.bash_history</TT
>, or cleaning up log entries, or even
 leaves strange, leftover files in <TT
CLASS="FILENAME"
>/tmp</TT
>. So these should
 always be checked too. Just don't necessarily expect them to be accurate. 
 Often such left behind files, or log entries, will have obvious 
 script kiddie sounding names, e.g. <SPAN
CLASS="QUOTE"
>"r00t.sh"</SPAN
>.</P
><P
> Packet sniffers, like <SPAN
CLASS="APPLICATION"
>tcpdump</SPAN
>
 (<A
HREF="http://www.tcpdump.org"
TARGET="_top"
>http://www.tcpdump.org</A
>), might
 be useful in finding any uninvited traffic. Interpreting sniffer output is
 probably beyond the grasp of the average new user. <SPAN
CLASS="APPLICATION"
>snort</SPAN
>  
 (<A
HREF="http://www.snort.org"
TARGET="_top"
>http://www.snort.org</A
>), and 
 <SPAN
CLASS="APPLICATION"
>ethereal</SPAN
>  
 (<A
HREF="http://www.ethereal.com"
TARGET="_top"
>http://www.ethereal.com</A
>), are 
 also good. <SPAN
CLASS="APPLICATION"
>Ethereal</SPAN
> has a GUI.&#13;</P
><P
> As mentioned, a compromised system will undoubtedly have altered system
 binaries, and the output of system utilities is not to be trusted. Nothing on
 the system can be relied upon to be telling you the whole truth. Re-installing
 individual packages may or may not help since it could be system libraries
 or kernel modules that are doing the dirty work. The point here is that there
 is no way to know with absolute certainty exactly what components have been
 altered. </P
><P
>  We can
 use <TT
CLASS="LITERAL"
>rpm -Va |less</TT
> to attempt to verify the integrity all
 packages. But again there is no assurance that <SPAN
CLASS="APPLICATION"
>rpm</SPAN
>
 itself has not been tampered with, or the system components that
 <SPAN
CLASS="APPLICATION"
>RPM</SPAN
> relies on. </P
><P
> If you have <B
CLASS="COMMAND"
>pstree</B
> on your system, try this instead 
 of the standard <B
CLASS="COMMAND"
>ps</B
>. Sometimes the script kiddies forget
 about this one. No guarantees though that this is accurate either.</P
><P
> You can also try querying the <TT
CLASS="FILENAME"
>/proc</TT
> filesystem, 
 which contains everything the kernel knows about processes that are 
 running:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
> 
 # cat /proc/*/stat | awk '{print $1,$2}'
 
 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This will provide a list of all processes and PID numbers (assuming 
 a malicious kernel module is not hiding this).</P
><P
> 
 Another approach is to visit <A
HREF="http://www.chkrootkit.org"
TARGET="_top"
>http://www.chkrootkit.org</A
>, download
 their rootkit checker, and see what it says.&#13;</P
><P
> Some interesting discussions on issues surrounding forensics can be found at <A
HREF="http://www.fish.com/security/"
TARGET="_top"
>http://www.fish.com/security/</A
>. 
 There is also a collection of tools available, aptly called  
 <SPAN
CLASS="QUOTE"
>"The Coroner's Toolkit"</SPAN
> (TCT). 
 </P
><P
> Read below for steps on recovering from an intrusion. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RECLAIM"
>6.3. Reclaiming a Compromised System</A
></H3
><P
> So now you've confirmed a break-in, and know that someone else has root 
 access, and quite likely one or more hidden backdoors to your system. You've 
 lost control. How to clean up and regain control? </P
><P
> There is no sure fire way of doing this short of a complete re-install. There
 is no way to find with assurance all the modified files and backdoors that
 may have been left. Trying to patch up a compromised system risks a false 
 sense of security and may actually aggravate an already bad situation.
 </P
><P
> The steps to take, in this order:&#13;</P
><P
> <P
></P
><UL
><LI
><P
>   Pull the plug and disconnect the machine. You may be unwittingly
   participating in criminal activity, and doing to others what has been done
   to you. 
  </P
></LI
><LI
><P
>   Depending on the needs of the situation and time available to restore the
   system, it is advantageous to learn as much as you can about how the 
   attacker got in, and what was done in order to plug the hole and avoid a
   recurrence. This could conceivably be time consuming, and is not always
   feasible. And it may require more expertise than the typical user
   possesses.
  </P
></LI
><LI
><P
>   Backup important data. Do <EM
>not</EM
> include any system files
   in the backup, and system configuration files like
   <TT
CLASS="FILENAME"
>inetd.conf</TT
>. Limit the backup to personal data files 
   only! You don't want to backup, then restore something that might open 
   a backdoor or other hole.
  </P
></LI
><LI
><P
>   Re-install from scratch, and reformat the drive during the installation
   (<B
CLASS="COMMAND"
>mke2fs</B
>) to make sure no remnants are hiding. Actually, 
   replacing the drive is not a bad idea. Especially, if you want to keep 
   the compromised data available for further analysis.
  
  </P
></LI
><LI
><P
>   Restore from backups. After a clean install is the best time to install 
   an IDS (Intrusion Detection System) such as <SPAN
CLASS="APPLICATION"
>tripwire</SPAN
>
   (<A
HREF="http://www.tripwire.org"
TARGET="_top"
>http://www.tripewire.org</A
>). 
  </P
></LI
><LI
><P
>   Apply all updates  from 
   <A
HREF="ftp://updates.redhat.com"
TARGET="_top"
>ftp://updates.redhat.com</A
>.
  </P
></LI
><LI
><P
>    Re-examine your system for unnecessary services. Re-examine your firewall and 
    access policies, and tighten all holes. <EM
>Use new
    passwords</EM
>, as these were stolen in all likelihood.
  </P
></LI
><LI
><P
>    Re-connect system ;-) 
  </P
></LI
></UL
></P
><P
> At this time, any rootkit cleanup tools that may be available on-line are not 
 recommended. They probably do work just fine most of the time. But again, 
 how to be absolutely sure that all is well and all vestiges of the intrusion
 are gone?&#13;</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GENERAL"
>7. General Tips</A
></H2
><P
> This section will quickly address some general concepts for maintaining a
 more secure and reliable system or network. Let's emphasize
 <SPAN
CLASS="QUOTE"
>"maintaining"</SPAN
> here since computer systems change daily, as does
 the environment around them. As mentioned before, there isn't any one thing
 that makes a system secure. There are too many variables. Security is an
 approach and an attitude more than it is a reliance on any particular
 product, application or specific policy.
 </P
><P
> <P
></P
><UL
><LI
><P
>  
   Do not allow remote root logins. This may be controlled by a configuration 
   file such as <TT
CLASS="FILENAME"
>/etc/securetty</TT
>. Remove any lines 
   that begin <SPAN
CLASS="QUOTE"
>"pts"</SPAN
>. This is one big security hole.
  </P
></LI
><LI
><P
>   In fact, don't log in as root at all. Period. Log in on your user account
   and <B
CLASS="COMMAND"
>su</B
> to root when needed. Whether the login is remote
   or local. Or use <B
CLASS="COMMAND"
>sudo</B
>, which can run individual commands
   with root privileges. 
    
   (Red hat includes a <B
CLASS="COMMAND"
>sudo</B
> package. )
    This takes some getting used to, but it is
   the <SPAN
CLASS="QUOTE"
>"right"</SPAN
> way to do things. And the safest. And will become 
   more a more natural way of doing this as time goes on.

  </P
><P
>   I know someone is saying right now <SPAN
CLASS="QUOTE"
>"but that is so much trouble, I am
   root, and it is my system"</SPAN
>. True, but root is a specialized account that
   was not ever meant to be used as a regular user account. Root has access to
   everything, even hardware devices. The system <SPAN
CLASS="QUOTE"
>"trusts"</SPAN
> root.
   It believes that you know what you are doing. If you make a mistook, it
   assumes that you meant that, and will do it's best to do what you told it
   to do...even if that destroys the system!

  </P
><P
>   As an example, let's say you start X as root, open
   <SPAN
CLASS="APPLICATION"
>Netscape</SPAN
>, and visit a web site. The web page has
   badly behaved java script. And conceivably now that badly written java
   script might have access to much more of your system than if you had done
   it the <SPAN
CLASS="QUOTE"
>"right"</SPAN
> way.
   
  </P
></LI
><LI
><P
>   Take passwords seriously. Don't give them out to anyone. Don't use the same
   one for everything. Don't use root's password for anything else -- except
   root's password! Never sign up or register on line, using any of your
   system passwords. Passwords should be a combination of mixed case letters,
   numbers and/or punctuation and a reasonable length (eight characters or
   longer). Don't use so-called <SPAN
CLASS="QUOTE"
>"dictionary"</SPAN
> words that are easy
   to guess like <SPAN
CLASS="QUOTE"
>"cat"</SPAN
> or <SPAN
CLASS="QUOTE"
>"dog"</SPAN
>. Don't incorporate 
   personal information like names or dates or hostnames. Don't write down
   system passwords -- memorize them.
   
   
  </P
><P
>   Use the more secure <SPAN
CLASS="QUOTE"
>"shadow"</SPAN
> passwords.  
   This has been the default on Red Hat for some time now. If
   the file <TT
CLASS="FILENAME"
>/etc/shadow</TT
> exists, then it is enabled
   already. The commands <B
CLASS="COMMAND"
>pwconv</B
> and
   <B
CLASS="COMMAND"
>grpconv</B
>, can be used to convert password and group files
   to shadow format if available. 
  </P
></LI
><LI
><P
>   Avoid using programs that require clear text logins over untrusted networks 
   like the Internet. <B
CLASS="COMMAND"
>Telnet</B
> is a prime example. 
   <B
CLASS="COMMAND"
>ssh</B
> is much better. If there is any support for 
   SSL (Secure Socket Layers), use it. For instance, does your ISP offer POP
   or IMAP mail via SSL? Recent  
    Red Hat releases do include  <SPAN
CLASS="APPLICATION"
><A
HREF="http://www.openssl.org/"
TARGET="_top"
>openssl</A
></SPAN
>, and many
   Linux applications can use SSL where support is available.

  </P
></LI
><LI
><P
>   Set resource limits. There are various ways to do this. The need for 
   this probably increases with the number of users accessing a given system.
   Not only does setting limits on such things as disk space prevent
   intentional mischief, it can also help with unintentionally misbehaved
   applications or processes. <B
CLASS="COMMAND"
>quota</B
> (<TT
CLASS="LITERAL"
>man
   quota</TT
>) can be used to set disk space limits.
   <SPAN
CLASS="APPLICATION"
>Bash</SPAN
> includes the <B
CLASS="COMMAND"
>ulimit</B
>
   command (<TT
CLASS="LITERAL"
>man ulimit</TT
> or <TT
CLASS="LITERAL"
>man bash</TT
>),
   that can limit various functions on a per user basis. 
   
  </P
><P
>   Also, not discussed here at any length, but <SPAN
CLASS="APPLICATION"
>PAM</SPAN
> 
   (Pluggable Authentication Modules) has a very sophisticated approach to 
   controlling various system functions and resources. See <TT
CLASS="LITERAL"
>man
   pam</TT
> to get started. <SPAN
CLASS="APPLICATION"
>PAM</SPAN
> is configured
   via either <TT
CLASS="FILENAME"
>/etc/pam.conf</TT
> or
   <TT
CLASS="FILENAME"
>/etc/pam.d/*</TT
>. Also files in
   <TT
CLASS="FILENAME"
>/etc/security/*</TT
>, including
   <TT
CLASS="FILENAME"
>/etc/security/limits.conf</TT
>, where again various sane
   limits can be imposed. An in depth look at <SPAN
CLASS="APPLICATION"
>PAM</SPAN
>
   is beyond the scope of this document. The 
   User-Authentication HOWTO (<A
HREF="http://tldp.org/HOWTO/User-Authentication-HOWTO/index.html"
TARGET="_top"
>http://tldp.org/HOWTO/User-Authentication-HOWTO/index.html</A
>) has more on this.
   
  </P
></LI
><LI
><P
>    Make sure someone with a clue is getting root's mail. This can be done with an 
    <SPAN
CLASS="QUOTE"
>"alias"</SPAN
>. Typically, the mail server will have a file such 
    as <TT
CLASS="FILENAME"
>/etc/aliases</TT
> where this can defined. This can 
    conceivably be an account on another machine if need be:
  </P
><P
>   <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>  
 # Person who should get root's mail.  This alias
 # must exist.
 # CHANGE THIS LINE to an account of a HUMAN
 root:           hal@bigcat

   </PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>   Remember to run <B
CLASS="COMMAND"
>newaliases</B
> (or equivalent) afterward.

  </P
></LI
><LI
><P
>   Be careful where you get software. Use trusted sources. How well do you
   trust complete strangers? Check  
    Red Hat's ftp site (or mirrors) first if looking for a
   specific package. It will probably be best suited for your system any way.
   Or, the original package's project site is good as well. Installing from raw
   source (either tarball or src.rpm) at least gives you the ability to
   examine the code. Even if you don't understand it ;-) While this does not
   seem to be a wide spread problem with Linux software sites, it is very
   trivial for someone to add a very few lines of code, turning that harmless
   looking binary into a <SPAN
CLASS="QUOTE"
>"Trojan horse"</SPAN
> that opens a backdoor to
   your system. Then the jig is up.
  
  </P
></LI
><LI
><P
>    So someone has scanned you, probed you, or otherwise seems to want into
    your system? Don't retaliate. There is a good chance that the source IP 
    address is a compromised system, and the owner is a victim already. Also, 
    you may be violating someone's Terms of Service, and have trouble with 
    your own ISP. The best you can do is to send your logs to the abuse
    department of the source IP's ISP, or owner. This is often
    something like <SPAN
CLASS="QUOTE"
>"abuse@someisp.com"</SPAN
>. Just don't expect to 
    hear much back. Generally speaking, such activity is not legally 
    criminal, unless an actual break-in has taken place. Furthermore, 
    even if criminal, it will never be prosecuted unless significant 
    damage (read: big dollars) can be shown.
    
  </P
></LI
><LI
><P
>   Red Hat users can install the <SPAN
CLASS="QUOTE"
>"Bastille
   Hardening System"</SPAN
>, <A
HREF="http://www.bastille-linux.org/"
TARGET="_top"
>http://www.bastille-linux.org/</A
>.
   This is a multi-purpose system for <SPAN
CLASS="QUOTE"
>"hardening"</SPAN
> Red Hat and
   Mandrake system security. It has a GUI interface which can be used to
   construct firewall scripts from scratch and configure
   <SPAN
CLASS="APPLICATION"
>PAM</SPAN
> among many other things. Debian support 
   is new.

  </P
></LI
><LI
><P
>   So you have a full-time Internet connection via cable-modem or DSL. But 
   do you always use it, or always need it? There's an old saying that
   <SPAN
CLASS="QUOTE"
>"the only truly secure system, is a disconnected system"</SPAN
>.
   Well, that's certainly one option. So take that interface down, or stop the
   controlling daemon (<B
CLASS="COMMAND"
>dhcpcd</B
>, <B
CLASS="COMMAND"
>pppoed</B
>,
   etc).  Or possibly even set up <SPAN
CLASS="APPLICATION"
>cron</SPAN
> jobs to bring your
   connection up and down according to your normal schedule and usage. 
  
  </P
></LI
><LI
><P
>   What about cable and DSL routers that are often promoted as
   <SPAN
CLASS="QUOTE"
>"firewalls"</SPAN
>? The lower priced units are mostly equating 
   NAT (Network Address Translation), together with the ability to open holes 
   for ports through it, as a firewall. While NAT itself does provide a fair
   degree of security for the systems behind the NAT gateway, this does not
   constitute anything but a very rudimentary firewall. And if holes are
   opened, there is still exposure. Also, you are relying on the router's
   firmware and implementation not to be flawed. It is wise to have some kind
   of additional protection behind such routers. 

  </P
></LI
><LI
><P
>   What about wireless network cards and hubs? Insecure, despite what 
   the manufacturers may claim. Treat these connections just as you would an
   Internet connection. Use secure protocols like <SPAN
CLASS="APPLICATION"
>ssh</SPAN
> 
   only! Even if it is just one LAN box to another.
  </P
></LI
><LI
><P
>   If you find you need to run a particular service, and it is for just you,
   or maybe a relatively small number of people, use a non-standard port. Most 
   server daemons support this. For instance, <B
CLASS="COMMAND"
>sshd</B
> runs on 
   port 22 by default. All worms and script kiddies will expect it there, and 
   look for it there. So, run it on another port! See the <B
CLASS="COMMAND"
>sshd</B
>
   man page.
   
  </P
></LI
><LI
><P
>   What about firewalls that block Internet connections according to the
   application (like <SPAN
CLASS="APPLICATION"
>ZoneAlarm</SPAN
> from Windowsdom)?
   These were designed with this feature primarily because of the plethora 
   of virii and trojans  that are so common with MS operating systems. This 
   is really not a problem on Linux. So, really no such application exists 
   on Linux at this time. And there does not seem to be enough demand for it 
   that someone has taken the time to implement it. A better firewall can be 
   had on Linux, by following the other suggestions in this document.
  </P
></LI
><LI
><P
>   Lastly, know your system! Let's face it, if you are new to Linux, you can't
   already know something you have never used. Understood. But in the process
   of learning, learn how to do things the right way, not the easiest way.
   There is several decades of history behind <SPAN
CLASS="QUOTE"
>"the right way"</SPAN
> of
   doing things. This has stood the test of time. What may seem unnecessary or
   burdensome now, will make sense in due time.
  </P
><P
>   Be familiar with whatever services you are running, and the implications
   these services might have to the overall health of your system if
   something does go wrong. Read what you can, and ask questions. Don't run
   something as a service <SPAN
CLASS="QUOTE"
>"just because I can"</SPAN
>, or because the
   installer put it there. You can't start out being an experienced System
   Administrator clearly. But you can work to learn enough about your own
   system, that you are in control. This is one thing that separates *nix from
   MS systems: we can never be in complete control with MS, but we can with
   *nix. Conversely, if something bad happens, we often have no one else to
   blame. 
  </P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="APPENDIX"
>8. Appendix</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SERVERSETC"
>8.1. Servers, Ports, and Packets</A
></H3
><P
> Let's take a quick, non-technical look at some networking concepts, and how
 they can potentially impact our own security. We don't need to know much
 about networking, but a general idea of how things work is certainly going to
 help us with firewalls and other related issues.</P
><P
> As you may have noticed Linux is a very network oriented Operating System. 
 Much is done by connecting to <SPAN
CLASS="QUOTE"
>"servers"</SPAN
> of one type or another
 -- X servers, font servers, print servers, etc. &#13;</P
><P
> Servers provide <SPAN
CLASS="QUOTE"
>"services"</SPAN
>, which provide various capabilities,
 both to the local system and potentially other remote systems. The same
 server generally provides both functionalities. Some servers
 work quietly behind the scenes, and others are more interactive by nature. We
 may only be aware of a print server when we need to print something, but it
 is there running, listening, and waiting for connection requests whether we
 ever use it or not (assuming of course we have it enabled). A typical Linux
 installation will have many, many types of servers available to it. Default 
 installations often will turn some of these <SPAN
CLASS="QUOTE"
>"on"</SPAN
>.</P
><P
> And even if we are not connected to a real network all the time, we are still
 <SPAN
CLASS="QUOTE"
>"networked"</SPAN
> so to speak. Take our friendly local X server for
 instance. We may tend to think of this as just providing a GUI interface,
 which is only true to a point. It does this by <SPAN
CLASS="QUOTE"
>"serving"</SPAN
> to
 client applications, and thus is truly a server. But X Windows is also
 capable of serving remote clients over a network -- even large networks like
 the Internet. Though we probably don't really want to be doing this ;-)</P
><P
> And yes, if you are not running a firewall or have not taken other
 precautions, and are connected to the Internet, it is quite possible that
 someone -- anyone -- could connect to your X server. X11
 <SPAN
CLASS="QUOTE"
>"listens"</SPAN
> on TCP <SPAN
CLASS="QUOTE"
>"port"</SPAN
> 6000 by default. This 
 principle applies to most other servers as well -- they can be easily 
 connected to, unless something is done to restrict or prevent connections.</P
><P
> In TCP/IP (Transmission Control Protocol/Internet Protocol) networks like we
 are talking about with Linux and the Internet, every connected computer 
 has a unique <SPAN
CLASS="QUOTE"
>"IP Address"</SPAN
>. Think of this like a phone number. 
 You have a phone number, and in order to call someone else, you have to know
 that phone number, and then dial it. The phone numbers have to be unique for
 the system to work. IP address are generally expressed as <SPAN
CLASS="QUOTE"
>"dotted
 quad"</SPAN
> notation, e.g. 152.19.254.81.&#13;</P
><P
> On this type of network, servers are said to <SPAN
CLASS="QUOTE"
>"listen"</SPAN
>. This
 means that they have a <SPAN
CLASS="QUOTE"
>"port"</SPAN
> opened, and are awaiting incoming
 connections to that port. Connections may be local, as is typically the case
 with our X server, or remote -- meaning from another computer
 <SPAN
CLASS="QUOTE"
>"somewhere"</SPAN
>. So servers <SPAN
CLASS="QUOTE"
>"listen"</SPAN
> on a specific
 <SPAN
CLASS="QUOTE"
>"port"</SPAN
> for incoming connections. Most servers have a default
 port, such as port 80 for web servers. Or 6000 for X11. See 
 <TT
CLASS="FILENAME"
>/etc/services</TT
> for a list of common ports and their 
 associated service.&#13;</P
><P
> The <SPAN
CLASS="QUOTE"
>"port"</SPAN
> is actually just an address in the kernel's 
 networking stack, and is a method that TCP, and other protocols, use to
 organize connections and the exchange of data between computers. There are
 total of 65,536 TCP and UDP ports available, though usually only a relatively
 few of these are used at any one time. These are classified as
 <SPAN
CLASS="QUOTE"
>"privileged"</SPAN
>, those ports below 1024, and
 <SPAN
CLASS="QUOTE"
>"unprivileged"</SPAN
>, 1024 and above. Most servers use the privileged
 ports. </P
><P
> Only one server may listen on, or <SPAN
CLASS="QUOTE"
>"bind"</SPAN
> to, a port at a time.
 Though that server may well be able to open multiple connections via that one
 port. Computers talk to each other via these <SPAN
CLASS="QUOTE"
>"port"</SPAN
> connections.
 One computer will open a connection to a <SPAN
CLASS="QUOTE"
>"port"</SPAN
> on another
 computer, and thus be able to exchange data via the connection that has been
 established between their respective ports. </P
><P
> Getting back to the phone analogy, and stretching it a bit, think of calling 
 a large organization with a complex phone system. The organization has many 
 <SPAN
CLASS="QUOTE"
>"departments"</SPAN
>: sales, shipping, billing, receiving, customer
 service, R&#38;D, etc. Each department has it's own <SPAN
CLASS="QUOTE"
>"extension"</SPAN
>
 number. So the shipping department might be extension 21, the sales might be
 department 80 and so on. The main phone number is the IP Address, and the
 department's extension is the port in this analogy. The
 <SPAN
CLASS="QUOTE"
>"department's"</SPAN
> number is always the same when we call. And
 generally they can handle many simultaneous incoming calls.
 </P
><P
> The data itself is contained in <SPAN
CLASS="QUOTE"
>"packets"</SPAN
>, which are small
 chunks of data, generally 1500 bytes or less each. Packets are used to
 control and organize the connection, as well as carry data. There are
 different types of packets. Some are specifically used for controlling the
 connection, and then some packets carry our data as their payload. If
 there is a lot of data, it will be broken up into multiple packets which is
 almost always how it works. The packets will be transmitted one at a time,
 and then <SPAN
CLASS="QUOTE"
>"re-assembled"</SPAN
> at the other end. One web page for
 instance, will take many packets to transmit -- maybe hundreds or even
 thousands. This all happens very quickly and transparently.&#13;</P
><P
> We can see a typical connection between two computers in this one line
 excerpt from <B
CLASS="COMMAND"
>netstat</B
> output:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp    30    0 169.254.179.139:1359    18.29.1.67:21      CLOSE_WAIT

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The interesting part is the IP addresses and ports in the fourth and fifth 
 columns. The port is the number just to the right of the colon. The left side
 of the colon is the IP address of each computer. The fourth column is the
 local address, or our end of the connection. In the example, 169.254.179.139
 is the IP address assigned by my ISP. It is connected to port 21
 (FTP) on 18.29.1.67, which is rpmfind.net. This is just after an FTP download
 from rpmfind.net. Note that while I am connected to their FTP server on their
 port 21, the port on my end that is used by my FTP client is 1359. This is a
 randomly assigned <SPAN
CLASS="QUOTE"
>"unprivileged"</SPAN
> port, used for my end of the
 two-way <SPAN
CLASS="QUOTE"
>"conversation"</SPAN
>. The data moves in both directions:
 me:port#1359 &#60;-&#62; them:port#21. The FTP protocol is actually a little
 more complicated than this, but we won't delve into the finer points here.
 The <TT
CLASS="LITERAL"
>CLOSE_WAIT</TT
> is the TCP state of the connection at this 
 particular point in time. Eventually the connection will close completely on
 both ends, and <SPAN
CLASS="APPLICATION"
>netstat</SPAN
> will not show anything for
 this. 
 </P
><P
> The <SPAN
CLASS="QUOTE"
>"unprivileged"</SPAN
> port that is used for my end of the
 connection, is temporary and is not associated with a locally running server.
 It will be closed by the kernel when the connection is terminated. This is
 quite different than the ports that are kept open by <SPAN
CLASS="QUOTE"
>"listening"</SPAN
>
 servers, which are permanent and remain <SPAN
CLASS="QUOTE"
>"open"</SPAN
> even after a
 remote connection is terminated.</P
><P
> So to summarize using the above example, we have client (me) connecting 
 to a server (rpmfind.net), and the connection is defined and controlled by
 the respective ports on either end. The data is transmitted and controlled by
 packets. The server is using a <SPAN
CLASS="QUOTE"
>"privileged"</SPAN
> port (i.e. a port
 below number 1024) which stays open listening for connections. The
 <SPAN
CLASS="QUOTE"
>"unprivileged"</SPAN
> port used on my end by my client application is
 temporary, is only opened for the duration of the connection, and only
 responds to the server's port at the other end of the connection. This type
 of port is not vulnerable to attacks or break-ins generally speaking. The
 server's port is vulnerable since it remains open. The administrator of the
 FTP server will need to take appropriate precautions that his server is
 secure. Other Internet connections, such as to web servers or mail servers,
 work similar to the above example, though the server ports are different. 
 SMTP mail servers use port 25, and web servers typically use port 80. 
 See the <A
HREF="#PORTS"
>Ports section</A
> for other commonly used 
 ports and services.</P
><P
> One more point on ports: ports are only accessible if there is something 
 listening on that port. No one can force a port open if there is no service
 or daemon listening there, ready to handle incoming connection requests. 
 A closed port is a totally safe port. 
 </P
><P
> And a final point on the distinction between clients and servers. The example
 above did not have a <B
CLASS="COMMAND"
>telnet</B
> or <B
CLASS="COMMAND"
>ftp</B
> 
 server in the <TT
CLASS="LITERAL"
>LISTENER</TT
> section in the
 <B
CLASS="COMMAND"
>netstat</B
> example above. In other words, no such servers 
 were running locally. You do not need to run a <B
CLASS="COMMAND"
>telnet</B
> or
 <B
CLASS="COMMAND"
>ftp</B
> server daemon in order to connect to
 <EM
>somebody else's</EM
> <B
CLASS="COMMAND"
>telnet</B
> or
 <B
CLASS="COMMAND"
>ftp</B
> server. These are only for providing these services
 to others that would be making connections to you. Which you don't really
 want to be doing in most cases. This in no way effects the ability to use 
 <B
CLASS="COMMAND"
>telnet</B
> and <B
CLASS="COMMAND"
>ftp</B
> client software.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PORTS"
>8.2. Common Ports</A
></H3
><P
> A quick run down of some commonly seen and used ports, with the commonly 
 associated service name, and risk factor. All have <EM
>some</EM
>
 risk. It is just that some have historically had more exploits than others.
 That is how they are evaluated below, and not necessarily to be interpreted
 as whether any given service is safe or not. &#13;</P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   1-19, assorted protocols, many of which are antiquated, and probably 
   none of which are needed on a modern system. If you don't know what 
   any of these are, then you definitely don't need them.
   The <SPAN
CLASS="APPLICATION"
>echo</SPAN
> service (port 7) should not be 
   confused with the common <B
CLASS="COMMAND"
>ping</B
> program. Leave all these
   off. 
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    20 - FTP-DATA. <SPAN
CLASS="QUOTE"
>"Active"</SPAN
> FTP connections use two
    ports: 21 is the control port, and 20 is where the data comes through.
    Passive FTP does not use port 20 at all. Low risk, but see below.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   21 - FTP server port, aka File Transfer Protocol. A well entrenched protocol
   for transferring files between systems. Very high risk, and maybe the number 
   one crack target.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   22 - SSH (Secure Shell), or sometimes PCAnywhere. Low to moderate 
   risk (yes there are exploits even against so called <SPAN
CLASS="QUOTE"
>"secure"</SPAN
>
   services).
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   23 - Telnet server. For LAN use only. Use <SPAN
CLASS="APPLICATION"
>ssh</SPAN
>
   instead in non-secure environments. Moderate risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   25 - SMTP, Simple Mail Transfer Protocol, or mail server port, used for 
   sending outgoing mail, and transferring mail from one place to another. 
   Moderate risk. This has had a bad history of exploits, but has improved 
   lately.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    37 - Time service. This is the built-in
    <SPAN
CLASS="APPLICATION"
>inetd</SPAN
> time service. Low risk. For LAN use 
    only.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    53 - DNS, or Domain Name Server port. Name servers listen on this port,
    and answer queries for resolving host names to IP addresses. High Risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    67 (UDP) - BOOTP, or DHCP, server port. Low risk. If using DHCP on your 
    LAN, this does not need to be exposed to the Internet.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    68 (UDP) - BOOTP, or DHCP, client port. Low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    69 - tftp, or Trivial File Transfer Protocol. Extremely insecure. LAN
    only, if really, really needed.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    79 - Finger, used to provide information about the system, and logged 
    in users. Low risk as a crack target, but gives out way too much 
    information and should not be run.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   80 - WWW or HTTP standard web server port. The most commonly used service 
   on the Internet. Low risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    98 - Linuxconf web access administrative port. LAN only, if really needed
    at all.   
   </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   110 - POP3, aka Post Office Protocol, mail server port. POP mail is mail 
   that the user retrieves from a remote system. Low risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   111 - sunrpc (Sun Remote Procedure Call), or portmapper port. Used by NFS
   (Network File System), NIS (Network Information Service), and various related
   services. Sounds dangerous and is high risk. LAN use only. A favorite crack
   target. 
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   113 - identd, or auth, server port. Used, and sometimes required, by some
   older style services (like SMTP and IRC) to validate the connection.
   Probably not needed in most cases. Low risk, but could give an attacker
   too much information about your system.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>  119 -- nntp or news server port. Low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   123 - Network Time Protocol for synchronizing with time servers where a 
   high degree of accuracy is required. Low risk, but probably not required 
   for most users. <SPAN
CLASS="APPLICATION"
>rdate</SPAN
> makes an easier and more  
   secure way of updating the system clock. And then
   <SPAN
CLASS="APPLICATION"
>inetd's</SPAN
> built in time service for synchronizing 
   LAN systems is another option.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   137-139 - NetBios (SMB) services. Mostly a Windows thing. Low risk on
   Linux, but LAN use only.  137 is a very commonly seen port attempt. A 
   rather obnoxious protocol from Redmond that generates a lot of 
   <SPAN
CLASS="QUOTE"
>"noise"</SPAN
>, much of which is harmless.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    143 - IMAP, Interim Mail Access Protocol. Another mail retrieval protocol. 
    Low to moderate risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   161 - SNMP, Simple Network Management Protocol. More commonly used in
   routers and switches to monitor statistics and vital signs. Not needed 
   for most of us, and low risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    177 - XDMCP, the X Display Management Control Protocol for remote connections 
    to X servers. Low risk, but LAN only is recommended.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   443 - HTTPS, a secure HTTP (WWW) protocol in fairly wide use. Low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    465 - SMTP over SSL, secure mail server protocol. Low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   512 (TCP) - exec is how it shows in <SPAN
CLASS="APPLICATION"
>netstat</SPAN
>. 
   Actually the proper name is <B
CLASS="COMMAND"
>rexec,</B
> for Remote 
   Execution. Sounds dangerous, and is. High risk, LAN only if at all.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   512 (UDP) - biff, a mail notification protocol. Low risk, LAN only.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   513 - login, actually <B
CLASS="COMMAND"
>rlogin</B
>, aka Remote Login. No 
   relation to the standard <B
CLASS="COMMAND"
>/bin/login</B
> that we use 
   every time we log in. Sounds dangerous, and is. High risk, and LAN only if
   really needed.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   514 (TCP) - shell is the nickname, and how <SPAN
CLASS="APPLICATION"
>netstat</SPAN
>
   shows it. Actually, <B
CLASS="COMMAND"
>rsh</B
> is the application for 
   <SPAN
CLASS="QUOTE"
>"Remote Shell"</SPAN
>. Like all the <SPAN
CLASS="QUOTE"
>"r"</SPAN
> commands, this
   is a throw back to kindler, gentler times. Very insecure, so high risk, and
   LAN only usage, if at all.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   514 (UDP) - syslog daemon port, only used for remote logging purposes. The 
   average user does not need this. Probably low risk, but definitely LAN 
   only if really required.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    515 - lp or print server port. High risk, and LAN only of course. Someone 
    on the other side of the world does not want to use your printer for it's
    intended purpose! 
   </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   587 - MSA, or <SPAN
CLASS="QUOTE"
>"submission"</SPAN
>, the Mail Submission Agent 
   protocol. A new mail handling protocol supported by most MTA's (mail
   servers). Low risk.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   631 - the CUPS (print daemon) web management port. LAN only, low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   635 - mountd, part of NFS. LAN use only.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   901 - SWAT, Samba Web Administration Tool port. LAN only.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   993 - IMAP over SSL, secure IMAP mail service. Very low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   995 - POP over SSL, secure POP mail service. Very low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   1024 - This is the first <SPAN
CLASS="QUOTE"
>"unprivileged"</SPAN
> port, which is 
   dynamically assigned by the kernel to whatever application requests 
   it. This can be almost anything. Ditto for ports just above this.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   1080 - Socks Proxy server. A favorite crack target. 
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   1243 - SubSeven Trojan. Windows only problem.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   1433 - MS SQL server port. A sometimes target. N/A on Linux.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    2049 - nfsd, Network File Service Daemon port. High risk, and LAN 
    usage only is recommended.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   3128 - Squid proxy server port. Low risk, but for most should be
   LAN only.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   3306 - MySQL server port. Low risk, but for most should be
   LAN only.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   5432 - PostgreSQL server port. LAN only, relatively low risk.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   5631 (TCP), 5632 (UDP) - PCAnywhere ports. Windows only. PCAnywhere 
   can be quite <SPAN
CLASS="QUOTE"
>"noisy"</SPAN
>, and broadcast wide address ranges.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   6000 - X11 TCP port for remote connections. Low to moderate risk, but 
   again, this should be LAN only. Actually, this can include ports 
   6000-6009 since X can support multiple displays and each display would 
   have its own port. <SPAN
CLASS="APPLICATION"
>ssh's</SPAN
> X11Forwarding will 
   start using ports at 6010.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   6346 - gnutella.    
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   6667 - ircd, Internet Relay Chat Daemon.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   6699 - napster.    
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   7100-7101 - Some font servers use these ports. Low risk, but LAN only.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    8000 and 8080 - common web cache and proxy server ports. LAN only.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   10000 - webmin, a web based system administration utility. Low risk at this
   point.   
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    27374 - SubSeven, a commonly probed for Windows only Trojan. Also, 1243.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>    31337 - Back Orifice, another commonly probed for Windows only Trojan.
  </TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
> More services and corresponding port numbers can be found in 
 <TT
CLASS="FILENAME"
>/etc/services</TT
>. Also, the <SPAN
CLASS="QUOTE"
>"official"</SPAN
> 
 list is <A
HREF="http://www.iana.org/assignments/port-numbers"
TARGET="_top"
>http://www.iana.org/assignments/port-numbers</A
>.&#13;</P
><P
> A great analysis of what probes to these and other ports might mean 
 from Robert Graham: <A
HREF="http://www.linuxsecurity.com/resource_files/firewalls/firewall-seen.html"
TARGET="_top"
>http://www.linuxsecurity.com/resource_files/firewalls/firewall-seen.html</A
>. A very good reference.</P
><P
> Another point here, these are the <EM
>standard</EM
> port
 designations. There is no law that says any service has to run on a 
 specific port. Usually they do, but certainly they don't always have to.&#13;</P
><P
> Just a reminder that when you see these types of ports in your firewall logs,
 it is not anything to go off the deep end about. Not if you have followed
 Steps 1-3 above, and verified your firewall works. You are fairly safe. Much
 of this traffic may be <SPAN
CLASS="QUOTE"
>"stray bullets"</SPAN
> too -- Internet
 background noise, misconfigured clients or routers, noisy Windows stuff, etc.
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NETSTAT"
>8.3. Netstat Tutorial</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1696"
>8.3.1. Overview</A
></H4
><P
> <B
CLASS="COMMAND"
>netstat</B
> is a very useful utility for viewing 
 the current state of your network status -- what servers are listening for
 incoming connections, what interfaces they listen on, who is connected to us,
 who we are connect to, and so on. Take a look at the man page for some of the
 many command line options. We'll just use a relative few options here.&#13;</P
><P
> As an example, let's check all currently listening servers and active
 connections for both TCP and UDP on our hypothetical host,
 bigcat. bigcat is a home desktop installation, with a DSL
 Internet connection in this example. bigcat has two ethernet cards: one for
 the external connection to the ISP, and one for a small LAN with an address
 of 192.168.1.1. </P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>   
$ netstat -tua
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State
tcp        0      0 *:printer               *:*                     LISTEN     
tcp        0      0 bigcat:8000             *:*                     LISTEN     
tcp        0      0 *:time                  *:*                     LISTEN     
tcp        0      0 *:x11                   *:*                     LISTEN
tcp        0      0 *:http                  *:*                     LISTEN     
tcp        0      0 bigcat:domain           *:*                     LISTEN     
tcp        0      0 bigcat:domain           *:*                     LISTEN     
tcp        0      0 *:ssh                   *:*                     LISTEN     
tcp        0      0 *:631                   *:*                     LISTEN     
tcp        0      0 *:smtp                  *:*                     LISTEN     
tcp        0      1 dsl-78-199-139.s:1174   64.152.100.93:nntp      SYN_SENT   
tcp        0      1 dsl-78-199-139.s:1175   64.152.100.93:nntp      SYN_SENT   
tcp        0      1 dsl-78-199-139.s:1173   64.152.100.93:nntp      SYN_SENT   
tcp        0      0 dsl-78-199-139.s:1172   207.153.203.114:http    ESTABLISHED
tcp        1      0 dsl-78-199-139.s:1199   www.xodiax.com:http     CLOSE_WAIT 
tcp        0      0 dsl-78-199-139.sd:http  63.236.92.144:34197     TIME_WAIT
tcp      400      0 bigcat:1152             bigcat:8000             CLOSE_WAIT 
tcp     6648      0 bigcat:1162             bigcat:8000             CLOSE_WAIT 
tcp      553      0 bigcat:1164             bigcat:8000             CLOSE_WAIT 
udp        0      0 *:32768                 *:*                                
udp        0      0 bigcat:domain           *:*                                
udp        0      0 bigcat:domain           *:*                                
udp        0      0 *:631                   *:*                               

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This output probably looks very different from what you get on your own 
 system. Notice the distinction between <SPAN
CLASS="QUOTE"
>"Local Address"</SPAN
> and
 <SPAN
CLASS="QUOTE"
>"Foreign Address"</SPAN
>, and how each includes a corresponding port
 number (or service name if available) after the colon. <SPAN
CLASS="QUOTE"
>"Local
 Address"</SPAN
> is our end of the connection. The first group with
 <TT
CLASS="LITERAL"
>LISTEN</TT
> in the far right hand column are services that are
 running on this system. These are servers that are running in the background 
 on bigcat, and <SPAN
CLASS="QUOTE"
>"listen"</SPAN
> for incoming connections. So they 
 have a port opened, and this is where they <SPAN
CLASS="QUOTE"
>"listen"</SPAN
>. These
 connections might come from the local system (i.e. bigcat itself), or remote
 systems. This is very important information to have! The others just below
 this are connections that have been established from this system to other
 systems. The respective connections are in varying states as indicated by the
 key words in the last column. Those with no key word in the last column at
 the end are servers responding to UDP connections. UDP is a different
 protocol from TCP altogether, but is used for some types of low priority
 network traffic.&#13;</P
><P
> Now, the same thing with the <SPAN
CLASS="QUOTE"
>"-n"</SPAN
> flag to suppress converting to
 <SPAN
CLASS="QUOTE"
>"names"</SPAN
> so we can actually see the port numbers:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;$ netstat -taun
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address      State
tcp        0      0 0.0.0.0:515             0.0.0.0:*            LISTEN     
tcp        0      0 127.0.0.1:8000          0.0.0.0:*            LISTEN     
tcp        0      0 0.0.0.0:37              0.0.0.0:*            LISTEN     
tcp        0      0 0.0.0.0:6000            0.0.0.0:*            LISTEN
tcp        0      0 0.0.0.0:80              0.0.0.0:*            LISTEN     
tcp        0      0 192.168.1.1:53          0.0.0.0:*            LISTEN     
tcp        0      0 127.0.0.1:53            0.0.0.0:*            LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*            LISTEN     
tcp        0      0 0.0.0.0:631             0.0.0.0:*            LISTEN     
tcp        0      0 0.0.0.0:25              0.0.0.0:*            LISTEN     
tcp        0      1 169.254.179.139:1174    64.152.100.93:119    SYN_SENT   
tcp        0      1 169.254.179.139:1175    64.152.100.93:119    SYN_SENT   
tcp        0      1 169.254.179.139:1173    64.152.100.93:119    SYN_SENT   
tcp        0      0 169.254.179.139:1172    207.153.203.114:80   ESTABLISHED
tcp        1      0 169.254.179.139:1199    216.26.129.136:80    CLOSE_WAIT 
tcp        0      0 169.254.179.139:80      63.236.92.144:34197  TIME_WAIT 
tcp      400      0 127.0.0.1:1152          127.0.0.1:8000       CLOSE_WAIT 
tcp     6648      0 127.0.0.1:1162          127.0.0.1:8000       CLOSE_WAIT 
tcp      553      0 127.0.0.1:1164          127.0.0.1:8000       CLOSE_WAIT 
udp        0      0 0.0.0.0:32768           0.0.0.0:*                    
udp        0      0 192.168.1.1:53          0.0.0.0:*                      
udp        0      0 127.0.0.1:53            0.0.0.0:*                     
udp        0      0 0.0.0.0:631             0.0.0.0:*          
   
 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Let's look at the first few lines of this in detail. On line one, </P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      0 0.0.0.0:515            0.0.0.0:*          LISTEN     

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> <SPAN
CLASS="QUOTE"
>"Local Address"</SPAN
> is <TT
CLASS="LITERAL"
>0.0.0.0</TT
>, meaning
 <SPAN
CLASS="QUOTE"
>"all"</SPAN
> interfaces that are available. The local port is 515, or the
 standard print server port, usually owned by the lpd daemon. You can find a
 listing of common service names and corresponding ports in the file 
 <TT
CLASS="FILENAME"
>/etc/services</TT
>. </P
><P
> The fact that it is listening on all interfaces is significant. In this case,
 that would be lo (localhost), eth0, and eth1. Printer connections could
 conceivably be made over any of these interfaces. Should a user on this system
 bring up a PPP connection, then the print daemon would be listening on that
 interface (ppp0) as well. The <SPAN
CLASS="QUOTE"
>"Foreign Address"</SPAN
> is also
 <TT
CLASS="LITERAL"
>0.0.0.0</TT
>, meaning from <SPAN
CLASS="QUOTE"
>"anywhere"</SPAN
>.</P
><P
> It is also worth noting here, that even though this server is telling the
 kernel to listen on all interfaces, the <B
CLASS="COMMAND"
>netstat</B
> output
 does not reflect whether there may be a firewall in place that may be
 filtering incoming connections. We just can't tell that at this point.
 Obviously, for certain servers, this is very desirable. Nobody outside your
 own LAN has any reason whatsoever to connect to your print server port for
 instance.</P
><P
> Line two is a little different:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      0 127.0.0.1:8000         0.0.0.0:*          LISTEN     

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Notice the <SPAN
CLASS="QUOTE"
>"Local Address"</SPAN
> this time is localhost's address 
 of <TT
CLASS="LITERAL"
>127.0.0.1</TT
>. This is very significant as only connections 
 local to this machine will be accepted. So only bigcat can connect to
 bigcat's TCP port 8000. The security implications should be obvious. Not all 
 servers have configuration options that allow this kind of restriction, but 
 it is a very useful feature for those that do. Port 8000 in this example, 
 is owned by the web proxy <SPAN
CLASS="APPLICATION"
>Junkbuster</SPAN
>.&#13;</P
><P
> With the next three entries, we are back to listening on all available 
 interfaces:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      0 0.0.0.0:37             0.0.0.0:*           LISTEN     
 tcp        0      0 0.0.0.0:6000           0.0.0.0:*           LISTEN
 tcp        0      0 0.0.0.0:80             0.0.0.0:*           LISTEN     

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Looking at <TT
CLASS="FILENAME"
>/etc/services</TT
>, we can tell that port 37 
 is a <SPAN
CLASS="QUOTE"
>"time"</SPAN
> service, which is a time server. 
 6000 is <SPAN
CLASS="APPLICATION"
>X11</SPAN
>, and 80 is the standard port for HTTP
 servers like <SPAN
CLASS="APPLICATION"
>Apache</SPAN
>. There is nothing really
 unusual here as these are all readily available services on Linux.</P
><P
> The first two above are definitely not the kind of services you'd want just
 anyone to connect to. These should be firewalled so that all outside
 connections are refused. Again, we can't tell from this output whether any
 firewall is in place, much less how effectively implemented it may be.</P
><P
> The web server on port 80 is not a huge security risk by itself. HTTP is a
 protocol that is often open to all comers. For instance, if we wanted to host
 our own home page, <SPAN
CLASS="APPLICATION"
>Apache</SPAN
> can certainly do this
 for us. It is also possible to firewall this off, so that it is for use only
 to our LAN clients as part of an Intranet. Obviously too, if you do not have
 a good justification for running a web server, then it should be disabled 
 completely.
 </P
><P
> The next two lines are interesting:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      0 192.168.1.1:53         0.0.0.0:*           LISTEN     
 tcp        0      0 127.0.0.1:53           0.0.0.0:*           LISTEN     

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Again notice the <SPAN
CLASS="QUOTE"
>"Local Address"</SPAN
> is not <TT
CLASS="LITERAL"
>0.0.0.0</TT
>. 
 This is good! The port this time is 53, or the DNS port used by nameserver
 daemons like <B
CLASS="COMMAND"
>named.</B
> But we see the nameserver
 daemon is only listening on the lo interface (localhost), and the interface
 that connects bigcat to the LAN. So the kernel only allows connections from
 localhost, and the LAN. There will be no port 53 available to outside
 connections at all. This is a good example of how individual applications 
 can sometimes be securely configured. In this case, we are probably looking 
 at a caching DNS server since a real nameserver that is responsible for 
 handling DNS queries would have to have port 53 open to the world. This 
 is a security risk and requires special handling.
 </P
><P
> The last three <TT
CLASS="LITERAL"
>LISTENER</TT
> entries:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      0 0.0.0.0:22             0.0.0.0:*           LISTEN     
 tcp        0      0 0.0.0.0:631            0.0.0.0:*           LISTEN     
 tcp        0      0 0.0.0.0:25             0.0.0.0:*           LISTEN     

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> These are back to listening on all available interfaces. Port 22 is
 <SPAN
CLASS="APPLICATION"
>sshd</SPAN
>, the Secure Shell server daemon. This is a good
 sign! Notice that the service for port 631 does not have a service name if we
 look at the output in the first example. This might be a clue that something
 unusual is going on here. (See the next section for the answer to this
 riddle.) And lastly, port 25, the standard port for the SMTP mail daemon.
 Most Linux installations probably will have an SMTP daemon running, so this
 is not necessarily unusual. But is it necessary?</P
><P
> The next grouping is established connections. For our purposes the state of 
 the connection as indicated by the last column is not so important. This is 
 well explained in the man page.</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; tcp        0      1 169.254.179.139:1174    64.152.100.93:119    SYN_SENT   
 tcp        0      1 169.254.179.139:1175    64.152.100.93:119    SYN_SENT    
 tcp        0      1 169.254.179.139:1173    64.152.100.93:119    SYN_SENT   
 tcp        0      0 169.254.179.139:1172    207.153.203.114:80   ESTABLISHED
 tcp        1      0 169.254.179.139:1199    216.26.129.136:80    CLOSE_WAIT 
 tcp        0      0 169.254.179.139:80      63.236.92.144:34197  TIME_WAIT 
 tcp      400      0 127.0.0.1:1152          127.0.0.1:8000       CLOSE_WAIT 
 tcp     6648      0 127.0.0.1:1162          127.0.0.1:8000       CLOSE_WAIT 
 tcp      553      0 127.0.0.1:1164          127.0.0.1:8000       CLOSE_WAIT 

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> There are nine total connections here. The first three is our external
 interface connecting to a remote host on their port 119, the standard NNTP (News) 
 port. There are three connections here to the same news server. Apparently 
 the application is multi-threaded, as it is trying to open multiple
 connections to the news server. The next two entries are connections to a
 remote web server as indicated by the port 80 after the colon in the fifth
 column. Probably a pretty common looking entry for most of us. But the one
 just after is reversed and has the port 80 in the fourth column, so this is
 someone that has connected to bigcat's web server via its external,
 Internet-side interface. The last three entries are all connections from
 localhost to localhost. So we are connecting to ourselves here. Remembering
 from above that port 8000 is bigcat's web proxy, this is a web browser that
 is connected to the locally running proxy. The proxy then will open an
 external connection of its own, which probably is what is going on with lines
 four and five.</P
><P
> Since we gave <B
CLASS="COMMAND"
>netstat</B
> both the <TT
CLASS="LITERAL"
>-t</TT
> and 
 <TT
CLASS="LITERAL"
>-u</TT
> options, we are getting both the TCP and UDP listening 
 servers. The last few lines are the UDP ones:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; udp        0      0 0.0.0.0:32768          0.0.0.0:*                    
 udp        0      0 192.168.1.1:53         0.0.0.0:*                      
 udp        0      0 127.0.0.1:53           0.0.0.0:*                     
 udp        0      0 0.0.0.0:631            0.0.0.0:*          

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The last three entries have ports that are familiar from the above
 discussion. These are servers that are listening for both TCP and UDP 
 connections. Same servers in this case, just using two different protocols.
 The first one on local port 32768 is new, and does not have a service name
 available to it in <TT
CLASS="FILENAME"
>/etc/services</TT
>. So at first glance
 this should be suspicious and pique our curiosity. See the next section for
 the explanation.</P
><P
> Can we draw any conclusions from this hypothetical situation? For 
 the most part, these look to be pretty normal looking network services and 
 connections for Linux. There does not seem to be an unduly high number of
 servers running here, but that by itself does not mean much since we don't
 know if all these servers are really required or not. We know that
 <B
CLASS="COMMAND"
>netstat</B
> can not tell us if any of these are effectively
 firewalled, so there is no way to say how secure all this might be. We also
 don't really know if all the listening services are really required by the
 owner here. That is something that varies widely from installation to
 installation. Does bigcat even have a printer attached for instance?
 Presumably it does, or this is a completely unnecessary risk.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="PID"
>8.3.2. Port and Process Owners</A
></H4
><P
> We've learned a lot about what is going on with bigcat's networking from 
 the above section. But suppose we see something we don't recognize and 
 want to know what started that particular service? Or we want to stop a
 particular server and it is not obvious from the above output?</P
><P
> The <TT
CLASS="LITERAL"
>-p</TT
> option should give us the process's PID and the 
 program name that started the process in the last column. Let's look at the
 TCP servers again (with first three columns cropped for spacing). We'll have
 to run this as root to get all the available information:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13;# netstat -tap
Active Internet connections (servers and established)
  Local Address           Foreign Address      State       PID/Program name
  *:printer               *:*                  LISTEN       988/inetd
  bigcat:8000             *:*                  LISTEN       1064/junkbuster
  *:time                  *:*                  LISTEN       988/inetd
  *:x11                   *:*                  LISTEN       1462/X
  *:http                  *:*                  LISTEN       1078/httpd
  bigcat:domain           *:*                  LISTEN       956/named
  bigcat:domain           *:*                  LISTEN       956/named
  *:ssh                   *:*                  LISTEN       972/sshd
  *:631                   *:*                  LISTEN       1315/cupsd
  *:smtp                  *:*                  LISTEN       1051/master

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Some of these we already know about. But we see now that the printer daemon
 on port 515 is being started via <B
CLASS="COMMAND"
>inetd</B
> with a 
 PID of <SPAN
CLASS="QUOTE"
>"988"</SPAN
>. <B
CLASS="COMMAND"
>inetd</B
> is a special situation.
 <B
CLASS="COMMAND"
>inetd</B
> is often called the <SPAN
CLASS="QUOTE"
>"super server"</SPAN
>,
 since it's main role is to spawn sub-services. 
 <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
> replaces <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>
 as of Red Hat 7.0.  If we look at the first line, <B
CLASS="COMMAND"
>inetd</B
>
 is listening on port 515 for printer services. If a connection comes for this
 port, <B
CLASS="COMMAND"
>inetd</B
> intercepts it, and then will spawn the
 appropriate daemon, i.e. the print daemon in this case. The configuration of
 how <B
CLASS="COMMAND"
>inetd</B
> handles this is typically done in
 <TT
CLASS="FILENAME"
>/etc/inetd.conf</TT
>. This should tell us that if we want to
 stop an <B
CLASS="COMMAND"
>inetd</B
> controlled server on a permanent basis, then
 we will have to dig into the <B
CLASS="COMMAND"
>inetd</B
> (or perhaps
 <B
CLASS="COMMAND"
>xinetd</B
>) configuration. Also the time service above is
 started via <B
CLASS="COMMAND"
>inetd</B
> as well. This should also tell us that
 these two services can be further protected by
 <SPAN
CLASS="APPLICATION"
>tcpwrappers</SPAN
> (discussed in Step 3 above). This is
 one benefit of using <B
CLASS="COMMAND"
>inetd</B
> to control certain system
 services.&#13;</P
><P
> We weren't sure about the service on port 631 above since it did not have 
 a standard service name, which means it is something maybe unusual or off 
 the beaten path. Now we see it is owned by <B
CLASS="COMMAND"
>cupsd</B
> 
  (not included with Red Hat by the way), which is one of
 several print daemons available under Linux. This happens to be the web
 interface for controlling the printer service. Something
 <B
CLASS="COMMAND"
>cupsd</B
> does that is indeed a little different than other
 print servers. &#13;</P
><P
> The last entry above is the SMTP mail server on bigcat. Often, this is 
 <B
CLASS="COMMAND"
>sendmail</B
>. But
 not in this case. The command is <SPAN
CLASS="QUOTE"
>"master"</SPAN
>, which may not ring
 any bells. Armed with the program name we could go searching the filesystem
 with tools like the <B
CLASS="COMMAND"
>locate</B
> or <B
CLASS="COMMAND"
>find</B
>
 commands. After we found it, we could then probably discern what package it
 belonged to. But with the PID available now, we can look at
 <B
CLASS="COMMAND"
>ps</B
> output, and see if that helps us any:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ /bin/ps ax |grep 1051 |grep -v grep
  1051 ?        S        0:24 /usr/libexec/postfix/master

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> We took a shortcut here by combining <B
CLASS="COMMAND"
>ps</B
> with
 <B
CLASS="COMMAND"
>grep</B
>. It looks like that this file belongs to  
 <B
CLASS="COMMAND"
>postfix</B
>, which is indeed a mail server package 
 comparable to <B
CLASS="COMMAND"
>sendmail</B
> ( and is  
 included with Powertools, not the base distribution). &#13;</P
><P
> Running <B
CLASS="COMMAND"
>ps</B
> with the <TT
CLASS="LITERAL"
>--forest</TT
> flag 
 (<TT
CLASS="LITERAL"
>-f</TT
> for short) can be helpful in determining what
 processes are parent or child process or another process. An edited example:
 </P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ /bin/ps -axf
  956 ?        S      0:00 named -u named
  957 ?        S      0:00  \_ named -u named
  958 ?        S      0:46      \_ named -u named
  959 ?        S      0:47      \_ named -u named
  960 ?        S      0:00      \_ named -u named
  961 ?        S      0:11      \_ named -u named
 1051 ?        S      0:30 /usr/libexec/postfix/master
 1703 ?        S      0:00  \_ tlsmgr -l -t fifo -u -c
 1704 ?        S      0:00  \_ qmgr -l -t fifo -u -c
 1955 ?        S      0:00  \_ pickup -l -t fifo -c
 1863 ?        S      0:00  \_ trivial-rewrite -n rewrite -t unix -u -c
 2043 ?        S      0:00  \_ cleanup -t unix -u -c
 2049 ?        S      0:00  \_ local -t unix
 2062 ?        S      0:00  \_ smtpd -n smtp -t inet -u -c

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> A couple of things to note here. We have two by now familiar daemons here: 
 <B
CLASS="COMMAND"
>named</B
> and <B
CLASS="COMMAND"
>postfix (smtpd)</B
>. Both 
 are spawning sub-processes. In the case of <B
CLASS="COMMAND"
>named</B
>, what we are
 seeing is threads, various sub-processes that it always spawns. 
 <B
CLASS="COMMAND"
>Postfix</B
> is also spawning sub-processes, but not as 
 <SPAN
CLASS="QUOTE"
>"threads"</SPAN
>. Each sub-process has its own specific task. It is 
 worth noting that child processes are dependent on the parent process. 
 So killing the parent PID, will in turn kill all child processes. 
 </P
><P
> If all this has not shed any light, we might also try <B
CLASS="COMMAND"
>locate</B
>:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ locate /master
 /etc/postfix/master.cf
 /var/spool/postfix/pid/master.pid
 /usr/libexec/postfix/master
 /usr/share/vim/syntax/master.vim
 /usr/share/vim/vim60z/syntax/master.vim
 /usr/share/doc/postfix-20010202/html/master.8.html
 /usr/share/doc/postfix-20010202/master.cf
 /usr/share/man/man8/master.8.gz

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> <B
CLASS="COMMAND"
>find</B
> is perhaps the most flexible file finding utility, 
 but doesn't use a database the way <B
CLASS="COMMAND"
>locate</B
> does, so is 
 much slower:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; $ find / -name master         
 /usr/libexec/postfix/master

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> If <B
CLASS="COMMAND"
>lsof</B
> is installed, it is another command that is useful
 for finding who owns processes or ports:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # lsof -i :631       
 COMMAND  PID  USER    FD   TYPE DEVICE SIZE NODE NAME
 cupsd   1315  root    0u   IPv4   3734       TCP *:631 (LISTEN)

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This is again telling us that the <B
CLASS="COMMAND"
>cupsd</B
> print daemon is
 the owner of port 631. Just a different way of getting at it. Yet one more
 way to get at this is with <B
CLASS="COMMAND"
>fuser</B
>, which should be
 installed:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # fuser -v -n tcp 631

                      USER        PID  ACCESS  COMMAND
 631/tcp              root       1315  f....   cupsd

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> See the man pages for <B
CLASS="COMMAND"
>fuser</B
> and <B
CLASS="COMMAND"
>lsof</B
> 
 command syntax.&#13;</P
><P
> Another place to look for where a service is started, is in the
 <TT
CLASS="FILENAME"
>init.d</TT
> directory, where the actual init scripts
 live. Something like <TT
CLASS="LITERAL"
>ls -l
 /etc/rc.d/init.d/</TT
>, should give us a list of these.
 Often the script name itself gives a hint as to which service(s) it starts,
 though it may not necessarily exactly match the <SPAN
CLASS="QUOTE"
>"Program Name"</SPAN
>
 as provided by <B
CLASS="COMMAND"
>netstat</B
>. Or we can use
 <B
CLASS="COMMAND"
>grep</B
> to search inside files and match a search pattern.
 Need to find where <B
CLASS="COMMAND"
>rpc.statd</B
> is being started, and we
 don't see a script by this name?&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # grep rpc.statd /etc/init.d/*
 /etc/init.d/nfslock: [ -x /sbin/rpc.statd ] || exit 0
 /etc/init.d/nfslock:    daemon rpc.statd
 /etc/init.d/nfslock:    killproc rpc.statd
 /etc/init.d/nfslock:    status rpc.statd
 /etc/init.d/nfslock:    /sbin/pidof rpc.statd &#62;/dev/null 2&#62;&#38;1; STATD="$?"

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> We didn't really need all that information, but at least we see now 
 exactly which script is starting it. Remember too that not all services 
 are started this way. Some may be started via <SPAN
CLASS="APPLICATION"
>inetd</SPAN
>, 
 or <SPAN
CLASS="APPLICATION"
>xinetd</SPAN
>.&#13;</P
><P
> The <TT
CLASS="FILENAME"
>/proc</TT
> filesystem also keeps everything we want 
 to know about processes that are running. We can query this to find out 
 more information about each process. Do you need to know the full path of the
 command that started a process?&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # ls -l /proc/1315/exe
 lrwxrwxrwx  1 root  root   0 July 4 19:41 /proc/1315/exe -&#62; /usr/sbin/cupsd

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> Finally, we had a loose end or two in the UDP listening services. Remember we
 had a strange looking port number 32768, that also had no service name 
 associated with it:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # netstat -aup
 Active Internet connections (servers and established)
  Local Address           Foreign Address         State       PID/Program name   
   *:32768                 *:*                                 956/named           
   bigcat:domain           *:*                                 956/named           
   bigcat:domain           *:*                                 956/named           
   *:631                   *:*                                 1315/cupsd          

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>  Now by including the <SPAN
CLASS="QUOTE"
>"PID/Program name"</SPAN
>
 option with the <TT
CLASS="LITERAL"
>-p</TT
> flag, we see this also belongs to
 <B
CLASS="COMMAND"
>named</B
>, the nameserver daemon. Recent versions of
 <SPAN
CLASS="APPLICATION"
>BIND</SPAN
> use an unprivileged port for some types 
 of traffic. In this case, this is <SPAN
CLASS="APPLICATION"
>BIND 9.x</SPAN
>. 
 So no real alarms here either. The unprivileged port here is the one 
 <B
CLASS="COMMAND"
>named</B
> uses to talk to other nameservers for name 
 and address lookups, and should not be firewalled. &#13;</P
><P
> So we found no big surprises in this hypothetical situation.</P
><P
> If all else fails, and you can't find a process owner for an open port,
 suspect that it may be an RPC (Remote Procedure Call) service of some kind.
 These use randomly assigned ports without any seeming logic or consistency,
 and are typically controlled by the <B
CLASS="COMMAND"
>portmap</B
> daemon. 
 In some cases, these may not reveal the process owner to
 <B
CLASS="COMMAND"
>netstat</B
> or <B
CLASS="COMMAND"
>lsof</B
>. Try stopping
 <B
CLASS="COMMAND"
>portmap</B
>, and then see if the mystery service goes away. Or
 you can use <B
CLASS="COMMAND"
>rpcinfo -p localhost</B
> to see what RPC services
 may be running (<B
CLASS="COMMAND"
>portmap</B
> must be running for this to
 work).</P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/warning.png"
HSPACE="5"
ALT="Warning"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>   If you suspect you have been broken into, <EM
>do not trust</EM
> 
   <B
CLASS="COMMAND"
>netstat</B
> or <B
CLASS="COMMAND"
>ps</B
> output. There is a good
   chance that they, and other system components, has been tampered with in
   such a way that the output is not reliable.
  </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="THREATS"
>8.4. Attacks and Threats</A
></H3
><P
> In this section, we will take a quick look at some of the common threats 
 and techniques that are out there, and attempt to put them into some 
 perspective.</P
><P
> The corporate world, government agencies and high profile Internet sites have
 to be concerned with a much more diverse and challenging set of threats than
 the typical home desktop user. There are many reasons someone may want to
 break in to someone else's computer. It may be just for kicks, or any number
 of malicious reasons. They may just want a base from which to attack 
 someone else. This is a very common motivation.
 </P
><P
> The most common <SPAN
CLASS="QUOTE"
>"attack"</SPAN
> for most of us is from already
 compromised systems. The Internet is littered with computers that have been
 broken into, and are now doing their master's bidding blindly, in zombie-like
 fashion. They are programmed to scan massively large address ranges, probing
 each individual IP address as they go. Looking for one or more open ports,
 and then probing for known weaknesses if they get the chance. Very
 impersonal. Very methodical. And very effective. We are all in the path of
 such robotic scans. All because those responsible for these systems fail to
 do what you are doing now - taking steps to protect their system(s), and
 avoid being r00ted.&#13;</P
><P
> These scans do not look at login banners that may be presented on connection.
 It will do little good to change your <TT
CLASS="FILENAME"
>/etc/issue.net</TT
> to
 pretend that you are running some obscure operating system. If they find
 something listening, they will try all of the exploits appropriate to that
 port, without regard to any indications your system may give. If it works,
 they are in -- if not, they will move on.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="SCANS"
>8.4.1. Port Scans and Probes</A
></H4
><P
> First, let's define <SPAN
CLASS="QUOTE"
>"scan"</SPAN
> and <SPAN
CLASS="QUOTE"
>"probe"</SPAN
> since these 
 terms come up quite a bit. A <SPAN
CLASS="QUOTE"
>"probe"</SPAN
> implies testing if a given
 port is open or closed, and possibly what might be listening on that port. A
 <SPAN
CLASS="QUOTE"
>"scan"</SPAN
> implies either <SPAN
CLASS="QUOTE"
>"probing"</SPAN
> multiple ports on
 one or more systems. Or individual ports on multiple systems. So you might 
 <SPAN
CLASS="QUOTE"
>"scan"</SPAN
> all ports on your own system for instance. Or a 
 cracker might <SPAN
CLASS="QUOTE"
>"scan"</SPAN
> the 216.78.*.* address range to see who
 has port 111 open. 
 </P
><P
> Black hats can use scan and probe information to know what services are
 running on a given system, and then they might know what exploits to try.
 They may even be able to tell what Operating System is running, and even
 kernel version, and thus get even more information. <SPAN
CLASS="QUOTE"
>"Worms"</SPAN
>, on
 the other hand, are automated and scan blindly, generally just looking for
 open ports, and then a susceptible victim. They are not trying to
 <SPAN
CLASS="QUOTE"
>"learn"</SPAN
> anything, the way a cracker might.&#13;</P
><P
> The distinction between <SPAN
CLASS="QUOTE"
>"scan"</SPAN
> and <SPAN
CLASS="QUOTE"
>"probe"</SPAN
>is often
 blurred.  Both can used in good ways, or in bad ways, depending on who is
 doing it, and why.  You might ask a friend to scan you, for instance, to see
 how well your firewall is working. This is a legitimate use of scanning tools
 such as <SPAN
CLASS="APPLICATION"
>nmap</SPAN
>. But what if someone you don't know
 does this? What is their intent? If it's your ISP, they may be trying to
 enforce their Terms of Service Agreement. Or maybe, it is someone just
 playing, and seeing who is <SPAN
CLASS="QUOTE"
>"out there"</SPAN
>. But more than likely it
 is someone or something with not such good intentions.&#13;</P
><P
> Full range port scans (meaning probing of many ports on the same machine)
 seem to be a not so common threat for home based networks. But certainly, 
 scanning individual ports across numerous systems is a very, very common 
 occurrence.
 </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1914"
>8.4.2. Rootkits</A
></H4
><P
> A <SPAN
CLASS="QUOTE"
>"rootkit"</SPAN
> is the script kiddie's stock in trade. When a
 successful intrusion takes place, the first thing that is often done, is to
 download and install such <SPAN
CLASS="QUOTE"
>"rootkits"</SPAN
>. The rootkit is a set of
 scripts designed to take control of the system, and then hide the intrusion.
 Rootkits are readily available on the web for various Operating Systems. &#13;</P
><P
> A rootkit will typically replace critical system files such as 
 <B
CLASS="COMMAND"
>ls</B
>, <B
CLASS="COMMAND"
>ps</B
>, <B
CLASS="COMMAND"
>netstat</B
>, 
 <B
CLASS="COMMAND"
>login</B
> and others. Passwords may be added, hidden 
 daemons started, logs tampered with, and surely one of more backdoors are
 opened. The hidden backdoors allow easy access any time the attacker wants
 back in. And often the vulnerability itself may even be fixed so that the new
 <SPAN
CLASS="QUOTE"
>"owner"</SPAN
> has the system all to himself. The entire process is
 scripted so it happens very quickly. The rightful owners of these compromised
 systems generally have no idea what is going on, and are victims themselves.
 A well designed rootkit can be very difficult to detect.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1925"
>8.4.3. Worms and Zombies</A
></H4
><P
> A <SPAN
CLASS="QUOTE"
>"worm"</SPAN
> is a self replicating exploit. It infects a system, 
 then attempts to spread itself typically via the same vulnerability. Various
 <SPAN
CLASS="QUOTE"
>"worms"</SPAN
> are weaving their way through the entire Internet
 address space constantly, spreading themselves as they go.&#13;</P
><P
> But somewhere behind the zombie, there is a controller. Someone launched 
 the worm, and they will be informed after a successful intrusion. It is 
 then up to them how the system will be used.
 </P
><P
> Many of these are Linux systems, looking for other Linux systems to
 <SPAN
CLASS="QUOTE"
>"infect"</SPAN
> via a number of exploits. But most Operating Systems
 share in this threat. Once a vulnerable system is found, the actual entry
 and take over is quick, and may be difficult to detect after the fact. The
 first thing an intruder (whether human or <SPAN
CLASS="QUOTE"
>"worm"</SPAN
>) will do is
 attempt to cover their tracks. A <SPAN
CLASS="QUOTE"
>"rootkit"</SPAN
> is downloaded and
 installed. This trend has been exacerbated by the growing popularity of cable
 modems and DSL. The number of full time Internet connections is growing
 rapidly, and this makes fertile ground for such exploits since often 
 these aren't as well secured as larger sites. &#13;</P
><P
> While this may sound ominous, a few simple precautions can effectively
 deter this type of attack. With so many easy victims out there, why waste much
 effort breaking into <EM
>your</EM
> system? There is no incentive
 to really try very hard. Just scan, look, try, move on if unsuccessful. There
 is always more IPs to be scanned. If your firewall is effectively bouncing
 this kind of thing, it is no threat to you at all. Take comfort in that, 
 and don't over re-act.&#13;</P
><P
> It is worth noting, that these worms cannot <SPAN
CLASS="QUOTE"
>"force"</SPAN
> their way
 in. They need an open and accessible port, <EM
>and</EM
> a known
 vulnerability. If you remember the <SPAN
CLASS="QUOTE"
>"Iptables Weekly Log Summary"</SPAN
>
 in the opening section above, many of those may have all been the result of
 this type of scan. If you've followed the steps in this HOWTO, you should be
 reasonably safe here. This one is easy enough to deflect.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1941"
>8.4.4. Script Kiddies</A
></H4
><P
> A <SPAN
CLASS="QUOTE"
>"script kiddie"</SPAN
> is a <SPAN
CLASS="QUOTE"
>"cracker"</SPAN
> wanna be who 
 doesn't know enough to come up with his/her own exploits, but instead 
 relies on <SPAN
CLASS="QUOTE"
>"scripts"</SPAN
> and exploits that have been developed by
 others. Like <SPAN
CLASS="QUOTE"
>"worms"</SPAN
>, they are looking for easy victims, 
 and may similarly scan large address ranges looking for specific ports 
 with known vulnerabilities. Often, the actual scanning is done from  
 already comprised systems so that it is difficult to trace it back to them.&#13;</P
><P
> The script kiddie has a bag of ready made tricks at his disposal, including 
 an arsenal of <SPAN
CLASS="QUOTE"
>"rootkits"</SPAN
> for various Operating Systems. Finding 
 susceptible victims is not so hard, given enough time and address space to
 probe. The motives are a mixed bag as well. Simple mischief, defacement 
 of web sites, stolen credit card numbers, and the latest craze, 
 <SPAN
CLASS="QUOTE"
>"Denial of Service"</SPAN
> attacks (see below). They collect 
 zombies like trophies and use them to carry out whatever their objective is.&#13;</P
><P
> Again, the key here is that they are following a <SPAN
CLASS="QUOTE"
>"script"</SPAN
>, and 
 looking for easy prey. Like the worm threat above, a functional firewall 
 and a few very basic precautions, should be sufficient to deflect any 
 threat here. By now, you should be relatively safe from this nuisance.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1953"
>8.4.5. Spoofed IPs</A
></H4
><P
> How easy is it to spoof an IP address? With the right tools, very easy. How
 much of a threat is this? Not much, for most of us, and is over-hyped as a 
 threat.&#13;</P
><P
> Because of the way TCP/IP works, each packet must carry both the source and
 destination IP addresses. Any return traffic is based on this information. So
 a spoofed IP can never return any useful information to an attacker who is
 sending out spoofed packets. The traffic would go back to wherever that
 spoofed IP address was pointed. The attacker gets nothing back at all.&#13;</P
><P
> This does have potential for <SPAN
CLASS="QUOTE"
>"DoS"</SPAN
> attacks (see below) where 
 learning something about the targeted system is not important. And may be 
 used for some general mischief making as well.&#13;</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1959"
>8.4.6. Targeted Attacks</A
></H4
><P
> The worm and wide ranging address type scans, are impersonal. They are just
 looking for any vulnerable system. It makes no difference whether it is a top
 secret government facility, or your mother's Window's box. But there are 
 <SPAN
CLASS="QUOTE"
>"black hats"</SPAN
> that will spend a great deal of effort to get into 
 a system or network.  We'll call these <SPAN
CLASS="QUOTE"
>"targeted"</SPAN
> attacks since 
 there has been a deliberate decision made to break in to a specific system 
 or network.
 </P
><P
> In this case, the attacker will look the system over for weaknesses. And
 possibly make many different kinds of attempts, until he finds a crack to
 wiggle through. Or gives up. This is more difficult to defend against. The
 attacker is armed and dangerous, so to speak, and is stalking his prey. &#13;</P
><P
> Again, this scenario is very unlikely for a typical home system. There just
 generally isn't any incentive to take the time and effort when there are
 bigger fish to fry. For those who may be targets, the best defense here
 includes many of things we've discussed. Vigilance is probably more important
 than ever. Good logging practices and an IDS (Intrusion Detection System)
 should be in place. And subscribing to one or more security related mailing
 lists like BUGTRAQ. And of course, reading those alerts daily, and taking
 the appropriate actions, etc. 
 </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="DOS"
>8.4.7. Denial of Service (DoS)</A
></H4
><P
> <SPAN
CLASS="QUOTE"
>"DoS"</SPAN
> is another type of <SPAN
CLASS="QUOTE"
>"attack"</SPAN
> in which the
 intention is to disrupt or overwhelm the targeted system or network in such a
 way that it cannot function normally. DoS can take many forms. On the
 Internet, this often means overwhelming the victim's bandwidth or TCP/IP
 stack, by sending floods of packets and thus effectively disabling the
 connection. We are talking about many, many packets per second. Thousands in
 some cases. Or perhaps, the objective is to crash a server.&#13;</P
><P
> This is much more likely to be targeted at organizations or high profile
 sites, than home users. And can be quite challenging to stop depending 
 on the technique. And it generally requires the co-operation of 
 networks between the source(s) and the target, so that the floods are
 stopped, or minimized, before they reach the targeted destination. Once they
 hit the destination, there is no good way to completely ignore them. &#13;</P
><P
> <SPAN
CLASS="QUOTE"
>"DDoS"</SPAN
>, Distributed Denial of Service, is where multiple sources
 are used to maximize the impact. Again, not likely to be directly targeted at
 home users. These are <SPAN
CLASS="QUOTE"
>"slaves"</SPAN
> that are <SPAN
CLASS="QUOTE"
>"owned"</SPAN
> 
 by a cracker, or script kiddie, that are woken up and are targeted at the 
 victim. There may be many computers involved in the attack.
 </P
><P
> If you are home user, and with a dynamic IP address, you might find
 disconnecting, then re-connecting to get a new IP, an effective way out 
 if you are the target. Maybe.
 </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1977"
>8.4.8. Brute Force</A
></H4
><P
> <SPAN
CLASS="QUOTE"
>"Brute force"</SPAN
> attacks are where the attacker makes repetitive
 attempts at the same perceived weakness(es). Like a battering ram. A classic
 example would be where someone tries to access a
 <SPAN
CLASS="APPLICATION"
>telnet</SPAN
> server simply by continually throwing
 passwords at it, hoping that one will eventually work. Or maybe crash the
 server. This doesn't require much imagination, and is not a commonly used
 tactic against home systems.
 </P
><P
> By the way, this is one good argument against allowing remote root logins. 
 The root account exists on all systems. It is probably the only one that this
 is true of. You'd like to make a potential attacker guess both the login 
 name <EM
>and</EM
> password. But if root is allowed remote logins, 
 then the attacker only needs to guess the password!
 </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="VIRUSES"
>8.4.9. Viruses</A
></H4
><P
> And now something <EM
>not</EM
> to worry about. Viruses seem to be
 primarily a Microsoft problem. For various reasons, viruses
 are not a significant threat to Linux users. This is not to say that it will
 always be this way, but the current virus explosion that plagues Microsoft
 systems, can not spread to Linux (or Unix) based systems. In fact, the
 various methods and practices that enable this phenomena, are not exploitable
 on Linux. So Anti-Virus software is not recommended as part of our arsenal.
 At least for the time being with Linux only networks.
 </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LINKS"
>8.5. Links</A
></H3
><P
> Some references for further reading are listed below. Not listed is your 
 distribution's site, security page or ftp download site. You will 
 have to find these on your own. Then you should bookmark them!&#13;</P
><P
> <P
></P
><UL
><LI
><P
>     Redhat sites of interest:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     The Redhat watch/security mailing list: <A
HREF="https://listman.redhat.com/mailman/listinfo/redhat-watch-list"
TARGET="_top"
>https://listman.redhat.com/mailman/listinfo/redhat-watch-list</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Red Hat errata and security notices:
     <A
HREF="http://redhat.com/errata/"
TARGET="_top"
>http://redhat.com/errata/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     The Red Hat update FTP site:
     <A
HREF="ftp://updates.redhat.com/"
TARGET="_top"
>ftp://updates.redhat.com/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>     Other relevant documents available from the Linux Documentation Project:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Security HOWTO: <A
HREF="http://tldp.org/HOWTO/Security-HOWTO.html "
TARGET="_top"
>http://tldp.org/HOWTO/Security-HOWTO.html</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Firewall HOWTO: <A
HREF="http://tldp.org/HOWTO/Firewall-HOWTO.html"
TARGET="_top"
>http://tldp.org/HOWTO/Firewall-HOWTO.html</A
>  
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Ipchains HOWTO: <A
HREF="http://tldp.org/HOWTO/IPCHAINS-HOWTO.html "
TARGET="_top"
>http://tldp.org/HOWTO/IPCHAINS-HOWTO.html</A
>  
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      User Authentication: <A
HREF="http://tldp.org/HOWTO/User-Authentication-HOWTO/index.html"
TARGET="_top"
>http://tldp.org/HOWTO/User-Authentication-HOWTO/index.html</A
>, includes a 
      nice discussion on PAM.
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     VPN (Virtual Private Network): <A
HREF="http://tldp.org/HOWTO/VPN-HOWTO.html"
TARGET="_top"
>http://tldp.org/HOWTO/VPN-HOWTO.html</A
>
     and <A
HREF="http://tldp.org/HOWTO/VPN-Masquerade-HOWTO.html"
TARGET="_top"
>http://tldp.org/HOWTO/VPN-Masquerade-HOWTO.html</A
>
     </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The Remote X Apps Mini HOWTO, 
      <A
HREF="http://www.tldp.org/HOWTO/mini/Remote-X-Apps.html"
TARGET="_top"
>http://www.tldp.org/HOWTO/mini/Remote-X-Apps.html</A
>, 
      includes excellent discussions on the security implications of running 
      X Windows.
     </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The Linux Network Administrators Guide: 
      <A
HREF="http://tldp.org/LDP/nag2/index.html"
TARGET="_top"
>http://tldp.org/LDP/nag2/index.html</A
>, includes a good overview of networking and TCP/IP, and 
      firewalling.
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The Linux Administrator's Security Guide: 
      <A
HREF="http://www.seifried.org/lasg/"
TARGET="_top"
> http://www.seifried.org/lasg/</A
>, 
      includes many obvious topics of interest, including firewalling, 
      passwords and authentication, PAM, and more.
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Securing Red Hat: 
     <A
HREF="http://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/index.html"
TARGET="_top"
>http://tldp.org/LDP/solrhe/Securing-Optimizing-Linux-RH-Edition-v1.3/index.html</A
>
     </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>     Tools for creating custom <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and 
     <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> firewall scripts:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Firestarter: <A
HREF="http://firestarter.sourceforge.net"
TARGET="_top"
>http://firestarter.sourceforge.net</A
>
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Two related projects: <A
HREF="http://seawall.sourceforge.net/"
TARGET="_top"
>http://seawall.sourceforge.net/</A
> for ipchains, 
     and <A
HREF="http://shorewall.sourceforge.net/"
TARGET="_top"
>http://shorewall.sourceforge.net/</A
> for iptables.
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>     Netfilter and iptables documentation from the netfilter developers 
     (available in many other languages as well):
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      FAQ: <A
HREF="http://netfilter.samba.org/documentation/FAQ/netfilter-faq.html"
TARGET="_top"
>http://netfilter.samba.org/documentation/FAQ/netfilter-faq.html</A
>
      </TD
></TR
><TR
><TD
>      Packet filtering: <A
HREF="http://netfilter.samba.org/documentation/HOWTO/packet-filtering-HOWTO.html"
TARGET="_top"
>http://netfilter.samba.org/documentation/HOWTO/packet-filtering-HOWTO.html</A
>
      </TD
></TR
><TR
><TD
>      Networking: <A
HREF="http://netfilter.samba.org/documentation/HOWTO/networking-concepts-HOWTO.html"
TARGET="_top"
>http://netfilter.samba.org/documentation/HOWTO/networking-concepts-HOWTO.html</A
>
      </TD
></TR
><TR
><TD
>      NAT/masquerading: <A
HREF="http://netfilter.samba.org/documentation/HOWTO/NAT-HOWTO.html"
TARGET="_top"
>http://netfilter.samba.org/documentation/HOWTO/NAT-HOWTO.html</A
>
      </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>     Port number assignments, and what that scanner may be scanning for:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      <A
HREF="http://www.linuxsecurity.com/resource_files/firewalls/firewall-seen.html"
TARGET="_top"
>http://www.linuxsecurity.com/resource_files/firewalls/firewall-seen.html</A
>
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      <A
HREF="http://www.sans.org/newlook/resources/IDFAQ/oddports.htm"
TARGET="_top"
>http://www.sans.org/newlook/resources/IDFAQ/oddports.htm</A
>
      </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      <A
HREF="http://www.iana.org/assignments/port-numbers"
TARGET="_top"
>http://www.iana.org/assignments/port-numbers</A
>, the official assignments.
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>    General security sites. These all have areas on documentation, alerts, 
    newsletters, mailing lists, and other resources.
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Linux Security.com: <A
HREF="http://www.linuxsecurity.com"
TARGET="_top"
>http://www.linuxsecurity.com</A
>, loaded with good info, and Linux specific. 
      Lots of good docs: <A
HREF="http://www.linuxsecurity.com/docs/"
TARGET="_top"
>http://www.linuxsecurity.com/docs/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      CERT, <A
HREF="http://www.cert.org"
TARGET="_top"
>http://www.cert.org</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The SANS Institute: <A
HREF="http://www.sans.org/"
TARGET="_top"
>http://www.sans.org/</A
> 
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The Coroner's Toolkit (TCT): <A
HREF="http://www.fish.com/security/"
TARGET="_top"
>http://www.fish.com/security/</A
>, 
      discussions and tools for dealing with post break-in issues (and
      preventing them in the first place).
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>    Privacy:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Junkbuster: <A
HREF="http://www.junkbuster.com"
TARGET="_top"
>http://www.junkbuster.com</A
>, a 
      web proxy and cookie manager.
     </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      PGP: <A
HREF="http://www.gnupg.org/"
TARGET="_top"
>http://www.gnupg.org/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>   Other documentation and reference sites:
  </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Linux Security.com: <A
HREF="http://www.linuxsecurity.com/docs/"
TARGET="_top"
>http://www.linuxsecurity.com/docs/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Linux Newbie: <A
HREF="http://www.linuxnewbie.org/nhf/intel/security/index.html"
TARGET="_top"
>http://www.linuxnewbie.org/nhf/intel/security/index.html</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The comp.os.linux.security FAQ: <A
HREF="http://www.linuxsecurity.com/docs/colsfaq.html"
TARGET="_top"
>http://www.linuxsecurity.com/docs/colsfaq.html</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      The Internet Firewall FAQ: <A
HREF="http://www.interhack.net/pubs/fwfaq/"
TARGET="_top"
>http://www.interhack.net/pubs/fwfaq/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     The Site Security Handbook RFC: <A
HREF="http://www.ietf.org/rfc/rfc2196.txt"
TARGET="_top"
>http://www.ietf.org/rfc/rfc2196.txt</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>     Miscellaneous sites of interest:
   </P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      <A
HREF="http://www.bastille-linux.org"
TARGET="_top"
>http://www.bastille-linux.org</A
>, for Mandrake and Red Hat only.
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      SAINT: <A
HREF="http://www.wwdsi.com/saint/"
TARGET="_top"
>http://www.wwdsi.com/saint/</A
>,
       system security analysis.
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      SSL: <A
HREF="http://www.openssl.org/"
TARGET="_top"
>http://www.openssl.org/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      SSH: <A
HREF="http://www.openssh.org/"
TARGET="_top"
>http://www.openssh.org/</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Scan yourself: <A
HREF="http://www.hackerwhacker.com"
TARGET="_top"
>http://www.hackerwhacker.com</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     PAM: <A
HREF="http://www.kernel.org/pub/linux/libs/pam/index.html"
TARGET="_top"
>http://www.kernel.org/pub/linux/libs/pam/index.html</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Detecting Trojaned Linux Kernel Modules: <A
HREF="http://members.prestige.net/tmiller12/papers/lkm.htm"
TARGET="_top"
>http://members.prestige.net/tmiller12/papers/lkm.htm</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Rootkit checker: <A
HREF="http://www.chkrootkit.org"
TARGET="_top"
>http://www.chkrootkit.org</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>     Port scanning tool <SPAN
CLASS="APPLICATION"
>nmap's</SPAN
> home page: <A
HREF="http://www.insecure.org"
TARGET="_top"
>http://www.insecure.org</A
> 
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Nessus, more than just a port scanner: <A
HREF="http://www.nessus.org"
TARGET="_top"
>http://www.nessus.org</A
> 
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Tripwire, intrusion detection: 
      <A
HREF="http://www.tripwire.org"
TARGET="_top"
>http://www.tripwire.org</A
>
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      Snort, sniffer and more: <A
HREF="http://www.snort.org"
TARGET="_top"
>http://www.snort.org</A
> 
    </TD
></TR
></TBODY
></TABLE
><P
></P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>      <A
HREF="http://www.mynetwatchman.com"
TARGET="_top"
>http://www.mynetwatchman.com</A
>
      and <A
HREF="http://dshield.org"
TARGET="_top"
>http://dshield.org</A
> are 
      <SPAN
CLASS="QUOTE"
>"Distributed Intrusion Detection Systems"</SPAN
>. They collect 
      log data from subscribing <SPAN
CLASS="QUOTE"
>"agents"</SPAN
>, and collate the 
      data to find and report malicious activity. If you want to fight back, 
      check these out.
    </TD
></TR
></TBODY
></TABLE
><P
></P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TEXT"
>8.6. Editing Text Files</A
></H3
><P
>By Bill Staehle</P
><P
>All the world is a file.</P
><P
>There are a great many types of files, but I'm going to stretch it here,
and class them into two really broad families:</P
><P
> <TT
CLASS="LITERAL"
>  <P
CLASS="LITERALLAYOUT"
><br>
<br>
&nbsp;Text&nbsp;files&nbsp;are&nbsp;just&nbsp;that.<br>
&nbsp;Binary&nbsp;files&nbsp;are&nbsp;not.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
>
 </TT
></P
><P
>Binary files are meant to be read by machines, text files can be easily
edited, and are generally read by people. But text files can be (and
frequently are) read by machines. Examples of this would be configuration
files, and scripts.</P
><P
>There are a number of different text editors available in *nix.  A few
are found on every system. That would be '/bin/ed' and '/bin/vi'. 'vi' is
almost always a clone such as 'vim' due to license problems. The problem with
'vi' and 'ed' is that they are terribly user unfriendly. Another common editor
that is not always installed by default is 'emacs'. It has a lot more features
and capability, and is not easy to learn either.</P
><P
> As to 'user friendly' editors, 'mcedit' and 'pico' are good choices to start
 with. These are often much easier for those new to *nix. </P
><P
> The first things to learn are how to exit an editing session, how to save
 changes to the file, and then how to avoid breaking long lines that should
 not be broken (wrapped). </P
><P
>The 'vi' editor</P
><P
>'vi' is one of the most common text editors in the Unix world, and it's
nearly always found on any *nix system. Actually, due to license problems,
the '/bin/vi' on a Linux system is always a 'clone', such as 'elvis',
'nvi', or 'vim' (there are others). These clones can act exactly like
the original 'vi', but usually have additional features that make it
slightly less impossible to use.</P
><P
>So, if it's so terrible, why learn about it?  Two reasons. First, as
noted, it's almost guaranteed to be installed, and other (more user
friendly) editors may not be installed by default.  Second, many of the
'commands' work in other applications (such as the pager 'less' which is
also used to view man pages). In 'less', accidentally pressing the 'v' key
starts 'vi' in most installations.</P
><P
>'vi' has two modes.  The first is 'command mode', and keystrokes are
interpreted as commands. The other mode is 'insert' mode, where nearly all
keystrokes are interpreted as text to be inserted.</P
><P
>==&#62; Emergency exit from 'vi'
1. press the &#60;esc&#62; key up to three times, until the computer beeps, or the
screen flashes.
2. press the keys :q! &#60;Enter&#62;</P
><P
> That is: colon, the letter Q, and then the exclamation point, followed by
 the Enter key.&#13;</P
><P
>'vi' commands  are as follows. All of these are in 'command' mode:</P
><P
> <TT
CLASS="LITERAL"
>  <P
CLASS="LITERALLAYOUT"
><br>
a&nbsp;&nbsp;&nbsp;&nbsp;Enter&nbsp;insertion&nbsp;mode&nbsp;after&nbsp;the&nbsp;cursor.<br>
A&nbsp;&nbsp;&nbsp;&nbsp;Enter&nbsp;insertion&nbsp;mode&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;current&nbsp;line.<br>
i&nbsp;&nbsp;&nbsp;&nbsp;Enter&nbsp;insertion&nbsp;mode&nbsp;before&nbsp;the&nbsp;cursor.<br>
o&nbsp;&nbsp;&nbsp;&nbsp;Enter&nbsp;insertion&nbsp;mode&nbsp;opening&nbsp;a&nbsp;new&nbsp;line&nbsp;BELOW&nbsp;current&nbsp;line.<br>
O&nbsp;&nbsp;&nbsp;&nbsp;Enter&nbsp;insertion&nbsp;mode&nbsp;opening&nbsp;a&nbsp;new&nbsp;line&nbsp;ABOVE&nbsp;current&nbsp;line.<br>
h&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;cursor&nbsp;left&nbsp;one&nbsp;character.<br>
l&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;cursor&nbsp;right&nbsp;one&nbsp;character.<br>
j&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;cursor&nbsp;down&nbsp;one&nbsp;line.<br>
k&nbsp;&nbsp;&nbsp;&nbsp;move&nbsp;cursor&nbsp;up&nbsp;one&nbsp;line.<br>
/mumble&nbsp;&nbsp;move&nbsp;cursor&nbsp;forward&nbsp;to&nbsp;next&nbsp;occurrence&nbsp;of&nbsp;'mumble'&nbsp;in&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;text<br>
?mumble&nbsp;&nbsp;move&nbsp;cursor&nbsp;backward&nbsp;to&nbsp;next&nbsp;occurrence&nbsp;of&nbsp;'mumble'&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;the&nbsp;text<br>
n&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;last&nbsp;search&nbsp;(?&nbsp;or&nbsp;/&nbsp;without&nbsp;'mumble'&nbsp;to&nbsp;search&nbsp;for&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;will&nbsp;do&nbsp;the&nbsp;same&nbsp;thing)<br>
u&nbsp;&nbsp;&nbsp;&nbsp;undo&nbsp;last&nbsp;change&nbsp;made<br>
<br>
^B&nbsp;&nbsp;&nbsp;Scroll&nbsp;back&nbsp;one&nbsp;window.<br>
^F&nbsp;&nbsp;&nbsp;Scroll&nbsp;forward&nbsp;one&nbsp;window.<br>
^U&nbsp;&nbsp;&nbsp;Scroll&nbsp;up&nbsp;one&nbsp;half&nbsp;window.<br>
^D&nbsp;&nbsp;&nbsp;Scroll&nbsp;down&nbsp;one&nbsp;half&nbsp;window.<br>
<br>
:w&nbsp;&nbsp;&nbsp;Write&nbsp;to&nbsp;file.<br>
:wq&nbsp;&nbsp;Write&nbsp;to&nbsp;file,&nbsp;and&nbsp;quit.<br>
:q&nbsp;&nbsp;&nbsp;quit.<br>
:q!&nbsp;&nbsp;Quit&nbsp;without&nbsp;saving.<br>
<br>
&#60;esc&#62;&nbsp;&nbsp;&nbsp;Leave&nbsp;insertion&nbsp;mode.<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
>
 </TT
></P
><P
>NOTE: The four 'arrow' keys almost always work in 'command' or 'insert'
mode.</P
><P
>The 'ed' editor.</P
><P
>The 'ed' editor is a line editor. Other than the fact that it is virtually
guaranteed to be on any *nix computer, it has no socially redeeming
features, although some applications may need it. A _lot_ of things have
been offered to replace this 'thing' from 1975.</P
><P
>==&#62; Emergency exit from 'ed'</P
><P
>1. type a period on a line by itself, and press &#60;Enter&#62;   This gets you to
the command mode or prints a line of text if you were in command mode.
2.  type  q  and press &#60;Enter&#62;.  If there were no changes to the file,
this action quits ed. If you then see a '?' this means that the file had
changed, and 'ed' is asking if you want to save the changes. Press q and
&#60;Enter&#62; a second time to confirm that you want out.</P
><P
>The 'pico' editor.</P
><P
>'pico' is a part of the Pine mail/news package from the University of
Washington (state, USA). It is a very friendly editor, with one minor
failing. It silently inserts a line feed character and wraps the line when
it exceeds (generally) 74 characters.  While this is fine while creating
mail, news articles, and text notes, it is often fatal when editing system
files. The solution to this problem is simple. Call the program with the
-w  option, like this:</P
><P
>pico -w file_2_edit</P
><P
>Pico is so user friendly, no further instructions are needed. It _should_
be obvious (look at the bottom of the screen for commands). There is an
extensive help function.  Pico is available with nearly all distributions,
although it _may_ not be installed by default.</P
><P
>==&#62; Emergency exit from 'pico'</P
><P
>Press and hold the &#60;Ctrl&#62; key, and press the letter x. If no changes
had been made to the file, this will quit pico. If changes had been made,
it will ask if you want to save the changes. Pressing n will then exit.</P
><P
>The 'mcedit' editor.</P
><P
>'mcedit' is part of the Midnight Commander shell program, a full featured
visual shell for Unix-like systems. It can be accessed directly from the
command line ( mcedit file_2_edit ) or as part of 'mc' (use the arrow keys
to highlight the file to be edited, then press the F4 key).</P
><P
>mcedit is probably the most intuitive editor available, and comes with
extensive help. "commands" are accessed through the F* keys. Midnight
Commander is available with nearly all distributions, although it _may_ not
be installed by default.</P
><P
>==&#62; Emergency exit from 'mcedit'</P
><P
>Press the F10 key. If no changes have been made to the file, this will
quit mcedit. If changes had been made, it will ask if you want to Cancel
this action. Pressing n   will then exit.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NMAP"
>8.7. nmap</A
></H3
><P
> Let's look at a few quick examples of what <B
CLASS="COMMAND"
>nmap</B
> scans 
 look like. The intent here is to show how to use <B
CLASS="COMMAND"
>nmap</B
>
 to verify our firewalling, and system integrity. <B
CLASS="COMMAND"
>nmap</B
> 
 has other uses that we don't need to get into. Do NOT use 
 <B
CLASS="COMMAND"
>nmap</B
> on systems other than your own, unless you have 
 permission from the owner, and you know it is not a violation of anyone's
 Terms of Service. This kind of thing <EM
>will</EM
> be taken as
 hostile by most people.&#13;</P
><P
> As mentioned previously, <B
CLASS="COMMAND"
>nmap</B
> is a sophisticated 
 port scanning tool. It tries to see if a host is <SPAN
CLASS="QUOTE"
>"there"</SPAN
>, 
 and what ports might be open. Barring that, what states those ports 
 might be in. <B
CLASS="COMMAND"
>nmap</B
> has a complex command line and 
 can do many types of <SPAN
CLASS="QUOTE"
>"scans"</SPAN
>. See the man page for all 
 the nitty gritty.&#13;</P
><P
> A couple of words of warning first. If using
 <SPAN
CLASS="APPLICATION"
>portsentry</SPAN
>, turn it off. It will drop the route
 to wherever the scan is coming from. You might want to turn off any logging
 also, or at least be aware that you might get copious logs if doing multiple
 scans.&#13;</P
><P
> A simple, default scan of <SPAN
CLASS="QUOTE"
>"localhost"</SPAN
>:</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # nmap localhost

 Starting nmap V. 2.53 by fyodor@insecure.org ( www.insecure.org/nmap/ )
 Interesting ports on bigcat (127.0.0.1):
 (The 1507 ports scanned but not shown below are in state: closed)

 Port       State       Service
 22/tcp     open        ssh                     
 25/tcp     open        smtp                    
 37/tcp     open        time                    
 53/tcp     open        domain                  
 80/tcp     open        http                    
 3000/tcp   open        ppp                     

 Nmap run completed -- 1 IP address (1 host up) scanned in 2 seconds

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> If you've read most of this document, you should be familiar with 
 these services by now. These are some of the same ports we've seen in other
 examples. Some things to note on this scan: it only did 1500+
 <SPAN
CLASS="QUOTE"
>"interesting"</SPAN
>  ports -- not all ports. This can be configured
 differently if more is desirable (see man page). It only did TCP ports too.
 Again, configurable. It only picks up <SPAN
CLASS="QUOTE"
>"listening"</SPAN
> services,
 unlike <B
CLASS="COMMAND"
>netstat</B
> that shows all open ports -- listening or
 otherwise. Note the last <SPAN
CLASS="QUOTE"
>"open"</SPAN
> port here is 3000 is identified
 as <SPAN
CLASS="QUOTE"
>"PPP"</SPAN
>. Wrong! That is just an educated guess by nmap based on
 what is contained in <TT
CLASS="FILENAME"
>/etc/services</TT
> for this port number.
 Actually in this case it is <SPAN
CLASS="APPLICATION"
>ntop</SPAN
> (a network
 traffic monitor). Take the service names with a grain of salt. There is no
 way for <B
CLASS="COMMAND"
>nmap</B
> to really know what is on that port. Matching
 port numbers with service names can at times be risky. Many do have standard
 ports, but there is nothing to say they have to use the commonly associated
 port numbers.  &#13;</P
><P
> Notice that in all our <B
CLASS="COMMAND"
>netstat</B
> examples, we had two classes
 of open ports: listening servers, and then established connections that we
 initiated to other remote hosts (e.g. a web server somewhere).
 <B
CLASS="COMMAND"
>nmap</B
> only sees the first group -- the listening servers! 
 The other ports connecting us to remote servers are not visible, and thus 
 not vulnerable. These ports are <SPAN
CLASS="QUOTE"
>"private"</SPAN
> to that single 
 connection, and will be closed when the connection is terminated.</P
><P
> So we have open and closed ports here. Simple enough, and gives a pretty good
 idea what is running on bigcat -- but not necessarily what we look like to
 the outside world since this was done from localhost, and wouldn't reflect 
 any firewalling or other access control mechanisms.&#13;</P
><P
> Let's do a little more intensive scan. Let's check all ports -- TCP and UDP.&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # nmap -sT -sU -p 1-65535 localhost

 Starting nmap V. 2.53 by fyodor@insecure.org ( www.insecure.org/nmap/ )
 Interesting ports on bigcat (127.0.0.1):
 (The 131050 ports scanned but not shown below are in state: closed)

 Port       State       Service
 22/tcp     open        ssh                     
 25/tcp     open        smtp                    
 37/tcp     open        time                    
 53/tcp     open        domain                  
 53/udp     open        domain                  
 80/tcp     open        http                    
 3000/tcp   open        ppp                     
 8000/tcp   open        unknown                 
 32768/udp  open        unknown                 

 Nmap run completed -- 1 IP address (1 host up) scanned in 385 seconds

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This is more than just <SPAN
CLASS="QUOTE"
>"interesting"</SPAN
> ports -- it is everything. 
 We picked up a couple of new ones in the process too. We've seen these before 
 with <B
CLASS="COMMAND"
>netstat</B
>, so we know what they are. That is the 
 <B
CLASS="COMMAND"
>Junkbuster</B
> web proxy on port 8000/tcp and
 <B
CLASS="COMMAND"
>named</B
> on 32768/udp. This scan takes much, much longer, but it 
 is the only way to see all ports.&#13;</P
><P
> So now we have a pretty good idea of what is open on bigcat. Since 
 we are scanning localhost from localhost, everything should be visible. 
 We still don't know how the outside world sees us though. Now I'll
 <B
CLASS="COMMAND"
>ssh</B
> to another host on the same LAN, and try again.&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # nmap bigcat

 Starting nmap V. 2.53 by fyodor@insecure.org ( www.insecure.org/nmap/ )
 Interesting ports on bigcat (192.168.1.1):
 (The 1520 ports scanned but not shown below are in state: closed)

 Port       State       Service
 22/tcp     open        ssh
 3000/tcp   open        ppp

 Nmap run completed -- 1 IP address (1 host up) scanned in 1 second

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> I confess to tampering with the <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> rules 
 here to make a point. Only two visible ports on this scan. Everything 
 else is <SPAN
CLASS="QUOTE"
>"closed"</SPAN
>. So says <SPAN
CLASS="APPLICATION"
>nmap</SPAN
>. 
 Once again:&#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # nmap bigcat

 Starting nmap V. 2.53 by fyodor@insecure.org ( www.insecure.org/nmap/ )
 Note: Host seems down. If it is really up, but blocking our ping probes, try -P0
 
 Nmap run completed -- 1 IP address (0 hosts up) scanned in 30 seconds

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Oops, I blocked ICMP (ping) while I was at it this time. One more time: &#13;</P
><P
> <TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#13; # nmap -P0 bigcat

 Starting nmap V. 2.53 by fyodor@insecure.org ( www.insecure.org/nmap/ )
 All 1523 scanned ports on bigcat (192.168.1.1) are: filtered
 
 Nmap run completed -- 1 IP address (1 host up) scanned in 1643 seconds

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> That's it. Notice how long that took. Notice ports are now
 <SPAN
CLASS="QUOTE"
>"filtered"</SPAN
> instead of <SPAN
CLASS="QUOTE"
>"closed"</SPAN
>. How does
 <B
CLASS="COMMAND"
>nmap</B
> know that? Well for one, <SPAN
CLASS="QUOTE"
>"closed"</SPAN
> means
 bigcat sent a packet back saying <SPAN
CLASS="QUOTE"
>"nothing running here"</SPAN
>, i.e.
 port is closed. In this last example, the <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>
 rules were changed to not allow ICMP (ping), and to <SPAN
CLASS="QUOTE"
>"DROP"</SPAN
> all
 incoming packets. In other words, no response at all. A subtle difference
 since <B
CLASS="COMMAND"
>nmap</B
> seems to still know there was a host there,
 even though no response was given. One lesson here, is if you want to slow a
 scanner down, <SPAN
CLASS="QUOTE"
>"DROP"</SPAN
> (or <SPAN
CLASS="QUOTE"
>"DENY"</SPAN
>) the packets. This
 forces a TCP time out for the remote end on each port probe. Anyway, if your
 scans look like this, that is probably as well as can be expected, and your 
 firewall is doing its job.&#13;</P
><P
> A brief note on UDP: <B
CLASS="COMMAND"
>nmap</B
> can not accurately determine 
 the status of these ports if they are <SPAN
CLASS="QUOTE"
>"filtered"</SPAN
>. You probably
 will get a false-positive <SPAN
CLASS="QUOTE"
>"open"</SPAN
> condition. This has to do with
 UDP being a connectionless protocol. If <B
CLASS="COMMAND"
>nmap</B
> gets no 
 answer (e.g. due to a <SPAN
CLASS="QUOTE"
>"DROP"</SPAN
>), it assumes the packets reached
 the target, and thus the port will be reported as <SPAN
CLASS="QUOTE"
>"open"</SPAN
>. 
 This is <SPAN
CLASS="QUOTE"
>"normal"</SPAN
> for <B
CLASS="COMMAND"
>nmap</B
>.&#13;</P
><P
> We can play with firewall rules in a LAN set up to try to simulate how the 
 outside world sees us, and if we are smart, and know what we are doing, 
 and don't have a brain fart, we probably will have a pretty good picture. But
 it is still best to try to find a way to do it from outside if possible.
 Again, make sure you are not violating any ISP rules of conduct. Do you have
 a friend on the same ISP? &#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SYSCTL"
>8.8. Sysctl Options</A
></H3
><P
> The <SPAN
CLASS="QUOTE"
>"sysctl"</SPAN
> options are kernel parameters that can be
 configured via the <TT
CLASS="FILENAME"
>/proc</TT
> filesystem. These can 
 be dynamically adjusted at run-time. Typically these options are off 
 if set to <SPAN
CLASS="QUOTE"
>"0"</SPAN
>, and on if set to <SPAN
CLASS="QUOTE"
>"1"</SPAN
>.&#13;</P
><P
> Some of these have security implications, and thus is why we are here ;-) 
 We'll just list the ones we think are relevant. Feel free to cut and 
 paste these into a firewall script, or other file that is run during boot
 (like <TT
CLASS="FILENAME"
>/etc/rc.local</TT
>).  
  Red Hat provides the <B
CLASS="COMMAND"
>sysctl</B
> command for
 dynamically adjusting these values (see man page). Or they can permanently be
 set in <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
> with your text editor of choice.
 <B
CLASS="COMMAND"
>sysctl</B
> is executed during init, and uses these values.
 You can read up on what these mean in
 <TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/sysctl/README</TT
> and other
 files in the kernel Documentation directories.
&#13;</P
><P
> The traditional method:&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;#!/bin/sh
# 
# Configure kernel sysctl run-time options. 
#
###################################################################

# Anti-spoofing blocks
for i in /proc/sys/net/ipv4/conf/*/rp_filter; 
do
 echo 1 &#62; $i
done

# Ensure source routing is OFF
for i in /proc/sys/net/ipv4/conf/*/accept_source_route;
 do
  echo 0 &#62; $i
 done

# Ensure TCP SYN cookies protection is enabled
[ -e /proc/sys/net/ipv4/tcp_syncookies ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/tcp_syncookies 

# Ensure ICMP redirects are disabled
for i in /proc/sys/net/ipv4/conf/*/accept_redirects; 
 do
  echo 0 &#62; $i
 done

# Ensure oddball addresses are logged
[ -e /proc/sys/net/ipv4/conf/all/log_martians ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/conf/all/log_martians

[ -e /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

[ -e /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

## Optional from here on down, depending on your situation. ############

# Ensure ip-forwarding is enabled if
# we want to do forwarding or masquerading.
[ -e /proc/sys/net/ipv4/ip_forward ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/ip_forward

# On if your IP is dynamic (or you don't know).
[ -e /proc/sys/net/ipv4/ip_dynaddr ] &#38;&#38;\
 echo 1 &#62; /proc/sys/net/ipv4/ip_dynaddr        

# eof

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> The same effect by using <TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
> instead:&#13;</P
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;# 
# Add to existing sysctl.conf
#

# Anti-spoofing blocks
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.rp_filter = 1

# Ensure source routing is OFF
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.all.accept_source_route = 0

# Ensure TCP SYN cookies protection is enabled
net.ipv4.tcp_syncookies = 1

# Ensure ICMP redirects are disabled
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.accept_redirects = 0

# Ensure oddball addresses are logged
net.ipv4.conf.default.log_martians = 1
net.ipv4.conf.all.log_martians = 1


net.ipv4.icmp_echo_ignore_broadcasts = 1

net.ipv4.icmp_ignore_bogus_error_responses = 1

## Optional from here on down, depending on your situation. ############

# Ensure ip-forwarding is enabled if
# we want to do forwarding or masquerading.
net.ipv4.ip_forward = 1

# On if your IP is dynamic (or you don't know).
net.ipv4.ip_dynaddr = 1

# end of example

 </PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SECUREALT"
>8.9. Secure Alternatives</A
></H3
><P
> This section will give a brief run down on secure alternatives to 
 potentially insecure methods. This will be a hodge podge of clients 
 and servers. &#13;</P
><P
> <P
></P
><UL
><LI
><P
>  
   telnet, rsh - ssh
  </P
></LI
><LI
><P
>   ftp, rcp - scp or sftp. Both are part of ssh packages. Also, files 
   can easily be transfered via HTTP if Apache is already running 
   anyway. Apache can be buttoned down even more by using SSL (HTTPS). 
  </P
></LI
><LI
><P
>   sendmail - postfix, qmail. Not to imply that current versions of 
   <SPAN
CLASS="APPLICATION"
>sendmail</SPAN
> are insecure. Just that there 
   is some bad history there, and just because it is so widely used 
   that it makes an inviting crack target.
  </P
><P
>   As noted above, Linux installations often include a fully functional 
   mail server. While this may have some advantages, it is not necessary 
   in many cases for simply sending mail, or retrieving mail. This can all 
   be done without a <SPAN
CLASS="QUOTE"
>"mail server daemon"</SPAN
> running locally.

  </P
></LI
><LI
><P
>    POP3 - SPOP3, POP3 over SSL. If you really need to run your own 
    POP server, this is the way to do it. If retrieving your mail from 
    your ISP's server, then you are at their mercy as to what they provide.
  </P
></LI
><LI
><P
>    IMAP - IMAPS, same as above. 
  </P
></LI
><LI
><P
>    If you find you need a particular service, and it is for just you or a few
    friends, consider running it on a non-standard port. Most server daemons 
    support this, and is not a problem as long as those who will be
    connecting, know about it. For instance, the standard port for
    <B
CLASS="COMMAND"
>sshd</B
> is 22. Any worm or scan will probe for this port
    number. So run it on a randomly chosen port. See the <B
CLASS="COMMAND"
>sshd</B
>
    man page.
  </P
></LI
></UL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PFILTERS"
>8.10. Ipchains and Iptables Redux</A
></H3
><P
> This section offers a little more advanced look at some of things that 
 <SPAN
CLASS="APPLICATION"
>ipchains</SPAN
> and <SPAN
CLASS="APPLICATION"
>iptables</SPAN
>
 can do. These are basically the same scripts as in Step 3 above, just 
 with some more advanced configuration options added. These will provide
 <SPAN
CLASS="QUOTE"
>"masquerading"</SPAN
>, <SPAN
CLASS="QUOTE"
>"port forwarding"</SPAN
>, allow access to
 some user definable services, and a few other things. Read the comments for
 explanations.&#13;</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2316"
>8.10.1. ipchains II</A
></H4
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;#!/bin/sh
#
# ipchains.sh
#
# An example of a simple ipchains configuration. This script 
# can enable 'masquerading' and will open user definable ports.
#
###################################################################
# Begin variable declarations and user configuration options ######
#
# Set the location of ipchains (default).
IPCHAINS=/sbin/ipchains

# Local Interfaces
#
# This is the WAN interface, that is our link to the outside world.
# For pppd and pppoe users.
# WAN_IFACE="ppp0"
WAN_IFACE="eth0"
#
# Local Area Network (LAN) interface.
#LAN_IFACE="eth0"
LAN_IFACE="eth1"

# Our private LAN address(es), for masquerading.
LAN_NET="192.168.1.0/24"

# For static IP, set it here! 
#WAN_IP="1.2.3.4"

# Set a list of public server port numbers here...not too many!
# These will be open to the world, so use caution. The example is
# sshd, and HTTP (www). Any services included here should be the
# latest version available from your vendor. Comment out to disable
# all PUBLIC services.
#PUBLIC_PORTS="22 80 443"
PUBLIC_PORTS="22"

# If we want to do port forwarding, this is the host 
# that will be forwarded to.
#FORWARD_HOST="192.168.1.3"

# A list of ports that are to be forwarded. 
#FORWARD_PORTS="25  80"

# If you get your public IP address via DHCP, set this.
DHCP_SERVER=66.21.184.66

# If you need identd for a mail server, set this.
MAIL_SERVER=

# A list of unwelcome hosts or nets. These will be denied access 
# to everything, even our 'PUBLIC' services. Provide your own list.
#BLACKLIST="11.22.33.44 55.66.77.88"

# A list of "trusted" hosts and/or nets. These will have access to 
# ALL protocols, and ALL open ports. Be selective here.
#TRUSTED="1.2.3.4/8  5.6.7.8"

## end user configuration options #################################
###################################################################

# The high ports used mostly for connections we initiate and return
# traffic.
LOCAL_PORTS=`cat /proc/sys/net/ipv4/ip_local_port_range |cut -f1`:\
`cat /proc/sys/net/ipv4/ip_local_port_range |cut -f2`

# Any and all addresses from anywhere.
ANYWHERE="0/0"

# Start building chains and rules #################################
#
# Let's start clean and flush all chains to an empty state.
$IPCHAINS -F  

# Set the default policies of the built-in chains. If no match for any 
# of the rules below, these will be the defaults that ipchains uses.
$IPCHAINS -P forward DENY
$IPCHAINS -P output ACCEPT
$IPCHAINS -P input DENY 

# Accept localhost/loopback traffic.
$IPCHAINS -A input -i lo -j ACCEPT

# Get our dynamic IP now from the Inet interface. WAN_IP will be our
# IP address we are protecting from the outside world. Put this
# here, so default policy gets set, even if interface is not up
# yet.
[ -z "$WAN_IP" ] &#38;&#38;\
  WAN_IP=`ifconfig $WAN_IFACE |grep inet |cut -d : -f 2 |cut -d \  -f 1`

# Bail out with error message if no IP available! Default policy is 
# already set, so all is not lost here.
[ -z "$WAN_IP" ] &#38;&#38; echo "$WAN_IFACE not configured, aborting." &#38;&#38; exit 1

WAN_MASK=`ifconfig $WAN_IFACE | grep Mask | cut -d : -f 4`
WAN_NET="$WAN_IP/$WAN_MASK"

## Reserved IPs:
#
# We should never see these private addresses coming in from outside 
# to our external interface.
$IPCHAINS -A input -l -i $WAN_IFACE -s 10.0.0.0/8     -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 172.16.0.0/12  -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 192.168.0.0/16 -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 127.0.0.0/8    -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 169.254.0.0/16 -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 224.0.0.0/4    -j DENY
$IPCHAINS -A input -l -i $WAN_IFACE -s 240.0.0.0/5    -j DENY
# Bogus routing
$IPCHAINS -A input -l -s 255.255.255.255 -d $ANYWHERE -j DENY

## LAN access and masquerading
#
# Allow connections from our own LAN's private IP addresses via the LAN
# interface and set up forwarding for masqueraders if we have a LAN_NET
# defined above. 
if [ -n "$LAN_NET" ]; then 
 echo 1 &#62; /proc/sys/net/ipv4/ip_forward
 $IPCHAINS -A input  -i $LAN_IFACE  -j ACCEPT
 $IPCHAINS -A forward -s $LAN_NET -d $LAN_NET -j ACCEPT
 $IPCHAINS -A forward  -s $LAN_NET -d ! $LAN_NET -j MASQ
fi

## Blacklist hosts/nets
#
# Get the blacklisted hosts/nets out of the way, before we start opening 
# up any services. These will have no access to us at all, and will be
# logged.
for i in $BLACKLIST; do
 $IPCHAINS -A input -l -s $i -j DENY
done

## Trusted hosts/nets
#
# This is our trusted host list. These have access to everything.
for i in $TRUSTED; do
 $IPCHAINS -A input -s $i -j ACCEPT
done

# Port Forwarding
#
# Which ports get forwarded to which host. This is one to one 
# port mapping (ie 80 -&#62; 80) in this case.
# NOTE: ipmasqadm is a separate package from ipchains and needs 
# to be installed also. Check first!
[ -n "$FORWARD_HOST" ] &#38;&#38; ipmasqadm portfw -f &#38;&#38;\
 for i in $FORWARD_PORTS; do
   ipmasqadm portfw -a -P tcp -L $WAN_IP $i -R $FORWARD_HOST $i
 done

## Open, but Restricted Access ports/services
#
# Allow DHCP server (their port 67) to client (to our port 68) UDP traffic
# from outside source.
[ -n "$DHCP_SERVER" ] &#38;&#38;\
 $IPCHAINS -A input -p udp -s $DHCP_SERVER 67 -d $ANYWHERE 68 -j ACCEPT 

# Allow 'identd' (to our TCP port 113) from mail server only.
[ -n "$MAIL_SERVER" ] &#38;&#38;\
 $IPCHAINS -A input -p tcp -s $MAIL_SERVER  -d $WAN_IP 113 -j ACCEPT 

# Open up PUBLIC server ports here (available to the world):
for i in $PUBLIC_PORTS; do
 $IPCHAINS -A input -p tcp -s $ANYWHERE -d $WAN_IP $i -j ACCEPT 
done

# So I can check my home POP3 mailbox from work. Also, so I can ssh 
# in to home system. Only allow connections from my workplace's
# various IPs. Everything else is blocked.
$IPCHAINS -A input -p tcp -s 255.10.9.8/29 -d $WAN_IP 110 -j ACCEPT 

# Uncomment to allow ftp data back (active ftp). Not required for 'passive'
# ftp connections.
#$IPCHAINS -A input -p tcp -s $ANYWHERE 20 -d $WAN_IP $LOCAL_PORTS -y -j ACCEPT

# Accept non-SYN TCP, and UDP connections to LOCAL_PORTS. These are
# the high, unprivileged ports (1024 to 4999 by default). This will
# allow return connection traffic for connections that we initiate
# to outside sources. TCP connections are opened with 'SYN' packets.
# We have already opened those services that need to accept SYNs
# for, so other SYNs are excluded here for everything else.
$IPCHAINS -A input -p tcp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS ! -y -j ACCEPT 

# We can't be so selective with UDP since that protocol does not know 
# about SYNs.
$IPCHAINS -A input -p udp -s $ANYWHERE -d $WAN_IP $LOCAL_PORTS -j ACCEPT 

# Allow access to the masquerading ports conditionally. Masquerading
# uses it's own port range -- on 2.2 kernels ONLY! 2.4 kernels, do not 
# use these ports, so comment out!
[ -n "$LAN_NET" ] &#38;&#38;\
 $IPCHAINS -A input -p tcp -s $ANYWHERE -d $WAN_IP 61000: ! -y -j ACCEPT &#38;&#38;\
 $IPCHAINS -A input -p udp -s $ANYWHERE -d $WAN_IP 61000: -j ACCEPT

## ICMP (ping)
#
# ICMP rules, allow the bare essential types of ICMP only. Ping
# request is blocked, ie we won't respond to someone else's pings,
# but can still ping out. 
$IPCHAINS -A input  -p icmp  --icmp-type echo-reply \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPCHAINS -A input  -p icmp  --icmp-type destination-unreachable \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT
$IPCHAINS -A input  -p icmp  --icmp-type time-exceeded \
   -s $ANYWHERE -i $WAN_IFACE -j ACCEPT

#######################################################################
# Set the catchall, default rule to DENY, and log it all. All other
# traffic not allowed by the rules above, winds up here, where it is
# blocked and logged. This is the default policy for this chain
# anyway, so we are just adding the logging ability here with '-l'.
# Outgoing traffic is allowed as the default policy for the 'output'
# chain. There are no restrictions on that.

$IPCHAINS -A input -l -j DENY

echo "Ipchains firewall is up `date`."

##-- eof ipchains.sh

 </PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2320"
>8.10.2. iptables II</A
></H4
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13;#!/bin/sh
#
# iptables.sh
#
# An example of a simple iptables configuration. This script 
# can enable 'masquerading' and will open user definable ports.
#
###################################################################
# Begin variable declarations and user configuration options ######
#
# Set the location of iptables (default).
IPTABLES=/sbin/iptables

# Local Interfaces
# This is the WAN interface that is our link to the outside world.
# For pppd and pppoe users.
# WAN_IFACE="ppp0"
WAN_IFACE="eth0"
#
# Local Area Network (LAN) interface.
#LAN_IFACE="eth0"
LAN_IFACE="eth1"

# Our private LAN address(es), for masquerading.
LAN_NET="192.168.1.0/24"

# For static IP, set it here! 
#WAN_IP="1.2.3.4"

# Set a list of public server port numbers here...not too many!
# These will be open to the world, so use caution. The example is
# sshd, and HTTP (www). Any services included here should be the
# latest version available from your vendor. Comment out to disable
# all Public services. Do not put any ports to be forwarded here,
# this only direct access.
#PUBLIC_PORTS="22 80 443"
PUBLIC_PORTS="22"

# If we want to do port forwarding, this is the host 
# that will be forwarded to.
#FORWARD_HOST="192.168.1.3"

# A list of ports that are to be forwarded. 
#FORWARD_PORTS="25  80"

# If you get your public IP address via DHCP, set this.
DHCP_SERVER=66.21.184.66

# If you need identd for a mail server, set this.
MAIL_SERVER=

# A list of unwelcome hosts or nets. These will be denied access 
# to everything, even our 'Public' services. Provide your own list.
#BLACKLIST="11.22.33.44 55.66.77.88"

# A list of "trusted" hosts and/or nets. These will have access to 
# ALL protocols, and ALL open ports. Be selective here.
#TRUSTED="1.2.3.4/8  5.6.7.8"

## end user configuration options #################################
###################################################################

# Any and all addresses from anywhere.
ANYWHERE="0/0"

# These modules may need to be loaded:
modprobe ip_conntrack_ftp
modprobe ip_nat_ftp

# Start building chains and rules #################################
#
# Let's start clean and flush all chains to an empty state.
$IPTABLES -F
$IPTABLES -X


# Set the default policies of the built-in chains. If no match for any 
# of the rules below, these will be the defaults that IPTABLES uses.
$IPTABLES -P FORWARD DROP
$IPTABLES -P OUTPUT ACCEPT
$IPTABLES -P INPUT DROP 

# Accept localhost/loopback traffic.
$IPTABLES -A INPUT -i lo -j ACCEPT

# Get our dynamic IP now from the Inet interface. WAN_IP will be the
# address we are protecting from outside addresses.
[ -z "$WAN_IP" ] &#38;&#38;\
  WAN_IP=`ifconfig $WAN_IFACE |grep inet |cut -d : -f 2 |cut -d \  -f 1`

# Bail out with error message if no IP available! Default policy is 
# already set, so all is not lost here.
[ -z "$WAN_IP" ] &#38;&#38; echo "$WAN_IFACE not configured, aborting." &#38;&#38; exit 1

WAN_MASK=`ifconfig $WAN_IFACE |grep Mask |cut -d : -f 4`
WAN_NET="$WAN_IP/$WAN_MASK"

## Reserved IPs:
#
# We should never see these private addresses coming in from outside 
# to our external interface.
$IPTABLES -A INPUT -i $WAN_IFACE -s 10.0.0.0/8      -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 172.16.0.0/12   -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 192.168.0.0/16  -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 127.0.0.0/8     -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 169.254.0.0/16  -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 224.0.0.0/4     -j DROP
$IPTABLES -A INPUT -i $WAN_IFACE -s 240.0.0.0/5     -j DROP
# Bogus routing
$IPTABLES -A INPUT -s 255.255.255.255 -d $ANYWHERE -j DROP

# Unclean
$IPTABLES -A INPUT -i $WAN_IFACE -m unclean -m limit \
  	--limit 15/minute -j LOG --log-prefix "Unclean: "
$IPTABLES -A INPUT -i $WAN_IFACE -m unclean -j DROP

## LAN access and masquerading
#
# Allow connections from our own LAN's private IP addresses via the LAN
# interface and set up forwarding for masqueraders if we have a LAN_NET
# defined above. 
if [ -n "$LAN_NET" ]; then 
 echo 1 &#62; /proc/sys/net/ipv4/ip_forward
 $IPTABLES -A INPUT -i $LAN_IFACE  -j ACCEPT
# $IPTABLES -A INPUT -i $LAN_IFACE -s $LAN_NET -d $LAN_NET  -j ACCEPT  
 $IPTABLES -t nat -A POSTROUTING -s $LAN_NET -o $WAN_IFACE -j MASQUERADE
fi

## Blacklist
#
# Get the blacklisted hosts/nets out of the way, before we start opening 
# up any services. These will have no access to us at all, and will 
# be logged.
for i in $BLACKLIST; do
 $IPTABLES -A INPUT -s $i -m limit --limit 5/minute \
   -j LOG --log-prefix "Blacklisted: "
 $IPTABLES -A INPUT -s $i -j DROP
done

## Trusted hosts/nets
#
# This is our trusted host list. These have access to everything.
for i in $TRUSTED; do
 $IPTABLES -A INPUT -s $i -j ACCEPT
done

# Port Forwarding
#
# Which ports get forwarded to which host. This is one to one 
# port mapping (ie 80 -&#62; 80) in this case.
[ -n "$FORWARD_HOST" ] &#38;&#38;\
 for i in $FORWARD_PORTS; do
   $IPTABLES -A FORWARD -p tcp -s $ANYWHERE -d $FORWARD_HOST \
     --dport $i -j ACCEPT
   $IPTABLES -t nat -A PREROUTING -p tcp -d $WAN_IP --dport $i \
     -j DNAT --to $FORWARD_HOST:$i
 done

## Open, but Restricted Access ports
#
# Allow DHCP server (their port 67) to client (to our port 68) UDP
# traffic from outside source.
[ -n "$DHCP_SERVER" ] &#38;&#38;\
 $IPTABLES -A INPUT -p udp -s $DHCP_SERVER --sport 67 \
   -d $ANYWHERE --dport 68 -j ACCEPT 

# Allow 'identd' (to our TCP port 113) from mail server only.
[ -n "$MAIL_SERVER" ] &#38;&#38;\
 $IPTABLES -A INPUT -p tcp -s $MAIL_SERVER  -d $WAN_IP --dport 113 -j ACCEPT 

# Open up Public server ports here (available to the world):
for i in $PUBLIC_PORTS; do
 $IPTABLES -A INPUT -p tcp -s $ANYWHERE -d $WAN_IP --dport $i -j ACCEPT 
done

# So I can check my home POP3 mailbox from work. Also, so I can ssh 
# in to home system. Only allow connections from my workplace's
# various IPs. Everything else is blocked.
$IPTABLES -A INPUT -p tcp -s 255.10.9.8/29 -d $WAN_IP --dport 110 -j ACCEPT 

## ICMP (ping)
#
# ICMP rules, allow the bare essential types of ICMP only. Ping
# request is blocked, ie we won't respond to someone else's pings,
# but can still ping out.
$IPTABLES -A INPUT  -p icmp  --icmp-type echo-reply \
   -s $ANYWHERE -d $WAN_IP -j ACCEPT
$IPTABLES -A INPUT  -p icmp  --icmp-type destination-unreachable \
   -s $ANYWHERE -d $WAN_IP -j ACCEPT
$IPTABLES -A INPUT  -p icmp  --icmp-type time-exceeded \
   -s $ANYWHERE -d $WAN_IP -j ACCEPT

# Identd Reject
#
# Special rule to reject (with rst) any identd/auth/port 113
# connections. This will speed up some services that ask for this,
# but don't require it. Be careful, some servers may require this
# one (IRC for instance).
#$IPTABLES -A INPUT -p tcp --dport 113 -j REJECT --reject-with tcp-reset

###################################################################
# Build a custom chain here, and set the default to DROP. All
# other traffic not allowed by the rules above, ultimately will
# wind up here, where it is blocked and logged, unless it passes
# our stateful rules for ESTABLISHED and RELATED connections. Let
# connection tracking do most of the worrying! We add the logging
# ability here with the '-j LOG' target. Outgoing traffic is
# allowed as that is the default policy for the 'output' chain.
# There are no restrictions placed on that in this script.

# New chain...
$IPTABLES -N DEFAULT
# Use the 'state' module to allow only certain connections based 
# on their 'state'.
$IPTABLES -A DEFAULT -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPTABLES -A DEFAULT -m state --state NEW -i ! $WAN_IFACE -j ACCEPT
# Enable logging for anything that gets this far.
$IPTABLES -A DEFAULT -j LOG -m limit --limit 30/minute --log-prefix "Dropping: "
# Now drop it, if it has gotten here.
$IPTABLES -A DEFAULT -j DROP

# This is the 'bottom line' so to speak. Everything winds up
# here, where we bounce it to our custom built 'DEFAULT' chain
# that we defined just above. This is for both the FORWARD and 
# INPUT chains. 

$IPTABLES -A FORWARD -j DEFAULT
$IPTABLES -A INPUT   -j DEFAULT

echo "Iptables firewall is up `date`."

##-- eof iptables.sh
 
 </PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2324"
>8.10.3. Summary</A
></H4
><P
> A quick run down of the some highlights...&#13;</P
><P
> We added some host based access control rules: <SPAN
CLASS="QUOTE"
>"blacklisted"</SPAN
>, 
 and <SPAN
CLASS="QUOTE"
>"trusted"</SPAN
>. We then showed several types of service 
 and port based access rules. For instance, we allowed some very restrictive
 access to bigcat's <SPAN
CLASS="APPLICATION"
>POP3</SPAN
> server so we could connect
 only from our workplace. We allowed a very narrow rule for the ISP's DHCP
 server. This rule only allows one port on one outside IP address to connect
 to only one of our ports and only via the UDP protocol. This is a very
 specific rule! We are being specific since there is no reason to allow any
 other traffic to these ports or from these addresses. Remember our goal is
 the minimum amount of traffic necessary for our particular situation. &#13;</P
><P
> So we made those few exceptions mentioned above, and all other services
 running on bigcat should be effectively blocked completely from outside
 connections. These are still happily running on bigcat, but are now safe and
 sound behind our packet filtering firewall. You probably have other services
 that fall in this category as well.&#13;</P
><P
> We also have a small, home network in the above example. We did not take any
 steps to block that traffic. So the LAN has access to all services running on
 bigcat. And it is further <SPAN
CLASS="QUOTE"
>"masqueraded"</SPAN
>, so that it has Internet 
 access (different HOWTO), by manipulating the <SPAN
CLASS="QUOTE"
>"forward"</SPAN
> chain. 
 And the LAN is still protected by our firewall since it sits behind the
 firewall. We also didn't impose any restrictive rules on the traffic leaving
 bigcat. In some situations, this might be a good idea. &#13;</P
><P
> Of course, this is just a hypothetical example. Your individual situation is
 surely different, and would require some changes and likely some additions to
 the rules above. For instance, if your ISP does not use DHCP (most do not),
 then that rule would make no sense. <SPAN
CLASS="APPLICATION"
>PPP</SPAN
> works
 differently and such rules are not needed. 
 </P
><P
> Please don't interpret that running any server as we did in this example is
 necessarily a <SPAN
CLASS="QUOTE"
>"safe"</SPAN
> thing to do. We shouldn't do it this way
 unless a) we really need to and b) we are running the current, safe version,
 and c) we are able to keep abreast of security related issues that might
 effect these services. Vigilance and caution are part of our responsibilities
 here too. 
 </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2339"
>8.10.4. iptables mini-me</A
></H4
><P
> Just to demonstrate how succinctly <SPAN
CLASS="APPLICATION"
>iptables</SPAN
> can be
 configured in a minimalist situation, the below is from the Netfilter team's
 <I
CLASS="CITETITLE"
>Rusty's Really Quick Guide To Packet Filtering</I
>:</P
><A
NAME="AEN2344"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
> <SPAN
CLASS="QUOTE"
>"Most people just have a single PPP connection to the Internet, and
 don't want anyone coming back into their network, or the firewall:"</SPAN
>
 </P
></BLOCKQUOTE
><P
> <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#13; ## Insert connection-tracking modules (not needed if built into kernel).
 insmod ip_conntrack
 insmod ip_conntrack_ftp

 ## Create chain which blocks new connections, except if coming from inside.
 iptables -N block
 iptables -A block -m state --state ESTABLISHED,RELATED -j ACCEPT
 iptables -A block -m state --state NEW -i ! ppp0 -j ACCEPT
 iptables -A block -j DROP

 ## Jump to that chain from INPUT and FORWARD chains.
 iptables -A INPUT -j block
 iptables -A FORWARD -j block

 </PRE
></FONT
></TD
></TR
></TABLE
></P
><P
> This simple script will allow all outbound connections that we initiate, i.e. 
 any <SPAN
CLASS="APPLICATION"
>NEW</SPAN
> connections (since the default policy of
 ACCEPT is not changed). Then any connections that are
 <SPAN
CLASS="QUOTE"
>"ESTABLISHED"</SPAN
> and <SPAN
CLASS="QUOTE"
>"RELATED"</SPAN
> to these are also
 allowed. And, any connections that are not incoming from our WAN side
 interface, <TT
CLASS="LITERAL"
>ppp0</TT
>, are also allowed. This would be lo or
 possibly a LAN interface like eth1. So we can do whatever we want, but no
 unwanted, incoming connection attempts are allowed from the Internet. None.&#13;</P
><P
> This script also demonstrates the creation of a custom chain, defined here
 as <SPAN
CLASS="QUOTE"
>"block"</SPAN
>, which is used both for the INPUT and FORWARD 
 chains.
 </P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>