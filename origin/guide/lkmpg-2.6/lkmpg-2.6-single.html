<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>The Linux Kernel Module Programming Guide</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>The Linux Kernel Module Programming Guide</A
></H1
><SPAN
CLASS="COLLAB"
><SPAN
CLASS="COLLABNAME"
>Peter Jay Salzman</SPAN
><BR></SPAN
><SPAN
CLASS="COLLAB"
><SPAN
CLASS="COLLABNAME"
>Michael Burian</SPAN
><BR></SPAN
><SPAN
CLASS="COLLAB"
><SPAN
CLASS="COLLABNAME"
>Ori Pomerantz</SPAN
><BR></SPAN
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2001 Peter Jay Salzman</P
><P
CLASS="PUBDATE"
>2007-05-18 ver 2.6.4<BR></P
><DIV
CLASS="LEGALNOTICE"
><P
></P
><A
NAME="AEN16"
></A
><P
>The Linux Kernel Module Programming Guide is a free book; you may reproduce and/or modify it under the terms of the
			Open Software License, version 1.1.  You can obtain a copy of this license at <A
HREF="http://opensource.org/licenses/osl.php"
TARGET="_top"
>http://opensource.org/licenses/osl.php</A
>.</P
><P
>This book is distributed in the hope it will be useful, but without any warranty, without even the implied warranty
			of merchantability or fitness for a particular purpose.</P
><P
>The author encourages wide distribution of this book for personal or commercial use, provided the above copyright
			notice remains intact and the method adheres to the provisions of the Open Software License.  In summary, you may copy and
			distribute this book free of charge or for a profit.  No explicit permission is required from the author for reproduction
			of this book in any medium, physical or electronic.</P
><P
>Derivative works and translations of this document must be placed under the Open Software License, and the original
			copyright notice must remain intact.  If you have contributed new material to this book, you must make the material and
			source code available for your revisions.  Please make revisions and updates available directly to the document
			maintainer, Peter Jay Salzman <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:p@dirac.org"
>p@dirac.org</A
>&#62;</CODE
>.  This will allow for the merging of updates and provide
			consistent revisions to the Linux community.</P
><P
>If you publish or distribute this book commercially, donations, royalties, and/or printed copies are greatly
			appreciated by the author and the <A
HREF="http://www.tldp.org"
TARGET="_top"
>Linux Documentation Project</A
> (LDP).
			Contributing in this way shows your support for free software and the LDP.  If you have questions or comments, please
			contact the address above.</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN25"
>Foreword</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#AEN27"
>Authorship</A
></DT
><DT
>2. <A
HREF="#AEN30"
>Versioning and Notes</A
></DT
><DT
>3. <A
HREF="#AEN35"
>Acknowledgements</A
></DT
></DL
></DD
><DT
>1. <A
HREF="#AEN38"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN40"
>What Is A Kernel Module?</A
></DT
><DT
>1.2. <A
HREF="#AEN44"
>How Do Modules Get Into The Kernel?</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#AEN119"
>Hello World</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN121"
>Hello, World (part 1): The Simplest Module</A
></DT
><DT
>2.2. <A
HREF="#AEN181"
>Compiling Kernel Modules</A
></DT
><DT
>2.3. <A
HREF="#HELLO2"
>Hello World (part 2)</A
></DT
><DT
>2.4. <A
HREF="#AEN245"
>Hello World (part 3): The <TT
CLASS="LITERAL"
>__init</TT
> and <TT
CLASS="LITERAL"
>__exit</TT
> Macros</A
></DT
><DT
>2.5. <A
HREF="#AEN279"
>Hello World (part 4): Licensing and Module Documentation</A
></DT
><DT
>2.6. <A
HREF="#AEN323"
>Passing Command Line Arguments to a Module</A
></DT
><DT
>2.7. <A
HREF="#AEN351"
>Modules Spanning Multiple Files</A
></DT
><DT
>2.8. <A
HREF="#AEN380"
>Building modules for a precompiled kernel</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN425"
>Preliminaries</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN427"
>Modules vs Programs</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#AEN567"
>Character Device Files</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN569"
>Character Device Drivers</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#AEN708"
>The /proc File System</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN710"
>The /proc File System</A
></DT
><DT
>5.2. <A
HREF="#AEN769"
>Read and Write a /proc File</A
></DT
><DT
>5.3. <A
HREF="#AEN810"
>Manage /proc file with standard filesystem</A
></DT
><DT
>5.4. <A
HREF="#AEN861"
>Manage /proc file with seq_file</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#AEN885"
>Using /proc For Input</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN887"
>TODO: Write a chapter about sysfs</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#AEN890"
>Talking To Device Files</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#AEN976"
>System Calls</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#AEN978"
>System Calls</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#AEN1050"
>Blocking Processes</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#AEN1052"
>Blocking Processes</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#AEN1159"
>Replacing Printks</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#AEN1161"
>Replacing <CODE
CLASS="FUNCTION"
>printk</CODE
></A
></DT
><DT
>10.2. <A
HREF="#AEN1194"
>Flashing keyboard LEDs</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#AEN1209"
>Scheduling Tasks</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#AEN1211"
>Scheduling Tasks</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#INTERRUPTHANDLERS"
>Interrupt Handlers</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#AEN1256"
>Interrupt Handlers</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#AEN1324"
>Symmetric Multi Processing</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#AEN1326"
>Symmetrical Multi-Processing</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#AEN1350"
>Common Pitfalls</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN1352"
>Common Pitfalls</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#AEN1387"
>Changes: 2.0 To 2.2</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#AEN1389"
>Changes between 2.4 and 2.6</A
></DT
></DL
></DD
><DT
>B. <A
HREF="#AEN1403"
>Where To Go From Here</A
></DT
><DD
><DL
><DT
>B.1. <A
HREF="#AEN1405"
>Where From Here?</A
></DT
></DL
></DD
><DT
><A
HREF="#DOC-INDEX"
>Index</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>5-1. <A
HREF="#AEN868"
>How seq_file works</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Examples</B
></DT
><DT
>2-1. <A
HREF="#AEN128"
>hello-1.c</A
></DT
><DT
>2-2. <A
HREF="#AEN189"
>Makefile for a basic kernel module</A
></DT
><DT
>2-3. <A
HREF="#AEN232"
>hello-2.c</A
></DT
><DT
>2-4. <A
HREF="#AEN237"
>Makefile for both our modules</A
></DT
><DT
>2-5. <A
HREF="#AEN275"
>hello-3.c</A
></DT
><DT
>2-6. <A
HREF="#AEN319"
>hello-4.c</A
></DT
><DT
>2-7. <A
HREF="#AEN345"
>hello-5.c</A
></DT
><DT
>2-8. <A
HREF="#AEN361"
>start.c</A
></DT
><DT
>2-9. <A
HREF="#AEN369"
>stop.c</A
></DT
><DT
>2-10. <A
HREF="#AEN374"
>Makefile</A
></DT
><DT
>4-1. <A
HREF="#AEN687"
>chardev.c</A
></DT
><DT
>5-1. <A
HREF="#AEN765"
>procfs1.c</A
></DT
><DT
>5-2. <A
HREF="#AEN806"
>procfs2.c</A
></DT
><DT
>5-3. <A
HREF="#AEN853"
>procfs3.c</A
></DT
><DT
>5-4. <A
HREF="#AEN872"
>procfs4.c</A
></DT
><DT
>7-1. <A
HREF="#AEN951"
>chardev.c</A
></DT
><DT
>7-2. <A
HREF="#AEN959"
>chardev.h</A
></DT
><DT
>7-3. <A
HREF="#AEN972"
>ioctl.c</A
></DT
><DT
>8-1. <A
HREF="#AEN1046"
>syscall.c</A
></DT
><DT
>9-1. <A
HREF="#AEN1151"
>sleep.c</A
></DT
><DT
>9-2. <A
HREF="#AEN1155"
>cat_noblock.c</A
></DT
><DT
>10-1. <A
HREF="#AEN1190"
>print_string.c</A
></DT
><DT
>10-2. <A
HREF="#AEN1201"
>kbleds.c</A
></DT
><DT
>11-1. <A
HREF="#AEN1250"
>sched.c</A
></DT
><DT
>12-1. <A
HREF="#AEN1320"
>intrpt.c</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="AEN25"
></A
>Foreword</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN27"
>1. Authorship</A
></H2
><P
>The Linux Kernel Module Programming Guide was originally written for the 2.2 kernels by Ori Pomerantz.  Eventually, Ori
	no longer had time to maintain the document.  After all, the Linux kernel is a fast moving target.  Peter Jay Salzman took
	over maintenance and updated it for the 2.4 kernels.  Eventually, Peter no longer had time to follow developments with the 2.6
	kernel, so Michael Burian became a co-maintainer to update the document for the 2.6 kernels.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN30"
>2. Versioning and Notes</A
></H2
><P
>The Linux kernel is a moving target.  There has always been a question whether the LKMPG should remove deprecated
	information or keep it around for historical sake.  Michael Burian and I decided to create a new branch of the LKMPG for each
	new stable kernel version.  So version LKMPG 2.4.x will address Linux kernel 2.4 and LKMPG 2.6.x will address Linux kernel
	2.6.  No attempt will be made to archive historical information; a person wishing this information should read the
	appropriately versioned LKMPG.</P
><P
>The source code and discussions should apply to most architectures, but I can't promise anything.  One exception is
	<A
HREF="#INTERRUPTHANDLERS"
>Chapter 12</A
>, Interrupt Handlers, which should not work on any architecture except for x86.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN35"
>3. Acknowledgements</A
></H2
><P
>The following people have contributed corrections or good suggestions: Ignacio Martin, David Porter, Daniele Paolo
	Scarpazza, Dimo Velev, Francois Audeon and Horst Schirmeier. </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN38"
></A
>Chapter 1. Introduction</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN40"
>1.1. What Is A Kernel Module?</A
></H2
><P
>So, you want to write a kernel module.  You know C, you've written a few normal programs to run as processes, and now
	you want to get to where the real action is, to where a single wild pointer can wipe out your file system and a core dump
	means a reboot.</P
><P
>What exactly is a kernel module?  Modules are pieces of code that can be loaded and unloaded into the kernel upon
	demand.  They extend the functionality of the kernel without the need to reboot the system.  For example, one type of module
	is the device driver, which allows the kernel to access hardware connected to the system.  Without modules, we would have to
	build monolithic kernels and add new functionality directly into the kernel image.  Besides having larger kernels, this has
	the disadvantage of requiring us to rebuild and reboot the kernel every time we want new functionality.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN44"
>1.2. How Do Modules Get Into The Kernel?</A
></H2
><P
>You can see what modules are already loaded into the kernel by running <B
CLASS="COMMAND"
>lsmod</B
>, which gets its
	information by reading the file <TT
CLASS="FILENAME"
>/proc/modules</TT
>.</P
><P
>How do these modules find their way into the kernel?  When the kernel needs a feature that is not resident in the
	kernel, the kernel module daemon kmod<A
NAME="AEN62"
HREF="#FTN.AEN62"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
> execs modprobe to load the module in.  modprobe is passed a string in one of two forms:</P
><P
></P
><UL
><LI
><P
>A module name like <TT
CLASS="FILENAME"
>softdog</TT
> or <TT
CLASS="FILENAME"
>ppp</TT
>.</P
></LI
><LI
><P
>A more generic identifier like <CODE
CLASS="VARNAME"
>char-major-10-30</CODE
>.</P
></LI
></UL
><P
>If modprobe is handed a generic identifier, it first looks for that string in the file
	<TT
CLASS="FILENAME"
>/etc/modprobe.conf</TT
>.<A
NAME="AEN74"
HREF="#FTN.AEN74"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>
	If it finds an alias line like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>alias char-major-10-30 softdog
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>it knows that the generic identifier refers to the module <TT
CLASS="FILENAME"
>softdog.ko</TT
>.</P
><P
>Next, modprobe looks through the file <TT
CLASS="FILENAME"
>/lib/modules/version/modules.dep</TT
>, to see if other modules
	must be loaded before the requested module may be loaded.  This file is created by <B
CLASS="COMMAND"
>depmod -a</B
> and 
	contains module dependencies. For example, <TT
CLASS="FILENAME"
>msdos.ko</TT
> requires the <TT
CLASS="FILENAME"
>fat.ko</TT
> module 
	to be already loaded into the kernel. The requested module has a dependency on another module if the other module defines 
	symbols	(variables or functions) that the requested module uses.</P
><P
>Lastly, modprobe uses insmod to first load any prerequisite modules into the kernel, and then the requested module.
	modprobe directs insmod to <TT
CLASS="FILENAME"
>/lib/modules/version/</TT
><A
NAME="AEN87"
HREF="#FTN.AEN87"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>, the standard directory for modules.  insmod is 
	intended to be fairly dumb about the location of modules, whereas modprobe is aware of the default location of modules,
	knows how to figure out the dependencies and load the modules in the right order.
	So for example,	if you wanted to load the msdos module, you'd have to either run:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>insmod /lib/modules/2.6.11/kernel/fs/fat/fat.ko
insmod /lib/modules/2.6.11/kernel/fs/msdos/msdos.ko
	</PRE
></FONT
></TD
></TR
></TABLE
><P
> or: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>modprobe msdos
	</PRE
></FONT
></TD
></TR
></TABLE
><P
> What we've seen here is: <B
CLASS="COMMAND"
> insmod </B
> requires you to pass it the full pathname and to insert the modules
	in the right order, while <B
CLASS="COMMAND"
> modprobe </B
> just takes the name, without any extension, and figures out
	all it needs to know by parsing <TT
CLASS="FILENAME"
>/lib/modules/version/modules.dep</TT
>.</P
><P
>Linux distros provide modprobe, insmod and depmod as a package called module-init-tools. In previous versions
	that package was called modutils. Some distros also set up some wrappers that allow both packages to be installed
	in parallel and do the right thing in order to be able to deal with 2.4 and 2.6 kernels. Users should not need to care
	about the details, as long as they're running recent versions of those tools.</P
><P
>Now you know how modules get into the kernel.  There's a bit more to the story if you want to write your own modules
	which depend on other modules (we calling this `stacking modules').  But this will have to wait for a future chapter. 
	We have	a lot to cover before addressing this relatively high-level issue.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN99"
>1.2.1. Before We Begin</A
></H3
><P
>Before we delve into code, there are a few issues we need to cover.  Everyone's system is different and everyone has
			their own groove.  Getting your first "hello world" program to compile and load correctly can sometimes be a trick.  Rest
			assured, after you get over the initial hurdle of doing it for the first time, it will be smooth sailing
			thereafter.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN102"
>1.2.1.1. Modversioning</A
></H4
><P
>A module compiled for one kernel won't load if you boot a different kernel unless you enable
					<TT
CLASS="LITERAL"
>CONFIG_MODVERSIONS</TT
> in the kernel.  We won't go into module versioning until later in this guide.
					Until we cover modversions, the examples in the guide may not work if you're running a kernel with modversioning
					turned on.  However, most stock Linux distro kernels come with it turned on.  If you're having trouble loading the
					modules because of versioning errors, compile a kernel with modversioning turned off.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="USINGX"
>1.2.1.2. Using X</A
></H4
><P
>It is highly recommended that you type in, compile and load all the examples this guide discusses.  It's also
					highly recommended you do this from a console.  You should not be working on this stuff in X.</P
><P
>Modules can't print to the screen like <CODE
CLASS="FUNCTION"
>printf()</CODE
> can, but they can log information and
					warnings, which ends up being printed on your screen, but only on a console.  If you insmod a module from an xterm,
					the information and warnings will be logged, but only to your log files.  You won't see it unless you look through
					your log files.  To have immediate access to this information, do all your work from the console.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN111"
>1.2.1.3. Compiling Issues and Kernel Version</A
></H4
><P
>Very often, Linux distros will distribute kernel source that has been patched in various non-standard ways,
					which may cause trouble.</P
><P
>A more common problem is that some Linux distros distribute incomplete kernel headers.  You'll need to compile
					your code using various header files from the Linux kernel.  Murphy's Law states that the headers that are missing are
					exactly the ones that you'll need for your module work.</P
><P
>To avoid these two problems, I highly recommend that you download, compile and boot into a fresh, stock Linux
					kernel which can be downloaded from any of the Linux kernel mirror sites.  See the Linux Kernel HOWTO for more
					details.</P
><P
>Ironically, this can also cause a problem.  By default, gcc on your system may look for the kernel headers in
					their default location rather than where you installed the new copy of the kernel (usually in <TT
CLASS="FILENAME"
>/usr/src/</TT
>.  This can be fixed by using gcc's <TT
CLASS="LITERAL"
>-I</TT
> switch.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN119"
></A
>Chapter 2. Hello World</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN121"
>2.1. Hello, World (part 1): The Simplest Module</A
></H2
><P
>When the first caveman programmer chiseled the first program on the walls of the first cave computer, it was a program
	to paint the string `Hello, world' in Antelope pictures.  Roman programming textbooks began with the `Salut, Mundi' program.
	I don't know what happens to people who break with this tradition, but I think it's safer not to find out.  We'll start with a
	series of hello world programs that demonstrate the different aspects of the basics of writing a kernel module.</P
><P
>Here's the simplest module possible.  Don't compile it yet; we'll cover module compilation in the next section.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN128"
></A
><P
><B
>Example 2-1. hello-1.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>Kernel modules must have at least two functions: a "start" (initialization) function called
	<CODE
CLASS="FUNCTION"
>init_module()</CODE
> which is called when the module is insmoded into the kernel, and an "end" (cleanup)
	function called <CODE
CLASS="FUNCTION"
>cleanup_module()</CODE
> which is called just before it is rmmoded.  Actually, things have
	changed starting with kernel 2.3.13.  You can now use whatever name you like for the start and end functions of a module, and
	you'll learn how to do this in <A
HREF="#HELLO2"
>Section 2.3</A
>.  In fact, the new method is the preferred method.  However, many
	people still use <CODE
CLASS="FUNCTION"
>init_module()</CODE
> and <CODE
CLASS="FUNCTION"
>cleanup_module()</CODE
> for their start and end
	functions.</P
><P
>Typically, <CODE
CLASS="FUNCTION"
>init_module()</CODE
> either registers a handler for something with the kernel, or it replaces
	one of the kernel functions with its own code (usually code to do something and then call the original function).  The
	<CODE
CLASS="FUNCTION"
>cleanup_module()</CODE
> function is supposed to undo whatever <CODE
CLASS="FUNCTION"
>init_module()</CODE
> did, so the
	module can be unloaded safely.</P
><P
>Lastly, every kernel module needs to include <TT
CLASS="FILENAME"
>linux/module.h</TT
>.  We needed to
	include <TT
CLASS="FILENAME"
>linux/kernel.h</TT
> only for the macro expansion for the
	<CODE
CLASS="FUNCTION"
>printk()</CODE
> log level, <CODE
CLASS="VARNAME"
>KERN_ALERT</CODE
>, which you'll learn about in <A
HREF="#INTRODUCINGPRINTK"
>Section 2.1.1</A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INTRODUCINGPRINTK"
>2.1.1. Introducing <CODE
CLASS="FUNCTION"
>printk()</CODE
></A
></H3
><P
>Despite what you might think, <CODE
CLASS="FUNCTION"
>printk()</CODE
> was not meant to communicate information to the user,
			even though we used it for exactly this purpose in <SPAN
CLASS="APPLICATION"
>hello-1</SPAN
>!  It happens to be a logging
			mechanism for the kernel, and is used to log information or give warnings.  Therefore, each <CODE
CLASS="FUNCTION"
>printk()</CODE
>
			statement comes with a priority, which is the <CODE
CLASS="VARNAME"
>&#60;1&#62;</CODE
> and <CODE
CLASS="VARNAME"
>KERN_ALERT</CODE
> you see.
			There are 8 priorities and the kernel has macros for them, so you don't have to use cryptic numbers, and you can view them
			(and their meanings) in <TT
CLASS="FILENAME"
>linux/kernel.h</TT
>.  If you don't specify a priority level, the
			default priority, <TT
CLASS="LITERAL"
>DEFAULT_MESSAGE_LOGLEVEL</TT
>, will be used.</P
><P
>Take time to read through the priority macros.  The header file also describes what each priority means.  In
			practise, don't use number, like <TT
CLASS="LITERAL"
>&#60;4&#62;</TT
>.  Always use the macro, like
			<TT
CLASS="LITERAL"
>KERN_WARNING</TT
>.</P
><P
>If the priority is less than <CODE
CLASS="VARNAME"
>int console_loglevel</CODE
>, the message is printed on your current
			terminal.  If both <B
CLASS="COMMAND"
>syslogd</B
> and <SPAN
CLASS="APPLICATION"
>klogd</SPAN
> are running, then the message will also
			get appended to <TT
CLASS="FILENAME"
>/var/log/messages</TT
>, whether it got printed to the console or not.  We use a high
			priority, like <TT
CLASS="LITERAL"
>KERN_ALERT</TT
>, to make sure the <CODE
CLASS="FUNCTION"
>printk()</CODE
> messages get printed to your
			console rather than just logged to your logfile.  When you write real modules, you'll want to use priorities that are
			meaningful for the situation at hand.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN181"
>2.2. Compiling Kernel Modules</A
></H2
><P
>Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us
	to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant
	settings accumulated in	sublevel Makefiles and made them large and rather difficult to maintain.

	Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules 
	is now fully integrated into the standard kernel build mechanism.  To learn more on how to compile modules which are not
	part of the official kernel (such as all the examples you'll find in this guide), see file 
	<TT
CLASS="FILENAME"
>linux/Documentation/kbuild/modules.txt</TT
>.</P
><P
>So, let's look at a simple Makefile for compiling a module named <TT
CLASS="FILENAME"
>hello-1.c</TT
>:</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN189"
></A
><P
><B
>Example 2-2. Makefile for a basic kernel module</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>From a technical point of view just the first line is really necessary, 
	the "all" and "clean" targets were added for pure convenience.</P
><P
>Now you can compile the module by issuing the command <B
CLASS="COMMAND"
> make </B
>.
	You should obtain an output which resembles the following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>hostname:~/lkmpg-examples/02-HelloWorld# make
make -C /lib/modules/2.6.11/build M=/root/lkmpg-examples/02-HelloWorld modules
make[1]: Entering directory `/usr/src/linux-2.6.11'
  CC [M]  /root/lkmpg-examples/02-HelloWorld/hello-1.o
 Building modules, stage 2.
  MODPOST
  CC      /root/lkmpg-examples/02-HelloWorld/hello-1.mod.o
  LD [M]  /root/lkmpg-examples/02-HelloWorld/hello-1.ko
make[1]: Leaving directory `/usr/src/linux-2.6.11'
hostname:~/lkmpg-examples/02-HelloWorld#
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that kernel 2.6 introduces a new file naming convention: kernel modules now have a <TT
CLASS="FILENAME"
>.ko</TT
>
	extension (in place of the old <TT
CLASS="FILENAME"
>.o</TT
> extension) which easily distinguishes them from conventional object 
	files. The reason for this is that they contain an additional .modinfo section that where additional information about the
	module is kept. We'll soon see what this information is good for. </P
><P
> Use <B
CLASS="COMMAND"
> modinfo hello-*.ko </B
> to see what kind of information it is. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>hostname:~/lkmpg-examples/02-HelloWorld# modinfo hello-1.ko
filename:       hello-1.ko
vermagic:       2.6.11 preempt PENTIUMII 4KSTACKS gcc-3.3
depends:</PRE
></FONT
></TD
></TR
></TABLE
><P
> Nothing spectacular, so far. That changes once we're using modinfo on one of our the later examples, 
	<TT
CLASS="FILENAME"
> hello-5.ko </TT
>. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>hostname:~/lkmpg-examples/02-HelloWorld# modinfo hello-5.ko
filename:       hello-5.ko
license:        GPL
author:         Peter Jay Salzman
vermagic:       2.6.11 preempt PENTIUMII 4KSTACKS gcc-3.3
depends:
parm:           myintArray:An array of integers (array of int)
parm:           mystring:A character string (charp)
parm:           mylong:A long integer (long)
parm:           myint:An integer (int)
parm:           myshort:A short integer (short)
hostname:~/lkmpg-examples/02-HelloWorld# </PRE
></FONT
></TD
></TR
></TABLE
><P
> Lot's of useful information to see here. An author string for bugreports,
	license information, even a short description of the parameters it accepts. </P
><P
> Additional details about Makefiles for kernel modules are available in 
	<TT
CLASS="FILENAME"
>linux/Documentation/kbuild/makefiles.txt</TT
>.
	Be sure to read this and the related files before starting to hack Makefiles.
	It'll probably save you lots of work. </P
><P
>Now it is time to insert your freshly-compiled module it into the kernel with <B
CLASS="COMMAND"
>insmod ./hello-1.ko</B
> 
	(ignore anything you see about tainted kernels; we'll cover that shortly).</P
><P
>	All modules loaded into the kernel are listed in <TT
CLASS="FILENAME"
>/proc/modules</TT
>.  
	Go ahead and cat that file to see that your module is really a part of the kernel.  
	Congratulations, you are now the author of Linux kernel code!  When the novelty wears off,
	remove your module from the kernel by using <B
CLASS="COMMAND"
>rmmod hello-1</B
>.  Take a look at
	<TT
CLASS="FILENAME"
>/var/log/messages</TT
> just to see that it got logged to your system logfile.</P
><P
>Here's another exercise for the reader.  See that comment above the return statement in
	<CODE
CLASS="FUNCTION"
>init_module()</CODE
>?  Change the return value to something negative, recompile and load the module again. 
	What happens?</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HELLO2"
>2.3. Hello World (part 2)</A
></H2
><P
>As of Linux 2.4, you can rename the init and cleanup functions of your modules; they no longer have to be called
	<CODE
CLASS="FUNCTION"
>init_module()</CODE
> and <CODE
CLASS="FUNCTION"
>cleanup_module()</CODE
> respectively.  This is done with the
	<CODE
CLASS="FUNCTION"
>module_init()</CODE
> and <CODE
CLASS="FUNCTION"
>module_exit()</CODE
> macros.  These macros are defined in <TT
CLASS="FILENAME"
>linux/init.h</TT
>.  The only caveat is that your init and cleanup functions must be defined before 
	calling	the macros, otherwise you'll get compilation errors. Here's an example of this technique:</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN232"
></A
><P
><B
>Example 2-3. hello-2.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>So now we have two real kernel modules under our belt. Adding another module is as simple as this: </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN237"
></A
><P
><B
>Example 2-4. Makefile for both our modules</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>Now have a look at <TT
CLASS="FILENAME"
>linux/drivers/char/Makefile</TT
> for a real world example. As you can see, some things
	get hardwired into the kernel (obj-y) but where are all those obj-m gone?  Those familiar with shell scripts will easily be
	able to spot them. For those not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on 
	whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables
	that you have set in the <TT
CLASS="FILENAME"
>linux/.config</TT
> file, the last time when you said <B
CLASS="COMMAND"
>make menuconfig</B
>
	or something like that.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN245"
>2.4. Hello World (part 3): The <TT
CLASS="LITERAL"
>__init</TT
> and <TT
CLASS="LITERAL"
>__exit</TT
> Macros</A
></H2
><P
>This demonstrates a feature of kernel 2.2 and later.  Notice the change in the definitions of the init and cleanup
	functions.  The <CODE
CLASS="FUNCTION"
>__init</CODE
> macro causes the init function to be discarded and its memory freed once the init
	function finishes for built-in drivers, but not loadable modules.  If you think about when the init function is invoked, this
	makes perfect sense.</P
><P
>There is also an <CODE
CLASS="FUNCTION"
>__initdata</CODE
> which works similarly to <CODE
CLASS="FUNCTION"
>__init</CODE
> but for init
	variables rather than functions.</P
><P
>The <CODE
CLASS="FUNCTION"
>__exit</CODE
> macro causes the omission of the function when the module is built into the kernel, and
	like <CODE
CLASS="FUNCTION"
>__exit</CODE
>, has no effect for loadable modules.  Again, if you consider when the cleanup function runs,
	this makes complete sense; built-in drivers don't need a cleanup function, while loadable modules do.</P
><P
>These macros are defined in <TT
CLASS="FILENAME"
>linux/init.h</TT
> and serve to free up kernel memory.
	When you boot your kernel and see something like <TT
CLASS="LITERAL"
>Freeing unused kernel memory: 236k freed</TT
>, this is
	precisely what the kernel is freeing.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN275"
></A
><P
><B
>Example 2-5. hello-3.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN279"
>2.5. Hello World (part 4): Licensing and Module Documentation</A
></H2
><P
>If you're running kernel 2.4 or later, you might have noticed something like this when you loaded	proprietary modules:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># insmod xxxxxx.o
Warning: loading xxxxxx.ko will taint the kernel: no license
  See http://www.tux.org/lkml/#export-tainted for information about tainted modules
Module xxxxxx loaded, with warnings
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>In kernel 2.4 and later, a mechanism was devised to identify code licensed under the GPL (and friends) so people can
	be warned that the code is non open-source. This is accomplished by the <CODE
CLASS="FUNCTION"
>MODULE_LICENSE()</CODE
> macro which 
	is demonstrated in the next piece of code. By setting the license to GPL, you can keep the warning from being printed. 
	This license mechanism is defined and documented in <TT
CLASS="FILENAME"
>linux/module.h</TT
>:

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/*
 * The following license idents are currently accepted as indicating free
 * software modules
 *
 *	"GPL"				[GNU Public License v2 or later]
 *	"GPL v2"			[GNU Public License v2]
 *	"GPL and additional rights"	[GNU Public License v2 rights and more]
 *	"Dual BSD/GPL"			[GNU Public License v2
 *					 or BSD license choice]
 *	"Dual MIT/GPL"			[GNU Public License v2
 *					 or MIT license choice]
 *	"Dual MPL/GPL"			[GNU Public License v2
 *					 or Mozilla license choice]
 *
 * The following other idents are available
 *
 *	"Proprietary"			[Non free products]
 *
 * There are dual licensed components, but when running with Linux it is the
 * GPL that is relevant so this is a non issue. Similarly LGPL linked with GPL
 * is a GPL combined work.
 *
 * This exists for several reasons
 * 1.	So modinfo can show license info for users wanting to vet their setup 
 *	is free
 * 2.	So the community can ignore bug reports including proprietary modules
 * 3.	So vendors can do likewise based on their own policies
 */</PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>Similarly, <CODE
CLASS="FUNCTION"
>MODULE_DESCRIPTION()</CODE
> is used to describe what the module does,
	<CODE
CLASS="FUNCTION"
>MODULE_AUTHOR()</CODE
> declares the module's author, and  <CODE
CLASS="FUNCTION"
>MODULE_SUPPORTED_DEVICE()</CODE
>
	declares what types of devices the module supports.</P
><P
>These macros are all defined in <TT
CLASS="FILENAME"
>linux/module.h</TT
> and aren't used by the kernel
	itself.  They're simply for documentation and can be viewed by a tool like <SPAN
CLASS="APPLICATION"
>objdump</SPAN
>.
	As an exercise to the reader, try and search fo these macros in <TT
CLASS="FILENAME"
>linux/drivers</TT
> 
	to see how module authors use these macros to document their modules.</P
><P
> I'd recommend to use something like <B
CLASS="COMMAND"
> grep -inr MODULE_AUTHOR * </B
> in 
	<TT
CLASS="FILENAME"
> /usr/src/linux-2.6.x/ </TT
>. People unfamiliar with command line tools will probably like
	some web base solution, search for sites that offer kernel trees that got indexed with LXR. (or setup it up on your 
	local machine).</P
><P
> Users of traditional Unix editors, like <B
CLASS="COMMAND"
> emacs </B
> or <B
CLASS="COMMAND"
> vi </B
> will also find 
	tag files useful. They can be generated by <B
CLASS="COMMAND"
> make tags </B
> or <B
CLASS="COMMAND"
> make TAGS </B
> in 
	<TT
CLASS="FILENAME"
> /usr/src/linux-2.6.x/ </TT
>. Once you've got such a tagfile in your kerneltree you can put the cursor
	on some function call and use some key combination to directly jump to the definition function. </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN319"
></A
><P
><B
>Example 2-6. hello-4.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN323"
>2.6. Passing Command Line Arguments to a Module</A
></H2
><P
>Modules can take command line arguments, but not with the <CODE
CLASS="VARNAME"
>argc</CODE
>/<CODE
CLASS="VARNAME"
>argv</CODE
> you might be
	used to.</P
><P
>To allow arguments to be passed to your module, declare the variables that will take the values of the command line
	arguments as global and then use the <CODE
CLASS="FUNCTION"
>module_param()</CODE
> macro, (defined in <TT
CLASS="FILENAME"
>linux/moduleparam.h</TT
>) to set the mechanism up.  At runtime, insmod will fill the variables with any
	command line arguments that are given, like <B
CLASS="COMMAND"
>./insmod mymodule.ko myvariable=5</B
>.  The variable 
	declarations and macros should be placed at the beginning of the module for clarity.  The example code should clear up my 
	admittedly lousy explanation.</P
><P
>The <CODE
CLASS="FUNCTION"
>module_param()</CODE
> macro takes 3 arguments: the name of the variable, its type and
	permissions for the corresponding file in sysfs. Integer types can be signed as usual or unsigned. 
	If you'd like to use arrays of integers or strings see <CODE
CLASS="FUNCTION"
>module_param_array()</CODE
> and
	<CODE
CLASS="FUNCTION"
>module_param_string()</CODE
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int myint = 3;
module_param(myint, int, 0);
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>Arrays are supported too, but things are a bit different now than they were in the 2.4. days. To keep track of the
	number of parameters you need to pass a pointer to a count variable as third parameter. At your option, you could also
	ignore the count and pass NULL instead. We show both possibilities here:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int myintarray[2];
module_param_array(myintarray, int, NULL, 0); /* not interested in count */

int myshortarray[4];
int count;
module_parm_array(myshortarray, short, &#38;count, 0); /* put count into "count" variable */
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>A good use for this is to have the module variable's default values set, like an port or IO address.  If the variables
	contain the default values, then perform autodetection (explained elsewhere).  Otherwise, keep the current value.  This will
	be made clear later on.</P
><P
>Lastly, there's a macro function, <CODE
CLASS="FUNCTION"
>MODULE_PARM_DESC()</CODE
>, that is used to document arguments that the
	module can take.  It takes two parameters: a variable name and a free form string describing that variable.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN345"
></A
><P
><B
>Example 2-7. hello-5.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>I would recommend playing around with this code:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>satan# insmod hello-5.ko mystring="bebop" mybyte=255 myintArray=-1
mybyte is an 8 bit integer: 255
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: bebop
myintArray is -1 and 420

satan# rmmod hello-5
Goodbye, world 5

satan# insmod hello-5.ko mystring="supercalifragilisticexpialidocious" \
&#62; mybyte=256 myintArray=-1,-1
mybyte is an 8 bit integer: 0
myshort is a short integer: 1
myint is an integer: 20
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious
myintArray is -1 and -1

satan# rmmod hello-5
Goodbye, world 5

satan# insmod hello-5.ko mylong=hello
hello-5.o: invalid argument syntax for mylong: 'h'</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN351"
>2.7. Modules Spanning Multiple Files</A
></H2
><P
>Sometimes it makes sense to divide a kernel module between several source files.</P
><P
>Here's an example of such a kernel module.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN361"
></A
><P
><B
>Example 2-8. start.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>The next file:</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN369"
></A
><P
><B
>Example 2-9. stop.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>And finally, the makefile:</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN374"
></A
><P
><B
>Example 2-10. Makefile</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>This is the complete makefile for all the examples we've seen so far. The first five lines are nothing special,
	but for the last example we'll need two lines. First we invent an object name for our combined module, second we tell
	<B
CLASS="COMMAND"
> make </B
> what object files are part of that module. </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN380"
>2.8. Building modules for a precompiled kernel</A
></H2
><P
>	Obviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as
	forced module unloading (<TT
CLASS="LITERAL"
>MODULE_FORCE_UNLOAD</TT
>): when this option is enabled, you can force the kernel to unload a module even  
	when it believes it is unsafe, via a <B
CLASS="COMMAND"
>rmmod -f module</B
> command. This option can save you a lot of time and a number of reboots 
	during the development of a module.
	</P
><P
>	Nevertheless, there is a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped
	with common Linux distributions, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a 
	module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot.
	If you can't think of a case that will force you to use modules for a precompiled kernel you
	might want to skip this and treat the rest of this chapter as a big footnote.
	</P
><P
>	Now, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel,
	in most cases you would obtain an error as follows:
	</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>insmod: error inserting 'poet_atkm.ko': -1 Invalid module format
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>	Less cryptical information are logged to <TT
CLASS="FILENAME"
>/var/log/messages</TT
>:
	</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jun  4 22:07:54 localhost kernel: poet_atkm: version magic '2.6.5-1.358custom 686 
REGPARM 4KSTACKS gcc-3.3' should be '2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3'
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>	In other words, your kernel refuses to accept your module because version strings (more precisely, version magics) 
	do not match. Incidentally, version magics are stored in the module object in the form of a static string, starting with 
	<TT
CLASS="LITERAL"
>vermagic:</TT
>. 
	Version data are inserted in your module when it is linked against the <TT
CLASS="FILENAME"
>init/vermagic.o</TT
> file.
	To inspect version magics and other strings stored in a given module, issue the 
	<B
CLASS="COMMAND"
>modinfo module.ko</B
> command:
	</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>[root@pcsenonsrv 02-HelloWorld]# modinfo hello-4.ko 
license:        GPL
author:         Peter Jay Salzman &#60;p@dirac.org&#62;
description:    A sample driver
vermagic:       2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3
depends:        
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>	To overcome this problem we could resort to the <B
CLASS="COMMAND"
>--force-vermagic</B
> option, but this solution is potentially unsafe, 
	and unquestionably inacceptable in production modules.
	Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built.
	How to do this, is the subject of the remainder of this chapter.</P
><P
>	First of all, make sure that a kernel source tree is available, having exactly the same version as 
	your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. 
	Usually, this is available in your current <TT
CLASS="FILENAME"
>/boot</TT
> directory, under a name like <TT
CLASS="FILENAME"
>config-2.6.x</TT
>. 
	You may just want to copy it to your kernel source tree:
	<B
CLASS="COMMAND"
> cp /boot/config-`uname -r` /usr/src/linux-`uname -r`/.config</B
>. </P
><P
>	Let's focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files
	which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module 
	into the kernel.
	That slight difference, namely the <TT
CLASS="LITERAL"
>custom</TT
> string which appears in the module's version magic and not in the kernel's one,
	is due to a modification with respect to the original, in the makefile that some distribution include.
	Then, examine your <TT
CLASS="FILENAME"
>/usr/src/linux/Makefile</TT
>, and make sure that the specified version information matches exactly the one used
	for your current kernel. For example, you makefile could start as follows: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>VERSION = 2
PATCHLEVEL = 6
SUBLEVEL = 5
EXTRAVERSION = -1.358custom
...
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>	In this case, you need to restore the value of symbol <TT
CLASS="LITERAL"
>EXTRAVERSION</TT
> to <TT
CLASS="LITERAL"
>-1.358</TT
>. 
	We suggest to keep a backup copy of the makefile used to compile your kernel available in <TT
CLASS="FILENAME"
>/lib/modules/2.6.5-1.358/build</TT
>.
	A simple <B
CLASS="COMMAND"
>cp /lib/modules/`uname -r`/build/Makefile /usr/src/linux-`uname -r`</B
> should suffice.
	Additionally, if you already started a kernel build with the previous (wrong) <TT
CLASS="FILENAME"
>Makefile</TT
>, 
	you should also rerun <B
CLASS="COMMAND"
>make</B
>, or directly modify symbol <TT
CLASS="LITERAL"
>UTS_RELEASE</TT
> in file 
	<TT
CLASS="FILENAME"
>/usr/src/linux-2.6.x/include/linux/version.h</TT
> according to contents of file
	<TT
CLASS="FILENAME"
>/lib/modules/2.6.x/build/include/linux/version.h</TT
>, or overwrite the latter with the first.
	</P
><P
>	Now, please run <B
CLASS="COMMAND"
>make</B
> to update configuration and version headers and objects:
	</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>[root@pcsenonsrv linux-2.6.x]# make
CHK     include/linux/version.h
UPD     include/linux/version.h
SYMLINK include/asm -&#62; include/asm-i386
SPLIT   include/linux/autoconf.h -&#62; include/config/*
HOSTCC  scripts/basic/fixdep
HOSTCC  scripts/basic/split-include
HOSTCC  scripts/basic/docproc
HOSTCC  scripts/conmakehash
HOSTCC  scripts/kallsyms
CC      scripts/empty.o
...
	</PRE
></FONT
></TD
></TR
></TABLE
><P
>	If you do not desire to actually compile the kernel, you can interrupt the build process (<B
CLASS="COMMAND"
>CTRL-C</B
>) just after the 
	<TT
CLASS="LITERAL"
>SPLIT</TT
> line, because at that time, the files you need will be are ready.
	Now you can turn back to the directory of your module and compile it: It will be built exactly according your current kernel settings,
	and it will load into it without any errors.
	</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN425"
></A
>Chapter 3. Preliminaries</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN427"
>3.1. Modules vs Programs</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN429"
>3.1.1. How modules begin and end</A
></H3
><P
>A program usually begins with a <CODE
CLASS="FUNCTION"
>main()</CODE
> function, executes a bunch of instructions and
			terminates upon completion of those instructions.  Kernel modules work a bit differently.  A module always begin with
			either the <CODE
CLASS="FUNCTION"
>init_module</CODE
> or the function you specify with <CODE
CLASS="FUNCTION"
>module_init</CODE
> call.  This
			is the entry function for modules; it tells the kernel what functionality the module provides and sets up the kernel to
			run the module's functions when they're needed.  Once it does this, entry function returns and the module does nothing
			until the kernel wants to do something with the code that the module provides.</P
><P
>All modules end by calling either <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> or the function you specify with the
			<CODE
CLASS="FUNCTION"
>module_exit</CODE
> call.  This is the exit function for modules; it undoes whatever entry function did.  It
			unregisters the functionality that the entry function registered.</P
><P
>Every module must have an entry function and an exit function.  Since there's more than one way to specify entry and
			exit functions, I'll try my best to use the terms `entry function' and `exit function', but if I slip and simply refer to
			them as <CODE
CLASS="FUNCTION"
>init_module</CODE
> and <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
>, I think you'll know what I mean.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN441"
>3.1.2. Functions available to modules</A
></H3
><P
>Programmers use functions they don't define all the time.  A prime example of this is
				<CODE
CLASS="FUNCTION"
>printf()</CODE
>.  You use these library functions which are provided by the standard C library, libc.  The
				definitions for these functions don't actually enter your program until the linking stage, which insures that the code
				(for <CODE
CLASS="FUNCTION"
>printf()</CODE
> for example) is available, and fixes the call instruction to point to that
				code.</P
><P
>Kernel modules are different here, too.  In the hello world example, you might have noticed that we used a
				function, <CODE
CLASS="FUNCTION"
>printk()</CODE
> but didn't include a standard I/O library.  That's because modules are object
				files whose symbols get resolved upon insmod'ing.  The definition for the symbols comes from the kernel itself; the only
				external functions you can use are the ones provided by the kernel.  If you're curious about what symbols have been
				exported by your kernel, take a look at <TT
CLASS="FILENAME"
>/proc/kallsyms</TT
>.</P
><P
>One point to keep in mind is the difference between library functions and system calls.  Library functions are
				higher level, run completely in user space and provide a more convenient interface for the programmer to the functions
				that do the real work---system calls.  System calls run in kernel mode on the user's behalf and are provided by the
				kernel itself.  The library function <CODE
CLASS="FUNCTION"
>printf()</CODE
> may look like a very general printing function, but
				all it really does is format the data into strings and write the string data using the low-level system call
				<CODE
CLASS="FUNCTION"
>write()</CODE
>, which then sends the data to standard output.</P
><P
> Would you like to see what system calls are made by <CODE
CLASS="FUNCTION"
>printf()</CODE
>?  It's easy!  Compile the
				following program: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>#include &#60;stdio.h&#62;
int main(void)
{ printf("hello"); return 0; }
				</PRE
></FONT
></TD
></TR
></TABLE
><P
>with <B
CLASS="COMMAND"
>gcc -Wall -o hello hello.c</B
>.  Run the exectable with
<B
CLASS="COMMAND"
>strace ./hello</B
>.  Are
				you impressed?  Every line you see corresponds to a system call.  strace<A
NAME="AEN467"
HREF="#FTN.AEN467"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
> is a handy program that gives you details about what system calls
				a program is making, including which call is made, what its arguments are what it returns.  It's an invaluable tool for
				figuring out things like what files a program is trying to access.  Towards the end, you'll see a line which looks like
				<CODE
CLASS="FUNCTION"
>write(1, "hello", 5hello)</CODE
>.  There it is.  The face behind the <CODE
CLASS="FUNCTION"
>printf()</CODE
> mask.
				You may not be familiar with write, since most people use library functions for file I/O (like fopen, fputs, fclose).
				If that's the case, try looking at <B
CLASS="COMMAND"
>man 2 write</B
>.  The 2nd man section is devoted to system calls (like
				<CODE
CLASS="FUNCTION"
>kill()</CODE
> and <CODE
CLASS="FUNCTION"
>read()</CODE
>.  The 3rd man section is devoted to library calls, which you
				would probably be more familiar with (like <CODE
CLASS="FUNCTION"
>cosh()</CODE
> and <CODE
CLASS="FUNCTION"
>random()</CODE
>).</P
><P
>You can even write modules to replace the kernel's system calls, which we'll do shortly.  Crackers often make use
				of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have
				the kernel write <EM
>Tee hee, that tickles!</EM
> everytime someone tries to delete a file on your
				system.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN478"
>3.1.3. User Space vs Kernel Space</A
></H3
><P
>A kernel is all about access to resources, whether the resource in question happens to be a video card, a hard drive
			or even memory.  Programs often compete for the same resource.  As I just saved this document, updatedb started updating
			the locate database.  My vim session and updatedb are both using the hard drive concurrently.  The kernel needs to keep
			things orderly, and not give users access to resources whenever they feel like it.  To this end, a <ACRONYM
CLASS="ACRONYM"
>CPU</ACRONYM
>
			can run in different modes.  Each mode gives a different level of freedom to do what you want on the system.  The Intel
			80386 architecture has 4 of these modes, which are called rings.  Unix uses only two rings; the highest ring (ring 0, also
			known as `supervisor mode' where everything is allowed to happen) and the lowest ring, which is called `user mode'.</P
><P
>Recall the discussion about library functions vs system calls.  Typically, you use a library function in user mode.
			The library function calls one or more system calls, and these system calls execute on the library function's behalf, but
			do so in supervisor mode since they are part of the kernel itself.  Once the system call completes its task, it returns
			and execution gets transfered back to user mode.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN483"
>3.1.4. Name Space</A
></H3
><P
>When you write a small C program, you use variables which are convenient and make sense to the reader.  If, on the
				other hand, you're writing routines which will be part of a bigger problem, any global variables you have are part of a
				community of other peoples' global variables; some of the variable names can clash.  When a program has lots of global
				variables which aren't meaningful enough to be distinguished, you get <EM
>namespace pollution</EM
>.  In
				large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique
				variable names and symbols.</P
><P
>When writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely
				an issue.  The best way to deal with this is to declare all your variables as <SPAN
CLASS="TYPE"
>static</SPAN
> and to use a
				well-defined prefix for your symbols.  By convention, all kernel prefixes are lowercase.  If you don't want to declare
				everything as <SPAN
CLASS="TYPE"
>static</SPAN
>, another option is to declare a <CODE
CLASS="VARNAME"
>symbol table</CODE
> and register it with a
				kernel.  We'll get to this later.</P
><P
>The file <TT
CLASS="FILENAME"
>/proc/kallsyms</TT
> holds all the symbols that the kernel knows about and which are
				therefore accessible to your modules since they share the kernel's codespace.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN500"
>3.1.5. Code space</A
></H3
><P
>Memory management is a very complicated subject---the majority of O'Reilly's `Understanding The Linux Kernel' is
			just on memory management!  We're not setting out to be experts on memory managements, but we do need to know a couple of
			facts to even begin worrying about writing real modules.</P
><P
>If you haven't thought about what a segfault really means, you may be surprised to hear that pointers don't actually
			point to memory locations.  Not real ones, anyway.  When a process is created, the kernel sets aside a portion of real
			physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a
			computer scientist would know about<A
NAME="AEN514"
HREF="#FTN.AEN514"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
>.
			This memory begins with 0x00000000 and extends up to whatever it needs to be.  Since the memory space for any two processes don't
			overlap, every process that can access a memory address, say <TT
CLASS="LITERAL"
>0xbffff978</TT
>, would be accessing a different
			location in real physical memory!  The processes would be accessing an index named <TT
CLASS="LITERAL"
>0xbffff978</TT
> which
			points to some kind of offset into the region of memory set aside for that particular process.  For the most part, a
			process like our Hello, World program can't access the space of another process, although there are ways which we'll talk
			about later.</P
><P
>The kernel has its own space of memory as well.  Since a module is code which can be dynamically inserted and
			removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel's codespace rather than having its
			own.  Therefore, if your module segfaults, the kernel segfaults.  And if you start writing over data because of an
			off-by-one error, then you're trampling on kernel data (or code). This is even worse than it sounds, so try your best to be
			careful.</P
><P
>By the way, I would like to point out that the above discussion is true for any operating system which uses a
			monolithic kernel<A
NAME="AEN520"
HREF="#FTN.AEN520"
><SPAN
CLASS="footnote"
>[6]</SPAN
></A
>.  There are things called microkernels which have modules which get their own
			codespace.  The GNU Hurd and QNX Neutrino are two examples of a microkernel.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN522"
>3.1.6. Device Drivers</A
></H3
><P
>One class of module is the device driver, which provides functionality for hardware like a TV card or a serial port.
			On unix, each piece of hardware is represented by a file located in <TT
CLASS="FILENAME"
>/dev</TT
> named a
			<TT
CLASS="FILENAME"
>device file</TT
> which provides the means to communicate with the hardware.  The device driver provides
			the communication on behalf of a user program.  So the <TT
CLASS="FILENAME"
>es1370.o</TT
> sound card device driver might
			connect the <TT
CLASS="FILENAME"
>/dev/sound</TT
> device file to the Ensoniq IS1370 sound card.  A userspace
			program like mp3blaster can use <TT
CLASS="FILENAME"
>/dev/sound</TT
> without ever knowing what kind of sound
			card is installed.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN530"
>3.1.6.1. Major and Minor Numbers</A
></H4
><P
>Let's look at some device files.  Here are device files which represent the first three partitions on the
					primary master IDE hard drive:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ls -l /dev/hda[1-3]
brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
					</PRE
></FONT
></TD
></TR
></TABLE
><P
>Notice the column of numbers separated by a comma?  The first number is called the device's major number.  The
					second number is the minor number.  The major number tells you which driver is used to access the hardware.  Each
					driver is assigned a unique major number; all device files with the same major number are controlled by the same
					driver.  All the above major numbers are 3, because they're all controlled by the same driver.</P
><P
>The minor number is used by the driver to distinguish between the various hardware it controls.  Returning to
					the example above, although all three devices are handled by the same driver they have unique minor numbers because
					the driver sees them as being different pieces of hardware.</P
><P
> Devices are divided into two types: character devices and block devices.  The difference is that block devices
					have a buffer for requests, so they can choose the best order in which to respond to the requests.  This is important
					in the case of storage devices, where it's faster to read or write sectors which are close to each other, rather than
					those which are further apart.  Another difference is that block devices can only accept input and return output in
					blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few
					bytes as they like.  Most devices in the world are character, because they don't need this type of buffering, and they
					don't operate with a fixed block size.  You can tell whether a device file is for a block device or a character device
					by looking at the first character in the output of <B
CLASS="COMMAND"
>ls -l</B
>.  If it's `b' then it's a block device,
					and if it's `c' then it's a character device.  The devices you see above are block devices.  Here are some character
					devices (the serial ports):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
					</PRE
></FONT
></TD
></TR
></TABLE
><P
> If you want to see which major numbers have been assigned, you can look at
					<TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/devices.txt</TT
>.  </P
><P
>When the system was installed, all of those device files were created by the <B
CLASS="COMMAND"
>mknod</B
> command.
					To create a new char device named `coffee' with major/minor number <TT
CLASS="LITERAL"
>12</TT
> and <TT
CLASS="LITERAL"
>2</TT
>,
					simply do <B
CLASS="COMMAND"
>mknod /dev/coffee c 12 2</B
>.  You don't <EM
>have</EM
> to put your device files
					into <TT
CLASS="FILENAME"
>/dev</TT
>, but it's done by convention.  Linus put his device files in
					<TT
CLASS="FILENAME"
> /dev</TT
>, and so should you.  However, when creating a device file for testing purposes, it's
					probably OK to place it in your working directory where you compile the kernel module.  Just be sure to put it in the
					right place when you're done writing the device driver.</P
><P
>I would like to make a few last points which are implicit from the above discussion, but I'd like to make them
					explicit just in case.  When a device file is accessed, the kernel uses the major number of the file to determine
					which driver should be used to handle the access.  This means that the kernel doesn't really need to use or even know
					about the minor number.  The driver itself is the only thing that cares about the minor number.  It uses the minor
					number to distinguish between different pieces of hardware.</P
><P
>By the way, when I say `hardware', I mean something a bit more abstract than a PCI card that you can hold in
					your hand.   Look at these two device files:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>% ls -l /dev/fd0 /dev/fd0u1680
brwxrwxrwx   1 root  floppy   2,  0 Jul  5  2000 /dev/fd0
brw-rw----   1 root  floppy   2, 44 Jul  5  2000 /dev/fd0u1680
					</PRE
></FONT
></TD
></TR
></TABLE
><P
>By now you can look at these two device files and know instantly that they are block devices and are handled by
					same driver (block major <TT
CLASS="LITERAL"
>2</TT
>).  You might even be aware that these both represent your floppy drive,
					even if you only have one floppy drive.  Why two files?  One represents the floppy drive with <TT
CLASS="LITERAL"
>1.44</TT
>
					<ACRONYM
CLASS="ACRONYM"
>MB</ACRONYM
> of storage.  The other is the <EM
>same</EM
> floppy drive with
					<TT
CLASS="LITERAL"
>1.68</TT
> <ACRONYM
CLASS="ACRONYM"
>MB</ACRONYM
> of storage, and corresponds to what some people call a `superformatted'
					disk.  One that holds more data than a standard formatted floppy.  So here's a case where two device files with
					different minor number actually represent the same piece of physical hardware.  So just be aware that the word
					`hardware' in our discussion can mean something very abstract.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN567"
></A
>Chapter 4. Character Device Files</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN569"
>4.1. Character Device Drivers</A
></H2
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN574"
>4.1.1. The <SPAN
CLASS="TYPE"
>file_operations</SPAN
> Structure</A
></H3
><P
>The <SPAN
CLASS="TYPE"
>file_operations</SPAN
> structure is defined in <TT
CLASS="FILENAME"
>linux/fs.h</TT
>, and
			holds pointers to functions defined by the driver that perform various operations on the device.  Each field of the
			structure corresponds to the address of some function defined by the driver to handle a requested operation.</P
><P
> For example, every character driver needs to define a function that reads from the device.  The
			<SPAN
CLASS="TYPE"
>file_operations</SPAN
> structure holds the address of the module's function that performs that operation.  Here is
			what the definition looks like for kernel <TT
CLASS="LITERAL"
>2.6.5</TT
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct file_operations {
	struct module *owner;
	 loff_t(*llseek) (struct file *, loff_t, int);
	 ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);
	 ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
	 ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);
	 ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t,
			      loff_t);
	int (*readdir) (struct file *, void *, filldir_t);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	int (*ioctl) (struct inode *, struct file *, unsigned int,
		      unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*open) (struct inode *, struct file *);
	int (*flush) (struct file *);
	int (*release) (struct inode *, struct file *);
	int (*fsync) (struct file *, struct dentry *, int datasync);
	int (*aio_fsync) (struct kiocb *, int datasync);
	int (*fasync) (int, struct file *, int);
	int (*lock) (struct file *, int, struct file_lock *);
	 ssize_t(*readv) (struct file *, const struct iovec *, unsigned long,
			  loff_t *);
	 ssize_t(*writev) (struct file *, const struct iovec *, unsigned long,
			   loff_t *);
	 ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t,
			     void __user *);
	 ssize_t(*sendpage) (struct file *, struct page *, int, size_t,
			     loff_t *, int);
	unsigned long (*get_unmapped_area) (struct file *, unsigned long,
					    unsigned long, unsigned long,
					    unsigned long);
};
			</PRE
></FONT
></TD
></TR
></TABLE
><P
>Some operations are not implemented by a driver.  For example, a driver that handles a video card won't need to read
			from a directory structure.  The corresponding entries in the <SPAN
CLASS="TYPE"
>file_operations</SPAN
> structure should be set to
			<CODE
CLASS="VARNAME"
>NULL</CODE
>.</P
><P
>There is a gcc extension that makes assigning to this structure more convenient.  You'll see it in modern drivers,
			and may catch you by surprise.  This is what the new way of assigning to the structure looks like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct file_operations fops = {
	read: device_read,
	write: device_write,
	open: device_open,
	release: device_release
};
			</PRE
></FONT
></TD
></TR
></TABLE
><P
>However, there's also a C99 way of assigning to elements of a structure, and this is definitely preferred over using
			the GNU extension.  The version of gcc the author used when writing this, <TT
CLASS="LITERAL"
>2.95</TT
>, supports the new C99 syntax.  You
			should use this syntax in case someone wants to port your driver.  It will help with compatibility:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct file_operations fops = {
	.read = device_read,
	.write = device_write,
	.open = device_open,
	.release = device_release
};
			</PRE
></FONT
></TD
></TR
></TABLE
><P
>The meaning is clear, and you should be aware that any member of the structure which you don't explicitly assign
			will be initialized to <CODE
CLASS="VARNAME"
>NULL</CODE
> by gcc.</P
><P
>An instance of <SPAN
CLASS="TYPE"
>struct file_operations</SPAN
> containing pointers to functions that are used to implement
			read, write, open, ... syscalls is commonly named <CODE
CLASS="VARNAME"
>fops</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN599"
>4.1.2. The <SPAN
CLASS="TYPE"
>file</SPAN
> structure</A
></H3
><P
>Each device is represented in the kernel by a <SPAN
CLASS="TYPE"
>file</SPAN
> structure, which is defined in <TT
CLASS="FILENAME"
>linux/fs.h</TT
>.  Be aware that a <SPAN
CLASS="TYPE"
>file</SPAN
> is a kernel level structure and never appears in a
			user space program.  It's not the same thing as a <SPAN
CLASS="TYPE"
>FILE</SPAN
>, which is defined by glibc and would never appear in a
			kernel space function.  Also, its name is a bit misleading; it represents an abstract open `file', not a file on a disk,
			which is represented by a structure named <SPAN
CLASS="TYPE"
>inode</SPAN
>.</P
><P
>An instance of <CODE
CLASS="VARNAME"
>struct file</CODE
> is commonly named <CODE
CLASS="FUNCTION"
>filp</CODE
>.  You'll also see it
			refered to as <CODE
CLASS="VARNAME"
>struct file file</CODE
>.  Resist the temptation.</P
><P
>Go ahead and look at the definition of <CODE
CLASS="FUNCTION"
>file</CODE
>.  Most of the entries you see, like
			<CODE
CLASS="FUNCTION"
>struct dentry</CODE
> aren't used by device drivers, and you can ignore them.  This is because drivers don't
			fill <CODE
CLASS="VARNAME"
>file</CODE
> directly; they only use structures contained in <CODE
CLASS="VARNAME"
>file</CODE
> which are created
			elsewhere.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN621"
>4.1.3. Registering A Device</A
></H3
><P
>As discussed earlier, char devices are accessed through device files, usually located in <TT
CLASS="FILENAME"
>/dev</TT
><A
NAME="AEN630"
HREF="#FTN.AEN630"
><SPAN
CLASS="footnote"
>[7]</SPAN
></A
>.  The major number tells you which driver handles which device file.  The minor number
			is used only by the driver itself to differentiate which device it's operating on, just in case the driver handles more
			than one device.</P
><P
>Adding a driver to your system means registering it with the kernel.  This is synonymous with assigning it a major
			number during the module's initialization.  You do this by using the <CODE
CLASS="FUNCTION"
>register_chrdev</CODE
> function,
			defined by <TT
CLASS="FILENAME"
>linux/fs.h</TT
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);
			</PRE
></FONT
></TD
></TR
></TABLE
><P
>where <CODE
CLASS="VARNAME"
>unsigned int major</CODE
> is the major number you want to request, <CODE
CLASS="VARNAME"
>const char
			*name</CODE
> is the name of the device as it'll appear in <TT
CLASS="FILENAME"
>/proc/devices</TT
> and <CODE
CLASS="VARNAME"
>struct
			file_operations *fops</CODE
> is a pointer to the <CODE
CLASS="VARNAME"
>file_operations</CODE
> table for your driver.  A negative
			return value means the registration failed.  Note that we didn't pass the minor number to
			<CODE
CLASS="FUNCTION"
>register_chrdev</CODE
>.  That's because the kernel doesn't care about the minor number; only our driver uses
			it.</P
><P
>Now the question is, how do you get a major number without hijacking one that's already in use?  The easiest way
			would be to look through <TT
CLASS="FILENAME"
>Documentation/devices.txt</TT
> and pick an unused one.  That's a bad way of doing
			things because you'll never be sure if the number you picked will be assigned later.  The answer is that you can ask the
			kernel to assign you a dynamic major number.</P
><P
>If you pass a major number of 0 to <CODE
CLASS="FUNCTION"
>register_chrdev</CODE
>, the return value will be the dynamically
			allocated major number.  The downside is that you can't make a device file in advance, since you don't know what the major
			number will be.  There are a couple of ways to do this.  First, the driver itself can print the newly assigned number and
			we can make the device file by hand.  Second, the newly registered device will have an entry in
			<TT
CLASS="FILENAME"
>/proc/devices</TT
>, and we can either make the device file by hand or write a shell script to read the
			file in and make the device file.  The third method is we can have our driver make the device file using the
			<CODE
CLASS="FUNCTION"
>mknod</CODE
> system call after a successful registration and rm during the call to
			<CODE
CLASS="FUNCTION"
>cleanup_module</CODE
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN651"
>4.1.4. Unregistering A Device</A
></H3
><P
>We can't allow the kernel module to be <SPAN
CLASS="APPLICATION"
>rmmod</SPAN
>'ed whenever root feels like it.  If the
			device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory
			location where the appropriate function (read/write) used to be.  If we're lucky, no other code was loaded there, and
			we'll get an ugly error message.  If we're unlucky, another kernel module was loaded into the same location, which means a
			jump into the middle of another function within the kernel.  The results of this would be impossible to predict, but they
			can't be very positive.</P
><P
>Normally, when you don't want to allow something, you return an error code (a negative number) from the function
			which is supposed to do it.  With <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> that's impossible because it's a void function.
			However, there's a counter which keeps track of how many processes are using your module.  You can see what it's value is
			by looking at the 3rd field of <TT
CLASS="FILENAME"
>/proc/modules</TT
>.  If this number isn't zero, <CODE
CLASS="FUNCTION"
>rmmod</CODE
>
			will fail.  Note that you don't have to check the counter from within <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> because the
			check will be performed for you by the system call <CODE
CLASS="FUNCTION"
>sys_delete_module</CODE
>, defined in
			<TT
CLASS="FILENAME"
>linux/module.c</TT
>.  You shouldn't use this counter directly, but there are functions defined in <TT
CLASS="FILENAME"
>linux/module.h</TT
> which let you increase, decrease and display this counter:</P
><P
></P
><UL
><LI
><P
><CODE
CLASS="VARNAME"
>try_module_get(THIS_MODULE)</CODE
>: Increment the use count.</P
></LI
><LI
><P
><CODE
CLASS="VARNAME"
>module_put(THIS_MODULE)</CODE
>: Decrement the use count.</P
></LI
></UL
><P
>It's important to keep the counter accurate; if you ever do lose track of the correct usage count, you'll never be
			able to unload the module; it's now reboot time, boys and girls.  This is bound to happen to you sooner or later during a
			module's development.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN680"
>4.1.5. chardev.c</A
></H3
><P
>The next code sample creates a char driver named <TT
CLASS="FILENAME"
>chardev</TT
>.  You can <TT
CLASS="FILENAME"
>cat</TT
> its
			device file (or <TT
CLASS="FILENAME"
>open</TT
> the file with a program) and the driver will put the number of times the device
			file has been read from into the file.  We don't support writing to the file (like <B
CLASS="COMMAND"
>echo "hi" &#62;
			/dev/hello</B
>), but catch these attempts and tell the user that the operation isn't supported.  Don't worry if you
			don't see what we do with the data we read into the buffer; we don't do much with it.  We simply read in the data and
			print a message acknowledging that we received it.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN687"
></A
><P
><B
>Example 4-1. chardev.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN691"
>4.1.6. Writing Modules for Multiple Kernel Versions</A
></H3
><P
>The system calls, which are the major interface the kernel shows to the processes, generally stay the same across
			versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is
			necessary for backward compatibility -- a new kernel version is not supposed to break regular processes. In most cases,
			the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change
			between versions.</P
><P
>The Linux kernel versions are divided between the stable versions (n.$&#60;$even number$&#62;$.m) and the development
			versions (n.$&#60;$odd number$&#62;$.m). The development versions include all the cool new ideas, including those which will
			be considered a mistake, or reimplemented, in the next version. As a result, you can't trust the interface to remain the
			same in those versions (which is why I don't bother to support them in this book, it's too much work and it would become
			dated too quickly). In the stable versions, on the other hand, we can expect the interface to remain the same regardless
			of the bug fix version (the m number).</P
><P
>There are differences between different kernel versions, and if you want to support multiple kernel versions, you'll
			find yourself having to code conditional compilation directives.  The way to do this to compare the macro
			<CODE
CLASS="VARNAME"
>LINUX_VERSION_CODE</CODE
> to the macro <CODE
CLASS="VARNAME"
>KERNEL_VERSION</CODE
>.  In version <CODE
CLASS="VARNAME"
>a.b.c</CODE
>
			of the kernel, the value of this macro would be $2^{16}a+2^{8}b+c$. </P
><P
>			While previous versions of this guide showed how you can write backward compatible code with such constructs in
			great detail, we decided to break with this tradition for the better. People interested in doing such
			might now use a LKMPG with a version matching to their kernel. We decided to version the LKMPG like the kernel, 
			at least as far as major and minor number are concerned. We use the patchlevel for our own versioning so
			use LKMPG version 2.4.x for kernels 2.4.x, use LKMPG version 2.6.x for kernels 2.6.x and so on.
			Also make sure that you always use current, up to date versions of both, kernel and guide.
			</P
><P
> Update: What we've said above was true for kernels up to and including 2.6.10. You might already
			have noticed that recent kernels look different. In case you haven't they look like 2.6.x.y now.
			The meaning of the first three items basically stays the same, but a subpatchlevel has been added and will
			indicate security fixes till the next stable patchlevel is out. So people can choose between a stable
			tree with security updates <EM
> and </EM
> use the latest kernel as developer tree.
			Search the kernel mailing list archives	if you're interested in the full story.
			</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN708"
></A
>Chapter 5. The /proc File System</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN710"
>5.1. The /proc File System</A
></H2
><P
>	In Linux, there is an additional mechanism for the kernel and kernel modules to send information to processes --- the
	<TT
CLASS="FILENAME"
>/proc</TT
> file system.  Originally designed to allow easy access to information about
	processes (hence the name), it is now used by every bit of the kernel which has something interesting to report, such as
	<TT
CLASS="FILENAME"
>/proc/modules</TT
> which provides the list of modules and <TT
CLASS="FILENAME"
>/proc/meminfo</TT
> 
	which stats memory usage statistics.
	</P
><P
>The method to use the proc file system is very similar to the one used with device drivers --- a structure is created
	with all the information needed for the <TT
CLASS="FILENAME"
>/proc</TT
> file, including pointers to any handler
	functions (in our case there is only one, the one called when somebody attempts to read from the <TT
CLASS="FILENAME"
>/proc</TT
> file). Then, <CODE
CLASS="FUNCTION"
>init_module</CODE
> registers the structure with the kernel and
	<CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> unregisters it.</P
><P
>The reason we use <CODE
CLASS="FUNCTION"
>proc_register_dynamic</CODE
><A
NAME="AEN736"
HREF="#FTN.AEN736"
><SPAN
CLASS="footnote"
>[8]</SPAN
></A
> is because we don't want to determine the inode number
	used for our file in advance, but to allow the kernel to determine it to prevent clashes. Normal file systems are located on a
	disk, rather than just in memory (which is where <TT
CLASS="FILENAME"
>/proc</TT
> is), and in that case the inode
	number is a pointer to a disk location where the file's index-node (inode for short) is located. The inode contains
	information about the file, for example the file's permissions, together with a pointer to the disk location or locations
	where the file's data can be found.</P
><P
>	Because we don't get called when the file is opened or closed, there's nowhere for us to put
	<CODE
CLASS="VARNAME"
>try_module_get</CODE
> and <CODE
CLASS="VARNAME"
>try_module_put</CODE
> in this module, and if
	the file is opened and then the module is removed, there's no way to avoid the consequences.
	</P
><P
>        Here a simple example showing how to use a /proc file. This is the HelloWorld for the /proc filesystem.
	There are three parts: create the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> in the function <CODE
CLASS="FUNCTION"
>init_module</CODE
>,
	return a value (and a buffer) when the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> is read in the callback
	function <CODE
CLASS="FUNCTION"
>procfs_read</CODE
>, and delete the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> 
	in the function <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
>.
	</P
><P
>        The <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> is created when the module is loaded with the function
	<CODE
CLASS="FUNCTION"
>create_proc_entry</CODE
>. The return value is a 'struct proc_dir_entry *', and it
	will be used to configure the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> (for example, the owner of this file).
	A null return value means that the creation has failed.
	</P
><P
>        Each time, everytime the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
> is read, the function 
	<CODE
CLASS="FUNCTION"
>procfs_read</CODE
> is called.
	Two parameters of this function are very important: the buffer (the first parameter) and the offset (the third one).
	The content of the buffer will be returned to the application which read it (for example the cat command). The offset 
	is the current position in the file. If the return value of the function isn't null, then this function is
	called again. So be careful with this function, if it never returns zero, the read function is called endlessly.
	</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>% cat /proc/helloworld
HelloWorld!
        </PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN765"
></A
><P
><B
>Example 5-1. procfs1.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN769"
>5.2. Read and Write a /proc File</A
></H2
><P
>        We have seen a very simple example for a /proc file where we only read the file <TT
CLASS="FILENAME"
>/proc/helloworld</TT
>.
	It's also possible to write in a /proc file. It works the same way as read, a function is called when the /proc
	file is written. But there is a little difference with read, data comes from user, so you have to import data from
	user space to kernel space (with <CODE
CLASS="FUNCTION"
>copy_from_user</CODE
> or <CODE
CLASS="FUNCTION"
>get_user</CODE
>)
        </P
><P
>	The reason for <CODE
CLASS="FUNCTION"
>copy_from_user</CODE
> or <CODE
CLASS="FUNCTION"
>get_user</CODE
> is that Linux memory (on Intel
	architecture, it may be different under some other processors) is segmented.  This means that a pointer, by itself,
	does not reference a unique location in memory, only a location in a memory segment, and you need to know which
	memory segment it is to be able to use it. There is one memory segment for the kernel, and one for each of the processes.
	</P
><P
>	The only memory segment accessible to a process is its own, so when writing regular programs to run as processes,
	there's no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory
	segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between
	the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the
	process segment. The <CODE
CLASS="FUNCTION"
>put_user</CODE
> and <CODE
CLASS="FUNCTION"
>get_user</CODE
> macros allow you to access that
	memory. These functions handle only one caracter, you can handle several caracters with <CODE
CLASS="FUNCTION"
>copy_to_user</CODE
> and
	<CODE
CLASS="FUNCTION"
>copy_from_user</CODE
>. As the buffer (in read or write function) is in kernel space, for write function
	you need to import data because	it comes from user space, but not for the read function because data is already
	in kernel space.
	</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN806"
></A
><P
><B
>Example 5-2. procfs2.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN810"
>5.3. Manage /proc file with standard filesystem</A
></H2
><P
>	We have seen how to read and write a /proc file with the /proc interface. But it's also possible
	to manage /proc file with inodes. The main interest is to use advanced function, like permissions.
	</P
><P
>	In Linux, there is a standard mechanism for file system registration. Since every file system has to have its own
	functions to handle inode and file operations<A
NAME="AEN814"
HREF="#FTN.AEN814"
><SPAN
CLASS="footnote"
>[9]</SPAN
></A
>,
	there is a special structure to hold pointers to all those functions, <CODE
CLASS="VARNAME"
>struct inode_operations</CODE
>, which
	includes a pointer to <CODE
CLASS="VARNAME"
>struct file_operations</CODE
>. In /proc, whenever we register a new file, we're allowed to
	specify which <CODE
CLASS="VARNAME"
>struct inode_operations</CODE
> will be used to access to it. This is the mechanism we use, a
	<CODE
CLASS="VARNAME"
>struct inode_operations</CODE
> which includes a pointer to a <CODE
CLASS="VARNAME"
>struct file_operations</CODE
> which
	includes pointers to our <CODE
CLASS="FUNCTION"
>procfs_read</CODE
> and <CODE
CLASS="FUNCTION"
>procfs_write</CODE
> functions.
	</P
><P
>	Another interesting point here is the <CODE
CLASS="FUNCTION"
>module_permission</CODE
> function. This function is called whenever
	a process tries to do something with the <TT
CLASS="FILENAME"
>/proc</TT
> file, and it can decide whether to allow
	access or not. Right now it is only based on the operation and the uid of the current user (as available in
	<CODE
CLASS="VARNAME"
>current</CODE
>, a pointer to a structure which includes information on the currently running process), but it
	could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last
	input we received.</P
><P
>	It's important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for
	output, whereas write functions are used for input. The reason for that is that read and write refer to the user's point of
	view --- if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something
	to the kernel, then the kernel receives it as input.
	</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN853"
></A
><P
><B
>Example 5-3. procfs3.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>	Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming
	that procfs is on it's way out, consider using sysfs instead. Second, if you really can't get enough, 
	there's a highly recommendable bonus level for procfs below <TT
CLASS="FILENAME"
> linux/Documentation/DocBook/ </TT
>. 
	Use <B
CLASS="COMMAND"
> make help </B
> in your toplevel kernel directory for instructions about how to convert it into 
	your favourite format. Example: <B
CLASS="COMMAND"
> make htmldocs </B
>. Consider using this mechanism, 
	in case you want to document something kernel related yourself.
	</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN861"
>5.4. Manage /proc file with seq_file</A
></H2
><P
>	As we have seen, writing a /proc file may be quite "complex". So to help people writting
	/proc file, there is an API named seq_file that helps formating a /proc file for output.
        It's based on sequence, which is composed of 3 functions: start(), next(), and stop(). 
        The seq_file API starts a sequence when a user read the /proc file.
	</P
><P
>	A sequence begins with the call of the function start(). If the return is a non NULL value,
	the function next() is called. This function is an iterator, the goal is to go thought
	all the data. Each time next() is called, the function show() is also called. It writes
	data values in the buffer read by the user. The function next() is called until it returns
	NULL. The sequence ends when next() returns NULL, then the function stop() is called.
	</P
><P
>	BE CARREFUL: when a sequence is finished, another one starts. That means that at the end
	of function stop(), the function start() is called again. This loop finishes when the 
        function start() returns NULL. You can see a scheme of this in the figure "How seq_file works".
	</P
><DIV
CLASS="FIGURE"
><A
NAME="AEN868"
></A
><P
><B
>Figure 5-1. How seq_file works</B
></P
><P
><IMG
SRC="figures/seq_file.png"></P
></DIV
><P
> 
        Seq_file provides basic functions for file_operations, as seq_read, seq_lseek, and some others.
        But nothing to write in the /proc file. Of course, you can still use the same way as in the 
        previous example.
	</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN872"
></A
><P
><B
>Example 5-4. procfs4.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>	
	If you want more information, you can read this web page:
	</P
><P
></P
><UL
><LI
><P
><A
HREF="http://lwn.net/Articles/22355/"
TARGET="_top"
>http://lwn.net/Articles/22355/</A
></P
></LI
><LI
><P
><A
HREF="http://www.kernelnewbies.org/documents/seq_file_howto.txt"
TARGET="_top"
>http://www.kernelnewbies.org/documents/seq_file_howto.txt</A
></P
></LI
></UL
><P
>		You can also read the code of fs/seq_file.c in the linux kernel.
	</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN885"
></A
>Chapter 6. Using /proc For Input</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN887"
>6.1. TODO: Write a chapter about sysfs</A
></H2
><P
> This is just a placeholder for now. Finally I'd like to see a 
(yet to be written) chapter about sysfs instead here. If you are familiar
with sysfs and would like to take part in writing this chapter, feel free to
contact us (the LKMPG maintainers) for further details.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN890"
></A
>Chapter 7. Talking To Device Files</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN892"
>7.1. Talking to Device Files (writes and IOCTLs)</A
></H2
><P
>Device files are supposed to represent physical devices. Most physical devices are used for output as well as input, so
	there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This
	is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this
	is implemented by <CODE
CLASS="FUNCTION"
>device_write</CODE
>.</P
><P
>This is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is
	still implemented from the CPU's perspective as a serial port connected to a modem, so you don't have to tax your imagination
	too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data
	to be sent through the phone line) and read things from the modem (either responses for commands or the data received through
	the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for
	example to send the rate at which data is sent and received.</P
><P
>The answer in Unix is to use a special function called <CODE
CLASS="FUNCTION"
>ioctl</CODE
> (short for Input Output ConTroL).
	Every device can have its own <CODE
CLASS="FUNCTION"
>ioctl</CODE
> commands, which can be read <CODE
CLASS="FUNCTION"
>ioctl</CODE
>'s (to send
	information from a process to the kernel), write <CODE
CLASS="FUNCTION"
>ioctl</CODE
>'s (to return information to a process),
	<A
NAME="AEN914"
HREF="#FTN.AEN914"
><SPAN
CLASS="footnote"
>[10]</SPAN
></A
> both or neither.  The <CODE
CLASS="FUNCTION"
>ioctl</CODE
> function is called with three parameters: the file
	descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to
	use it to pass anything.  <A
NAME="AEN919"
HREF="#FTN.AEN919"
><SPAN
CLASS="footnote"
>[11]</SPAN
></A
></P
><P
>The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter.
	This ioctl number is usually created by a macro call (<CODE
CLASS="VARNAME"
>_IO</CODE
>, <CODE
CLASS="VARNAME"
>_IOR</CODE
>, <CODE
CLASS="VARNAME"
>_IOW</CODE
>
	or <CODE
CLASS="VARNAME"
>_IOWR</CODE
> --- depending on the type) in a header file. This header file should then be included both by the
	programs which will use <CODE
CLASS="FUNCTION"
>ioctl</CODE
> (so they can generate the appropriate <CODE
CLASS="FUNCTION"
>ioctl</CODE
>'s) and by
	the kernel module (so it can understand it). In the example below, the header file is <TT
CLASS="FILENAME"
>chardev.h</TT
> and the program which uses it is <CODE
CLASS="FUNCTION"
>ioctl.c</CODE
>.</P
><P
>If you want to use <CODE
CLASS="FUNCTION"
>ioctl</CODE
>s in your own kernel modules, it is best to receive an official
	<CODE
CLASS="FUNCTION"
>ioctl</CODE
> assignment, so if you accidentally get somebody else's <CODE
CLASS="FUNCTION"
>ioctl</CODE
>s, or if they get
	yours, you'll know something is wrong. For more information, consult the kernel source tree at
	<TT
CLASS="FILENAME"
>Documentation/ioctl-number.txt</TT
>.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN951"
></A
><P
><B
>Example 7-1. chardev.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN959"
></A
><P
><B
>Example 7-2. chardev.h</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN972"
></A
><P
><B
>Example 7-3. ioctl.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN976"
></A
>Chapter 8. System Calls</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN978"
>8.1. System Calls</A
></H2
><P
>So far, the only thing we've done was to use well defined kernel mechanisms to register <TT
CLASS="FILENAME"
>/proc</TT
> files and device handlers. This is fine if you want to do something the kernel programmers
	thought you'd want, such as write a device driver. But what if you want to do something unusual, to change the behavior of the
	system in some way? Then, you're mostly on your own.</P
><P
>This is where kernel programming gets dangerous. While writing the example below, I killed the
	<CODE
CLASS="FUNCTION"
>open()</CODE
> system call. This meant I couldn't open any files, I couldn't run any programs, and I couldn't
	<B
CLASS="COMMAND"
>shutdown</B
> the computer.  I had to pull the power switch.  Luckily, no files died. To ensure you won't lose
	any files either, please run <B
CLASS="COMMAND"
>sync</B
> right before you do the <B
CLASS="COMMAND"
>insmod</B
> and the
	<B
CLASS="COMMAND"
>rmmod</B
>.</P
><P
>Forget about <TT
CLASS="FILENAME"
>/proc</TT
> files, forget about device files. They're just minor details.
	The <EM
>real</EM
> process to kernel communication mechanism, the one used by all processes, is system calls. When
	a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory),
	this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it.
	By the way, if you want to see which system calls a program uses, run <B
CLASS="COMMAND"
>strace &#60;arguments&#62;</B
>.</P
><P
>In general, a process is not supposed to be able to access the kernel. It can't access kernel memory and it can't call
	kernel functions. The hardware of the CPU enforces this (that's the reason why it's called `protected mode').</P
><P
>System calls are an exception to this general rule. What happens is that the process fills the registers with the
	appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course,
	that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt
	0x80.  The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the
	operating system kernel --- and therefore you're allowed to do whatever you want.</P
><P
>The location in the kernel a process can jump to is called <EM
>system_call</EM
>. The procedure at that
	location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table
	of system calls (<CODE
CLASS="VARNAME"
>sys_call_table</CODE
>) to see the address of the kernel function to call. Then it calls the
	function, and after it returns, does a few system checks and then return back to the process (or to a different process, if
	the process time ran out). If you want to read this code, it's at the source file
	<TT
CLASS="FILENAME"
>arch/$&#60;$architecture$&#62;$/kernel/entry.S</TT
>, after the line <CODE
CLASS="FUNCTION"
>ENTRY(system_call)</CODE
>.</P
><P
>So, if we want to change the way a certain system call works, what we need to do is to write our own function to
	implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at
	<CODE
CLASS="VARNAME"
>sys_call_table</CODE
> to point to our function.  Because we might be removed later and we don't want to leave the
	system in an unstable state, it's important for <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> to restore the table to its original
	state.</P
><P
>The source code here is an example of such a kernel module. We want to `spy' on a certain user, and to
	<CODE
CLASS="FUNCTION"
>printk()</CODE
> a message whenever that user opens a file. Towards this end, we replace the system call to open
	a file with our own function, called <CODE
CLASS="FUNCTION"
>our_sys_open</CODE
>. This function checks the uid (user's id) of the
	current process, and if it's equal to the uid we spy on, it calls <CODE
CLASS="FUNCTION"
>printk()</CODE
> to display the name of the
	file to be opened.  Then, either way, it calls the original <CODE
CLASS="FUNCTION"
>open()</CODE
> function with the same parameters, to
	actually open the file.</P
><P
>The <CODE
CLASS="FUNCTION"
>init_module</CODE
> function replaces the appropriate location in <CODE
CLASS="VARNAME"
>sys_call_table</CODE
> and
	keeps the original pointer in a variable. The <CODE
CLASS="FUNCTION"
>cleanup_module</CODE
> function uses that variable to restore
	everything back to normal.  This approach is dangerous, because of the possibility of two kernel modules changing the same
	system call. Imagine we have two kernel modules, A and B.  A's open system call will be A_open and B's will be B_open. Now,
	when A is inserted into the kernel, the system call is replaced with A_open, which will call the original sys_open when it's
	done. Next, B is inserted into the kernel, which replaces the system call with B_open, which will call what it thinks is the
	original system call, A_open, when it's done.</P
><P
>Now, if B is removed first, everything will be well---it will simply restore the system call to A_open, which calls the
	original. However, if A is removed and then B is removed, the system will crash. A's removal will restore the system call to
	the original, sys_open, cutting B out of the loop.  Then, when B is removed, it will restore the system call to what
	<EM
>it</EM
> thinks is the original, A_open, which is no longer in memory. At first glance, it appears we could
	solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all
	(so that B won't change the system call when it's removed), but that will cause an even worse problem. When A is removed, it
	sees that the system call was changed to B_open so that it is no longer pointing to A_open, so it won't restore it to sys_open
	before it is removed from memory.  Unfortunately, B_open will still try to call A_open which is no longer there, so that even
	without removing B the system would crash.</P
><P
>Note that all the related problems make syscall stealing unfeasiable for production use. In order to keep people from
	doing potential harmful things sys_call_table is no longer exported. This means, if you want to do something more than a
	mere dry run of this example, you will have to patch your current kernel in order to have sys_call_table exported. 
	In the example directory you will find a README and the patch. As you can imagine, such modifications are not to be
	taken lightly. Do not try this on valueable systems (ie systems that you do not own - or cannot restore easily).
	You'll need to get the complete sourcecode of this guide as a tarball in order to get the patch and the README.
	Depending on your kernel version, you might even need to hand apply the patch. Still here? Well, so is this chapter.
	If Wyle E. Coyote was a kernel hacker, this would be the first thing he'd try. ;)
			
	</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1046"
></A
><P
><B
>Example 8-1. syscall.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1050"
></A
>Chapter 9. Blocking Processes</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1052"
>9.1. Blocking Processes</A
></H2
><P
>What do you do when somebody asks you for something you can't do right away?  If you're a human being and you're
			bothered by a human being, the only thing you can say is: <SPAN
CLASS="QUOTE"
>"Not right now, I'm busy.  <EM
>Go
			away!</EM
>"</SPAN
>. But if you're a kernel module and you're bothered by a process, you have another possibility.
			You can put the process to sleep until you can service it.  After all, processes are being put to sleep by the kernel and
			woken up all the time (that's the way multiple processes appear to run on the same time on a single CPU).</P
><P
>This kernel module is an example of this. The file (called <TT
CLASS="FILENAME"
>/proc/sleep</TT
>) can only be opened by a
			single process at a time.  If the file is already open, the kernel module calls
			<CODE
CLASS="FUNCTION"
>wait_event_interruptible</CODE
><A
NAME="AEN1089"
HREF="#FTN.AEN1089"
><SPAN
CLASS="footnote"
>[12]</SPAN
></A
>. This function changes the status of the task (a task is the kernel data
			structure which holds information about a process and the system call it's in, if any) to
			<CODE
CLASS="PARAMETER"
>TASK_INTERRUPTIBLE</CODE
>, which means that the task will not run until it is woken up somehow, and adds
			it to <CODE
CLASS="STRUCTNAME"
>WaitQ</CODE
>, the queue of tasks waiting to access the file.  Then, the function calls the
			scheduler to context switch to a different process, one which has some use for the CPU.</P
><P
>When a process is done with the file, it closes it, and <CODE
CLASS="FUNCTION"
>module_close</CODE
> is called.  That function
			wakes up all the processes in the queue (there's no mechanism to only wake up one of them).  It then returns and the
			process which just closed the file can continue to run.  In time, the scheduler decides that the process has had enough
			and gives control of the CPU to another process.  Eventually, one of the processes which was in the queue will be given
			control of the CPU by the scheduler.  It starts at the point right after the call to
			<CODE
CLASS="FUNCTION"
>module_interruptible_sleep_on</CODE
><A
NAME="AEN1097"
HREF="#FTN.AEN1097"
><SPAN
CLASS="footnote"
>[13]</SPAN
></A
>.  It can then proceed to set a global variable to tell all the other
			processes that the file is still open and go on with its life.  When the other processes get a piece of the CPU, they'll
			see that global variable and go back to sleep.</P
><P
> So we'll use <B
CLASS="COMMAND"
> tail -f </B
> to keep the file open in the background, while
			trying to access it with another process (again in the background, so that we need not switch to
			a different vt). As soon as the first background process is killed with <B
CLASS="COMMAND"
> kill %1 </B
>,
			the second is woken up, is able to access the file and finally terminates. </P
><P
>To make our life more interesting, <CODE
CLASS="FUNCTION"
>module_close</CODE
> doesn't have a monopoly on waking up the
			processes which wait to access the file.  A signal, such as <B
CLASS="KEYCAP"
>Ctrl</B
>+<B
CLASS="KEYCAP"
>c</B
> (<CODE
CLASS="PARAMETER"
>SIGINT</CODE
>) can also wake up a
			process.  <A
NAME="AEN1121"
HREF="#FTN.AEN1121"
><SPAN
CLASS="footnote"
>[14]</SPAN
></A
> In that case, we want
			to return with <CODE
CLASS="PARAMETER"
>-EINTR</CODE
>  immediately.  This is
			important so users can, for example, kill the process before it receives the file.</P
><P
>There is one more point to remember.  Some times processes don't want to sleep, they want either to get what they
			want immediately, or to be told it cannot be done.  Such processes use the <CODE
CLASS="PARAMETER"
>O_NONBLOCK</CODE
> flag when
			opening the file.  The kernel is supposed to respond by returning with the error code <CODE
CLASS="PARAMETER"
>-EAGAIN</CODE
> from
			operations which would otherwise block, such as opening the file in this example.  The program
			<B
CLASS="COMMAND"
>cat_noblock</B
>, available in the source directory for this chapter, can be used to open a file with
			<CODE
CLASS="PARAMETER"
>O_NONBLOCK</CODE
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>hostname:~/lkmpg-examples/09-BlockingProcesses# insmod sleep.ko
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses# tail -f /proc/sleep &#38;
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
Last input:
tail: /proc/sleep: file truncated
[1] 6540
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Open would block
hostname:~/lkmpg-examples/09-BlockingProcesses# kill %1
[1]+  Terminated              tail -f /proc/sleep
hostname:~/lkmpg-examples/09-BlockingProcesses# cat_noblock /proc/sleep
Last input:
hostname:~/lkmpg-examples/09-BlockingProcesses#</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1151"
></A
><P
><B
>Example 9-1. sleep.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1155"
></A
><P
><B
>Example 9-2. cat_noblock.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1159"
></A
>Chapter 10. Replacing Printks</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1161"
>10.1. Replacing <CODE
CLASS="FUNCTION"
>printk</CODE
></A
></H2
><P
>In <A
HREF="#USINGX"
>Section 1.2.1.2</A
>, I said that X and kernel module programming don't mix.  That's true for developing kernel
	modules, but in actual use, you want to be able to send messages to whichever
	tty<A
NAME="AEN1169"
HREF="#FTN.AEN1169"
><SPAN
CLASS="footnote"
>[15]</SPAN
></A
> the command to load the
	module came from.</P
><P
>The way this is done is by using <CODE
CLASS="VARNAME"
>current</CODE
>, a pointer to the currently running task, to get the current
	task's <CODE
CLASS="STRUCTNAME"
>tty</CODE
> structure.  Then, we look inside that <CODE
CLASS="STRUCTNAME"
>tty</CODE
> structure to find a
	pointer to a string write function, which we use to write a string to the tty.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1190"
></A
><P
><B
>Example 10-1. print_string.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1194"
>10.2. Flashing keyboard LEDs</A
></H2
><P
>In certain conditions, you may desire a simpler and more direct way to communicate to the external world.
	Flashing keyboard LEDs can be such a solution: It is an immediate way to attract attention or to display a status condition.
	Keyboard LEDs are present on every hardware, they are always visible, they do not need any setup, and their use is rather simple and 
	non-intrusive,  compared to writing to a tty or a file.</P
><P
>The following source code illustrates a minimal kernel module which, when loaded, starts blinking the keyboard LEDs until it is unloaded.</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1201"
></A
><P
><B
>Example 10-2. kbleds.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>	If none of the examples in this chapter fit your debugging needs there might yet be some other tricks to try. Ever wondered what
	CONFIG_LL_DEBUG in <B
CLASS="COMMAND"
> make menuconfig </B
> is good for? If you activate that you get low level access to the serial port.
	While this might not sound very powerful by itself, you can patch <TT
CLASS="FILENAME"
>kernel/printk.c</TT
> or any other
	essential syscall to use printascii, thus makeing it possible to trace virtually everything what your code does over a
	serial line. If you find yourself porting the kernel to some new and former unsupported architecture this is usually
	amongst the first things that should be implemented. Logging over a netconsole might also be worth a try.
	</P
><P
>	While you have seen lots of stuff that can be used to aid debugging here, there are some things to be aware of.
	Debugging is almost always intrusive. Adding debug code can change the situation enough to make the bug seem to dissappear.
	Thus you should try to keep debug code to a minimum and make sure it does not show up in production code.
	</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1209"
></A
>Chapter 11. Scheduling Tasks</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1211"
>11.1. Scheduling Tasks</A
></H2
><P
>Very often, we have <SPAN
CLASS="QUOTE"
>"housekeeping"</SPAN
> tasks which have to be done at a certain time, or every so often. If the
	task is to be done by a process, we do it by putting it in the <TT
CLASS="FILENAME"
>crontab</TT
> file.  If the task is to be done
	by a kernel module, we have two possibilities.  The first is to put a process in the <TT
CLASS="FILENAME"
>crontab</TT
> file which
	will wake up the module by a system call when necessary, for example by opening a file. This is terribly inefficient, however
	-- we run a new process off of <TT
CLASS="FILENAME"
>crontab</TT
>, read a new executable to memory, and all this just to wake up a
	kernel module which is in memory anyway.</P
><P
>Instead of doing that, we can create a function that will be called once for every timer interrupt.  The way we do this
	is we create a task, held in a <CODE
CLASS="STRUCTNAME"
>workqueue_struct</CODE
> structure, which will hold a pointer to the function.  Then,
	we use <CODE
CLASS="FUNCTION"
>queue_delayed_work</CODE
> to put that task on a task list called <CODE
CLASS="STRUCTNAME"
>my_workqueue</CODE
>, 
	which is the list of tasks to be executed on the next timer interrupt.  Because we want the function to keep on being executed,
	we need to put it back on <CODE
CLASS="STRUCTNAME"
>my_workqueue</CODE
> whenever it is called, for the next timer interrupt.</P
><P
>There's one more point we need to remember here.  When a module is removed by <B
CLASS="COMMAND"
>rmmod</B
>, first its
	reference count is checked.  If it is zero, <CODE
CLASS="FUNCTION"
>module_cleanup</CODE
> is called.  Then, the module is removed from
	memory with all its functions. Things need to be shut down properly, or bad things will happen. See the code below how
	this can be done in a safe way.  </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1250"
></A
><P
><B
>Example 11-1. sched.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="INTERRUPTHANDLERS"
></A
>Chapter 12. Interrupt Handlers</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1256"
>12.1. Interrupt Handlers</A
></H2
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1263"
>12.1.1. Interrupt Handlers</A
></H3
><P
>                Except for the last chapter, everything we did in the kernel so far we've done as a response to a process 
                asking for it, either by dealing with a special file, sending an <CODE
CLASS="FUNCTION"
>ioctl()</CODE
>, or issuing 
                a system call.  But the job of the kernel isn't just to respond to process requests.  Another job, which 
                is every bit as important, is to speak to the hardware connected to the machine.
                </P
><P
>There are two types of interaction between the CPU and the rest of the computer's hardware.
                The first type is when the CPU gives orders to the hardware, the other is when the hardware needs to tell 
                the CPU something.  The second, called interrupts, is much harder to implement because it has to be dealt 
                with when convenient for the hardware, not the CPU. Hardware devices typically have a very small amount of 
                RAM, and if you don't read their information when available, it is lost.
                </P
><P
>                Under Linux, hardware interrupts are called IRQ's (<EM
>I</EM
>nterrupt<EM
>R</EM
>e
                <EM
>q</EM
>uests)<A
NAME="AEN1272"
HREF="#FTN.AEN1272"
><SPAN
CLASS="footnote"
>[16]</SPAN
></A
>.  There are two types of IRQ's, short and long.  A short IRQ is one which 
                is expected to take a <EM
>very</EM
> short period of time, during which the rest of the machine 
                will be blocked and no other interrupts will be handled.  A long IRQ is one which can take longer, and during
                which other interrupts may occur (but not interrupts from the same device).  If at all possible, it's better
                to declare an interrupt handler to be long.
                </P
><P
>                When the CPU receives an interrupt, it stops whatever it's doing (unless it's processing a more important
                interrupt, in which case it will deal with this one only when the more important one is done), saves certain 
                parameters on the stack and calls the interrupt handler.  This means that certain things are not allowed 
                in the interrupt handler itself, because the system is in an unknown state.  The solution to this problem
                is for the interrupt handler to do what needs to be done immediately, usually read something from the hardware
                or send something to the hardware, and then schedule the handling of the new information at a later time 
                (this is called the <SPAN
CLASS="QUOTE"
>"bottom half"</SPAN
>) and return.  The kernel is then	guaranteed to call the bottom
                half as soon as possible -- and when it does, everything allowed in kernel modules will be allowed.
                </P
><P
>                The way to implement this is to call <CODE
CLASS="FUNCTION"
>request_irq()</CODE
> to get your interrupt handler 
                called when the relevant IRQ is received. <A
NAME="AEN1289"
HREF="#FTN.AEN1289"
><SPAN
CLASS="footnote"
>[17]</SPAN
></A
>This function receives the IRQ number, the name of the function, flags, 
                a name for <TT
CLASS="FILENAME"
>/proc/interrupts</TT
> and a parameter to pass to the interrupt handler. Usually 
                there is a certain number of IRQs available. How many IRQs there are is hardware-dependent. The flags can 
                include <CODE
CLASS="PARAMETER"
>SA_SHIRQ</CODE
> to indicate you're willing to share the IRQ with other interrupt 
                handlers (usually because a number of hardware devices sit on the same IRQ) and <CODE
CLASS="PARAMETER"
>SA_INTERRUPT
                </CODE
> to indicate this is a fast interrupt.  This function will only succeed if there isn't already 
                a handler on this IRQ, or if you're both willing to share.
                </P
><P
>                Then, from within the interrupt handler, we communicate with the hardware and then use <CODE
CLASS="FUNCTION"
>queue_work()
                </CODE
> <CODE
CLASS="FUNCTION"
>mark_bh(BH_IMMEDIATE)</CODE
> to schedule the bottom half.
                </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="KEYBOARD"
>12.1.2. Keyboards on the Intel Architecture</A
></H3
><P
>                The rest of this chapter is completely Intel specific.  If you're not running on an Intel platform, it
		will not work.  Don't even try to compile the code here.
                </P
><P
>                I had a problem with writing the sample code for this chapter.  On one hand, for an example to be useful
                it has to run on everybody's computer with meaningful results.  On the other hand, the kernel already 
                includes device drivers for all of the common devices, and those device drivers won't coexist with what 
                I'm going to write.  The solution I've found was to write something for the keyboard interrupt, and disable
                the regular keyboard interrupt handler first.  Since it is defined as a static symbol in the kernel source
                files (specifically, <TT
CLASS="FILENAME"
>drivers/char/keyboard.c</TT
>), there is no way to restore it. Before 
                <KBD
CLASS="USERINPUT"
>insmod</KBD
>'ing this code, do on another terminal <KBD
CLASS="USERINPUT"
>sleep 120; reboot</KBD
>
                if you value your file system.
                </P
><P
>                This code binds itself to IRQ 1, which is the IRQ of the keyboard controlled under Intel architectures.
                Then, when it receives a keyboard interrupt, it reads the keyboard's status (that's the purpose of the
                <KBD
CLASS="USERINPUT"
>inb(0x64)</KBD
>) and the scan code, which is the value returned by the keyboard. Then, 
                as soon as the kernel thinks it's feasible, it runs <CODE
CLASS="FUNCTION"
>got_char</CODE
> which gives the code 
                of the key used (the first seven bits of the scan code) and whether it has been pressed (if the 8th bit
                is zero) or released (if it's one).
                </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1320"
></A
><P
><B
>Example 12-1. intrpt.c</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>&#62;
                </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1324"
></A
>Chapter 13. Symmetric Multi Processing</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1326"
>13.1. Symmetrical Multi-Processing</A
></H2
><P
>One of the easiest and cheapest ways to improve hardware performance is to put more than one CPU on the board.  This can
	be done either making the different CPU's take on different jobs (asymmetrical multi-processing) or by making them all run in
	parallel, doing the same job (symmetrical multi-processing, a.k.a. SMP).  Doing asymmetrical multi-processing effectively
	requires specialized knowledge about the tasks the computer should do, which is unavailable in a general purpose operating
	system such as Linux.  On the other hand, symmetrical multi-processing is relatively easy to implement.</P
><P
>By relatively easy, I mean exactly that: not that it's <EM
>really</EM
> easy.  In a symmetrical
	multi-processing environment, the CPU's share the same memory, and as a result code running in one CPU can affect the memory
	used by another.  You can no longer be certain that a variable you've set to a certain value in the previous line still has
	that value; the other CPU might have played with it while you weren't looking.  Obviously, it's impossible to program like
	this.</P
><P
>In the case of process programming this normally isn't an issue, because a process will normally only run on one CPU at
	a time<A
NAME="AEN1344"
HREF="#FTN.AEN1344"
><SPAN
CLASS="footnote"
>[18]</SPAN
></A
>.  The
	kernel, on the other hand, could be called by different processes running on different CPU's.</P
><P
>In version 2.0.x, this isn't a problem because the entire kernel is in one big spinlock.  This means that if one CPU is
	in the kernel and another CPU wants to get in, for example because of a system call, it has to wait until the first CPU is
	done.  This makes Linux SMP safe<A
NAME="AEN1347"
HREF="#FTN.AEN1347"
><SPAN
CLASS="footnote"
>[19]</SPAN
></A
>, but
	inefficient.</P
><P
>In version 2.2.x, several CPU's can be in the kernel at the same time.  This is something module writers need to be
	aware of.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1350"
></A
>Chapter 14. Common Pitfalls</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1352"
>14.1. Common Pitfalls</A
></H2
><P
>Before I send you on your way to go out into the world and write kernel modules, there are a few things I need to warn
	you about. If I fail to warn you and something bad happens, please report the problem to me for a full refund of the amount I
	was paid for your copy of the book.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Using standard libraries</DT
><DD
><P
>You can't do that.  In a kernel module you can only use kernel functions, which are the functions you can
			see in <TT
CLASS="FILENAME"
>/proc/kallsyms</TT
>.</P
></DD
><DT
>Disabling interrupts</DT
><DD
><P
>You might need to do this for a short time and that is OK, but if you don't enable them afterwards, your
			system will be stuck and you'll have to power it off.</P
></DD
><DT
>Sticking your head inside a large carnivore</DT
><DD
><P
>I probably don't have to warn you about this, but I figured I will anyway, just in case.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="AEN1387"
></A
>Appendix A. Changes: 2.0 To 2.2</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1389"
>A.1. Changes between 2.4 and 2.6</A
></H2
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1396"
>A.1.1. Changes between 2.4 and 2.6</A
></H3
><P
>I don't know the entire kernel well enough to document all of the changes.
			Some hints for porting can be found by comparing this version of the LKMPG with it's counterpart for
			kernel 2.4. Apart from that, anybody who needs to port drivers from 2.4 to 2.6 kernels might want to visit
			<A
HREF="http://lwn.net/Articles/driver-porting/"
TARGET="_top"
> http://lwn.net/Articles/driver-porting/ </A
>.
			If you still can't find an example that exactly meets your needs there, find a driver that's similar to your driver
			and present in both kernel versions. File comparison tools like <B
CLASS="COMMAND"
> xxdiff </B
> or 
			<B
CLASS="COMMAND"
> meld </B
> can be a great help then. Also check if your driver is covered by docs in
			<TT
CLASS="FILENAME"
> linux/Documentation/ </TT
>. Before starting with porting and in case you're stuck it's 
			a good idea to find an appropiate mailinglist and ask people there for pointers.
			</P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="AEN1403"
></A
>Appendix B. Where To Go From Here</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1405"
>B.1. Where From Here?</A
></H2
><P
>I could easily have squeezed a few more chapters into this book.  I could have added a chapter about creating new file
	systems, or about adding new protocol stacks (as if there's a need for that -- you'd have to dig underground to find a
	protocol stack not supported by Linux).  I could have added explanations of the kernel mechanisms we haven't touched upon,
	such as bootstrapping or the disk interface.</P
><P
>However, I chose not to.  My purpose in writing this book was to provide initiation into the mysteries of kernel module
	programming and to teach the common techniques for that purpose.  For people seriously interested in kernel programming, I
	recommend Juan-Mariano de Goyeneche's <A
HREF="http://jungla.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html"
TARGET="_top"
> list of
	kernel resources </A
>.  Also, as Linus said, the best way to learn the kernel is to read the source code yourself.</P
><P
>If you're interested in more examples of short kernel modules, I recommend Phrack magazine.  Even if you're not
	interested in security, and as a programmer you should be, the kernel modules there are good examples of what you can do
	inside the kernel, and they're short enough not to require too much effort to understand.</P
><P
>I hope I have helped you in your quest to become a better programmer, or at least to have fun through technology.  And,
	if you do write useful kernel modules, I hope you publish them under the GPL, so I can use them too.</P
><P
>If you'd like to contribute to this guide, please contact one the maintainers for details. As you've
	already seen, there's a placeholder chapter now, waiting to be filled with examples for sysfs. </P
></DIV
></DIV
><DIV
CLASS="INDEX"
><HR><H1
><A
NAME="DOC-INDEX"
></A
>Index</H1
><DIV
CLASS="INDEXDIV"
><H2
CLASS="INDEXDIV"
><A
NAME="AEN1415"
>Symbols</A
></H2
><DL
><DT
>/etc/conf.modules,
    <A
HREF="x44.htm"
>How Do Modules Get Into The Kernel?</A
>
  </DT
><DT
>/etc/modules.conf,
    <A
HREF="x44.htm"
>How Do Modules Get Into The Kernel?</A
>
  </DT
><DT
>/proc filesystem,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>/proc/interrupts,
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
><DT
>/proc/kallsyms,
    <A
HREF="c425.htm#AEN441"
>Functions available to modules</A
>,
    <A
HREF="c425.htm#AEN483"
>Name Space</A
>,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DT
>/proc/meminfo,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>/proc/modules,
    <A
HREF="x44.htm"
>How Do Modules Get Into The Kernel?</A
>,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>2.6 changes,
    <A
HREF="a1387.htm#AEN1389"
>Changes between 2.4 and 2.6</A
>
  </DT
><DT
>_IO,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>_IOR,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>_IOW,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>_IOWR,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>__exit,
    <A
HREF="x245.htm"
>Hello World (part 3): The __init and __exit Macros</A
>
  </DT
><DT
>__init,
    <A
HREF="x245.htm"
>Hello World (part 3): The __init and __exit Macros</A
>
  </DT
><DT
>__initdata,
    <A
HREF="x245.htm"
>Hello World (part 3): The __init and __exit Macros</A
>
  </DT
><DT
>__initfunction(),
    <A
HREF="x245.htm"
>Hello World (part 3): The __init and __exit Macros</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1468"
>B</A
></H2
><DL
><DT
>blocking processes,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>blocking, how to avoid,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>bottom half,
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
><DT
>busy,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1482"
>C</A
></H2
><DL
><DT
>carnivore
  </DT
><DD
><DL
><DT
>large,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>cleanup_module(),
    <A
HREF="c119.htm#AEN121"
>Hello, World (part 1): The Simplest Module</A
>
  </DT
><DT
>code space,
    <A
HREF="c425.htm#AEN500"
>Code space</A
>
  </DT
><DT
>coffee,
    <A
HREF="c425.htm#AEN530"
>Major and Minor Numbers</A
>
  </DT
><DT
>copy_from_user,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DT
>copy_to_user,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DT
>CPU
  </DT
><DD
><DL
><DT
>multiple,
    <A
HREF="c1324.htm#AEN1326"
>Symmetrical Multi-Processing</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>crontab,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>ctrl-c,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>current task,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1516"
>D</A
></H2
><DL
><DT
>DEFAULT_MESSAGE_LOGLEVEL,
    <A
HREF="c119.htm#INTRODUCINGPRINTK"
>Introducing printk()</A
>
  </DT
><DT
>defining ioctls,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>device file
  </DT
><DD
><DL
><DT
>character,
    <A
HREF="c567.htm#AEN569"
>Character Device Drivers</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>device files
  </DT
><DD
><DL
><DT
>input to,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>write to,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1534"
>E</A
></H2
><DL
><DT
>EAGAIN,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>EINTR,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>ENTRY(system call),
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>entry.S,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1548"
>F</A
></H2
><DL
><DT
>file,
    <A
HREF="c567.htm#AEN599"
>The file structure</A
>
  </DT
><DT
>filesystem
  </DT
><DD
><DL
><DT
>/proc,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>registration,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>filesystem registration,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>file_operations,
    <A
HREF="c567.htm#AEN574"
>The file_operations Structure</A
>
  </DT
><DT
>file_operations structure,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1568"
>G</A
></H2
><DL
><DT
>get_user,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1573"
>H</A
></H2
><DL
><DT
>handlers
  </DT
><DD
><DL
><DT
>interrupt,
    <A
HREF="c1254.htm#AEN1256"
>Interrupt Handlers</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>housekeeping,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>Hurd,
    <A
HREF="c425.htm#AEN500"
>Code space</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1585"
>I</A
></H2
><DL
><DT
>inb,
    <A
HREF="c1254.htm#KEYBOARD"
>Keyboards on the Intel Architecture</A
>
  </DT
><DT
>init_module(),
    <A
HREF="c119.htm#AEN121"
>Hello, World (part 1): The Simplest Module</A
>
  </DT
><DT
>inode,
    <A
HREF="c567.htm#AEN599"
>The file structure</A
>,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>inode_operations structure,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>insmod,
    <A
HREF="x181.htm"
>Compiling Kernel Modules</A
>,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>Intel architecture
  </DT
><DD
><DL
><DT
>keyboard,
    <A
HREF="c1254.htm#KEYBOARD"
>Keyboards on the Intel Architecture</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>interrupt 0x80,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>interrupt handlers,
    <A
HREF="c1254.htm#AEN1256"
>Interrupt Handlers</A
>
  </DT
><DT
>interruptible_sleep_on,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>interrupts
  </DT
><DD
><DL
><DT
>disabling,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>ioctl,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
><DT
>defining,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>official assignment,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1628"
>K</A
></H2
><DL
><DT
>kernel
  </DT
><DD
><DL
><DT
>versions,
    <A
HREF="a1387.htm#AEN1389"
>Changes between 2.4 and 2.6</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>kernel versions,
    <A
HREF="c567.htm#AEN691"
>Writing Modules for Multiple Kernel Versions</A
>
  </DT
><DT
>kerneld,
    <A
HREF="x44.htm"
>How Do Modules Get Into The Kernel?</A
>
  </DT
><DT
>KERNEL_VERSION,
    <A
HREF="c567.htm#AEN691"
>Writing Modules for Multiple Kernel Versions</A
>
  </DT
><DT
>keyboard,
    <A
HREF="c1254.htm#KEYBOARD"
>Keyboards on the Intel Architecture</A
>
  </DT
><DT
>keyboard LEDs
  </DT
><DD
><DL
><DT
>flashing,
    <A
HREF="x1194.htm"
>Flashing keyboard LEDs</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>kmod,
    <A
HREF="x44.htm"
>How Do Modules Get Into The Kernel?</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1653"
>L</A
></H2
><DL
><DT
>libraries
  </DT
><DD
><DL
><DT
>standard,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>library function,
    <A
HREF="c425.htm#AEN441"
>Functions available to modules</A
>
  </DT
><DT
>LINUX_VERSION_CODE,
    <A
HREF="c567.htm#AEN691"
>Writing Modules for Multiple Kernel Versions</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1665"
>M</A
></H2
><DL
><DT
>major number,
    <A
HREF="c425.htm#AEN530"
>Major and Minor Numbers</A
>
  </DT
><DD
><DL
><DT
>dynamic allocation,
    <A
HREF="c567.htm#AEN621"
>Registering A Device</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>memory segments,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DT
>microkernel,
    <A
HREF="c425.htm#AEN500"
>Code space</A
>
  </DT
><DT
>minor number,
    <A
HREF="c425.htm#AEN530"
>Major and Minor Numbers</A
>
  </DT
><DT
>mknod,
    <A
HREF="c425.htm#AEN530"
>Major and Minor Numbers</A
>
  </DT
><DT
>modem,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>MODULE_AUTHOR(),
    <A
HREF="x279.htm"
>Hello World (part 4): Licensing and Module Documentation</A
>
  </DT
><DT
>module_cleanup,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>MODULE_DESCRIPTION(),
    <A
HREF="x279.htm"
>Hello World (part 4): Licensing and Module Documentation</A
>
  </DT
><DT
>module_exit,
    <A
HREF="x217.htm"
>Hello World (part 2)</A
>
  </DT
><DT
>module_init,
    <A
HREF="x217.htm"
>Hello World (part 2)</A
>
  </DT
><DT
>module_interruptible_sleep_on,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>MODULE_LICENSE(),
    <A
HREF="x279.htm"
>Hello World (part 4): Licensing and Module Documentation</A
>
  </DT
><DT
>module_permissions,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>module_sleep_on,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>MODULE_SUPPORTED_DEVICE(),
    <A
HREF="x279.htm"
>Hello World (part 4): Licensing and Module Documentation</A
>
  </DT
><DT
>module_wake_up,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>MOD_DEC_USE_COUNT,
    <A
HREF="c567.htm#AEN651"
>Unregistering A Device</A
>
  </DT
><DT
>MOD_INC_USE_COUNT,
    <A
HREF="c567.htm#AEN651"
>Unregistering A Device</A
>
  </DT
><DT
>MOD_IN_USE,
    <A
HREF="c567.htm#AEN651"
>Unregistering A Device</A
>
  </DT
><DT
>monolithic kernel,
    <A
HREF="c425.htm#AEN500"
>Code space</A
>
  </DT
><DT
>multi-processing,
    <A
HREF="c1324.htm#AEN1326"
>Symmetrical Multi-Processing</A
>
  </DT
><DT
>multi-tasking,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>multitasking,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1741"
>N</A
></H2
><DL
><DT
>namespace pollution,
    <A
HREF="c425.htm#AEN483"
>Name Space</A
>
  </DT
><DT
>Neutrino,
    <A
HREF="c425.htm#AEN500"
>Code space</A
>
  </DT
><DT
>non-blocking,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1752"
>O</A
></H2
><DL
><DT
>official ioctl assignment,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>O_NONBLOCK,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1760"
>P</A
></H2
><DL
><DT
>permission,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>pointer
  </DT
><DD
><DL
><DT
>current,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>printk
  </DT
><DD
><DL
><DT
>replacing,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>printk(),
    <A
HREF="c119.htm#INTRODUCINGPRINTK"
>Introducing printk()</A
>
  </DT
><DT
>proc file
  </DT
><DD
><DL
><DT
>kallsyms,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>processes
  </DT
><DD
><DL
><DT
>blocking,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>killing,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>waking up,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>processing
  </DT
><DD
><DL
><DT
>multi,
    <A
HREF="c1324.htm#AEN1326"
>Symmetrical Multi-Processing</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>proc_register,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>proc_register_dynamic,
    <A
HREF="c708.htm#AEN710"
>The /proc File System</A
>
  </DT
><DT
>putting processes to sleep,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>put_user,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1804"
>Q</A
></H2
><DL
><DT
>queue_delayed_work,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>queue_work,
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1812"
>R</A
></H2
><DL
><DT
>read
  </DT
><DD
><DL
><DT
>in the kernel,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>reference count,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>refund policy,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DT
>register_chrdev,
    <A
HREF="c567.htm#AEN621"
>Registering A Device</A
>
  </DT
><DT
>request_irq(),
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
><DT
>rmmod,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DD
><DL
><DT
>preventing,
    <A
HREF="c567.htm#AEN651"
>Unregistering A Device</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1836"
>S</A
></H2
><DL
><DT
>SA_INTERRUPT,
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
><DT
>SA_SHIRQ,
    <A
HREF="c1254.htm#AEN1263"
>Interrupt Handlers</A
>
  </DT
><DT
>scheduler,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>scheduling tasks,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>segment
  </DT
><DD
><DL
><DT
>memory,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>seq_file,
    <A
HREF="x861.htm"
>Manage /proc file with seq_file</A
>
  </DT
><DT
>serial port,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DT
>shutdown,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>SIGINT,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>signal,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>sleep
  </DT
><DD
><DL
><DT
>putting processes to,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>sleep_on,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>SMP,
    <A
HREF="c1324.htm#AEN1326"
>Symmetrical Multi-Processing</A
>
  </DT
><DT
>source file
  </DT
><DD
><DL
><DT
>chardev.c,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>chardev.h,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hello-1.c,
    <A
HREF="c119.htm#AEN121"
>Hello, World (part 1): The Simplest Module</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hello-2.c,
    <A
HREF="x217.htm"
>Hello World (part 2)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hello-3.c,
    <A
HREF="x245.htm"
>Hello World (part 3): The __init and __exit Macros</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hello-4.c,
    <A
HREF="x279.htm"
>Hello World (part 4): Licensing and Module Documentation</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>hello-5.c,
    <A
HREF="x323.htm"
>Passing Command Line Arguments to a Module</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>intrpt.c,
    <A
HREF="c1254.htm#KEYBOARD"
>Keyboards on the Intel Architecture</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>ioctl.c,
    <A
HREF="c890.htm#AEN892"
>Talking to Device Files (writes and IOCTLs)</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>print_string.c,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sched.c,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>sleep.c,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>start.c,
    <A
HREF="x351.htm"
>Modules Spanning Multiple Files</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>stop.c,
    <A
HREF="x351.htm"
>Modules Spanning Multiple Files</A
>
  </DT
><DD
><DL
></DL
></DD
><DT
>syscall.c,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>source files
  </DT
><DD
><DL
><DT
>multiple,
    <A
HREF="x351.htm"
>Modules Spanning Multiple Files</A
>,
    <A
HREF="x380.htm"
>Building modules for a precompiled kernel</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>standard libraries,
    <A
HREF="c1350.htm#AEN1352"
>Common Pitfalls</A
>
  </DT
><DT
>strace,
    <A
HREF="c425.htm#AEN441"
>Functions available to modules</A
>,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>struct
  </DT
><DD
><DL
><DT
>tty,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>struct file_operations,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>struct inode_operations,
    <A
HREF="x810.htm"
>Manage /proc file with standard filesystem</A
>
  </DT
><DT
>symbol table,
    <A
HREF="c425.htm#AEN483"
>Name Space</A
>
  </DT
><DT
>symmetrical multi-processing,
    <A
HREF="c1324.htm#AEN1326"
>Symmetrical Multi-Processing</A
>
  </DT
><DT
>sync,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>system call,
    <A
HREF="c425.htm#AEN441"
>Functions available to modules</A
>,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DD
><DL
><DT
>open,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>system calls,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>sys_call_table,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>sys_open,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1957"
>T</A
></H2
><DL
><DT
>task,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DD
><DL
><DT
>current,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>tasks
  </DT
><DD
><DL
><DT
>scheduling,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
><DT
>TASK_INTERRUPTIBLE,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>try_module_get,
    <A
HREF="c976.htm#AEN978"
>System Calls</A
>
  </DT
><DT
>tty_structure,
    <A
HREF="c1159.htm#AEN1161"
>Replacing printk</A
>
  </DT
></DL
></DIV
><DIV
CLASS="INDEXDIV"
><HR><H2
CLASS="INDEXDIV"
><A
NAME="AEN1977"
>W</A
></H2
><DL
><DT
>waking up processes,
    <A
HREF="c1050.htm#AEN1052"
>Blocking Processes</A
>
  </DT
><DT
>workqueue_struct,
    <A
HREF="c1209.htm#AEN1211"
>Scheduling Tasks</A
>
  </DT
><DT
>write
  </DT
><DD
><DL
><DT
>in the kernel,
    <A
HREF="x769.htm"
>Read and Write a /proc File</A
>
  </DT
><DD
><DL
></DL
></DD
></DL
></DD
></DL
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN62"
HREF="#AEN62"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In earlier versions of linux, this was known as
	kerneld.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN74"
HREF="#AEN74"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>If such a file exists. Note that the acual behavoir might be
	distribution-dependent.	If you're interested in the details,read the man pages that came with module-init-tools,
	and see for yourself what's really going on. You could use something like <B
CLASS="COMMAND"
> strace modprobe dummy </B
>
	to find out how dummy.ko gets loaded. FYI: The dummy.ko I'm talking about here is part of the mainline kernel
	and can be found in the networking section. It needs to be compiled as a module (and installed, of course) for this to
	work. </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN87"
HREF="#AEN87"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>If you are modifying
	the kernel, to avoid overwriting your existing modules you may want to use the <CODE
CLASS="VARNAME"
>EXTRAVERSION</CODE
> variable in 
	the kernel Makefile to create a seperate directory.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN467"
HREF="#AEN467"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>It's an invaluable tool for
				figuring out things like what files a program is trying to access.  Ever have a program bail silently because it
				couldn't find a file?  It's a PITA!</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN514"
HREF="#AEN514"
><SPAN
CLASS="footnote"
>[5]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>I'm a physicist, not a computer scientist, Jim!</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN520"
HREF="#AEN520"
><SPAN
CLASS="footnote"
>[6]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This isn't quite the same thing as `building all your modules into the kernel', although
			the idea is the same.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN630"
HREF="#AEN630"
><SPAN
CLASS="footnote"
>[7]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is by convention.  When writing a driver, it's OK to put the device
			file in your current directory.  Just make sure you place it in <TT
CLASS="FILENAME"
>/dev</TT
> for a
			production driver</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN736"
HREF="#AEN736"
><SPAN
CLASS="footnote"
>[8]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In version 2.0, in version 2.2 this is done
	automatically if we set the inode to zero.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN814"
HREF="#AEN814"
><SPAN
CLASS="footnote"
>[9]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The difference between the two is that file operations deal with
	the file itself, and inode operations deal with ways of referencing the file, such as creating links to it.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN914"
HREF="#AEN914"
><SPAN
CLASS="footnote"
>[10]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Notice that here the roles of read and write are reversed <EM
>again</EM
>, so in
	<CODE
CLASS="FUNCTION"
>ioctl</CODE
>'s read is to send information to the kernel and write is to receive information from the
	kernel.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN919"
HREF="#AEN919"
><SPAN
CLASS="footnote"
>[11]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This isn't exact. You won't be able to pass a structure, for example, through an
	ioctl --- but you will be able to pass a pointer to the structure.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1089"
HREF="#AEN1089"
><SPAN
CLASS="footnote"
>[12]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The easiest way to keep a file open is to open it with
			<B
CLASS="COMMAND"
>tail -f</B
>.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1097"
HREF="#AEN1097"
><SPAN
CLASS="footnote"
>[13]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This means that the process is still in kernel mode --
			as far as the process is concerned, it issued the <CODE
CLASS="FUNCTION"
>open</CODE
> system call and the system call hasn't
			returned yet.  The process doesn't know somebody else used the CPU for most of the time between the moment it issued the
			call and the moment it returned.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1121"
HREF="#AEN1121"
><SPAN
CLASS="footnote"
>[14]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
> This is because we used <CODE
CLASS="FUNCTION"
>module_interruptible_sleep_on</CODE
>.  We could have
			used <CODE
CLASS="FUNCTION"
>module_sleep_on</CODE
> instead, but that would have resulted is extremely angry users whose <B
CLASS="KEYCAP"
>Ctrl</B
>+<B
CLASS="KEYCAP"
>c</B
>s are ignored.  </P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1169"
HREF="#AEN1169"
><SPAN
CLASS="footnote"
>[15]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><EM
>T</EM
>ele<EM
>ty</EM
>pe, originally a combination keyboard-printer used to
	communicate with a Unix system, and today an abstraction for the text stream used for a Unix program, whether it's a physical
	terminal, an xterm on an X display, a network connection used with telnet, etc.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1272"
HREF="#AEN1272"
><SPAN
CLASS="footnote"
>[16]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>This is standard nomencalture on the Intel architecture where 
                Linux originated.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1289"
HREF="#AEN1289"
><SPAN
CLASS="footnote"
>[17]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In practice IRQ handling can be a bit more 
                complex. Hardware is often designed in a way that chains two interrupt controllers, so that all the IRQs
                from interrupt controller B are cascaded to a certain IRQ from interrupt controller A. Of course that 
                requires that the kernel finds out which IRQ it really was afterwards and that adds overhead. Other 
                architectures offer some special, very low overhead, so called "fast IRQ" or FIQs. To take advantage 
                of them requires handlers to be written in assembler, so they do not really fit into the kernel. They 
                can be made to work similar to the others, but after that procedure, they're no longer any faster than 
                "common" IRQs. SMP enabled kernels running on systems with more than one processor need to solve another
                truckload of problems. It's not enough to know if a certain IRQs has happend, it's also important for 
                what CPU(s) it was for. People still interested in more details, might want to do a web search for 
                "APIC" now ;)</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1344"
HREF="#AEN1344"
><SPAN
CLASS="footnote"
>[18]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>The exception is threaded processes, which can run on several CPU's at once.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1347"
HREF="#AEN1347"
><SPAN
CLASS="footnote"
>[19]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Meaning it is safe to use it with SMP</P
></TD
></TR
></TABLE
></BODY
></HTML
>