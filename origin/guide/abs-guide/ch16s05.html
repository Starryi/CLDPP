<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>5. File and Archiving Commands</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Advanced Bash-Scripting Guide"><link rel="up" href="ch16.html" title="Chapter 16. External Filters, Programs and Commands"><link rel="prev" href="ch16s04.html" title="4. Text Processing Commands"><link rel="next" href="ch16s06.html" title="6. Communications Commands"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. File and Archiving Commands</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16s04.html">Prev</a> </td><th width="60%" align="center">Chapter 16. External Filters, Programs and Commands</th><td width="20%" align="right"> <a accesskey="n" href="ch16s06.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="filearchiv"></a>5. File and Archiving Commands</h2></div></div></div><div class="variablelist"><a name="faarchiving"></a><p class="title"><b><a name="faarchiving1"></a>Archiving</b></p><dl class="variablelist"><dt><span class="term"><a name="tarref"></a><span class="command"><strong>tar</strong></span></span></dt><dd><a class="indexterm" name="idm11883"></a><a class="indexterm" name="idm11885"></a><p>The standard UNIX archiving utility.

	        <a href="#ftn.idm11889" class="footnote" name="idm11889"><sup class="footnote">[75]</sup></a>

	      Originally a
	      <em class="wordasword">Tape ARchiving</em> program, it has
	      developed into a general purpose package that can handle
	      all manner of archiving with all types of destination
	      devices, ranging from tape drives to regular files to even
	      <code class="filename">stdout</code> (see <a class="xref" href="ch03.html#ex58" title="Example 3.4. Backup of all files changed in last day">Example 3.4, &#8220;Backup of all files changed in last day&#8221;</a>). GNU
	      <em class="firstterm">tar</em> has been patched to accept
	      various compression filters, for example: <span class="command"><strong>tar
	      czvf archive_name.tar.gz *</strong></span>, which recursively
	      archives and <a class="link" href="ch16s05.html#gzipref">gzips</a>
	      all files in a directory tree except <a class="link" href="ch16s01.html#dotfilesref">dotfiles</a> in the current
	      working directory (<a class="link" href="ch09s01.html#pwdref">$PWD</a>).

		<a href="#ftn.idm11900" class="footnote" name="idm11900"><sup class="footnote">[76]</sup></a>
            </p><p>Some useful <span class="command"><strong>tar</strong></span> options:  
	      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="option">-c</code> create (a new
		  archive)</p></li><li class="listitem"><p><code class="option">-x</code> extract (files from
		  existing archive)</p></li><li class="listitem"><p><code class="option">--delete</code> delete (files
		  from existing archive)</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>This option will not work on magnetic tape
		  devices.</p></div></li><li class="listitem"><p><code class="option">-r</code> append (files to
		  existing archive)</p></li><li class="listitem"><p><code class="option">-A</code> append
		  (<em class="firstterm">tar</em> files to
		  existing archive)</p></li><li class="listitem"><p><code class="option">-t</code> list (contents of
                  existing archive)</p></li><li class="listitem"><p><code class="option">-u</code> update archive</p></li><li class="listitem"><p><code class="option">-d</code> compare archive with
		  specified filesystem</p></li><li class="listitem"><p><code class="option">--after-date</code> only process
		  files with a date stamp <span class="emphasis"><em>after</em></span>
		  specified date</p></li><li class="listitem"><p><code class="option">-z</code> <a class="link" href="ch16s05.html#gzipref">gzip</a> the archive</p><p>(compress or uncompress, depending on whether
		combined with the <code class="option">-c</code> or
		<code class="option">-x</code>) option</p></li><li class="listitem"><p><code class="option">-j</code>
		  <a class="link" href="ch16s05.html#bzipref">bzip2</a> the
		  archive</p></li></ol></div><p>
	      </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>It may be difficult to recover data from a
	      corrupted <em class="firstterm">gzipped</em> tar
	      archive. When archiving important files, make multiple
	      backups.</p></div></dd><dt><span class="term"><a name="sharref"></a><span class="command"><strong>shar</strong></span></span></dt><dd><a class="indexterm" name="idm11960"></a><a class="indexterm" name="idm11962"></a><p><em class="firstterm">Shell archiving</em> utility.
              The text and/or binary files in a shell archive are
              concatenated without compression, and the resultant
              archive is essentially a shell script, complete with
              <span class="token">#!/bin/sh</span> header, containing all the
              necessary unarchiving commands, as well as the files
              themselves. Unprintable binary characters in the target
              file(s) are converted to printable ASCII characters in the
              output <em class="firstterm">shar</em> file. <em class="firstterm">Shar
              archives</em> still show up in Usenet newsgroups,
              but otherwise <span class="command"><strong>shar</strong></span> has been replaced
              by <span class="command"><strong>tar</strong></span>/<span class="command"><strong>gzip</strong></span>.
              The <span class="command"><strong>unshar</strong></span> command unpacks
              <em class="firstterm">shar</em> archives.</p><p>The
              <span class="command"><strong>mailshar</strong></span> command is a Bash script that
              uses <span class="command"><strong>shar</strong></span> to concatenate multiple files
              into a single one for e-mailing.
              This script supports compression and <a class="link" href="ch16s05.html#uuencoderef">uuencoding</a>.</p></dd><dt><span class="term"><a name="arref"></a><span class="command"><strong>ar</strong></span></span></dt><dd><a class="indexterm" name="idm11984"></a><a class="indexterm" name="idm11986"></a><p>Creation and manipulation utility for archives, mainly
	      used for binary object file libraries.</p></dd><dt><span class="term"><a name="rpmref"></a><span class="command"><strong>rpm</strong></span></span></dt><dd><a class="indexterm" name="idm11995"></a><a class="indexterm" name="idm11997"></a><p>The <em class="firstterm">Red Hat Package Manager</em>, or
	      <span class="command"><strong>rpm</strong></span> utility provides a wrapper for
	      source or binary archives. It includes commands for
	      installing and checking the integrity of packages, among
	      other things.</p><p>A simple <span class="command"><strong>rpm -i package_name.rpm</strong></span>
	      usually suffices to install a package, though there are many
	      more options available.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><strong class="userinput"><code>rpm -qf</code></strong> identifies which package a
	      file originates from.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>rpm -qf /bin/ls</code></strong>
<code class="computeroutput">coreutils-5.2.1-31</code>
	      </pre><p>
	    </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><strong class="userinput"><code>rpm -qa</code></strong> gives a
	      complete list of all installed <em class="firstterm">rpm</em> packages
	      on a given system. An <strong class="userinput"><code>rpm -qa package_name</code></strong>
	      lists only the package(s) corresponding to
	      <code class="filename">package_name</code>.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>rpm -qa</code></strong>
<code class="computeroutput">redhat-logos-1.1.3-1
 glibc-2.2.4-13
 cracklib-2.7-12
 dosfstools-2.7-1
 gdbm-1.8.0-10
 ksymoops-2.4.1-1
 mktemp-1.5-11
 perl-5.6.0-17
 reiserfs-utils-3.x.0j-2
 ...</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>rpm -qa docbook-utils</code></strong>
<code class="computeroutput">docbook-utils-0.6.9-2</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>rpm -qa docbook | grep docbook</code></strong>
<code class="computeroutput">docbook-dtd31-sgml-1.0-10
 docbook-style-dsssl-1.64-3
 docbook-dtd30-sgml-1.0-10
 docbook-dtd40-sgml-1.0-11
 docbook-utils-pdf-0.6.9-2
 docbook-dtd41-sgml-1.0-10
 docbook-utils-0.6.9-2</code>
	      </pre><p>
	    </p></div></dd><dt><span class="term"><a name="cpioref"></a><span class="command"><strong>cpio</strong></span></span></dt><dd><a class="indexterm" name="idm12035"></a><a class="indexterm" name="idm12037"></a><p>This specialized archiving copy command
	      (<span class="command"><strong>c</strong></span>o<span class="command"><strong>p</strong></span>y
	      <span class="command"><strong>i</strong></span>nput and <span class="command"><strong>o</strong></span>utput)
	      is rarely seen any more, having been supplanted by
	      <span class="command"><strong>tar</strong></span>/<span class="command"><strong>gzip</strong></span>. It still
	      has its uses, such as moving a directory tree. With an
	      appropriate block size (for copying) specified, it
	      can be appreciably faster than <span class="command"><strong>tar</strong></span>.</p><div class="example"><a name="ex48"></a><p class="title"><b>Example 16.30. Using <em class="firstterm">cpio</em> to move a directory tree</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

# Copying a directory tree using cpio.

# Advantages of using 'cpio':
#   Speed of copying. It's faster than 'tar' with pipes.
#   Well suited for copying special files (named pipes, etc.)
#+  that 'cp' may choke on.

ARGS=2
E_BADARGS=65

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` source destination"
  exit $E_BADARGS
fi  

source="$1"
destination="$2"

###################################################################
find "$source" -depth | cpio -admvp "$destination"
#               ^^^^^         ^^^^^
#  Read the 'find' and 'cpio' info pages to decipher these options.
#  The above works only relative to $PWD (current directory) . . .
#+ full pathnames are specified.
###################################################################


# Exercise:
# --------

#  Add code to check the exit status ($?) of the 'find | cpio' pipe
#+ and output appropriate error messages if anything went wrong.

exit $?
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="rpm2cpioref"></a><span class="command"><strong>rpm2cpio</strong></span></span></dt><dd><a class="indexterm" name="idm12057"></a><a class="indexterm" name="idm12059"></a><p>This command extracts a
	      <span class="command"><strong>cpio</strong></span> archive from an <a class="link" href="ch16s05.html#rpmref">rpm</a> one.</p><div class="example"><a name="derpm"></a><p class="title"><b>Example 16.31. Unpacking an <em class="firstterm">rpm</em> archive</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# de-rpm.sh: Unpack an 'rpm' archive

: ${1?"Usage: `basename $0` target-file"}
# Must specify 'rpm' archive name as an argument.


TEMPFILE=$$.cpio                         #  Tempfile with "unique" name.
                                         #  $$ is process ID of script.

rpm2cpio &lt; $1 &gt; $TEMPFILE                #  Converts rpm archive into
                                         #+ cpio archive.
cpio --make-directories -F $TEMPFILE -i  #  Unpacks cpio archive.
rm -f $TEMPFILE                          #  Deletes cpio archive.

exit 0

#  Exercise:
#  Add check for whether 1) "target-file" exists and
#+                       2) it is an rpm archive.
#  Hint:                    Parse output of 'file' command.
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="paxref"></a><span class="command"><strong>pax</strong></span></span></dt><dd><a class="indexterm" name="idm12074"></a><a class="indexterm" name="idm12076"></a><p>The <em class="firstterm">pax</em>
            <span class="command"><strong>p</strong></span>ortable <span class="command"><strong>a</strong></span>rchive
            e<span class="command"><strong>x</strong></span>change toolkit facilitates periodic
            file backups and is designed to be cross-compatible
            between various flavors of UNIX. It was designed
	    to replace <a class="link" href="ch16s05.html#tarref">tar</a> and <a class="link" href="ch16s05.html#cpioref">cpio</a>.</p><p>
	  </p><pre class="programlisting">pax -wf daily_backup.pax ~/linux-server/files 
#  Creates a tar archive of all files in the target directory.
#  Note that the options to pax must be in the correct order --
#+ pax -fw     has an entirely different effect.

pax -f daily_backup.pax
#  Lists the files in the archive.

pax -rf daily_backup.pax ~/bsd-server/files
#  Restores the backed-up files from the Linux machine
#+ onto a BSD one.</pre><p>
	  </p><p>Note that <em class="firstterm">pax</em> handles many of
            the standard archiving and compression commands.</p></dd></dl></div><div class="variablelist"><a name="facompression"></a><p class="title"><b><a name="facompression1"></a>Compression</b></p><dl class="variablelist"><dt><span class="term"><a name="gzipref"></a><span class="command"><strong>gzip</strong></span></span></dt><dd><a class="indexterm" name="idm12098"></a><a class="indexterm" name="idm12100"></a><p>The standard GNU/UNIX compression utility, replacing
	      the inferior and proprietary
	      <span class="command"><strong>compress</strong></span>. The corresponding decompression
	      command is <span class="command"><strong>gunzip</strong></span>, which is the equivalent of
	      <span class="command"><strong>gzip -d</strong></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="option">-c</code> option sends the output of
	      <span class="command"><strong>gzip</strong></span> to <code class="filename">stdout</code>. This
	      is useful when <a class="link" href="ch03.html#piperef">piping</a> to other
	      commands.</p></div><p><a name="zcatref"></a></p><p>The <span class="command"><strong>zcat</strong></span> filter decompresses a
	      <em class="firstterm">gzipped</em> file to
	      <code class="filename">stdout</code>, as possible input to a pipe or
	      redirection. This is, in effect, a <span class="command"><strong>cat</strong></span>
	      command that works on compressed files (including files
	      processed with the older <a class="link" href="ch16s05.html#compressref">compress</a>
	      utility). The <span class="command"><strong>zcat</strong></span> command is equivalent to
	      <span class="command"><strong>gzip -dc</strong></span>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>On some commercial UNIX systems, <span class="command"><strong>zcat</strong></span>
	      is a synonym for <span class="command"><strong>uncompress -c</strong></span>,
	      and will not work on <em class="firstterm">gzipped</em>
	      files.</p></div><p>See also <a class="xref" href="ch07s03.html#ex14" title="Example 7.7. zmore">Example 7.7, &#8220;<em class="firstterm">zmore</em>&#8221;</a>.</p></dd><dt><span class="term"><a name="bzipref"></a><span class="command"><strong>bzip2</strong></span></span></dt><dd><a class="indexterm" name="idm12135"></a><a class="indexterm" name="idm12137"></a><p>An alternate compression utility, usually more efficient
	      (but slower) than <span class="command"><strong>gzip</strong></span>, especially on
	      large files. The corresponding decompression command is
	      <span class="command"><strong>bunzip2</strong></span>.</p><p>Similar to the <span class="command"><strong>zcat</strong></span> command,
	      <span class="command"><strong>bzcat</strong></span> decompresses a
	      <em class="firstterm">bzipped2-ed</em> file to
	      <code class="filename">stdout</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Newer versions of <a class="link" href="ch16s05.html#tarref">tar</a> have been patched with
	      <span class="command"><strong>bzip2</strong></span> support.</p></div></dd><dt><span class="term"><a name="compressref"></a><span class="command"><strong>compress</strong></span>, </span><span class="term"><a name="uncompressref"></a><span class="command"><strong>uncompress</strong></span></span></dt><dd><a class="indexterm" name="idm12160"></a><a class="indexterm" name="idm12162"></a><a class="indexterm" name="idm12165"></a><a class="indexterm" name="idm12167"></a><p>This is an older, proprietary compression
	      utility found in commercial UNIX distributions. The
	      more efficient <span class="command"><strong>gzip</strong></span> has largely
	      replaced it. Linux distributions generally include a
	      <span class="command"><strong>compress</strong></span> workalike for compatibility,
	      although <span class="command"><strong>gunzip</strong></span> can unarchive files
	      treated with <span class="command"><strong>compress</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>The <span class="command"><strong>znew</strong></span> command transforms
	      <em class="firstterm">compressed</em> files into
	      <em class="firstterm">gzipped</em> ones.</p></div></dd><dt><span class="term"><a name="sqref"></a><span class="command"><strong>sq</strong></span></span></dt><dd><a class="indexterm" name="idm12185"></a><a class="indexterm" name="idm12187"></a><p>Yet another compression (<span class="command"><strong>sq</strong></span>ueeze)
	      utility, a filter that works only on sorted
	      <a class="link" href="ch03.html#asciidef">ASCII</a> word lists. It
	      uses the standard invocation syntax for a filter,
	      <span class="command"><strong>sq &lt; input-file &gt; output-file</strong></span>.
	      Fast, but not nearly as efficient as <a class="link" href="ch16s05.html#gzipref">gzip</a>.  The corresponding
	      uncompression filter is <span class="command"><strong>unsq</strong></span>, invoked
	      like <span class="command"><strong>sq</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>The output of <span class="command"><strong>sq</strong></span> may be
	        piped to <span class="command"><strong>gzip</strong></span> for further
		compression.</p></div></dd><dt><span class="term"><a name="zipref"></a><span class="command"><strong>zip</strong></span>, </span><span class="term"><span class="command"><strong>unzip</strong></span></span></dt><dd><a class="indexterm" name="idm12208"></a><a class="indexterm" name="idm12210"></a><a class="indexterm" name="idm12213"></a><a class="indexterm" name="idm12215"></a><p>Cross-platform file archiving and compression utility
	      compatible with DOS <em class="firstterm">pkzip.exe</em>.
	      <span class="quote">&#8220;<span class="quote">Zipped</span>&#8221;</span> archives seem to be a more
	      common medium of file exchange on the Internet than
	      <span class="quote">&#8220;<span class="quote">tarballs.</span>&#8221;</span></p></dd><dt><span class="term"><a name="unarcref"></a><span class="command"><strong>unarc</strong></span>, </span><span class="term"><span class="command"><strong>unarj</strong></span>, </span><span class="term"><span class="command"><strong>unrar</strong></span></span></dt><dd><a class="indexterm" name="idm12231"></a><a class="indexterm" name="idm12233"></a><a class="indexterm" name="idm12236"></a><a class="indexterm" name="idm12238"></a><a class="indexterm" name="idm12241"></a><a class="indexterm" name="idm12243"></a><p>These Linux utilities permit unpacking archives
	      compressed with the DOS <em class="firstterm">arc.exe</em>,
	      <em class="firstterm">arj.exe</em>, and
	      <em class="firstterm">rar.exe</em> programs.</p></dd><dt><span class="term"><a name="lzmaref"></a><span class="command"><strong>lzma</strong></span>, </span><span class="term"><span class="command"><strong>unlzma</strong></span>, </span><span class="term"><span class="command"><strong>lzcat</strong></span></span></dt><dd><a class="indexterm" name="idm12259"></a><a class="indexterm" name="idm12261"></a><a class="indexterm" name="idm12264"></a><a class="indexterm" name="idm12266"></a><a class="indexterm" name="idm12269"></a><a class="indexterm" name="idm12271"></a><p>Highly efficient Lempel-Ziv-Markov compression.
	      The syntax of <em class="firstterm">lzma</em> is similar to
              that of <em class="firstterm">gzip</em>. The <a class="ulink" href="http://www.7-zip.org/sdk.html" target="_top">7-zip Website</a>
              has more information.</p></dd><dt><span class="term"><a name="xzref"></a><span class="command"><strong>xz</strong></span>, </span><span class="term"><span class="command"><strong>unxz</strong></span>, </span><span class="term"><span class="command"><strong>xzcat</strong></span></span></dt><dd><a class="indexterm" name="idm12287"></a><a class="indexterm" name="idm12289"></a><a class="indexterm" name="idm12292"></a><a class="indexterm" name="idm12294"></a><a class="indexterm" name="idm12297"></a><a class="indexterm" name="idm12299"></a><p>A new high-efficiency compression tool, backward compatible
	      with <em class="firstterm">lzma</em>, and with an invocation
	      syntax similar to <em class="firstterm">gzip</em>. For
	      more information, see the <a class="ulink" href="http://en.wikipedia.org/wiki/Xz" target="_top">Wikipedia
	      entry</a>.</p></dd></dl></div><div class="variablelist"><a name="fainformation"></a><p class="title"><b><a name="fainformation1"></a>File Information</b></p><dl class="variablelist"><dt><span class="term"><a name="fileref"></a><span class="command"><strong>file</strong></span></span></dt><dd><a class="indexterm" name="idm12314"></a><a class="indexterm" name="idm12316"></a><p>A utility for identifying file types. The command
	      <strong class="userinput"><code>file file-name</code></strong> will return a
	      file specification for <code class="filename">file-name</code>,
	      such as <code class="computeroutput">ascii text</code> or
	      <code class="computeroutput">data</code>. It references
	      the <a class="link" href="ch02.html#magnumref">magic numbers</a>
	      found in <code class="filename">/usr/share/magic</code>,
	      <code class="filename">/etc/magic</code>, or
	      <code class="filename">/usr/lib/magic</code>, depending on the
	      Linux/UNIX distribution.</p><p>The <code class="option">-f</code> option causes
	      <span class="command"><strong>file</strong></span> to run in <a class="link" href="ch16s03.html#batchprocref">batch</a> mode, to read from
	      a designated file a list of filenames to analyze. The
	      <code class="option">-z</code> option, when used on a compressed
	      target file, forces an attempt to analyze the uncompressed
	      file type.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>file test.tar.gz</code></strong>
<code class="computeroutput">test.tar.gz: gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix</code>

<code class="prompt">bash </code><strong class="userinput"><code>file -z test.tar.gz</code></strong>
<code class="computeroutput">test.tar.gz: GNU tar archive (gzip compressed data, deflated,
 last modified: Sun Sep 16 13:34:51 2001, os: Unix)</code>
	      </pre><p>
	    </p><p>
	      </p><pre class="programlisting"># Find sh and Bash scripts in a given directory:

DIRECTORY=/usr/local/bin
KEYWORD=Bourne
# Bourne and Bourne-Again shell scripts

file $DIRECTORY/* | fgrep $KEYWORD

# Output:

# /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
# /usr/local/bin/burnit:           Bourne-Again shell script text executable
# /usr/local/bin/cassette.sh:      Bourne shell script text executable
# /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
# . . .</pre><p>
	    </p><div class="example"><a name="stripc"></a><p class="title"><b>Example 16.32. Stripping comments from C program files</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# strip-comment.sh: Strips out the comments (/* COMMENT */) in a C program.

E_NOARGS=0
E_ARGERROR=66
E_WRONG_FILE_TYPE=67

if [ $# -eq "$E_NOARGS" ]
then
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2 # Error message to stderr.
  exit $E_ARGERROR
fi  

# Test for correct file type.
type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
# "file $1" echoes file type . . .
# Then awk removes the first field, the filename . . .
# Then the result is fed into the variable "type."
correct_type="ASCII C program text"

if [ "$type" != "$correct_type" ]
then
  echo
  echo "This script works on C program files only."
  echo
  exit $E_WRONG_FILE_TYPE
fi  


# Rather cryptic sed script:
#--------
sed '
/^\/\*/d
/.*\*\//d
' $1
#--------
# Easy to understand if you take several hours to learn sed fundamentals.


#  Need to add one more line to the sed script to deal with
#+ case where line of code has a comment following it on same line.
#  This is left as a non-trivial exercise.

#  Also, the above code deletes non-comment lines with a "*/" . . .
#+ not a desirable result.

exit 0


# ----------------------------------------------------------------
# Code below this line will not execute because of 'exit 0' above.

# Stephane Chazelas suggests the following alternative:

usage() {
  echo "Usage: `basename $0` C-program-file" &gt;&amp;2
  exit 1
}

WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
[[ $# -eq 1 ]] || usage
case `file "$1"` in
  *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
     | tr '\377\n' '\n\377' \
     | sed -ne 'p;n' \
     | tr -d '\n' | tr '\377' '\n';;
  *) usage;;
esac

#  This is still fooled by things like:
#  printf("/*");
#  or
#  /*  /* buggy embedded comment */
#
#  To handle all special cases (comments in strings, comments in string
#+ where there is a \", \\" ...),
#+ the only way is to write a C parser (using lex or yacc perhaps?).

exit 0
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="whichref"></a><span class="command"><strong>which</strong></span></span></dt><dd><a class="indexterm" name="idm12351"></a><a class="indexterm" name="idm12353"></a><p><span class="command"><strong>which command</strong></span> gives the full path
	      to <span class="quote">&#8220;<span class="quote">command.</span>&#8221;</span> This is useful for finding
	      out whether a particular command or utility is installed
	      on the system.</p><p><strong class="userinput"><code>$bash which rm</code></strong>
</p><pre class="screen"><code class="computeroutput">/usr/bin/rm</code></pre><p>
	  </p><p>For an interesting use of this command, see <a class="xref" href="ch36s05.html#horserace" title="Example 36.16. A &#8220;horserace&#8221; game">Example 36.16, &#8220;A <span class="quote">&#8220;<span class="quote">horserace</span>&#8221;</span> game&#8221;</a>.</p></dd><dt><span class="term"><a name="whereisref"></a><span class="command"><strong>whereis</strong></span></span></dt><dd><a class="indexterm" name="idm12370"></a><a class="indexterm" name="idm12372"></a><p>Similar to <span class="command"><strong>which</strong></span>, above,
	      <span class="command"><strong>whereis command</strong></span> gives the
	      full path to <span class="quote">&#8220;<span class="quote">command,</span>&#8221;</span> but also to its
	      <a class="link" href="ch16s01.html#manref">manpage</a>.</p><p><strong class="userinput"><code>$bash whereis rm</code></strong>
</p><pre class="screen"><code class="computeroutput">rm: /bin/rm /usr/share/man/man1/rm.1.bz2</code></pre><p>
	  </p></dd><dt><span class="term"><a name="whatisref"></a><span class="command"><strong>whatis</strong></span></span></dt><dd><a class="indexterm" name="idm12389"></a><a class="indexterm" name="idm12391"></a><p><span class="command"><strong>whatis command</strong></span> looks up
	      <span class="quote">&#8220;<span class="quote">command</span>&#8221;</span> in the
	      <em class="replaceable"><code>whatis</code></em> database. This is useful
	      for identifying system commands and important configuration
	      files. Consider it a simplified <span class="command"><strong>man</strong></span>
	      command.</p><p><strong class="userinput"><code>$bash whatis whatis</code></strong>
</p><pre class="screen"><code class="computeroutput">whatis               (1)  - search the whatis database for complete words</code></pre><p>
	  </p><div class="example"><a name="what"></a><p class="title"><b>Example 16.33. Exploring <code class="filename">/usr/X11R6/bin</code></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

# What are all those mysterious binaries in /usr/X11R6/bin?

DIRECTORY="/usr/X11R6/bin"
# Try also "/bin", "/usr/bin", "/usr/local/bin", etc.

for file in $DIRECTORY/*
do
  whatis `basename $file`   # Echoes info about the binary.
done

exit 0

#  Note: For this to work, you must create a "whatis" database
#+ with /usr/sbin/makewhatis.
#  You may wish to redirect output of this script, like so:
#    ./what.sh &gt;&gt;whatis.db
#  or view it a page at a time on stdout,
#    ./what.sh | less
</pre></div></div><br class="example-break"><p>See also <a class="xref" href="ch11s01.html#fileinfo" title="Example 11.3. Fileinfo: operating on a file list contained in a variable">Example 11.3, &#8220;<span class="emphasis"><em>Fileinfo:</em></span> operating on a file list
	        contained in a variable&#8221;</a>.</p></dd><dt><span class="term"><a name="vdirref"></a><span class="command"><strong>vdir</strong></span></span></dt><dd><a class="indexterm" name="idm12414"></a><a class="indexterm" name="idm12416"></a><p>Show a detailed directory listing. The effect is similar to
	      <a class="link" href="ch16s01.html#lsref">ls -lb</a>.</p><p>This is one of the GNU
	    <em class="firstterm">fileutils</em>.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>vdir</code></strong>
<code class="computeroutput">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</code>

<code class="prompt">bash </code><strong class="userinput"><code>ls -l</code></strong>
<code class="computeroutput">total 10
 -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
 -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
 -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo</code>
	      </pre><p>
	      </p></dd><dt><span class="term"><a name="locateref"></a><span class="command"><strong>locate</strong></span>, </span><span class="term"><a name="slocateref"></a><span class="command"><strong>slocate</strong></span></span></dt><dd><a class="indexterm" name="idm12439"></a><a class="indexterm" name="idm12441"></a><a class="indexterm" name="idm12444"></a><a class="indexterm" name="idm12446"></a><p>The <span class="command"><strong>locate</strong></span> command searches for
	      files using a database stored for just that purpose. The
	      <span class="command"><strong>slocate</strong></span> command is the secure version of
	      <span class="command"><strong>locate</strong></span> (which may be aliased to
	      <span class="command"><strong>slocate</strong></span>).</p><p><strong class="userinput"><code>$bash locate hickson</code></strong>
</p><pre class="screen"><code class="computeroutput">/usr/lib/xephem/catalogs/hickson.edb</code></pre></dd><dt><span class="term"><a name="getfaclref"></a><span class="command"><strong>getfacl</strong></span>, </span><span class="term"><a name="setfaclref"></a><span class="command"><strong>setfacl</strong></span></span></dt><dd><a class="indexterm" name="idm12466"></a><a class="indexterm" name="idm12468"></a><a class="indexterm" name="idm12471"></a><a class="indexterm" name="idm12473"></a><p>These commands <em class="firstterm">retrieve</em> or
              <em class="firstterm">set</em> the <span class="command"><strong>f</strong></span>ile
              <span class="command"><strong>a</strong></span>ccess <span class="command"><strong>c</strong></span>ontrol
              <span class="command"><strong>l</strong></span>ist -- the <em class="firstterm">owner</em>,
	      <em class="firstterm">group</em>, and file permissions.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>getfacl *</code></strong>
<code class="computeroutput"># file: test1.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--

 # file: test2.txt
 # owner: bozo
 # group: bozgrp
 user::rw-
 group::rw-
 other::r--</code>
 

 
<code class="prompt">bash$ </code><strong class="userinput"><code>setfacl -m u:bozo:rw yearly_budget.csv</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>getfacl yearly_budget.csv</code></strong>
<code class="computeroutput"># file: yearly_budget.csv
 # owner: accountant
 # group: budgetgrp
 user::rw-
 user:bozo:rw-
 user:accountant:rw-
 group::rw-
 mask::rw-
 other::r--</code>
	      </pre><p>
	    </p></dd><dt><span class="term"><a name="readlinkref"></a><span class="command"><strong>readlink</strong></span></span></dt><dd><a class="indexterm" name="idm12500"></a><a class="indexterm" name="idm12502"></a><p>Disclose the file that a symbolic link points to.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>readlink /usr/bin/awk</code></strong>
<code class="computeroutput">../../bin/gawk</code>
	      </pre><p>
	    </p></dd><dt><span class="term"><a name="stringsref"></a><span class="command"><strong>strings</strong></span></span></dt><dd><a class="indexterm" name="idm12516"></a><a class="indexterm" name="idm12518"></a><p>Use the <span class="command"><strong>strings</strong></span> command to find
	      printable strings in a binary or data file. It will list
	      sequences of printable characters found in the target
	      file. This might be handy for a quick 'n dirty examination
	      of a core dump or for looking at an unknown graphic image
	      file (<strong class="userinput"><code>strings image-file | more</code></strong> might
	      show something like <em class="firstterm">JFIF</em>,
	      which would identify the file as a <em class="firstterm">jpeg</em>
	      graphic). In a script, you would probably
	      parse the output of <span class="command"><strong>strings</strong></span>
	      with <a class="link" href="ch16s04.html#grepref">grep</a> or <a class="link" href="apc.html#sedref">sed</a>. See <a class="xref" href="ch11s01.html#bingrep" title="Example 11.8. A grep replacement for binary files">Example 11.8, &#8220;A <em class="firstterm">grep</em> replacement
	        for binary files&#8221;</a>
	      and <a class="xref" href="ch11s01.html#findstring" title="Example 11.10. Checking all the binaries in a directory for authorship">Example 11.10, &#8220;Checking all the binaries in a directory for
	      authorship&#8221;</a>.</p><div class="example"><a name="wstrings"></a><p class="title"><b>Example 16.34. An <span class="quote">&#8220;<span class="quote">improved</span>&#8221;</span>
	      <em class="firstterm">strings</em> command</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# wstrings.sh: "word-strings" (enhanced "strings" command)
#
#  This script filters the output of "strings" by checking it
#+ against a standard word list file.
#  This effectively eliminates gibberish and noise,
#+ and outputs only recognized words.

# ===========================================================
#                 Standard Check for Script Argument(s)
ARGS=1
E_BADARGS=85
E_NOFILE=86

if [ $# -ne $ARGS ]
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

if [ ! -f "$1" ]                      # Check if file exists.
then
    echo "File \"$1\" does not exist."
    exit $E_NOFILE
fi
# ===========================================================


MINSTRLEN=3                           #  Minimum string length.
WORDFILE=/usr/share/dict/linux.words  #  Dictionary file.
#  May specify a different word list file
#+ of one-word-per-line format.
#  For example, the "yawl" word-list package,
#  http://bash.deta.in/yawl-0.3.2.tar.gz


wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
       tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`

# Translate output of 'strings' command with multiple passes of 'tr'.
#  "tr A-Z a-z"  converts to lowercase.
#  "tr '[:space:]'"  converts whitespace characters to Z's.
#  "tr -cs '[:alpha:]' Z"  converts non-alphabetic characters to Z's,
#+ and squeezes multiple consecutive Z's.
#  "tr -s '\173-\377' Z"  converts all characters past 'z' to Z's
#+ and squeezes multiple consecutive Z's,
#+ which gets rid of all the weird characters that the previous
#+ translation failed to deal with.
#  Finally, "tr Z ' '" converts all those Z's to whitespace,
#+ which will be seen as word separators in the loop below.

#  ***********************************************************************
#  Note the technique of feeding/piping the output of 'tr' back to itself,
#+ but with different arguments and/or options on each successive pass.
#  ***********************************************************************


for word in $wlist                    #  Important:
                                      #  $wlist must not be quoted here.
                                      # "$wlist" does not work.
                                      #  Why not?
do
  strlen=${#word}                     #  String length.
  if [ "$strlen" -lt "$MINSTRLEN" ]   #  Skip over short strings.
  then
    continue
  fi

  grep -Fw $word "$WORDFILE"          #   Match whole words only.
#      ^^^                            #  "Fixed strings" and
                                      #+ "whole words" options. 
done  

exit $?
</pre></div></div><br class="example-break"></dd></dl></div><div class="variablelist"><a name="comparisonn"></a><p class="title"><b><a name="comparisonn1"></a>Comparison</b></p><dl class="variablelist"><dt><span class="term"><a name="diffref"></a><span class="command"><strong>diff</strong></span>, </span><span class="term"><span class="command"><strong>patch</strong></span></span></dt><dd><a class="indexterm" name="idm12546"></a><a class="indexterm" name="idm12548"></a><a class="indexterm" name="idm12551"></a><a class="indexterm" name="idm12553"></a><p><span class="command"><strong>diff</strong></span>: flexible file comparison
	      utility. It compares the target files line-by-line
	      sequentially.  In some applications, such as comparing
	      word dictionaries, it may be helpful to filter the
	      files through <a class="link" href="ch16s04.html#sortref">sort</a>
	      and <span class="command"><strong>uniq</strong></span> before piping them
	      to <span class="command"><strong>diff</strong></span>. <strong class="userinput"><code>diff file-1
	      file-2</code></strong> outputs the lines in the files that
	      differ, with carets showing which file each particular
	      line belongs to.</p><p>The <code class="option">--side-by-side</code> option to
	    <span class="command"><strong>diff</strong></span> outputs each compared file, line by
	    line, in separate columns, with non-matching lines marked. The
	    <code class="option">-c</code> and <code class="option">-u</code> options likewise
	    make the output of the command easier to interpret.</p><p>There are available various fancy frontends for
	    <span class="command"><strong>diff</strong></span>, such as <span class="command"><strong>sdiff</strong></span>,
	    <span class="command"><strong>wdiff</strong></span>, <span class="command"><strong>xdiff</strong></span>, and
	    <span class="command"><strong>mgdiff</strong></span>. </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><a name="differr2"></a>The <span class="command"><strong>diff</strong></span>
              command returns an exit status of <span class="errorcode">0</span>
              if the compared files are identical, and
              <span class="errorcode">1</span> if they differ (or
              <span class="errorcode">2</span> when <em class="firstterm">binary</em>
              files are being compared).  This permits use of
              <span class="command"><strong>diff</strong></span> in a test construct within a shell
              script (see below).</p></div><p>A common use for <span class="command"><strong>diff</strong></span> is generating
	      difference files to be used with <span class="command"><strong>patch</strong></span>
	      The <code class="option">-e</code> option outputs files suitable
	      for <span class="command"><strong>ed</strong></span> or <span class="command"><strong>ex</strong></span>
	      scripts.</p><p><a name="patchref"></a></p><p><span class="command"><strong>patch</strong></span>: flexible versioning
	      utility. Given a difference file generated by
	      <span class="command"><strong>diff</strong></span>, <span class="command"><strong>patch</strong></span> can
	      upgrade a previous version of a package to a newer version.
	      It is much more convenient to distribute a relatively
	      small <span class="quote">&#8220;<span class="quote">diff</span>&#8221;</span> file than the entire body of a
	      newly revised package. Kernel <span class="quote">&#8220;<span class="quote">patches</span>&#8221;</span> have
	      become the preferred method of distributing the frequent
	      releases of the Linux kernel.</p><pre class="programlisting">patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file'
# and applies them to the files referenced therein.
# This upgrades to a newer version of the package.</pre><p>Patching the kernel:</p><pre class="programlisting">cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="command"><strong>diff</strong></span> command can also
	      recursively compare directories (for the filenames
	      present).</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>diff -r ~/notes1 ~/notes2</code></strong>
<code class="computeroutput">Only in /home/bozo/notes1: file02
 Only in /home/bozo/notes1: file03
 Only in /home/bozo/notes2: file04</code>
	      </pre><p>
	    </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><a name="zdiffref"></a></p><p>Use <span class="command"><strong>zdiff</strong></span> to compare
	       <em class="firstterm">gzipped</em> files.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><a name="diffstatref"></a></p><p>Use <span class="command"><strong>diffstat</strong></span> to create
	       a histogram (point-distribution graph) of output from
	       <span class="command"><strong>diff</strong></span>.</p></div></dd><dt><span class="term"><a name="diff3ref"></a><span class="command"><strong>diff3</strong></span>, </span><span class="term"><span class="command"><strong>merge</strong></span></span></dt><dd><a class="indexterm" name="idm12628"></a><a class="indexterm" name="idm12630"></a><a class="indexterm" name="idm12633"></a><a class="indexterm" name="idm12635"></a><p>An extended version of <span class="command"><strong>diff</strong></span> that compares
	      three files at a time. This command returns an exit value
	      of 0 upon successful execution, but unfortunately this gives
	      no information about the results of the comparison.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>diff3 file-1 file-2 file-3</code></strong>
<code class="computeroutput">====
 1:1c
   This is line 1 of "file-1".
 2:1c
   This is line 1 of "file-2".
 3:1c
   This is line 1 of "file-3"</code>
	      </pre><p>
	      </p><p><a name="mergeref"></a>The <span class="command"><strong>merge</strong></span>
	      (3-way file merge) command is an interesting adjunct to
	      <em class="firstterm">diff3</em>. Its syntax is
	      <strong class="userinput"><code>merge Mergefile file1 file2</code></strong>.
	      The result is to output to <code class="filename">Mergefile</code>
	      the changes that lead from <code class="filename">file1</code>
	      to <code class="filename">file2</code>. Consider this command
	      a stripped-down version of <em class="firstterm">patch</em>.</p></dd><dt><span class="term"><a name="sdiffref"></a><span class="command"><strong>sdiff</strong></span></span></dt><dd><a class="indexterm" name="idm12659"></a><a class="indexterm" name="idm12661"></a><p>Compare and/or edit two files in order to merge
	      them into an output file. Because of its interactive nature,
	      this command would find little use in a script.</p></dd><dt><span class="term"><a name="cmpref"></a><span class="command"><strong>cmp</strong></span></span></dt><dd><a class="indexterm" name="idm12670"></a><a class="indexterm" name="idm12672"></a><p>The <span class="command"><strong>cmp</strong></span> command is a simpler version of
	      <span class="command"><strong>diff</strong></span>, above. Whereas <span class="command"><strong>diff</strong></span>
	      reports the differences between two files,
	      <span class="command"><strong>cmp</strong></span> merely shows at what point they
	      differ.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Like <span class="command"><strong>diff</strong></span>, <span class="command"><strong>cmp</strong></span>
	    returns an exit status of 0 if the compared files are
	    identical, and 1 if they differ. This permits use in a test
	    construct within a shell script.</p></div><div class="example"><a name="filecomp"></a><p class="title"><b>Example 16.35. Using <em class="firstterm">cmp</em> to compare two files
	        within a script.</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# file-comparison.sh

ARGS=2  # Two args to script expected.
E_BADARGS=85
E_UNREADABLE=86

if [ $# -ne "$ARGS" ]
then
  echo "Usage: `basename $0` file1 file2"
  exit $E_BADARGS
fi

if [[ ! -r "$1" || ! -r "$2" ]]
then
  echo "Both files to be compared must exist and be readable."
  exit $E_UNREADABLE
fi

cmp $1 $2 &amp;&gt; /dev/null
#   Redirection to /dev/null buries the output of the "cmp" command.
#   cmp -s $1 $2  has same result ("-s" silent flag to "cmp")
#   Thank you  Anders Gustavsson for pointing this out.
#
#  Also works with 'diff', i.e.,
#+ diff $1 $2 &amp;&gt; /dev/null

if [ $? -eq 0 ]         # Test exit status of "cmp" command.
then
  echo "File \"$1\" is identical to file \"$2\"."
else  
  echo "File \"$1\" differs from file \"$2\"."
fi

exit 0
</pre></div></div><br class="example-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Use <span class="command"><strong>zcmp</strong></span> on
	      <em class="firstterm">gzipped</em> files.</p></div></dd><dt><span class="term"><a name="commref"></a><span class="command"><strong>comm</strong></span></span></dt><dd><a class="indexterm" name="idm12697"></a><a class="indexterm" name="idm12699"></a><p>Versatile file comparison utility. The files must be
	      sorted for this to be useful.</p><p><span class="command"><strong>comm
		<em class="replaceable"><code>-options</code></em>
		<em class="replaceable"><code>first-file</code></em>
		<em class="replaceable"><code>second-file</code></em></strong></span></p><p><strong class="userinput"><code>comm file-1 file-2</code></strong> outputs three columns:
	      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>column 1 = lines unique to <code class="filename">file-1</code></p></li><li class="listitem"><p>column 2 = lines unique to <code class="filename">file-2</code></p></li><li class="listitem"><p>column 3 = lines common to both.</p></li></ul></div><p>The options allow suppressing output of one or more columns.
	      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="option">-1</code> suppresses column
		    <code class="literal">1</code></p></li><li class="listitem"><p><code class="option">-2</code> suppresses column
		    <code class="literal">2</code></p></li><li class="listitem"><p><code class="option">-3</code> suppresses column
		    <code class="literal">3</code></p></li><li class="listitem"><p><code class="option">-12</code> suppresses both columns
		    <code class="literal">1</code> and <code class="literal">2</code>, etc.</p></li></ul></div><p>
	    </p><p>This command is useful for comparing
	      <span class="quote">&#8220;<span class="quote">dictionaries</span>&#8221;</span> or <em class="firstterm">word
	      lists</em> -- sorted text files with one word per
	      line.</p></dd></dl></div><div class="variablelist"><a name="fautils"></a><p class="title"><b><a name="fautils1"></a>Utilities</b></p><dl class="variablelist"><dt><span class="term"><a name="basenameref"></a><span class="command"><strong>basename</strong></span></span></dt><dd><a class="indexterm" name="idm12749"></a><a class="indexterm" name="idm12751"></a><p>Strips the path information from a file name, printing
	      only the file name. The construction  <strong class="userinput"><code>basename
		$0</code></strong> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <span class="quote">&#8220;<span class="quote">usage</span>&#8221;</span> messages if, 
	      for example a script is called with missing arguments:
              </p><pre class="programlisting">echo "Usage: `basename $0` arg1 arg2 ... argn"</pre><p>
	    </p></dd><dt><span class="term"><a name="dirnameref"></a><span class="command"><strong>dirname</strong></span></span></dt><dd><a class="indexterm" name="idm12763"></a><a class="indexterm" name="idm12765"></a><p>Strips the <span class="command"><strong>basename</strong></span> from
	    a filename, printing only the path information.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="command"><strong>basename</strong></span> and <span class="command"><strong>dirname</strong></span>
		can operate on any arbitrary string. The argument
		does not need to refer to an existing file, or
		even be a filename for that matter (see <a class="xref" href="apa.html#daysbetween" title="Example A.7. days-between: Days between two dates">Example A.7, &#8220;<em class="firstterm">days-between</em>: Days between two
        dates&#8221;</a>).</p></div><div class="example"><a name="ex35"></a><p class="title"><b>Example 16.36. <em class="firstterm">basename</em> and
	      <em class="firstterm">dirname</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

address=/home/bozo/daily-journal.txt

echo "Basename of /home/bozo/daily-journal.txt = `basename $address`"
echo "Dirname of /home/bozo/daily-journal.txt = `dirname $address`"
echo
echo "My own home is `basename ~/`."         # `basename ~` also works.
echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.

exit 0
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="splitref"></a><span class="command"><strong>split</strong></span>, </span><span class="term"><a name="csplitref"></a><span class="command"><strong>csplit</strong></span></span></dt><dd><a class="indexterm" name="idm12788"></a><a class="indexterm" name="idm12790"></a><a class="indexterm" name="idm12793"></a><a class="indexterm" name="idm12795"></a><p>These are utilities for splitting a file into smaller
	      chunks. Their usual use is for splitting up large files
	      in order to back them up on floppies or preparatory to
	      e-mailing or uploading them.</p><p>The <span class="command"><strong>csplit</strong></span> command splits a file
	      according to <em class="firstterm">context</em>, the split occuring
	      where patterns are matched.</p><div class="example"><a name="splitcopy"></a><p class="title"><b>Example 16.37. A script that copies itself in sections</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# splitcopy.sh

#  A script that splits itself into chunks,
#+ then reassembles the chunks into an exact copy
#+ of the original script.

CHUNKSIZE=4    #  Size of first chunk of split files.
OUTPREFIX=xx   #  csplit prefixes, by default,
               #+ files with "xx" ...

csplit "$0" "$CHUNKSIZE"

# Some comment lines for padding . . .
# Line 15
# Line 16
# Line 17
# Line 18
# Line 19
# Line 20

cat "$OUTPREFIX"* &gt; "$0.copy"  # Concatenate the chunks.
rm "$OUTPREFIX"*               # Get rid of the chunks.

exit $?
</pre></div></div><br class="example-break"></dd></dl></div><div class="variablelist"><a name="faencencr"></a><p class="title"><b><a name="faencencr1"></a>Encoding and Encryption</b></p><dl class="variablelist"><dt><span class="term"><a name="sumref"></a><span class="command"><strong>sum</strong></span>, </span><span class="term"><a name="cksumref"></a><span class="command"><strong>cksum</strong></span>, </span><span class="term"><a name="md5sumref"></a><span class="command"><strong>md5sum</strong></span>, </span><span class="term"><a name="sha1sumref"></a><span class="command"><strong>sha1sum</strong></span></span></dt><dd><a class="indexterm" name="idm12822"></a><a class="indexterm" name="idm12824"></a><a class="indexterm" name="idm12827"></a><a class="indexterm" name="idm12829"></a><a class="indexterm" name="idm12832"></a><a class="indexterm" name="idm12834"></a><a class="indexterm" name="idm12837"></a><p><a name="checksumref"></a>These are utilities for
              generating <em class="firstterm">checksums</em>. A
	      <em class="firstterm">checksum</em> is a number

		<a href="#ftn.idm12844" class="footnote" name="idm12844"><sup class="footnote">[77]</sup></a>

              mathematically calculated from the contents of a file,
              for the purpose of checking its integrity. A script might
              refer to a list of checksums for security purposes, such
              as ensuring that the contents of key system files have not
              been altered or corrupted. For security applications, use
              the <span class="command"><strong>md5sum</strong></span> (<span class="command"><strong>m</strong></span>essage
              <span class="command"><strong>d</strong></span>igest <span class="command"><strong>5</strong></span>
              check<span class="command"><strong>sum</strong></span>) command, or better yet, the
              newer <span class="command"><strong>sha1sum</strong></span> (Secure Hash Algorithm).

	        <a href="#ftn.idm12853" class="footnote" name="idm12853"><sup class="footnote">[78]</sup></a>
            </p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>cksum /boot/vmlinuz</code></strong>
<code class="computeroutput">1670054224 804083 /boot/vmlinuz</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo -n "Top Secret" | cksum</code></strong>
<code class="computeroutput">3391003827 10</code>



<code class="prompt">bash$ </code><strong class="userinput"><code>md5sum /boot/vmlinuz</code></strong>
<code class="computeroutput">0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo -n "Top Secret" | md5sum</code></strong>
<code class="computeroutput">8babc97a6f62a4649716f4df8d61728f  -</code>
	      </pre><p>
	  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="command"><strong>cksum</strong></span> command shows the size,
	    in bytes, of its target, whether file or
	    <code class="filename">stdout</code>.</p><p>The <span class="command"><strong>md5sum</strong></span> and
	    <span class="command"><strong>sha1sum</strong></span> commands display a
	    <a class="link" href="ch03.html#dashref2">dash</a> when they receive their input from
	    <code class="filename">stdout</code>.</p></div><div class="example"><a name="fileintegrity"></a><p class="title"><b>Example 16.38. Checking file integrity</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# file-integrity.sh: Checking whether files in a given directory
#                    have been tampered with.

E_DIR_NOMATCH=80
E_BAD_DBFILE=81

dbfile=File_record.md5
# Filename for storing records (database file).


set_up_database ()
{
  echo ""$directory"" &gt; "$dbfile"
  # Write directory name to first line of file.
  md5sum "$directory"/* &gt;&gt; "$dbfile"
  # Append md5 checksums and filenames.
}

check_database ()
{
  local n=0
  local filename
  local checksum

  # ------------------------------------------- #
  #  This file check should be unnecessary,
  #+ but better safe than sorry.

  if [ ! -r "$dbfile" ]
  then
    echo "Unable to read checksum database file!"
    exit $E_BAD_DBFILE
  fi
  # ------------------------------------------- #

  while read record[n]
  do

    directory_checked="${record[0]}"
    if [ "$directory_checked" != "$directory" ]
    then
      echo "Directories do not match up!"
      # Tried to use file for a different directory.
      exit $E_DIR_NOMATCH
    fi

    if [ "$n" -gt 0 ]   # Not directory name.
    then
      filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
      #  md5sum writes records backwards,
      #+ checksum first, then filename.
      checksum[n]=$( md5sum "${filename[n]}" )


      if [ "${record[n]}" = "${checksum[n]}" ]
      then
        echo "${filename[n]} unchanged."

        elif [ "`basename ${filename[n]}`" != "$dbfile" ]
               #  Skip over checksum database file,
               #+ as it will change with each invocation of script.
               #  ---
               #  This unfortunately means that when running
               #+ this script on $PWD, tampering with the
               #+ checksum database file will not be detected.
               #  Exercise: Fix this.
        then
          echo "${filename[n]} : CHECKSUM ERROR!"
        # File has been changed since last checked.
        fi

      fi



    let "n+=1"
  done &lt;"$dbfile"       # Read from checksum database file. 

}  

# =================================================== #
# main ()

if [ -z  "$1" ]
then
  directory="$PWD"      #  If not specified,
else                    #+ use current working directory.
  directory="$1"
fi  

clear                   # Clear screen.
echo " Running file integrity check on $directory"
echo

# ------------------------------------------------------------------ #
  if [ ! -r "$dbfile" ] # Need to create database file?
  then
    echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
    set_up_database
  fi  
# ------------------------------------------------------------------ #

check_database          # Do the actual work.

echo 

#  You may wish to redirect the stdout of this script to a file,
#+ especially if the directory checked has many files in it.

exit 0

#  For a much more thorough file integrity check,
#+ consider the "Tripwire" package,
#+ http://sourceforge.net/projects/tripwire/.
</pre></div></div><br class="example-break"><p>Also see <a class="xref" href="apa.html#directoryinfo" title="Example A.19. Directory information">Example A.19, &#8220;Directory information&#8221;</a>, <a class="xref" href="ch36s05.html#horserace" title="Example 36.16. A &#8220;horserace&#8221; game">Example 36.16, &#8220;A <span class="quote">&#8220;<span class="quote">horserace</span>&#8221;</span> game&#8221;</a>, and <a class="xref" href="ch10s01.html#randstring" title="Example 10.2. Generating an 8-character &#8220;random&#8221; string">Example 10.2, &#8220;Generating an 8-character <span class="quote">&#8220;<span class="quote">random</span>&#8221;</span>
	        string&#8221;</a> for
	    creative uses of the <span class="command"><strong>md5sum</strong></span> command.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
	    There have been reports that the 128-bit
	    <span class="command"><strong>md5sum</strong></span> can be cracked, so the more secure
	    160-bit <span class="command"><strong>sha1sum</strong></span> is a welcome new addition
	    to the checksum toolkit.
          </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>md5sum testfile</code></strong>
<code class="computeroutput">e181e2c8720c60522c4c4c981108e367  testfile</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>sha1sum testfile</code></strong>
<code class="computeroutput">5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile</code>
	      </pre></div><p>Security consultants have demonstrated that even
	      <span class="command"><strong>sha1sum</strong></span> can be compromised. Fortunately,
	      newer Linux distros include longer bit-length
	      <span class="command"><strong>sha224sum</strong></span>,
	      <span class="command"><strong>sha256sum</strong></span>,
	      <span class="command"><strong>sha384sum</strong></span>, and
	      <span class="command"><strong>sha512sum</strong></span> commands.</p></dd><dt><span class="term"><a name="uuencoderef"></a><span class="command"><strong>uuencode</strong></span></span></dt><dd><a class="indexterm" name="idm12912"></a><a class="indexterm" name="idm12914"></a><p>This utility encodes binary files (images, sound files,
		    compressed files, etc.) into <a class="link" href="ch03.html#asciidef">ASCII</a> characters, making
		    them suitable for transmission in the body of an
		    e-mail message or in a newsgroup posting. This is
		    especially useful where MIME (multimedia) encoding
		    is not available.</p></dd><dt><span class="term"><a name="uudecoderef"></a><span class="command"><strong>uudecode</strong></span></span></dt><dd><a class="indexterm" name="idm12924"></a><a class="indexterm" name="idm12926"></a><p>This reverses the encoding, decoding
	      <em class="firstterm">uuencoded</em> files back into the
	      original binaries.</p><div class="example"><a name="ex52"></a><p class="title"><b>Example 16.39. Uudecoding encoded files</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# Uudecodes all uuencoded files in current working directory.

lines=35        # Allow 35 lines for the header (very generous).

for File in *   # Test all the files in $PWD.
do
  search1=`head -n $lines $File | grep begin | wc -w`
  search2=`tail -n $lines $File | grep end | wc -w`
  #  Uuencoded files have a "begin" near the beginning,
  #+ and an "end" near the end.
  if [ "$search1" -gt 0 ]
  then
    if [ "$search2" -gt 0 ]
    then
      echo "uudecoding - $File -"
      uudecode $File
    fi  
  fi
done  

#  Note that running this script upon itself fools it
#+ into thinking it is a uuencoded file,
#+ because it contains both "begin" and "end".

#  Exercise:
#  --------
#  Modify this script to check each file for a newsgroup header,
#+ and skip to next if not found.

exit 0
</pre></div></div><br class="example-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>The <a class="link" href="ch16s04.html#foldref">fold -s</a> command
	    may be useful (possibly in a pipe) to process long uudecoded
	    text messages downloaded from Usenet newsgroups.</p></div></dd><dt><span class="term"><a name="mimencoderef"></a><span class="command"><strong>mimencode</strong></span>, </span><span class="term"><a name="mmencoderef"></a><span class="command"><strong>mmencode</strong></span></span></dt><dd><a class="indexterm" name="idm12945"></a><a class="indexterm" name="idm12947"></a><a class="indexterm" name="idm12950"></a><a class="indexterm" name="idm12952"></a><p>The <span class="command"><strong>mimencode</strong></span> and
	      <span class="command"><strong>mmencode</strong></span> commands process
	      multimedia-encoded e-mail attachments. Although
	      <em class="firstterm">mail user agents</em> (such as
	      <em class="firstterm">pine</em> or <em class="firstterm">kmail</em>)
	      normally handle this automatically, these particular
	      utilities permit manipulating such attachments manually from
	      the command-line or in <a class="link" href="ch16s03.html#batchprocref">batch
	      processing mode</a> by means of a shell script.</p></dd><dt><span class="term"><a name="cryptref"></a><span class="command"><strong>crypt</strong></span></span></dt><dd><a class="indexterm" name="idm12967"></a><a class="indexterm" name="idm12969"></a><p>At one time, this was the standard UNIX file encryption
	      utility.

              <a href="#ftn.idm12973" class="footnote" name="idm12973"><sup class="footnote">[79]</sup></a>

	      Politically-motivated government regulations
	      prohibiting the export of encryption software resulted
	      in the disappearance of <span class="command"><strong>crypt</strong></span>
	      from much of the UNIX world, and it is still
	      missing from most Linux distributions. Fortunately,
	      programmers have come up with a number of decent
	      alternatives to it, among them the author's very own <a class="ulink" href="ftp://metalab.unc.edu/pub/Linux/utils/file/cruft-0.2.tar.gz" target="_top">cruft</a>
	      (see <a class="xref" href="apa.html#encryptedpw" title="Example A.4. encryptedpw: Uploading to an ftp site, using a locally encrypted password">Example A.4, &#8220;<em class="firstterm">encryptedpw</em>: Uploading to an ftp site,
      using a locally encrypted password&#8221;</a>).  </p></dd><dt><span class="term"><a name="opensslref"></a><span class="command"><strong>openssl</strong></span></span></dt><dd><a class="indexterm" name="idm12985"></a><a class="indexterm" name="idm12987"></a><p>This is an Open Source implementation of
             <em class="firstterm">Secure Sockets Layer</em> encryption.

	     </p><pre class="programlisting"># To encrypt a file:
openssl aes-128-ecb -salt -in file.txt -out file.encrypted \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.
#       aes-128-ecb      is the encryption method chosen.

# To decrypt an openssl-encrypted file:
openssl aes-128-ecb -d -salt -in file.encrypted -out file.txt \
-pass pass:my_password
#          ^^^^^^^^^^^   User-selected password.</pre><p><a class="link" href="ch03.html#piperef">Piping</a>
             <em class="firstterm">openssl</em> to/from <a class="link" href="ch16s05.html#tarref">tar</a> makes it possible to encrypt
             an entire directory tree.
     
            </p><pre class="programlisting"># To encrypt a directory:

sourcedir="/home/bozo/testfiles"
encrfile="encr-dir.tar.gz"
password=my_secret_password

tar czvf - "$sourcedir" |
openssl des3 -salt -out "$encrfile" -pass pass:"$password"
#       ^^^^   Uses des3 encryption.
# Writes encrypted file "encr-dir.tar.gz" in current working directory.

# To decrypt the resulting tarball:
openssl des3 -d -salt -in "$encrfile" -pass pass:"$password" |
tar -xzv
# Decrypts and unpacks into current working directory.</pre><p>

           </p><p>Of course, <em class="firstterm">openssl</em> has many other uses,
             such as obtaining signed <em class="firstterm">certificates</em>
	     for Web sites. See the <a class="link" href="ch16s01.html#inforef">info</a>
	     page.</p></dd><dt><span class="term"><a name="shredref"></a><span class="command"><strong>shred</strong></span></span></dt><dd><a class="indexterm" name="idm13007"></a><a class="indexterm" name="idm13009"></a><p>Securely erase a file by overwriting it multiple times with
	      random bit patterns before deleting it. This command has
	      the same effect as <a class="xref" href="ch16s09.html#blotout" title="Example 16.61. Securely deleting a file">Example 16.61, &#8220;Securely deleting a file&#8221;</a>, but does it
	      in a more thorough and elegant manner.</p><p>This is one of the GNU
	    <em class="firstterm">fileutils</em>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Advanced forensic technology may still be able to
	      recover the contents of a file, even after application of
	      <span class="command"><strong>shred</strong></span>.</p></div></dd></dl></div><div class="variablelist"><a name="famisc"></a><p class="title"><b><a name="famisc1"></a>Miscellaneous</b></p><dl class="variablelist"><dt><span class="term"><a name="mktempref"></a><span class="command"><strong>mktemp</strong></span></span></dt><dd><a class="indexterm" name="idm13027"></a><a class="indexterm" name="idm13029"></a><p>Create a <em class="firstterm">temporary file</em>

	       <a href="#ftn.idm13034" class="footnote" name="idm13034"><sup class="footnote">[80]</sup></a>

	      with a <span class="quote">&#8220;<span class="quote">unique</span>&#8221;</span> filename. When invoked
	      from the command-line without additional arguments,
	      it creates a zero-length file in the <code class="filename">/tmp</code> directory.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>mktemp</code></strong>
<code class="computeroutput">/tmp/tmp.zzsvql3154</code>
	      </pre><p>
	    </p><pre class="programlisting">PREFIX=filename
tempfile=`mktemp $PREFIX.XXXXXX`
#                        ^^^^^^ Need at least 6 placeholders
#+                              in the filename template.
#   If no filename template supplied,
#+ "tmp.XXXXXXXXXX" is the default.

echo "tempfile name = $tempfile"
# tempfile name = filename.QA2ZpY
#                 or something similar...

#  Creates a file of that name in the current working directory
#+ with 600 file permissions.
#  A "umask 177" is therefore unnecessary,
#+ but it's good programming practice nevertheless.</pre></dd><dt><span class="term"><a name="makeref"></a><span class="command"><strong>make</strong></span></span></dt><dd><a class="indexterm" name="idm13052"></a><a class="indexterm" name="idm13054"></a><p><a name="makefileref"></a></p><p>Utility for building and compiling binary packages. 
	      This can also be used for any set of operations triggered
	      by incremental changes in source files.</p><p>The <em class="firstterm">make</em> command checks a
	    <code class="filename">Makefile</code>, a list of file dependencies and
	      operations to be carried out.</p><p>The <em class="firstterm">make</em> utility is, in effect,
	      a powerful scripting language similar in many ways to
	      <em class="firstterm">Bash</em>, but with the capability of
	      recognizing <em class="firstterm">dependencies</em>. For in-depth
	      coverage of this useful tool set, see the <a class="ulink" href="http://www.gnu.org/manual/manual.html" target="_top">GNU software
	      documentation site</a>.</p></dd><dt><span class="term"><a name="installref"></a><span class="command"><strong>install</strong></span></span></dt><dd><a class="indexterm" name="idm13073"></a><a class="indexterm" name="idm13075"></a><p>Special purpose file copying command, similar to
	      <a class="link" href="ch16s01.html#cpref">cp</a>, but capable of
	      setting permissions and attributes of the copied
	      files. This command seems tailormade for installing
	      software packages, and as such it shows up frequently in
	      <code class="filename">Makefiles</code> (in the <em class="replaceable"><code>make
	      install :</code></em> section). It could likewise prove
	      useful in installation scripts.</p></dd><dt><span class="term"><a name="dos2unixref"></a><span class="command"><strong>dos2unix</strong></span></span></dt><dd><a class="indexterm" name="idm13087"></a><a class="indexterm" name="idm13089"></a><p>This utility, written by Benjamin Lin and collaborators,
	      converts DOS-formatted text files (lines terminated by
	      CR-LF) to UNIX format (lines terminated by LF only),
	      and <a class="link" href="ch34.html#dosnewlines">vice-versa</a>.</p></dd><dt><span class="term"><a name="ptxref"></a><span class="command"><strong>ptx</strong></span></span></dt><dd><a class="indexterm" name="idm13099"></a><a class="indexterm" name="idm13101"></a><p>The <span class="command"><strong>ptx [targetfile]</strong></span> command
	      outputs a permuted index (cross-reference list) of the
	      targetfile. This may be further filtered and formatted in a
	      pipe, if necessary.</p></dd><dt><span class="term"><a name="moreref"></a><span class="command"><strong>more</strong></span>, </span><span class="term"><a name="lessref"></a><span class="command"><strong>less</strong></span></span></dt><dd><a class="indexterm" name="idm13114"></a><a class="indexterm" name="idm13116"></a><a class="indexterm" name="idm13119"></a><a class="indexterm" name="idm13121"></a><p>Pagers that display a text file or stream to
	      <code class="filename">stdout</code>, one screenful at a time.
	      These may be used to filter the output of
	      <code class="filename">stdout</code> . . . or of a script.</p><p>
	       An interesting application of <em class="firstterm">more</em>
	       is to <span class="quote">&#8220;<span class="quote">test drive</span>&#8221;</span> a command sequence,
	       to forestall potentially unpleasant consequences.
                 </p><pre class="programlisting">ls /home/bozo | awk '{print "rm -rf " $1}' | more
#                                            ^^^^
		 
# Testing the effect of the following (disastrous) command-line:
#      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
#      Hand off to the shell to execute . . .       ^^</pre><p>
            </p><p>The <em class="firstterm">less</em> pager has the
	      interesting property of doing a formatted display of
	      <em class="firstterm">man page</em> source. See <a class="xref" href="apa.html#maned" title="Example A.39. A man page editor">Example A.39, &#8220;A <em class="firstterm">man page</em> editor&#8221;</a>.</p></dd></dl></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idm11889" class="footnote"><p><a href="#idm11889" class="para"><sup class="para">[75] </sup></a>An <em class="firstterm">archive</em>,
	        in the sense discussed here, is simply a set of related
	        files stored in a single location.</p></div><div id="ftn.idm11900" class="footnote"><p><a href="#idm11900" class="para"><sup class="para">[76] </sup></a>
		    A <em class="replaceable"><code>tar czvf ArchiveName.tar.gz *</code></em>
		    <span class="emphasis"><em>will</em></span> include dotfiles in
		    subdirectories <span class="emphasis"><em>below</em></span> the current
		    working directory. This is an undocumented GNU
		    <span class="command"><strong>tar</strong></span> <span class="quote">&#8220;<span class="quote">feature.</span>&#8221;</span>
		  </p></div><div id="ftn.idm12844" class="footnote"><p><a href="#idm12844" class="para"><sup class="para">[77] </sup></a>The checksum may be expressed as a
		<em class="firstterm">hexadecimal</em> number, or to some
		other base.</p></div><div id="ftn.idm12853" class="footnote"><p><a href="#idm12853" class="para"><sup class="para">[78] </sup></a>For even <span class="emphasis"><em>better</em></span>
		  security, use the <em class="firstterm">sha256sum</em>,
		  <em class="firstterm">sha512</em>, and
                  <em class="firstterm">sha1pass</em>
                  commands.</p></div><div id="ftn.idm12973" class="footnote"><p><a href="#idm12973" class="para"><sup class="para">[79] </sup></a>This is a symmetric block cipher, used to
		encrypt files on a single system or local network,
		as opposed to the <em class="firstterm">public key</em>
		cipher class, of which <em class="firstterm">pgp</em> is a
		well-known example.</p></div><div id="ftn.idm13034" class="footnote"><p><a href="#idm13034" class="para"><sup class="para">[80] </sup></a>Creates a temporary
	       <em class="firstterm">directory</em> when invoked with the
	       <code class="option">-d</code> option.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Text Processing Commands </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. Communications Commands</td></tr></table></div></body></html>
