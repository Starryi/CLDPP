<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>1. Internal Variables</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Advanced Bash-Scripting Guide"><link rel="up" href="ch09.html" title="Chapter 9. Another Look at Variables"><link rel="prev" href="ch09.html" title="Chapter 9. Another Look at Variables"><link rel="next" href="ch09s02.html" title="2. Typing variables: declare or typeset"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. Internal Variables</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch09.html">Prev</a> </td><th width="60%" align="center">Chapter 9. Another Look at Variables</th><td width="20%" align="right"> <a accesskey="n" href="ch09s02.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="internalvariables"></a>1. Internal Variables</h2></div></div></div><div class="variablelist"><a name="internalvariables1"></a><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code><a class="link" href="ch15.html#builtinref">Builtin</a> variables:</code></em></span></dt><dd><p>variables affecting bash script behavior</p></dd><dt><span class="term"><a name="bashvarref"></a><code class="varname">$BASH</code></span></dt><dd><a class="indexterm" name="idm4517"></a><a class="indexterm" name="idm4519"></a><a class="indexterm" name="idm4522"></a><p>The path to the <em class="firstterm">Bash</em>
	    binary itself
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $BASH</code></strong>
<code class="computeroutput">/bin/bash</code></pre><p>
	    </p></dd><dt><span class="term"><a name="bashenvref"></a><code class="varname">$BASH_ENV</code></span></dt><dd><a class="indexterm" name="idm4535"></a><a class="indexterm" name="idm4537"></a><p>An <a class="link" href="ch04s04.html#envref">environmental
	  variable</a> pointing to a Bash startup file to be read
	  when a script is invoked</p></dd><dt><span class="term"><a name="bashsubshellref"></a><code class="varname">$BASH_SUBSHELL</code></span></dt><dd><a class="indexterm" name="idm4547"></a><a class="indexterm" name="idm4549"></a><p>A variable indicating the <a class="link" href="ch21.html#subshellsref">subshell</a> level. This is a
	      new addition to Bash, <a class="link" href="ch37s02.html#bash3ref">version 3</a>.</p><p>See <a class="xref" href="ch21.html#subshell" title="Example 21.1. Variable scope in a subshell">Example 21.1, &#8220;Variable scope in a subshell&#8221;</a> for usage.</p></dd><dt><span class="term"><a name="bashpidref"></a><code class="varname">$BASHPID</code></span></dt><dd><a class="indexterm" name="idm4562"></a><a class="indexterm" name="idm4564"></a><p><em class="firstterm">Process ID</em>
            of the current instance of Bash. This is not the same as the
            <a class="link" href="ch09s01.html#proccid">$$</a> variable, but it often
            gives the same result.</p><p>
		  </p><pre class="screen">
<code class="prompt">bash4$ </code><strong class="userinput"><code>echo $$</code></strong>
<code class="computeroutput">11015</code>


<code class="prompt">bash4$ </code><strong class="userinput"><code>echo $BASHPID</code></strong>
<code class="computeroutput">11015</code>


<code class="prompt">bash4$ </code><strong class="userinput"><code>ps ax | grep bash4</code></strong>
<code class="computeroutput">11015 pts/2    R      0:00 bash4</code>
	      </pre><p>
	    </p><p><a name="bashpidref2"></a>But ...</p><pre class="programlisting">
#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
  # Note that $$ returns PID of parent process.
</pre></dd><dt><span class="term"><code class="varname">$BASH_VERSINFO[n]</code></span></dt><dd><a class="indexterm" name="idm4589"></a><a class="indexterm" name="idm4591"></a><p>A 6-element <a class="link" href="ch27.html#arrayref">array</a>
	    containing version information about the installed release
	    of Bash. This is similar to <code class="varname">$BASH_VERSION</code>,
	    below, but a bit more detailed.</p><p>
	  </p><pre class="programlisting"># Bash version info:

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done  

# BASH_VERSINFO[0] = 3                      # Major version no.
# BASH_VERSINFO[1] = 00                     # Minor version no.
# BASH_VERSINFO[2] = 14                     # Patch level.
# BASH_VERSINFO[3] = 1                      # Build version.
# BASH_VERSINFO[4] = release                # Release status.
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
                                            # (same as $MACHTYPE).</pre><p>
	  </p></dd><dt><span class="term"><code class="varname">$BASH_VERSION</code></span></dt><dd><a class="indexterm" name="idm4603"></a><a class="indexterm" name="idm4605"></a><p>The version of Bash installed on the system</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $BASH_VERSION</code></strong>
<code class="computeroutput">3.2.25(1)-release</code>
	      </pre><p>
	    </p><p>
	      </p><pre class="screen"><code class="prompt">tcsh% </code><strong class="userinput"><code>echo $BASH_VERSION</code></strong>
<code class="computeroutput">BASH_VERSION: Undefined variable.</code>
	      </pre><p>
	    </p><p>Checking $BASH_VERSION is a good method of determining which
	    shell is running. <a class="link" href="ch09s01.html#shellvarref">$SHELL</a>
	    does not necessarily give the correct answer.</p></dd><dt><span class="term"><a name="cdpathref"></a><code class="varname">$CDPATH</code></span></dt><dd><a class="indexterm" name="idm4626"></a><a class="indexterm" name="idm4628"></a><a class="indexterm" name="idm4631"></a><a class="indexterm" name="idm4633"></a><p>A colon-separated list of search paths
	    available to the <a class="link" href="ch15.html#cdref">cd</a>
	    command, similar in function to the <a class="link" href="ch09s01.html#pathref">$PATH</a> variable for binaries.
            The <code class="varname">$CDPATH</code> variable may be set in the
	    local <a class="link" href="apm.html#bashrc" title="Example M.1. Sample .bashrc file"><code class="filename">~/.bashrc</code></a>
	    file.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>cd bash-doc</code></strong>
<code class="computeroutput">bash: cd: bash-doc: No such file or directory</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>CDPATH=/usr/share/doc</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>cd bash-doc</code></strong>
<code class="computeroutput">/usr/share/doc/bash-doc</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>echo $PWD</code></strong>
<code class="computeroutput">/usr/share/doc/bash-doc</code>
	      </pre><p>
           </p></dd><dt><span class="term"><a name="dirstackref"></a><code class="varname">$DIRSTACK</code></span></dt><dd><a class="indexterm" name="idm4660"></a><a class="indexterm" name="idm4662"></a><a class="indexterm" name="idm4665"></a><a class="indexterm" name="idm4667"></a><p>The top value in the directory stack

              <a href="#ftn.idm4671" class="footnote" name="idm4671"><sup class="footnote">[41]</sup></a>

	    (affected by <a class="link" href="ch15.html#pushdref">pushd</a> and <a class="link" href="ch15.html#popdref">popd</a>)</p><p>This builtin
	    variable corresponds to the <a class="link" href="ch15.html#dirsd">dirs</a>
	    command, however <span class="command"><strong>dirs</strong></span> shows the entire
	    contents of the directory stack.</p></dd><dt><span class="term"><code class="varname">$EDITOR</code></span></dt><dd><a class="indexterm" name="idm4690"></a><a class="indexterm" name="idm4692"></a><a class="indexterm" name="idm4695"></a><p>The default editor invoked by a script, usually
	      <span class="command"><strong>vi</strong></span> or <span class="command"><strong>emacs</strong></span>.</p></dd><dt><span class="term"><a name="euidref"></a><code class="varname">$EUID</code></span></dt><dd><a class="indexterm" name="idm4705"></a><a class="indexterm" name="idm4707"></a><a class="indexterm" name="idm4710"></a><p><span class="quote">&#8220;<span class="quote">effective</span>&#8221;</span> user ID number</p><p>Identification number of whatever identity the
	      current user has assumed, perhaps by means of <a class="link" href="ch17.html#suref">su</a>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <code class="varname">$EUID</code> is not necessarily
	      the same as the <a class="link" href="ch09s01.html#uidref">$UID</a>.</p></div></dd><dt><span class="term"><code class="varname">$FUNCNAME</code></span></dt><dd><a class="indexterm" name="idm4724"></a><a class="indexterm" name="idm4726"></a><a class="indexterm" name="idm4729"></a><p>Name of the current function</p><pre class="programlisting">xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz23 now executing.
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # Null value outside a function.</pre><p>
            </p><p>See also <a class="xref" href="apa.html#usegetopt" title="Example A.50. An alternate version of the getopt-simple.sh script">Example A.50, &#8220;An alternate version of the
      getopt-simple.sh script&#8221;</a>.</p></dd><dt><span class="term"><code class="varname">$GLOBIGNORE</code></span></dt><dd><a class="indexterm" name="idm4740"></a><a class="indexterm" name="idm4742"></a><a class="indexterm" name="idm4745"></a><p>A list of filename patterns to be excluded from
	    matching in <a class="link" href="ch18s02.html" title="2. Globbing">globbing</a>.</p></dd><dt><span class="term"><a name="groupsref"></a><code class="varname">$GROUPS</code></span></dt><dd><a class="indexterm" name="idm4754"></a><a class="indexterm" name="idm4756"></a><a class="indexterm" name="idm4759"></a><p>Groups current user belongs to</p><p>This is a listing (array) of the group id numbers for
	      current user, as  recorded in
	      <a class="link" href="aph.html#datafilesref1"><code class="filename">/etc/passwd</code></a>
	      and <code class="filename">/etc/group</code>.
	    </p><p>
	      </p><pre class="screen">
<code class="prompt">root# </code><strong class="userinput"><code>echo $GROUPS</code></strong>
<code class="computeroutput">0</code>


<code class="prompt">root# </code><strong class="userinput"><code>echo ${GROUPS[1]}</code></strong>
<code class="computeroutput">1</code>


<code class="prompt">root# </code><strong class="userinput"><code>echo ${GROUPS[5]}</code></strong>
<code class="computeroutput">6</code>
	      </pre><p>
	      </p></dd><dt><span class="term"><a name="homedirref"></a><code class="varname">$HOME</code></span></dt><dd><a class="indexterm" name="idm4782"></a><a class="indexterm" name="idm4784"></a><a class="indexterm" name="idm4787"></a><a class="indexterm" name="idm4789"></a><p>Home directory of the user, usually <code class="filename">/home/username</code> (see <a class="xref" href="ch10s02.html#ex6" title="Example 10.7. Using parameter substitution and error messages">Example 10.7, &#8220;Using parameter substitution and error messages&#8221;</a>)</p></dd><dt><span class="term"><a name="hostnameref"></a><code class="varname">$HOSTNAME</code></span></dt><dd><a class="indexterm" name="idm4800"></a><a class="indexterm" name="idm4802"></a><a class="indexterm" name="idm4805"></a><a class="indexterm" name="idm4807"></a><p>The <a class="link" href="ch17.html#hnameref">hostname</a> command
	    assigns the system host name at bootup in an init script.
	    However, the <code class="function">gethostname()</code> function
	    sets the Bash internal variable <code class="varname">$HOSTNAME</code>.
	    See also <a class="xref" href="ch10s02.html#ex6" title="Example 10.7. Using parameter substitution and error messages">Example 10.7, &#8220;Using parameter substitution and error messages&#8221;</a>.</p></dd><dt><span class="term"><code class="varname">$HOSTTYPE</code></span></dt><dd><a class="indexterm" name="idm4819"></a><a class="indexterm" name="idm4821"></a><a class="indexterm" name="idm4824"></a><p>host type</p><p>Like <a class="link" href="ch09s01.html#machtyperef">$MACHTYPE</a>,
	      identifies the system hardware.</p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $HOSTTYPE</code></strong>
<code class="computeroutput">i686</code></pre></dd><dt><span class="term"><a name="ifsref"></a><code class="varname">$IFS</code></span></dt><dd><a class="indexterm" name="idm4838"></a><a class="indexterm" name="idm4840"></a><a class="indexterm" name="idm4843"></a><p>internal field separator</p><p>This variable determines how Bash recognizes <a class="link" href="ch03.html#fieldref">fields</a>, or word boundaries,
	      when it interprets character strings.</p><p><a name="ifsws"></a></p><p>$IFS defaults to <a class="link" href="ch03.html#whitespaceref">whitespace</a> (space,
	      tab, and newline), but may be changed, for example,
	      to parse a comma-separated data file. Note that
	      <a class="link" href="ch09s01.html#appref">$*</a> uses the first
	      character held in <code class="varname">$IFS</code>. See <a class="xref" href="ch05s01.html#weirdvars" title="Example 5.1. Echoing Weird Variables">Example 5.1, &#8220;Echoing Weird Variables&#8221;</a>.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>echo "$IFS"</code></strong>
<code class="computeroutput">

</code>
<code class="computeroutput">(With $IFS set to default, a blank line displays.)</code>
	      


<code class="prompt">bash$ </code><strong class="userinput"><code>echo "$IFS" | cat -vte</code></strong>
<code class="computeroutput"> ^I$
 $</code>
<code class="computeroutput">(Show whitespace: here a single space, ^I [horizontal tab],
  and newline, and display "$" at end-of-line.)</code>



<code class="prompt">bash$ </code><strong class="userinput"><code>bash -c 'set w x y z; IFS=":-;"; echo "$*"'</code></strong>
<code class="computeroutput">w:x:y:z</code>
<code class="computeroutput">(Read commands from string and assign any arguments to pos params.)</code>
	      </pre><p>
	  </p><p>Set <code class="varname">$IFS</code> to eliminate whitespace
		  in <a class="link" href="ch03.html#pathnameref">pathnames</a>.
</p><pre class="programlisting">IFS="$(printf '\n\t')"   # Per David Wheeler.</pre><p>
	  </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p><code class="varname">$IFS</code> does not handle whitespace
	    the same as it does other characters.

	  </p><div class="example"><a name="ifsh"></a><p class="title"><b>Example 9.1. $IFS and whitespace</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# ifs.sh


var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# The plus sign will be interpreted as a separator.
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# The plus sign reverts to default interpretation.
# The minus sign will be interpreted as a separator.
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# The comma will be interpreted as a separator.
# The minus sign reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# The space character will be interpreted as a separator.
# The comma reverts to default interpretation.
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# However ...
# $IFS treats whitespace differently than other characters.

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   Embed within brackets, for your viewing pleasure.
}

echo; echo "IFS=\" \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
# [a]
# [b]
# [c]


echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # Same pattern as above,
#    ^ ^^   ^^^                #+ but substituting ":" for " "  ...
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# Note "empty" brackets.
# The same thing happens with the "FS" field separator in awk.


echo

exit
</pre></div></div><p><br class="example-break">

	  </p></div><p>(Many thanks, Stéphane Chazelas, for clarification
	  and above examples.)</p><p>See also <a class="xref" href="ch16s06.html#isspammer" title="Example 16.41. Analyzing a spam domain">Example 16.41, &#8220;Analyzing a spam domain&#8221;</a>, <a class="xref" href="ch11s01.html#bingrep" title="Example 11.8. A grep replacement for binary files">Example 11.8, &#8220;A <em class="firstterm">grep</em> replacement
	        for binary files&#8221;</a>, and <a class="xref" href="ch19s01.html#mailboxgrep" title="Example 19.14. Parsing a mailbox">Example 19.14, &#8220;Parsing a mailbox&#8221;</a>
             for instructive examples of using
             <code class="varname">$IFS</code>.</p></dd><dt><span class="term"><code class="varname">$IGNOREEOF</code></span></dt><dd><a class="indexterm" name="idm4889"></a><a class="indexterm" name="idm4891"></a><a class="indexterm" name="idm4894"></a><p>Ignore EOF: how many end-of-files (control-D)
	    the shell will ignore before logging out.</p></dd><dt><span class="term"><code class="varname">$LC_COLLATE</code></span></dt><dd><a class="indexterm" name="idm4901"></a><a class="indexterm" name="idm4903"></a><a class="indexterm" name="idm4906"></a><p>Often set in the <a class="link" href="apm.html" title="Appendix M. Sample .bashrc and .bash_profile Files"><code class="filename">.bashrc</code></a>
	    or <code class="filename">/etc/profile</code> files, this
	    variable controls collation order in filename
	    expansion and pattern matching. If mishandled,
	    <code class="varname">LC_COLLATE</code> can cause unexpected results in
	    <a class="link" href="ch18s02.html" title="2. Globbing">filename globbing</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As of version 2.05 of Bash,
	    filename globbing no longer distinguishes between lowercase
	    and uppercase letters in a character range between
	    brackets. For example, <span class="command"><strong>ls [A-M]*</strong></span>
	    would match both <code class="filename">File1.txt</code>
	    and <code class="filename">file1.txt</code>. To revert to
	    the customary behavior of bracket matching, set
	    <code class="varname">LC_COLLATE</code> to <code class="option">C</code>
	    by an <strong class="userinput"><code>export LC_COLLATE=C</code></strong>
	    in <code class="filename">/etc/profile</code> and/or
	    <code class="filename">~/.bashrc</code>.</p></div></dd><dt><span class="term"><code class="varname">$LC_CTYPE</code></span></dt><dd><a class="indexterm" name="idm4928"></a><a class="indexterm" name="idm4930"></a><a class="indexterm" name="idm4933"></a><p>This internal variable controls character interpretation
	    in <a class="link" href="ch18s02.html" title="2. Globbing">globbing</a> and pattern
	    matching.</p></dd><dt><span class="term"><a name="linenoref"></a><code class="varname">$LINENO</code></span></dt><dd><a class="indexterm" name="idm4942"></a><a class="indexterm" name="idm4944"></a><a class="indexterm" name="idm4947"></a><p>This variable is the line number of the shell
	    script in which this variable appears. It has significance only
	    within the script in which it appears, and is chiefly useful for
	    debugging purposes.</p><pre class="programlisting"># *** BEGIN DEBUG BLOCK ***
last_cmd_arg=$_  # Save it.

echo "At line number $LINENO, variable \"v1\" = $v1"
echo "Last command argument processed = $last_cmd_arg"
# *** END DEBUG BLOCK ***</pre></dd><dt><span class="term"><a name="machtyperef"></a><code class="varname">$MACHTYPE</code></span></dt><dd><a class="indexterm" name="idm4957"></a><a class="indexterm" name="idm4959"></a><a class="indexterm" name="idm4962"></a><p>machine type</p><p>Identifies the system hardware.</p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $MACHTYPE</code></strong>
<code class="computeroutput">i686</code></pre></dd><dt><span class="term"><a name="oldpwd"></a><code class="varname">$OLDPWD</code></span></dt><dd><a class="indexterm" name="idm4975"></a><a class="indexterm" name="idm4977"></a><a class="indexterm" name="idm4980"></a><a class="indexterm" name="idm4982"></a><p>Old working directory
	  (<span class="quote">&#8220;<span class="quote">OLD-Print-Working-Directory</span>&#8221;</span>,
	    previous directory you were in).</p></dd><dt><span class="term"><code class="varname">$OSTYPE</code></span></dt><dd><a class="indexterm" name="idm4991"></a><a class="indexterm" name="idm4993"></a><a class="indexterm" name="idm4996"></a><p>operating system type</p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $OSTYPE</code></strong>
<code class="computeroutput">linux</code></pre></dd><dt><span class="term"><a name="pathref"></a><code class="varname">$PATH</code></span></dt><dd><a class="indexterm" name="idm5008"></a><a class="indexterm" name="idm5010"></a><a class="indexterm" name="idm5013"></a><p>Path to binaries, usually 
	      <code class="filename">/usr/bin/</code>, 
	      <code class="filename">/usr/X11R6/bin/</code>, 
	      <code class="filename">/usr/local/bin</code>, etc.</p><p>When given a command, the shell automatically does
	      a hash table search on the directories listed in the
	      <em class="firstterm">path</em> for the executable. The path
	      is stored in the <a class="link" href="ch04s04.html#envref">environmental
	      variable</a>, <code class="varname">$PATH</code>, a list
	      of directories, separated by colons. Normally,
	      the system stores the <code class="varname">$PATH</code>
	      definition in <code class="filename">/etc/profile</code>
	      and/or <a class="link" href="apm.html" title="Appendix M. Sample .bashrc and .bash_profile Files"><code class="filename">~/.bashrc</code></a>
	      (see <a class="xref" href="aph.html" title="Appendix H.  Important Files">Appendix H, <i> Important Files</i></a>).</p><pre class="screen"><code class="prompt">bash$ </code><span class="command"><strong>echo $PATH</strong></span>
<code class="computeroutput">/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin</code></pre><p>
              </p><p><strong class="userinput"><code>PATH=${PATH}:/opt/bin</code></strong> appends
	      the <code class="filename">/opt/bin</code>
	      directory to the current path. In a script, it may be
	      expedient to temporarily add a directory to the path
	      in this way. When the script exits, this restores the
	      original <code class="varname">$PATH</code> (a child process, such
	      as a script, may not change the environment of the parent
	      process, the shell).</p><p><a name="currentwdref"></a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The current <span class="quote">&#8220;<span class="quote">working directory</span>&#8221;</span>, 
	      <code class="filename">./</code>, is usually
	      omitted from the <code class="varname">$PATH</code> as a security
	      measure.</p></div></dd><dt><span class="term"><a name="pipestatusref"></a><code class="varname">$PIPESTATUS</code></span></dt><dd><a class="indexterm" name="idm5049"></a><a class="indexterm" name="idm5051"></a><p><a class="link" href="ch27.html#arrayref">Array</a> variable holding
            <a class="link" href="ch06.html#exitstatusref">exit status</a>(es) of
	    last executed <em class="firstterm">foreground</em> <a class="link" href="ch03.html#piperef">pipe</a>.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $PIPESTATUS</code></strong>
<code class="computeroutput">0</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>ls -al | bogus_command</code></strong>
<code class="computeroutput">bash: bogus_command: command not found</code>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo ${PIPESTATUS[1]}</code></strong>
<code class="computeroutput">127</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>ls -al | bogus_command</code></strong>
<code class="computeroutput">bash: bogus_command: command not found</code>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $?</code></strong>
<code class="computeroutput">127</code>
	      </pre><p>
	      </p><p>The members of the <code class="varname">$PIPESTATUS</code>
		array hold the exit status of each respective command
		executed in a pipe. <code class="varname">$PIPESTATUS[0]</code>
		holds the exit status of the first command in the pipe,
		<code class="varname">$PIPESTATUS[1]</code> the exit status of
		the second command, and so on.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>
	      The <code class="varname">$PIPESTATUS</code> variable
              may contain an erroneous <span class="errorcode">0</span> value
              in a login shell (in releases prior to 3.0 of Bash).
              </p><p>
	      </p><pre class="screen">
<code class="prompt">tcsh% </code><strong class="userinput"><code>bash</code></strong>

<code class="prompt">bash$ </code><strong class="userinput"><code>who | grep nobody | sort</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo ${PIPESTATUS[*]}</code></strong>
<code class="computeroutput">0</code>
	      </pre><p>
	      </p><p>
	      The above lines contained in a script would produce the expected
	      <code class="computeroutput">0 1 0</code> output.
              </p><p>
	      Thank you, Wayne Pollock for pointing this out and supplying the
	      above example.
	      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="varname">$PIPESTATUS</code> variable gives
	        unexpected results in some contexts.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $BASH_VERSION</code></strong>
<code class="computeroutput">3.00.14(1)-release</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>$ ls | bogus_command | wc</code></strong>
<code class="computeroutput">bash: bogus_command: command not found
 0       0       0</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo ${PIPESTATUS[@]}</code></strong>
<code class="computeroutput">141 127 0</code>
	      </pre><p>
	      </p><p>Chet Ramey attributes the above output to the behavior of
		<a class="link" href="ch16s01.html#lsref">ls</a>. If <em class="firstterm">ls</em>
		writes to a <em class="firstterm">pipe</em> whose output is not
		read, then <em class="replaceable"><code>SIGPIPE</code></em> kills it,
		and its <a class="link" href="ch06.html#exitstatusref">exit status</a>
		is <span class="returnvalue">141</span>. Otherwise
		its exit status is <span class="returnvalue">0</span>,
		as expected. This likewise is the case for <a class="link" href="ch16s04.html#trref">tr</a>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><code class="varname">$PIPESTATUS</code> is a
		    <span class="quote">&#8220;<span class="quote">volatile</span>&#8221;</span> variable. It needs to be
		    captured immediately after the pipe in question, before
		    any other command intervenes.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>$ ls | bogus_command | wc</code></strong>
<code class="computeroutput">bash: bogus_command: command not found
 0       0       0</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo ${PIPESTATUS[@]}</code></strong>
<code class="computeroutput">0 127 0</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo ${PIPESTATUS[@]}</code></strong>
<code class="computeroutput">0</code>
	      </pre><p>
	      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <a class="link" href="ch37s02.html#pipefailref">pipefail option</a>
		    may be useful in cases where
		    <code class="varname">$PIPESTATUS</code> does not give the desired
		    information.</p></div></dd><dt><span class="term"><a name="ppidref"></a><code class="varname">$PPID</code></span></dt><dd><a class="indexterm" name="idm5143"></a><a class="indexterm" name="idm5145"></a><a class="indexterm" name="idm5148"></a><p></p><p>The <code class="varname">$PPID</code> of a process is
	    the process ID (<code class="varname">pid</code>) of its parent process.

	      <a href="#ftn.idm5154" class="footnote" name="idm5154"><sup class="footnote">[42]</sup></a>
	      </p><p>Compare this with the <a class="link" href="ch17.html#pidofref">pidof</a> command.</p></dd><dt><span class="term"><code class="varname">$PROMPT_COMMAND</code></span></dt><dd><a class="indexterm" name="idm5163"></a><a class="indexterm" name="idm5165"></a><p>A variable holding a command to be executed
	      just before the primary prompt, <code class="varname">$PS1</code>
	      is to be displayed.</p></dd><dt><span class="term"><a name="ps1ref"></a><code class="varname">$PS1</code></span></dt><dd><a class="indexterm" name="idm5175"></a><a class="indexterm" name="idm5177"></a><a class="indexterm" name="idm5180"></a><p>This is the main prompt, seen at the command-line.</p></dd><dt><span class="term"><a name="secpromptref"></a><code class="varname">$PS2</code></span></dt><dd><a class="indexterm" name="idm5188"></a><a class="indexterm" name="idm5190"></a><a class="indexterm" name="idm5193"></a><p>The secondary prompt, seen when additional input is
	      expected. It displays as <span class="quote">&#8220;<span class="quote">&gt;</span>&#8221;</span>.</p></dd><dt><span class="term"><code class="varname">$PS3</code></span></dt><dd><a class="indexterm" name="idm5202"></a><a class="indexterm" name="idm5204"></a><a class="indexterm" name="idm5207"></a><p>The tertiary prompt, displayed in a
	    <a class="link" href="ch11s04.html#selectref">select</a> loop (see <a class="xref" href="ch11s04.html#ex31" title="Example 11.30. Creating menus using select">Example 11.30, &#8220;Creating menus using <em class="firstterm">select</em>&#8221;</a>).</p></dd><dt><span class="term"><code class="varname">$PS4</code></span></dt><dd><a class="indexterm" name="idm5217"></a><a class="indexterm" name="idm5219"></a><a class="indexterm" name="idm5222"></a><p>The quartenary prompt, shown at the beginning of
	    each line of output when invoking a script with the
	    <span class="token">-x</span> <span class="emphasis"><em>[verbose trace]</em></span>
	    <a class="link" href="ch33.html#optionsref">option</a>. It displays as
	    <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span>.</p><p>As a debugging aid, it may be useful to embed diagnostic
	    information in <code class="varname">$PS4</code>.
</p><pre class="programlisting">P4='$(read time junk &lt; /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# Per suggestion by Erik Brandsberg.
set -x
# Various commands follow ...</pre></dd><dt><span class="term"><a name="pwdref"></a><code class="varname">$PWD</code></span></dt><dd><a class="indexterm" name="idm5238"></a><a class="indexterm" name="idm5240"></a><a class="indexterm" name="idm5243"></a><a class="indexterm" name="idm5245"></a><p>Working directory (directory you are in at the time)</p><p>This is the analog to the <a class="link" href="ch15.html#pwd2ref">pwd</a>
	    builtin command.</p><pre class="programlisting">#!/bin/bash

E_WRONG_DIRECTORY=85

clear # Clear the screen.

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."

if [ "$PWD" != "$TargetDirectory" ]
then    # Keep from wiping out wrong directory by accident.
  echo "Wrong directory!"
  echo "In $PWD, rather than $TargetDirectory!"
  echo "Bailing out!"
  exit $E_WRONG_DIRECTORY
fi  

rm -rf *
rm .[A-Za-z0-9]*    # Delete dotfiles.
# rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
# (shopt -s dotglob; rm -f *)   will also work.
# Thanks, S.C. for pointing this out.

#  A filename (`basename`) may contain all characters in the 0 - 255 range,
#+ except "/".
#  Deleting files beginning with weird characters, such as -
#+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)
result=$?   # Result of delete operations. If successful = 0.

echo
ls -al              # Any files left?
echo "Done."
echo "Old files deleted in $TargetDirectory."
echo

# Various other operations here, as necessary.

exit $result
</pre></dd><dt><span class="term"><a name="replyref"></a><code class="varname">$REPLY</code></span></dt><dd><a class="indexterm" name="idm5258"></a><a class="indexterm" name="idm5260"></a><a class="indexterm" name="idm5263"></a><a class="indexterm" name="idm5265"></a><p>The default value when a variable is not
	    supplied to <a class="link" href="ch15.html#readref">read</a>. Also
	    applicable to <a class="link" href="ch11s04.html#selectref">select</a> menus,
	    but only supplies the item number of the variable chosen,
	    not the value of the variable itself.</p><pre class="programlisting">#!/bin/bash
# reply.sh

# REPLY is the default value for a 'read' command.

echo
echo -n "What is your favorite vegetable? "
read

echo "Your favorite vegetable is $REPLY."
#  REPLY holds the value of last "read" if and only if
#+ no variable supplied.

echo
echo -n "What is your favorite fruit? "
read fruit
echo "Your favorite fruit is $fruit."
echo "but..."
echo "Value of \$REPLY is still $REPLY."
#  $REPLY is still set to its previous value because
#+ the variable $fruit absorbed the new "read" value.

echo

exit 0
</pre></dd><dt><span class="term"><code class="varname">$SECONDS</code></span></dt><dd><a class="indexterm" name="idm5277"></a><a class="indexterm" name="idm5279"></a><a class="indexterm" name="idm5282"></a><a class="indexterm" name="idm5284"></a><p>The number of seconds the script has been running.</p><pre class="programlisting">#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS is an internal shell variable.
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else  
    units=seconds
  fi

  echo "This script has been running $SECONDS $units."
  #  On a slow or overburdened machine, the script may skip a count
  #+ every once in a while.
  sleep $INTERVAL
done

echo -e "\a"  # Beep!

exit 0
</pre></dd><dt><span class="term"><code class="varname">$SHELLOPTS</code></span></dt><dd><a class="indexterm" name="idm5294"></a><a class="indexterm" name="idm5296"></a><a class="indexterm" name="idm5299"></a><p>The list of enabled shell <a class="link" href="ch33.html#optionsref">options</a>, a readonly variable.
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>echo $SHELLOPTS</code></strong>
<code class="computeroutput">braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs</code>
	      </pre><p>
	    </p></dd><dt><span class="term"><a name="shlvlref"></a><code class="varname">$SHLVL</code></span></dt><dd><a class="indexterm" name="idm5312"></a><a class="indexterm" name="idm5314"></a><a class="indexterm" name="idm5317"></a><p>Shell level, how deeply Bash is nested.
	      <a href="#ftn.idm5320" class="footnote" name="idm5320"><sup class="footnote">[43]</sup></a>
	    If, at the command-line, $SHLVL is 1, then in a script it
	    will increment to 2.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This variable is <a class="link" href="ch21.html#subshnlevref">
	      <span class="emphasis"><em>not</em></span> affected by
	      subshells</a>. Use <a class="link" href="ch09s01.html#bashsubshellref">$BASH_SUBSHELL</a> when you
	      need an indication of subshell nesting.</p></div></dd><dt><span class="term"><a name="tmoutref"></a><code class="varname">$TMOUT</code></span></dt><dd><a class="indexterm" name="idm5338"></a><a class="indexterm" name="idm5340"></a><a class="indexterm" name="idm5343"></a><p>If the <em class="replaceable"><code>$TMOUT</code></em>
	  environmental variable is set to a non-zero value
	  <code class="varname">time</code>, then the shell prompt will time out
	  after <code class="varname">$time</code> seconds. This will cause a
	  logout.</p><p>As of version 2.05b of Bash, it is now possible to use
	    <em class="replaceable"><code>$TMOUT</code></em> in a script in combination
	    with <a class="link" href="ch15.html#readref">read</a>.</p><p>
	  </p><pre class="programlisting"># Works in scripts for Bash, versions 2.05b and later.

TMOUT=3    # Prompt times out at three seconds.

echo "What is your favorite song?"
echo "Quickly now, you only have $TMOUT seconds to answer!"
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # Default response.
fi

echo "Your favorite song is $song."</pre><p>
	  </p><p><a name="timingloop"></a></p><p>There are other, more complex, ways of implementing
	    timed input in a script. One alternative is to set up
	    a timing loop to signal the script when it times out.
	    This also requires a signal handling routine to <a class="link" href="ch32.html#trapref1">trap</a> (see <a class="xref" href="ch32.html#ex76" title="Example 32.5. Trapping at exit">Example 32.5, &#8220;Trapping at exit&#8221;</a>)
	    the interrupt generated by the timing loop (whew!).</p><div class="example"><a name="tmdin"></a><p class="title"><b>Example 9.2. Timed Input</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# timed-input.sh

# TMOUT=3    Also works, as of newer versions of Bash.

TIMER_INTERRUPT=14
TIMELIMIT=3  # Three seconds in this instance.
             # May be set to different value.

PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # Don't want to mix up the two instances. 
    echo "Your favorite veggie is $answer"
    kill $!  #  Kills no-longer-needed TimerOn function
             #+ running in background.
             #  $! is PID of last job running in background.
  fi

}  


TimerOn()
{
  sleep $TIMELIMIT &amp;&amp; kill -s 14 $$ &amp;
  # Waits 3 seconds, then sends sigalarm to script.
}  


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}  

trap Int14Vector $TIMER_INTERRUPT
# Timer interrupt (14) subverted for our purposes.

echo "What is your favorite vegetable "
TimerOn
read answer
PrintAnswer


#  Admittedly, this is a kludgy implementation of timed input.
#  However, the "-t" option to "read" simplifies this task.
#  See the "t-out.sh" script.
#  However, what about timing not just single user input,
#+ but an entire script?

#  If you need something really elegant ...
#+ consider writing the application in C or C++,
#+ using appropriate library functions, such as 'alarm' and 'setitimer.'

exit 0
</pre></div></div><br class="example-break"><p><a name="sttyto"></a></p><p>An alternative is using <a class="link" href="ch17.html#sttyref">stty</a>.</p><div class="example"><a name="timeout"></a><p class="title"><b>Example 9.3. Once more, timed input</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# timeout.sh

#  Written by Stephane Chazelas,
#+ and modified by the document author.

INTERVAL=5                # timeout interval

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # or just  read $varname
  stty "$old_tty_settings"
  # See man page for "stty."
}

echo; echo -n "What's your name? Quick! "
timedout_read $INTERVAL your_name

#  This may not work on every terminal type.
#  The maximum timeout depends on the terminal.
#+ (it is often 25.5 seconds).

echo

if [ ! -z "$your_name" ]  # If name input before timeout ...
then
  echo "Your name is $your_name."
else
  echo "Timed out."
fi

echo

# The behavior of this script differs somewhat from "timed-input.sh."
# At each keystroke, the counter resets.

exit 0
</pre></div></div><br class="example-break"><p>Perhaps the simplest method is using the
	    <code class="option">-t</code> option to <a class="link" href="ch15.html#readref">read</a>.</p><div class="example"><a name="tout"></a><p class="title"><b>Example 9.4. Timed <em class="firstterm">read</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# t-out.sh [time-out]
# Inspired by a suggestion from "syngin seven" (thanks).


TIMELIMIT=4         # 4 seconds

read -t $TIMELIMIT variable &lt;&amp;1
#                           ^^^
#  In this instance, "&lt;&amp;1" is needed for Bash 1.x and 2.x,
#  but unnecessary for Bash 3+.

echo

if [ -z "$variable" ]  # Is null?
then
  echo "Timed out, variable still unset."
else  
  echo "variable = $variable"
fi  

exit 0
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="uidref"></a><code class="varname">$UID</code></span></dt><dd><a class="indexterm" name="idm5381"></a><a class="indexterm" name="idm5383"></a><a class="indexterm" name="idm5386"></a><p>User ID number</p><p>Current user's user identification number, as
	      recorded in <a class="link" href="aph.html#datafilesref1"><code class="filename">/etc/passwd</code></a></p><p>This is the current user's real id, even if she has
	      temporarily assumed another identity through <a class="link" href="ch17.html#suref">su</a>. <code class="varname">$UID</code> is a
	      readonly variable, not subject to change from the command
	      line or within a script, and is the counterpart to the
	      <a class="link" href="ch17.html#idref">id</a> builtin.</p><div class="example"><a name="amiroot"></a><p class="title"><b>Example 9.5. Am I root?</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# am-i-root.sh:   Am I root or not?

ROOT_UID=0   # Root has $UID 0.

if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
then
  echo "You are root."
else
  echo "You are just an ordinary user (but mom loves you just the same)."
fi

exit 0


# ============================================================= #
# Code below will not execute, because the script already exited.

# An alternate method of getting to the root of matters:

ROOTUSER_NAME=root

username=`id -nu`              # Or...   username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
else
  echo "You are just a regular fella."
fi
</pre></div></div><br class="example-break"><p>See also <a class="xref" href="ch02.html#ex2" title="Example 2.3. cleanup: An enhanced and generalized version of above scripts.">Example 2.3, &#8220;<em class="firstterm">cleanup</em>: An enhanced
      and generalized version of above scripts.&#8221;</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The variables <code class="varname">$ENV</code>,
	  <code class="varname">$LOGNAME</code>, <code class="varname">$MAIL</code>,
	  <code class="varname">$TERM</code>, <code class="varname">$USER</code>, and
	  <code class="varname">$USERNAME</code> are <span class="emphasis"><em>not</em></span>
	  Bash <a class="link" href="ch15.html#builtinref">builtins</a>. These are,
	  however, often set as <a class="link" href="ch04s04.html#envref">environmental variables</a> in
	  one of the <a class="link" href="aph.html#filesref1">Bash</a> or
	  <em class="firstterm">login</em> startup files. <a name="shellvarref"></a><code class="varname">$SHELL</code>,
	  the name of the user's login shell, may be set from
	  <code class="filename">/etc/passwd</code> or in an <span class="quote">&#8220;<span class="quote">init</span>&#8221;</span>
	  script, and it is likewise not a Bash builtin.</p><p>
	      </p><pre class="screen">
<code class="prompt">tcsh% </code><strong class="userinput"><code>echo $LOGNAME</code></strong>
<code class="computeroutput">bozo</code>
<code class="prompt">tcsh% </code><strong class="userinput"><code>echo $SHELL</code></strong>
<code class="computeroutput">/bin/tcsh</code>
<code class="prompt">tcsh% </code><strong class="userinput"><code>echo $TERM</code></strong>
<code class="computeroutput">rxvt</code>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo $LOGNAME</code></strong>
<code class="computeroutput">bozo</code>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $SHELL</code></strong>
<code class="computeroutput">/bin/tcsh</code>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $TERM</code></strong>
<code class="computeroutput">rxvt</code>
	      </pre><p>
	      </p></div></dd></dl></div><div class="variablelist"><a name="posparmslist"></a><p class="title"><b>Positional Parameters</b></p><dl class="variablelist"><dt><span class="term"><a name="posparamref"></a><code class="varname">$0</code>, <code class="varname">$1</code>,
	  <code class="varname">$2</code>, etc.</span></dt><dd><a class="indexterm" name="idm5447"></a><a class="indexterm" name="idm5449"></a><a class="indexterm" name="idm5452"></a><a class="indexterm" name="idm5454"></a><p>Positional parameters, passed from command
	      line to script, passed to a function, or <a class="link" href="ch15.html#setref">set</a> to a variable (see <a class="xref" href="ch04s04.html#ex17" title="Example 4.5. Positional Parameters">Example 4.5, &#8220;Positional Parameters&#8221;</a> and <a class="xref" href="ch15.html#ex34" title="Example 15.16. Using set with positional parameters">Example 15.16, &#8220;Using <em class="firstterm">set</em> with positional
	        parameters&#8221;</a>)</p></dd><dt><span class="term"><a name="clacountref"></a><code class="varname">$#</code></span></dt><dd><a class="indexterm" name="idm5466"></a><a class="indexterm" name="idm5468"></a><a class="indexterm" name="idm5471"></a><a class="indexterm" name="idm5474"></a><p>Number of command-line arguments
		<a href="#ftn.idm5479" class="footnote" name="idm5479"><sup class="footnote">[44]</sup></a>
	    or positional parameters (see <a class="xref" href="ch36s02.html#ex4" title="Example 36.2.  A slightly more complex shell wrapper">Example 36.2, &#8220; A slightly more complex <em class="firstterm">shell
	wrapper</em>&#8221;</a>)</p></dd><dt><span class="term"><a name="appref"></a><code class="varname">$*</code></span></dt><dd><a class="indexterm" name="idm5490"></a><a class="indexterm" name="idm5492"></a><a class="indexterm" name="idm5495"></a><a class="indexterm" name="idm5498"></a><p>All of the positional parameters, seen as a single
	    word, <span class="command"><strong>"$*"</strong></span> is equivalent to 
	    <span class="command"><strong>"$1${IFS:0:1}$2${IFS:0:1}$3..."</strong></span>
	  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span class="quote">&#8220;<span class="quote"><code class="varname">$*</code></span>&#8221;</span> must be
	    quoted.</p></div></dd><dt><span class="term"><a name="appref2"></a><code class="varname">$@</code></span></dt><dd><a class="indexterm" name="idm5514"></a><a class="indexterm" name="idm5516"></a><a class="indexterm" name="idm5519"></a><p>Same as <span class="token">$*</span>, but each parameter is a
	    quoted string, that is, the parameters are passed on
	    intact, without interpretation or expansion. This means,
	    among other things, that each parameter in the argument
	    list is seen as a separate word, <span class="command"><strong>"$@"</strong></span>
	    is equivalent to <span class="command"><strong>"$1" "$2" ...</strong></span>
	  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Of course, <span class="quote">&#8220;<span class="quote"><code class="varname">$@</code></span>&#8221;</span>
	    should be quoted.</p></div><div class="example"><a name="arglist"></a><p class="title"><b>Example 9.6. <em class="firstterm">arglist</em>: Listing arguments
	      with $* and $@</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# arglist.sh
# Invoke this script with several arguments, such as "one two three" ...

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  exit $E_BADARGS
fi  

echo

index=1          # Initialize count.

echo "Listing args with \"\$*\":"
for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* sees all arguments as single word. 
echo "Entire arg list seen as single word."

echo

index=1          # Reset count.
                 # What happens if you forget to do this?

echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ sees arguments as separate words. 
echo "Arg list seen as separate words."

echo

index=1          # Reset count.

echo "Listing args with \$* (unquoted):"
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # Unquoted $* sees arguments as separate words. 
echo "Arg list seen as separate words."

exit 0
</pre></div></div><br class="example-break"><p>Following a <span class="command"><strong>shift</strong></span>, the
	      <code class="varname">$@</code> holds the remaining command-line
	      parameters, lacking the previous <code class="varname">$1</code>,
	      which was lost.
	        </p><pre class="programlisting">#!/bin/bash
# Invoke with ./scriptname 1 2 3 4 5

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# Each "shift" loses parameter $1.
# "$@" then contains the remaining parameters.</pre><p>
            </p><p>The <code class="varname">$@</code> special parameter finds
	      use as a tool for filtering input into shell scripts. The
	      <span class="command"><strong>cat "$@"</strong></span> construction accepts input
	      to a script either from <code class="filename">stdin</code> or
	      from files given as parameters to the script. See <a class="xref" href="ch16s04.html#rot13" title="Example 16.24. rot13: ultra-weak encryption.">Example 16.24, &#8220;<em class="firstterm">rot13</em>: ultra-weak encryption.&#8221;</a> and <a class="xref" href="ch16s04.html#cryptoquote" title="Example 16.25. Generating &#8220;Crypto-Quote&#8221; Puzzles">Example 16.25, &#8220;Generating <span class="quote">&#8220;<span class="quote">Crypto-Quote</span>&#8221;</span> Puzzles&#8221;</a>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <code class="varname">$*</code> and <code class="varname">$@</code>
	      parameters sometimes display inconsistent and
	      puzzling behavior, depending on the setting of <a class="link" href="ch09s01.html#ifsref">$IFS</a>.</p></div><div class="example"><a name="incompat"></a><p class="title"><b>Example 9.7. Inconsistent <code class="varname">$*</code> and <code class="varname">$@</code> behavior</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

#  Erratic behavior of the "$*" and "$@" internal Bash variables,
#+ depending on whether or not they are quoted.
#  Demonstrates inconsistent handling of word splitting and linefeeds.


set -- "First one" "second" "third:one" "" "Fifth: :one"
# Setting the script arguments, $1, $2, $3, etc.

echo

echo 'IFS unchanged, using "$*"'
c=0
for i in "$*"               # quoted
do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
                            # Echo args.
done
echo ---

echo 'IFS unchanged, using $*'
c=0
for i in $*                 # unquoted
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# Try this script with ksh or zsh -y.

exit 0

#  This example script written by Stephane Chazelas,
#+ and slightly modified by the document author.
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="command"><strong>$@</strong></span> and <span class="command"><strong>$*</strong></span>
	      parameters differ only when between double quotes.</p></div><div class="example"><a name="ifsempty"></a><p class="title"><b>Example 9.8. <code class="varname">$*</code> and <code class="varname">$@</code> when
	        <code class="varname">$IFS</code> is empty</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

#  If $IFS set, but empty,
#+ then "$*" and "$@" do not echo positional params as expected.

mecho ()       # Echo positional parameters.
{
echo "$1,$2,$3";
}


IFS=""         # Set, but empty.
set a b c      # Positional parameters.

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  The behavior of $* and $@ when $IFS is empty depends
#+ on which Bash or sh version being run.
#  It is therefore inadvisable to depend on this "feature" in a script.


# Thanks, Stephane Chazelas.

exit
</pre></div></div><br class="example-break"></dd></dl></div><div class="variablelist"><a name="otherspecparams"></a><p class="title"><b>Other Special Parameters</b></p><dl class="variablelist"><dt><span class="term"><a name="flpref"></a><code class="varname">$-</code></span></dt><dd><a class="indexterm" name="idm5572"></a><a class="indexterm" name="idm5574"></a><a class="indexterm" name="idm5577"></a><p>Flags passed to script (using <a class="link" href="ch15.html#setref">set</a>). See <a class="xref" href="ch15.html#ex34" title="Example 15.16. Using set with positional parameters">Example 15.16, &#8220;Using <em class="firstterm">set</em> with positional
	        parameters&#8221;</a>.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>This was originally a <em class="firstterm">ksh</em>
	      construct adopted into Bash, and unfortunately it does not
	      seem to work reliably in Bash scripts. One possible use
	      for it is to have a script <a class="link" href="ch36s01.html#iitest">self-test
	      whether it is interactive</a>.</p></div></dd><dt><span class="term"><a name="pidvarref"></a><code class="varname">$!</code></span></dt><dd><a class="indexterm" name="idm5591"></a><a class="indexterm" name="idm5593"></a><a class="indexterm" name="idm5596"></a><p><a class="link" href="ch03.html#processiddef">PID</a> (process ID) of last
	      job run in background</p><p>
	      </p><pre class="programlisting">LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" &gt;&gt; "$LOG"
# So they can be monitored, and killed as necessary.
echo &gt;&gt; "$LOG"

# Logging commands.

echo -n "PID of \"$COMMAND1\":  " &gt;&gt; "$LOG"
${COMMAND1} &amp;
echo $! &gt;&gt; "$LOG"
# PID of "sleep 100":  1506

# Thank you, Jacques Lederer, for suggesting this.</pre><p>
            </p><p>Using <code class="varname">$!</code> for job control:</p><p>
	      </p><pre class="programlisting">possibly_hanging_job &amp; { sleep ${TIMEOUT}; eval 'kill -9 $!' &amp;&gt; /dev/null; }
# Forces completion of an ill-behaved program.
# Useful, for example, in init scripts.

# Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.</pre><p>

            </p><p>Or, alternately:</p><p>
              </p><pre class="programlisting"># This example by Matthew Sage.
# Used with permission.

TIMEOUT=30   # Timeout value in seconds
count=0

possibly_hanging_job &amp; {
        while ((count &lt; TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] &amp;&amp; ((count = TIMEOUT))'
                # /proc is where information about running processes is found.
                # "-d" tests whether it exists (whether directory exists).
                # So, we're waiting for the job in question to show up.
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] &amp;&amp; kill -15 $!'
        # If the hanging job is running, kill it.
}

#  -------------------------------------------------------------- #

#  However, this may not work as specified if another process
#+ begins to run after the "hanging_job" . . .
#  In such a case, the wrong job may be killed.
#  Ariel Meragelman suggests the following fix.

TIMEOUT=30
count=0
# Timeout value in seconds
possibly_hanging_job &amp; {

while ((count &lt; TIMEOUT )); do
  eval '[ ! -d "/proc/$lastjob" ] &amp;&amp; ((count = TIMEOUT))'
  lastjob=$!
  ((count++))
  sleep 1
done
eval '[ -d "/proc/$lastjob" ] &amp;&amp; kill -15 $lastjob'

}

exit</pre><p>
	    </p></dd><dt><span class="term"><a name="underscoreref"></a><code class="varname">$_</code></span></dt><dd><a class="indexterm" name="idm5615"></a><a class="indexterm" name="idm5617"></a><a class="indexterm" name="idm5620"></a><p>Special variable set to final argument of previous command
	        executed.</p><div class="example"><a name="uscref"></a><p class="title"><b>Example 9.9. Underscore variable</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

echo $_              #  /bin/bash
                     #  Just called /bin/bash to run the script.
                     #  Note that this will vary according to
                     #+ how the script is invoked.

du &gt;/dev/null        #  So no output from command.
echo $_              #  du

ls -al &gt;/dev/null    #  So no output from command.
echo $_              #  -al  (last argument)

:
echo $_              #  :</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="xstatvarref"></a><code class="varname">$?</code></span></dt><dd><a class="indexterm" name="idm5632"></a><a class="indexterm" name="idm5634"></a><a class="indexterm" name="idm5637"></a><p><a class="link" href="ch06.html#exitstatusref">Exit status</a>
	    of a command, <a class="link" href="ch24.html#functionref">function</a>,
	    or the script itself (see <a class="xref" href="ch24s01.html#max" title="Example 24.7. Maximum of two numbers">Example 24.7, &#8220;Maximum of two numbers&#8221;</a>)</p></dd><dt><span class="term"><a name="proccid"></a><code class="varname">$$</code></span></dt><dd><a class="indexterm" name="idm5648"></a><a class="indexterm" name="idm5650"></a><a class="indexterm" name="idm5653"></a><p>Process ID (<em class="firstterm">PID</em>) of
            the script itself.

	      <a href="#ftn.idm5658" class="footnote" name="idm5658"><sup class="footnote">[45]</sup></a>

            The <code class="varname">$$</code> variable often
	    finds use in scripts to construct <span class="quote">&#8220;<span class="quote">unique</span>&#8221;</span>
	    temp file names (see <a class="xref" href="ch32.html#online" title="Example 32.6. Cleaning up after Control-C">Example 32.6, &#8220;Cleaning up after <span class="keycap">Control-C</span>&#8221;</a>, <a class="xref" href="ch16s05.html#derpm" title="Example 16.31. Unpacking an rpm archive">Example 16.31, &#8220;Unpacking an <em class="firstterm">rpm</em> archive&#8221;</a>, and <a class="xref" href="ch15s01.html#selfdestruct" title="Example 15.27. A script that kills itself">Example 15.27, &#8220;A script that kills itself&#8221;</a>).
	    This is usually simpler than invoking <a class="link" href="ch16s05.html#mktempref">mktemp</a>.</p></dd></dl></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idm4671" class="footnote"><p><a href="#idm4671" class="para"><sup class="para">[41] </sup></a><a name="stackdefref"></a>
              A <em class="firstterm">stack register</em>
              is a set of consecutive memory locations, such that
	      the values stored (<em class="firstterm">pushed</em>)
	      are retrieved (<em class="firstterm">popped</em>)
	      in <span class="emphasis"><em>reverse</em></span> order. The last
	      value stored is the first retrieved. This is
	      sometimes called a <em class="replaceable"><code>LIFO</code></em>
	      (<em class="firstterm">last-in-first-out</em>) or
	      <em class="firstterm">pushdown</em> stack.</p></div><div id="ftn.idm5154" class="footnote"><p><a href="#idm5154" class="para"><sup class="para">[42] </sup></a>The PID of the currently running script is
		  <code class="varname">$$</code>, of course.</p></div><div id="ftn.idm5320" class="footnote"><p><a href="#idm5320" class="para"><sup class="para">[43] </sup></a>
		Somewhat analogous to <a class="link" href="ch24s02.html#recursionref">recursion</a>, in this context
		<em class="firstterm">nesting</em> refers to a pattern
		embedded within a larger pattern. One of the definitions
		of <em class="firstterm">nest</em>, according to the 1913
		edition of <span class="emphasis"><em>Webster's Dictionary</em></span>,
		illustrates this beautifully: <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>A collection of
		boxes, cases, or the like, of graduated size, each put
		within the one next larger.</em></span></span>&#8221;</span>
	      </p></div><div id="ftn.idm5479" class="footnote"><p><a href="#idm5479" class="para"><sup class="para">[44] </sup></a>The words <span class="quote">&#8220;<span class="quote">argument</span>&#8221;</span>
		and <span class="quote">&#8220;<span class="quote">parameter</span>&#8221;</span> are often used
		interchangeably. In the context of this document, they
		have the same precise meaning: <span class="emphasis"><em>a variable passed
		to a script or function.</em></span></p></div><div id="ftn.idm5658" class="footnote"><p><a href="#idm5658" class="para"><sup class="para">[45] </sup></a>Within a script, inside a subshell,
              <code class="varname">$$</code> <a class="link" href="ch09s01.html#bashpidref">returns
              the PID of the script</a>, not the
              subshell.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch09.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch09.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch09s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 9. Another Look at Variables </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2. Typing variables: <span class="command"><strong>declare</strong></span> or
	  <span class="command"><strong>typeset</strong></span></td></tr></table></div></body></html>
