<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>9. Miscellaneous Commands</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Advanced Bash-Scripting Guide"><link rel="up" href="ch16.html" title="Chapter 16. External Filters, Programs and Commands"><link rel="prev" href="ch16s08.html" title="8. Math Commands"><link rel="next" href="ch17.html" title="Chapter 17. System and Administrative Commands"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9. Miscellaneous Commands</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16s08.html">Prev</a> </td><th width="60%" align="center">Chapter 16. External Filters, Programs and Commands</th><td width="20%" align="right"> <a accesskey="n" href="ch17.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extmisc"></a>9. Miscellaneous Commands</h2></div></div></div><div class="variablelist"><a name="misccommandlisting"></a><p class="title"><b><a name="misccommandlisting1"></a>Command that fit in no
	   special category</b></p><dl class="variablelist"><dt><span class="term"><a name="jotref"></a><span class="command"><strong>jot</strong></span>, </span><span class="term"><a name="seqref"></a><span class="command"><strong>seq</strong></span></span></dt><dd><a class="indexterm" name="idm14011"></a><a class="indexterm" name="idm14013"></a><a class="indexterm" name="idm14016"></a><a class="indexterm" name="idm14018"></a><a class="indexterm" name="idm14021"></a><p>These utilities emit a sequence of integers, with a
	      user-selectable increment.</p><p>The default separator character between each integer is a
	      newline, but this can be changed with the <code class="option">-s</code>
	      option.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>seq 5</code></strong>
<code class="computeroutput">1
 2
 3
 4
 5</code>



<code class="prompt">bash$ </code><strong class="userinput"><code>seq -s : 5</code></strong>
<code class="computeroutput">1:2:3:4:5</code>
	      </pre><p>
	    </p><p>Both <span class="command"><strong>jot</strong></span> and <span class="command"><strong>seq</strong></span>
	      come in handy in a <a class="link" href="ch11s01.html#forloopref1">for
	      loop</a>.</p><div class="example"><a name="ex53"></a><p class="title"><b>Example 16.54. Using <em class="firstterm">seq</em> to generate loop
	      arguments</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# Using "seq"

echo

for a in `seq 80`  # or   for a in $( seq 80 )
# Same as   for a in 1 2 3 4 5 ... 80   (saves much typing!).
# May also use 'jot' (if present on system).
do
  echo -n "$a "
done      # 1 2 3 4 5 ... 80
# Example of using the output of a command to generate 
# the [list] in a "for" loop.

echo; echo


COUNT=80  # Yes, 'seq' also accepts a replaceable parameter.

for a in `seq $COUNT`  # or   for a in $( seq $COUNT )
do
  echo -n "$a "
done      # 1 2 3 4 5 ... 80

echo; echo

BEGIN=75
END=80

for a in `seq $BEGIN $END`
#  Giving "seq" two arguments starts the count at the first one,
#+ and continues until it reaches the second.
do
  echo -n "$a "
done      # 75 76 77 78 79 80

echo; echo

BEGIN=45
INTERVAL=5
END=80

for a in `seq $BEGIN $INTERVAL $END`
#  Giving "seq" three arguments starts the count at the first one,
#+ uses the second for a step interval,
#+ and continues until it reaches the third.
do
  echo -n "$a "
done      # 45 50 55 60 65 70 75 80

echo; echo

exit 0
</pre></div></div><br class="example-break"><p>A simpler example:</p><pre class="programlisting">#  Create a set of 10 files,
#+ named file.1, file.2 . . . file.10.
COUNT=10
PREFIX=file

for filename in `seq $COUNT`
do
  touch $PREFIX.$filename
  #  Or, can do other operations,
  #+ such as rm, grep, etc.
done</pre><div class="example"><a name="lettercount"></a><p class="title"><b>Example 16.55. Letter Count"</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# letter-count.sh: Counting letter occurrences in a text file.
# Written by Stefano Palmeri.
# Used in ABS Guide with permission.
# Slightly modified by document author.

MINARGS=2          # Script requires at least two arguments.
E_BADARGS=65
FILE=$1

let LETTERS=$#-1   # How many letters specified (as command-line args).
                   # (Subtract 1 from number of command-line args.)


show_help(){
	   echo
           echo Usage: `basename $0` file letters  
           echo Note: `basename $0` arguments are case sensitive.
           echo Example: `basename $0` foobar.txt G n U L i N U x.
	   echo
}

# Checks number of arguments.
if [ $# -lt $MINARGS ]; then
   echo
   echo "Not enough arguments."
   echo
   show_help
   exit $E_BADARGS
fi  


# Checks if file exists.
if [ ! -f $FILE ]; then
    echo "File \"$FILE\" does not exist."
    exit $E_BADARGS
fi



# Counts letter occurrences .
for n in `seq $LETTERS`; do
      shift
      if [[ `echo -n "$1" | wc -c` -eq 1 ]]; then             #  Checks arg.
             echo "$1" -\&gt; `cat $FILE | tr -cd  "$1" | wc -c` #  Counting.
      else
             echo "$1 is not a  single char."
      fi  
done

exit $?

#  This script has exactly the same functionality as letter-count2.sh,
#+ but executes faster.
#  Why?
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Somewhat more capable than <em class="firstterm">seq</em>,
	<span class="command"><strong>jot</strong></span> is a classic UNIX
	utility that is not normally included in a standard Linux
	distro. However, the source <em class="firstterm">rpm</em>
	is available for download from the <a class="ulink" href="http://www.mit.edu/afs/athena/system/rhlinux/athena-9.0/free/SRPMS/athena-jot-9.0-3.src.rpm" target="_top">
	MIT repository</a>.</p><p><a name="jotrandom"></a></p><p>Unlike <em class="firstterm">seq</em>, <span class="command"><strong>jot</strong></span> can
        generate a sequence of random numbers, using the <code class="option">-r</code>
	option.</p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>jot -r 3 999</code></strong>
<code class="computeroutput">1069
 1272
 1428</code></pre></div></dd><dt><span class="term"><a name="getopty"></a><span class="command"><strong>getopt</strong></span></span></dt><dd><a class="indexterm" name="idm14071"></a><a class="indexterm" name="idm14073"></a><p>The <span class="command"><strong>getopt</strong></span> command
	      parses command-line options preceded by a <a class="link" href="ch03.html#dashref">dash</a>. This external command
	      corresponds to the <a class="link" href="ch15.html#getoptsx">getopts</a>
	      Bash builtin. Using <span class="command"><strong>getopt</strong></span> permits
	      handling long options by means of the <code class="option">-l</code>
	      flag, and this also allows parameter reshuffling.</p><div class="example"><a name="ex33a"></a><p class="title"><b>Example 16.56. Using <em class="firstterm">getopt</em> to parse command-line
	        options</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# Using getopt

# Try the following when invoking this script:
#   sh ex33a.sh -a
#   sh ex33a.sh -abc
#   sh ex33a.sh -a -b -c
#   sh ex33a.sh -d
#   sh ex33a.sh -dXYZ
#   sh ex33a.sh -d XYZ
#   sh ex33a.sh -abcd
#   sh ex33a.sh -abcdZ
#   sh ex33a.sh -z
#   sh ex33a.sh a
# Explain the results of each of the above.

E_OPTERR=65

if [ "$#" -eq 0 ]
then   # Script needs at least one command-line argument.
  echo "Usage $0 -[options a,b,c]"
  exit $E_OPTERR
fi  

set -- `getopt "abcd:" "$@"`
# Sets positional parameters to command-line arguments.
# What happens if you use "$*" instead of "$@"?

while [ ! -z "$1" ]
do
  case "$1" in
    -a) echo "Option \"a\"";;
    -b) echo "Option \"b\"";;
    -c) echo "Option \"c\"";;
    -d) echo "Option \"d\" $2";;
     *) break;;
  esac

  shift
done

#  It is usually better to use the 'getopts' builtin in a script.
#  See "ex33.sh."

exit 0
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As <span class="emphasis"><em>Peggy Russell</em></span> points out:</p><p>It is often necessary to include an <a class="link" href="ch15.html#evalref">eval</a> to correctly process
              <a class="link" href="ch03.html#whitespaceref">whitespace</a> and
	      <em class="firstterm">quotes</em>.
	        </p><pre class="programlisting">args=$(getopt -o a:bc:d -- "$@")
eval set -- "$args"</pre></div><p>See <a class="xref" href="ch10s01.html#getoptsimple" title="Example 10.5. Emulating getopt">Example 10.5, &#8220;Emulating <em class="firstterm">getopt</em>&#8221;</a> for a simplified emulation
	      of <span class="command"><strong>getopt</strong></span>.</p></dd><dt><span class="term"><a name="runpartsref"></a><span class="command"><strong>run-parts</strong></span></span></dt><dd><a class="indexterm" name="idm14102"></a><a class="indexterm" name="idm14104"></a><p>The <span class="command"><strong>run-parts</strong></span> command

		<a href="#ftn.idm14109" class="footnote" name="idm14109"><sup class="footnote">[82]</sup></a>
	      
	      executes all the scripts in a target directory, sequentially
	      in ASCII-sorted filename order. Of course, the scripts
	      need to have execute permission.</p><p>The <a class="link" href="ch17.html#cronref">cron</a> <a class="link" href="ch16s06.html#daemonref">daemon</a> invokes
	      <span class="command"><strong>run-parts</strong></span> to run the scripts in
	      the <code class="filename">/etc/cron.*</code>
	      directories.</p></dd><dt><span class="term"><a name="yesref"></a><span class="command"><strong>yes</strong></span></span></dt><dd><a class="indexterm" name="idm14121"></a><a class="indexterm" name="idm14123"></a><p>In its default behavior the <span class="command"><strong>yes</strong></span>
	      command feeds a continuous string of the character
	      <code class="computeroutput">y</code> followed
	      by a line feed to <code class="filename">stdout</code>. A
	      <span class="keycap"><strong>control</strong></span>+<span class="keycap"><strong>C</strong></span>
	      terminates the run. A different output string
	      may be specified, as in <strong class="userinput"><code>yes different
	      string</code></strong>, which would continually output
	      <code class="computeroutput">different string</code> to
	      <code class="filename">stdout</code>.</p><p>One might well ask the purpose of this. From the
	      command-line or in a script, the output of
	      <span class="command"><strong>yes</strong></span> can be redirected or piped into a
	      program expecting user input. In effect, this becomes a sort
	      of poor man's version of <em class="firstterm">expect</em>.</p><p><strong class="userinput"><code>yes | fsck /dev/hda1</code></strong> runs
	      <span class="command"><strong>fsck</strong></span> non-interactively (careful!).</p><p><strong class="userinput"><code>yes | rm -r dirname</code></strong> has same effect as
	     <strong class="userinput"><code>rm -rf dirname</code></strong> (careful!).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Caution advised when piping
	     <em class="firstterm">yes</em> to a potentially dangerous
	     system command, such as <a class="link" href="ch17.html#fsckref">fsck</a>
	     or <a class="link" href="ch17.html#fdiskref">fdisk</a>. It might have
	     unintended consequences.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <em class="firstterm">yes</em> command parses variables,
	       or more accurately, it echoes parsed variables.
	       For example:</p><p>
	        </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>yes $BASH_VERSION</code></strong>
<code class="computeroutput">3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 3.1.17(1)-release
 . . .</code>
	      </pre><p>
	        </p><p>
	       This particular <span class="quote">&#8220;<span class="quote">feature</span>&#8221;</span> may be used
	       to create a <span class="emphasis"><em>very large</em></span> ASCII file on the fly:
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>yes $PATH &gt; huge_file.txt</code></strong>
<strong class="userinput"><code>Ctl-C</code></strong>	      
	      </pre><p>
	      Hit <strong class="userinput"><code>Ctl-C</code></strong> <span class="emphasis"><em>very
	      quickly</em></span>, or you just might get more than you
	      bargained for. . . .
	      </p></div><p><a name="yesemu"></a>The <em class="firstterm">yes</em>
	     command may be emulated in a very simple script <a class="link" href="ch24.html#functionref">function</a>.</p><pre class="programlisting">yes ()
{ # Trivial emulation of "yes" ...
  local DEFAULT_TEXT="y"
  while [ true ]   # Endless loop.
  do
    if [ -z "$1" ]
    then
      echo "$DEFAULT_TEXT"
    else           # If argument ...
      echo "$1"    # ... expand and echo it.
    fi
  done             #  The only things missing are the
}                  #+ --help and --version options.</pre></dd><dt><span class="term"><a name="bannerref"></a><span class="command"><strong>banner</strong></span></span></dt><dd><a class="indexterm" name="idm14178"></a><a class="indexterm" name="idm14180"></a><p>Prints arguments as a large vertical banner to
	      <code class="filename">stdout</code>, using an <a class="link" href="ch03.html#asciidef">ASCII</a> character (default
	      '#'). This may be redirected to a printer for
	      hardcopy.</p><p>Note that <em class="firstterm">banner</em> has been
               dropped from many Linux distros, presumably because it
               is no longer considered useful.</p></dd><dt><span class="term"><a name="printenvref"></a><span class="command"><strong>printenv</strong></span></span></dt><dd><a class="indexterm" name="idm14193"></a><a class="indexterm" name="idm14195"></a><p>Show all the <a class="link" href="ch04s04.html#envref">environmental
	      variables</a> set for a particular user.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>printenv | grep HOME</code></strong>
<code class="computeroutput">HOME=/home/bozo</code>
	      </pre><p>
	    </p></dd><dt><span class="term"><a name="lpref"></a><span class="command"><strong>lp</strong></span></span></dt><dd><a class="indexterm" name="idm14210"></a><a class="indexterm" name="idm14212"></a><p>The <span class="command"><strong>lp</strong></span> and <span class="command"><strong>lpr</strong></span>
	      commands send file(s) to the print queue, to be printed as
	      hard copy.

	      <a href="#ftn.idm14218" class="footnote" name="idm14218"><sup class="footnote">[83]</sup></a>

	      These commands trace the origin of their names to the
	      line printers of another era.
		<a href="#ftn.idm14222" class="footnote" name="idm14222"><sup class="footnote">[84]</sup></a>
      
      </p><p><code class="prompt">bash$ </code><strong class="userinput"><code>lp file1.txt</code></strong>
	        or <code class="prompt">bash </code><strong class="userinput"><code>lp
		&lt;file1.txt</code></strong></p><p>It is often useful to pipe the formatted output from
	        <span class="command"><strong>pr</strong></span> to <span class="command"><strong>lp</strong></span>.</p><p><code class="prompt">bash$ </code><strong class="userinput"><code>pr -options file1.txt | lp</code></strong>
	        </p><p>Formatting packages, such as <a class="link" href="ch16s04.html#groffref">groff</a> and
		<em class="firstterm">Ghostscript</em> may send their output
		directly to <span class="command"><strong>lp</strong></span>.</p><p><code class="prompt">bash$ </code><strong class="userinput"><code>groff -Tascii file.tr | lp</code></strong>
	        </p><p><code class="prompt">bash$ </code><strong class="userinput"><code>gs -options | lp file.ps</code></strong>
	        </p><p>Related commands are <span class="command"><strong>lpq</strong></span>, for viewing
	        the print queue, and <span class="command"><strong>lprm</strong></span>, for removing
		jobs from the print queue.</p></dd><dt><span class="term"><a name="teeref"></a><span class="command"><strong>tee</strong></span></span></dt><dd><a class="indexterm" name="idm14257"></a><a class="indexterm" name="idm14259"></a><p>[UNIX borrows an idea from the plumbing trade.]</p><p>This is a redirection operator, but with a difference. Like the
	      plumber's <em class="firstterm">tee,</em> it permits <span class="quote">&#8220;<span class="quote">siphoning
              off</span>&#8221;</span> <span class="emphasis"><em>to a file </em></span>the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</p><pre class="screen">
                             (redirection)
                            |----&gt; to file
                            |
  ==========================|====================
  command ---&gt; command ---&gt; |tee ---&gt; command ---&gt; ---&gt; output of pipe
  ===============================================
	      </pre><pre class="programlisting">cat listfile* | sort | tee check.file | uniq &gt; result.file
#                      ^^^^^^^^^^^^^^   ^^^^    

#  The file "check.file" contains the concatenated sorted "listfiles,"
#+ before the duplicate lines are removed by 'uniq.'</pre></dd><dt><span class="term"><a name="mkfiforef"></a><span class="command"><strong>mkfifo</strong></span></span></dt><dd><a class="indexterm" name="idm14275"></a><a class="indexterm" name="idm14277"></a><p><a name="namedpiperef"></a>This obscure command
	      creates a <em class="firstterm">named pipe</em>, a temporary
	      <em class="firstterm">first-in-first-out buffer</em> for
	      transferring data between processes.

		<a href="#ftn.idm14284" class="footnote" name="idm14284"><sup class="footnote">[85]</sup></a>

	      Typically, one process writes to the FIFO, and the other
	      reads from it. See <a class="xref" href="apa.html#fifo" title="Example A.14. fifo: Making daily backups, using named pipes">Example A.14, &#8220;<em class="firstterm">fifo</em>: Making daily backups, using
      named pipes&#8221;</a>.</p><p>
	      </p><pre class="programlisting">#!/bin/bash
# This short script by Omair Eshkenazi.
# Used in ABS Guide with permission (thanks!).

mkfifo pipe1   # Yes, pipes can be given names.
mkfifo pipe2   # Hence the designation "named pipe."

(cut -d' ' -f1 | tr "a-z" "A-Z") &gt;pipe2 &lt;pipe1 &amp;
ls -l | tr -s ' ' | cut -d' ' -f3,9- | tee pipe1 |
cut -d' ' -f2 | paste - pipe2

rm -f pipe1
rm -f pipe2

# No need to kill background processes when script terminates (why not?).

exit $?

Now, invoke the script and explain the output:
sh mkfifo-example.sh

4830.tar.gz          BOZO
pipe1   BOZO
pipe2   BOZO
mkfifo-example.sh    BOZO
Mixed.msg BOZO</pre><p>
            </p></dd><dt><span class="term"><a name="pathchkref"></a><span class="command"><strong>pathchk</strong></span></span></dt><dd><a class="indexterm" name="idm14297"></a><a class="indexterm" name="idm14299"></a><p>This command checks the validity of a filename. If the
	      filename exceeds the maximum allowable length (255
	      characters) or one or more of the directories in
	      its path is not searchable, then an error message
	      results.</p><p>Unfortunately, <span class="command"><strong>pathchk</strong></span> does
	      not return a recognizable error code, and it is therefore
	      pretty much useless in a script. Consider instead the
	      <a class="link" href="ch07s02.html#rtif">file test operators</a>.</p></dd><dt><span class="term"><a name="ddref"></a><span class="command"><strong>dd</strong></span></span></dt><dd><a class="indexterm" name="idm14311"></a><a class="indexterm" name="idm14313"></a><p>Though this somewhat obscure and much feared
              <span class="command"><strong>d</strong></span>ata <span class="command"><strong>d</strong></span>uplicator
              command originated as a utility for exchanging
              data on magnetic tapes between UNIX minicomputers
              and IBM mainframes, it still has its uses.
              The <span class="command"><strong>dd</strong></span> command simply copies a
              file (or <code class="filename">stdin/stdout</code>), but with
              conversions. <a name="ddconversions"></a>Possible conversions
              include ASCII/EBCDIC,
	        
		<a href="#ftn.idm14322" class="footnote" name="idm14322"><sup class="footnote">[86]</sup></a>

	      upper/lower case, swapping of byte pairs between input
	      and output, and skipping and/or truncating the head or
	      tail of the input file.</p><p>
	      </p><pre class="programlisting"># Converting a file to all uppercase:

dd if=$filename conv=ucase &gt; $filename.uppercase
#                    lcase   # For lower case conversion</pre><p>
            </p><p><a name="ddoptions"></a></p><p>Some basic options to <span class="command"><strong>dd</strong></span> are:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>if=INFILE</p><p>INFILE is the <em class="firstterm">source</em>
		        file.</p></li><li class="listitem"><p>of=OUTFILE</p><p>OUTFILE is the <em class="firstterm">target</em>
		        file, the file that will have the data written to it.</p></li><li class="listitem"><p>bs=BLOCKSIZE</p><p>This is the size of each block of data being read
		        and written, usually a power of 2.</p></li><li class="listitem"><p>skip=BLOCKS</p><p>How many blocks of data to skip in INFILE before
		        starting to copy. This is useful when the INFILE has
			<span class="quote">&#8220;<span class="quote">garbage</span>&#8221;</span> or garbled data in its
			header or when it is desirable to copy only a portion
			of the INFILE.</p></li><li class="listitem"><p>seek=BLOCKS</p><p>How many blocks of data to skip in OUTFILE before
		        starting to copy, leaving blank data at beginning
			of OUTFILE.</p></li><li class="listitem"><p>count=BLOCKS</p><p>Copy only this many blocks of data, rather than the
		        entire INFILE.</p></li><li class="listitem"><p>conv=CONVERSION</p><p>Type of conversion to be applied to INFILE data
                        before copying operation.</p></li></ul></div><p>
            </p><p>A <strong class="userinput"><code>dd --help</code></strong> lists all the
	      options this powerful utility takes.</p><div class="example"><a name="selfcopy"></a><p class="title"><b>Example 16.57. A script that copies itself</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# self-copy.sh

# This script copies itself.

file_subscript=copy

dd if=$0 of=$0.$file_subscript 2&gt;/dev/null
# Suppress messages from dd:   ^^^^^^^^^^^

exit $?

#  A program whose only output is its own source code
#+ is called a "quine" per Willard Quine.
#  Does this script qualify as a quine?
</pre></div></div><br class="example-break"><div class="example"><a name="exercisingdd"></a><p class="title"><b>Example 16.58. Exercising <em class="firstterm">dd</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# exercising-dd.sh

# Script by Stephane Chazelas.
# Somewhat modified by ABS Guide author.

infile=$0           # This script.
outfile=log.txt     # Output file left behind.
n=8
p=11

dd if=$infile of=$outfile bs=1 skip=$((n-1)) count=$((p-n+1)) 2&gt; /dev/null
# Extracts characters n to p (8 to 11) from this script ("bash").

# ----------------------------------------------------------------

echo -n "hello vertical world" | dd cbs=1 conv=unblock 2&gt; /dev/null
# Echoes "hello vertical world" vertically downward.
# Why? A newline follows each character dd emits.

exit $?
</pre></div></div><br class="example-break"><p><a name="ddkeystrokes"></a></p><p>To demonstrate just how versatile <span class="command"><strong>dd</strong></span> is,
	     let's use it to capture keystrokes.</p><div class="example"><a name="ddkeypress"></a><p class="title"><b>Example 16.59. Capturing Keystrokes</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# dd-keypress.sh: Capture keystrokes without needing to press ENTER.


keypresses=4                      # Number of keypresses to capture.


old_tty_setting=$(stty -g)        # Save old terminal settings.

echo "Press $keypresses keys."
stty -icanon -echo                # Disable canonical mode.
                                  # Disable local echo.
keys=$(dd bs=1 count=$keypresses 2&gt; /dev/null)
# 'dd' uses stdin, if "if" (input file) not specified.

stty "$old_tty_setting"           # Restore old terminal settings.

echo "You pressed the \"$keys\" keys."

# Thanks, Stephane Chazelas, for showing the way.
exit 0
</pre></div></div><br class="example-break"><p><a name="ddrandom"></a></p><p>The <span class="command"><strong>dd</strong></span> command can do random access on a
	      data stream.

	        </p><pre class="programlisting">echo -n . | dd bs=1 seek=4 of=file conv=notrunc
#  The "conv=notrunc" option means that the output file
#+ will not be truncated.

# Thanks, S.C.</pre><p>
            </p><p><a name="ddcopy"></a></p><p>The <span class="command"><strong>dd</strong></span> command can copy raw data
	      and disk images to and from devices, such as floppies and
	      tape drives (<a class="xref" href="apa.html#copycd" title="Example A.5. copy-cd: Copying a data CD">Example A.5, &#8220;<em class="firstterm">copy-cd</em>: Copying a data CD&#8221;</a>). A common use is
	      creating boot floppies.</p><p>
		<strong class="userinput"><code>dd if=kernel-image of=/dev/fd0H1440</code></strong>
             </p><p>Similarly, <span class="command"><strong>dd</strong></span> can copy the entire
	       contents of a floppy, even one formatted with a
	       <span class="quote">&#8220;<span class="quote">foreign</span>&#8221;</span> OS, to the hard drive as an
	       image file.</p><p>
		<strong class="userinput"><code>dd if=/dev/fd0 of=/home/bozo/projects/floppy.img</code></strong>
             </p><p><a name="bfs"></a>Likewise, <span class="command"><strong>dd</strong></span>
             can create bootable flash drives and SD cards.</p><p><strong class="userinput"><code>dd if=image.iso of=/dev/sdb</code></strong></p><p><a name="rpsdcard01"></a></p><div class="example"><a name="rpsdcard"></a><p class="title"><b>Example 16.60. Preparing a bootable SD card for the
		    <span class="emphasis"><em>Raspberry Pi</em></span></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# rp.sdcard.sh
# Preparing an SD card with a bootable image for the Raspberry Pi.

# $1 = imagefile name
# $2 = sdcard (device file)
# Otherwise defaults to the defaults, see below.

DEFAULTbs=4M                                 # Block size, 4 mb default.
DEFAULTif="2013-07-26-wheezy-raspbian.img"   # Commonly used distro.
DEFAULTsdcard="/dev/mmcblk0"                 # May be different. Check!
ROOTUSER_NAME=root                           # Must run as root!
E_NOTROOT=81
E_NOIMAGE=82

username=$(id -nu)                           # Who is running this script?
if [ "$username" != "$ROOTUSER_NAME" ]
then
  echo "This script must run as root or with root privileges."
  exit $E_NOTROOT
fi

if [ -n "$1" ]
then
  imagefile="$1"
else
  imagefile="$DEFAULTif"
fi

if [ -n "$2" ]
then
  sdcard="$2"
else
  sdcard="$DEFAULTsdcard"
fi

if [ ! -e $imagefile ]
then
  echo "Image file \"$imagefile\" not found!"
  exit $E_NOIMAGE
fi

echo "Last chance to change your mind!"; echo
read -s -n1 -p "Hit a key to write $imagefile to $sdcard [Ctl-c to exit]."
echo; echo

echo "Writing $imagefile to $sdcard ..."
dd bs=$DEFAULTbs if=$imagefile of=$sdcard

exit $?

# Exercises:
# ---------
# 1) Provide additional error checking.
# 2) Have script autodetect device file for SD card (difficult!).
# 3) Have script sutodetect image file (*img) in $PWD.
</pre></div></div><br class="example-break"><p><a name="ddswap"></a></p><p>
	      Other applications of <span class="command"><strong>dd</strong></span> include
	      initializing temporary swap files (<a class="xref" href="ch31.html#ex73" title="Example 31.2. Setting up a swapfile using /dev/zero">Example 31.2, &#8220;Setting up a swapfile using <code class="filename">/dev/zero</code>&#8221;</a>)
	      and ramdisks (<a class="xref" href="ch31.html#ramdisk" title="Example 31.3. Creating a ramdisk">Example 31.3, &#8220;Creating a ramdisk&#8221;</a>). It can even do a
	      low-level copy of an entire hard drive partition, although
	      this is not necessarily recommended.</p><p>People (with presumably nothing better to do with
	      their time) are constantly thinking of interesting
	      applications of <span class="command"><strong>dd</strong></span>.</p><p><a name="ddfdel"></a></p><div class="example"><a name="blotout"></a><p class="title"><b>Example 16.61. Securely deleting a file</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# blot-out.sh: Erase "all" traces of a file.

#  This script overwrites a target file alternately
#+ with random bytes, then zeros before finally deleting it.
#  After that, even examining the raw disk sectors by conventional methods
#+ will not reveal the original file data.

PASSES=7         #  Number of file-shredding passes.
                 #  Increasing this slows script execution,
                 #+ especially on large target files.
BLOCKSIZE=1      #  I/O with /dev/urandom requires unit block size,
                 #+ otherwise you get weird results.
E_BADARGS=70     #  Various error exit codes.
E_NOT_FOUND=71
E_CHANGED_MIND=72

if [ -z "$1" ]   # No filename specified.
then
  echo "Usage: `basename $0` filename"
  exit $E_BADARGS
fi

file=$1

if [ ! -e "$file" ]
then
  echo "File \"$file\" not found."
  exit $E_NOT_FOUND
fi  

echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
read answer
case "$answer" in
[nN]) echo "Changed your mind, huh?"
      exit $E_CHANGED_MIND
      ;;
*)    echo "Blotting out file \"$file\".";;
esac


flength=$(ls -l "$file" | awk '{print $5}')  # Field 5 is file length.
pass_count=1

chmod u+w "$file"   # Allow overwriting/deleting the file.

echo

while [ "$pass_count" -le "$PASSES" ]
do
  echo "Pass #$pass_count"
  sync         # Flush buffers.
  dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
               # Fill with random bytes.
  sync         # Flush buffers again.
  dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
               # Fill with zeros.
  sync         # Flush buffers yet again.
  let "pass_count += 1"
  echo
done  


rm -f $file    # Finally, delete scrambled and shredded file.
sync           # Flush buffers a final time.

echo "File \"$file\" blotted out and deleted."; echo


exit 0

#  This is a fairly secure, if inefficient and slow method
#+ of thoroughly "shredding" a file.
#  The "shred" command, part of the GNU "fileutils" package,
#+ does the same thing, although more efficiently.

#  The file cannot not be "undeleted" or retrieved by normal methods.
#  However . . .
#+ this simple method would *not* likely withstand
#+ sophisticated forensic analysis.

#  This script may not play well with a journaled file system.
#  Exercise (difficult): Fix it so it does.



#  Tom Vier's "wipe" file-deletion package does a much more thorough job
#+ of file shredding than this simple script.
#     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2

#  For an in-depth analysis on the topic of file deletion and security,
#+ see Peter Gutmann's paper,
#+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
#       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html
</pre></div></div><br class="example-break"><p>See also the <a class="link" href="bi01.html#ddlink">dd
	      thread</a> entry in the <a class="link" href="bi01.html#biblioref">bibliography</a>.</p></dd><dt><span class="term"><a name="odref"></a><span class="command"><strong>od</strong></span></span></dt><dd><a class="indexterm" name="idm14425"></a><a class="indexterm" name="idm14427"></a><p>The <span class="command"><strong>od</strong></span>, or <em class="firstterm">octal
	      dump</em> filter converts input (or files) to octal
	      (base-8) or other bases. This is useful for viewing or
	      processing binary data files or otherwise unreadable system
	      <a class="link" href="ch29s01.html#devfileref">device files</a>, such as
	      <code class="filename">/dev/urandom</code>, and as a filter for
	      binary data.</p><p>
	      </p><pre class="programlisting">head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
# Sample output: 1324725719, 3918166450, 2989231420, etc.

# From rnd.sh example script, by Stéphane Chazelas</pre><p>
	  </p><p>See also <a class="xref" href="ch09s03.html#seedingrandom" title="Example 9.16. Reseeding RANDOM">Example 9.16, &#8220;Reseeding RANDOM&#8221;</a> and <a class="xref" href="apa.html#insertionsort" title="Example A.36. Insertion sort">Example A.36, &#8220;Insertion sort&#8221;</a>.</p></dd><dt><span class="term"><a name="hexdumpref"></a><span class="command"><strong>hexdump</strong></span></span></dt><dd><a class="indexterm" name="idm14445"></a><a class="indexterm" name="idm14447"></a><p>Performs a hexadecimal, octal, decimal, or ASCII
	      dump of a binary file. This command is the rough equivalent
	      of <span class="command"><strong>od</strong></span>, above, but not nearly as
	      useful. May be used to view the contents of a binary file,
	      in combination with <a class="link" href="ch16s09.html#ddref">dd</a> and <a class="link" href="ch16s05.html#lessref">less</a>.</p><p>
	  </p><pre class="programlisting">dd if=/bin/ls | hexdump -C | less
# The -C option nicely formats the output in tabular form.</pre><p>
	    </p></dd><dt><span class="term"><a name="objdumpref"></a><span class="command"><strong>objdump</strong></span></span></dt><dd><a class="indexterm" name="idm14461"></a><a class="indexterm" name="idm14463"></a><p>Displays information about an object file or binary
	      executable in either hexadecimal form or as a disassembled
	      listing (with the <code class="option">-d</code> option).</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>objdump -d /bin/ls</code></strong>
<code class="computeroutput">/bin/ls:     file format elf32-i386

 Disassembly of section .init:

 080490bc &lt;.init&gt;:
  80490bc:       55                      push   %ebp
  80490bd:       89 e5                   mov    %esp,%ebp
  . . .</code>
	      </pre><p>
	    </p></dd><dt><span class="term"><a name="mcookieref"></a><span class="command"><strong>mcookie</strong></span></span></dt><dd><a class="indexterm" name="idm14478"></a><a class="indexterm" name="idm14480"></a><p>This command generates a <span class="quote">&#8220;<span class="quote">magic cookie,</span>&#8221;</span> a
	      128-bit (32-character) pseudorandom hexadecimal number,
	      normally used as an authorization <span class="quote">&#8220;<span class="quote">signature</span>&#8221;</span>
	      by the X server. This also available for use in a script
	      as a <span class="quote">&#8220;<span class="quote">quick 'n dirty</span>&#8221;</span> random number.</p><pre class="programlisting">random000=$(mcookie)</pre><p>Of course, a script could use <a class="link" href="ch16s05.html#md5sumref">md5sum</a> for the same purpose.</p><pre class="programlisting"># Generate md5 checksum on the script itself.
random001=`md5sum $0 | awk '{print $1}'`
# Uses 'awk' to strip off the filename.</pre><p>The <span class="command"><strong>mcookie</strong></span> command gives yet another way
	      to generate a <span class="quote">&#8220;<span class="quote">unique</span>&#8221;</span> filename.</p><div class="example"><a name="tempfilename"></a><p class="title"><b>Example 16.62. Filename generator</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# tempfile-name.sh:  temp filename generator

BASE_STR=`mcookie`   # 32-character magic cookie.
POS=11               # Arbitrary position in magic cookie string.
LEN=5                # Get $LEN consecutive characters.

prefix=temp          #  This is, after all, a "temp" file.
                     #  For more "uniqueness," generate the
                     #+ filename prefix using the same method
                     #+ as the suffix, below.

suffix=${BASE_STR:POS:LEN}
                     #  Extract a 5-character string,
                     #+ starting at position 11.

temp_filename=$prefix.$suffix
                     # Construct the filename.

echo "Temp filename = "$temp_filename""

# sh tempfile-name.sh
# Temp filename = temp.e19ea

#  Compare this method of generating "unique" filenames
#+ with the 'date' method in ex51.sh.

exit 0
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="unitsref"></a><span class="command"><strong>units</strong></span></span></dt><dd><a class="indexterm" name="idm14504"></a><a class="indexterm" name="idm14506"></a><p>This utility converts between different <em class="firstterm">units
	      of measure</em>. While normally invoked in interactive
	      mode, <span class="command"><strong>units</strong></span> may find use in a
	      script.</p><div class="example"><a name="unitconversion"></a><p class="title"><b>Example 16.63. Converting meters to miles</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# unit-conversion.sh
# Must have 'units' utility installed.


convert_units ()  # Takes as arguments the units to convert.
{
  cf=$(units "$1" "$2" | sed --silent -e '1p' | awk '{print $2}')
  # Strip off everything except the actual conversion factor.
  echo "$cf"
}  

Unit1=miles
Unit2=meters
cfactor=`convert_units $Unit1 $Unit2`
quantity=3.73

result=$(echo $quantity*$cfactor | bc)

echo "There are $result $Unit2 in $quantity $Unit1."

#  What happens if you pass incompatible units,
#+ such as "acres" and "miles" to the function?

exit 0

# Exercise: Edit this script to accept command-line parameters,
#           with appropriate error checking, of course.
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="m4ref"></a><span class="command"><strong>m4</strong></span></span></dt><dd><a class="indexterm" name="idm14520"></a><a class="indexterm" name="idm14522"></a><p>A hidden treasure, <span class="command"><strong>m4</strong></span> is a
	      powerful macro
		 <a href="#ftn.idm14527" class="footnote" name="idm14527"><sup class="footnote">[87]</sup></a>
	      processing filter, virtually a complete language.
	      Although originally written as a pre-processor
	      for <em class="firstterm">RatFor</em>, <span class="command"><strong>m4</strong></span>
	      turned out to be useful as a stand-alone utility. In
	      fact, <span class="command"><strong>m4</strong></span> combines some of the
	      functionality of <a class="link" href="ch15.html#evalref">eval</a>,
	      <a class="link" href="ch16s04.html#trref">tr</a>, and <a class="link" href="apcs02.html#awkref">awk</a>, in addition to its extensive
	      macro expansion facilities.</p><p>The April, 2002 issue of <a class="ulink" href="http://www.linuxjournal.com" target="_top"><em class="citetitle">Linux Journal</em></a>
	      has a very nice article on <span class="command"><strong>m4</strong></span> and
	      its uses.</p><div class="example"><a name="m4"></a><p class="title"><b>Example 16.64. Using <em class="firstterm">m4</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# m4.sh: Using the m4 macro processor

# Strings
string=abcdA01
echo "len($string)" | m4                            #   7
echo "substr($string,4)" | m4                       # A01
echo "regexp($string,[0-1][0-1],\&amp;Z)" | m4      # 01Z

# Arithmetic
var=99
echo "incr($var)" | m4                              #  100
echo "eval($var / 3)" | m4                          #   33

exit
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="xmessageref"></a><span class="command"><strong>xmessage</strong></span></span></dt><dd><a class="indexterm" name="idm14549"></a><a class="indexterm" name="idm14551"></a><p>This X-based variant of
              <a class="link" href="ch15.html#echoref">echo</a> pops up a message/query
	      window on the desktop.</p><p>
	      </p><pre class="programlisting">xmessage Left click to continue -button okay</pre><p>
	      </p></dd><dt><span class="term"><a name="zenityref"></a><span class="command"><strong>zenity</strong></span></span></dt><dd><a class="indexterm" name="idm14563"></a><a class="indexterm" name="idm14565"></a><p>The
	      <a class="ulink" href="http://freshmeat.net/projects/zenity" target="_top">zenity</a>
	      utility is adept at displaying
	      <em class="firstterm">GTK+</em> dialog <a class="link" href="ch36s07.html#widgetref">widgets</a> and <a class="link" href="ch36s07.html#zenityref2">very suitable for scripting
	      purposes</a>.</p></dd><dt><span class="term"><a name="doexecref"></a><span class="command"><strong>doexec</strong></span></span></dt><dd><a class="indexterm" name="idm14578"></a><a class="indexterm" name="idm14580"></a><p>The <span class="command"><strong>doexec</strong></span> command enables passing
	      an arbitrary list of arguments to a <em class="firstterm">binary
	      executable</em>. In particular, passing
	      <em class="parameter"><code>argv[0]</code></em> (which corresponds to <a class="link" href="ch04s04.html#posparamref1">$0</a> in a script) lets the
	      executable be invoked by various names, and it can then
	      carry out different sets of actions, according to the name
	      by which it was called. What this amounts to is roundabout
	      way of passing options to an executable.</p><p>For example, the <code class="filename">/usr/local/bin</code> directory might
	      contain a binary called <span class="quote">&#8220;<span class="quote">aaa</span>&#8221;</span>.  Invoking
	      <span class="command"><strong>doexec /usr/local/bin/aaa list</strong></span>
	      would <span class="emphasis"><em>list</em></span> all those files
	      in the current working directory beginning with an
	      <span class="quote">&#8220;<span class="quote">a</span>&#8221;</span>, while invoking (the same executable
	      with) <span class="command"><strong>doexec /usr/local/bin/aaa delete </strong></span>
	      would <span class="emphasis"><em>delete</em></span> those files.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The various behaviors of the executable
              must be defined within the code of the executable itself,
              analogous to something like the following in a shell script:
                </p><pre class="programlisting">case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*       ) bail_out;;
esac</pre></div></dd><dt><span class="term"><span class="command"><strong>dialog</strong></span></span></dt><dd><a class="indexterm" name="idm14603"></a><a class="indexterm" name="idm14605"></a><p>The <a class="link" href="ch36s07.html#dialogref">dialog</a> family of tools
	      provide a method of calling interactive
	      <span class="quote">&#8220;<span class="quote">dialog</span>&#8221;</span> boxes from a script. The more
	      elaborate variations of <span class="command"><strong>dialog</strong></span> --
	      <span class="command"><strong>gdialog</strong></span>, <span class="command"><strong>Xdialog</strong></span>,
	      and <span class="command"><strong>kdialog</strong></span> -- actually invoke X-Windows
	      <a class="link" href="ch36s07.html#widgetref">widgets</a>.</p></dd><dt><span class="term"><a name="soxref"></a><span class="command"><strong>sox</strong></span></span></dt><dd><a class="indexterm" name="idm14621"></a><a class="indexterm" name="idm14623"></a><p>The <span class="command"><strong>sox</strong></span>, or
	      <span class="quote">&#8220;<span class="quote"><span class="command"><strong>so</strong></span>und
	      e<span class="command"><strong>x</strong></span>change</span>&#8221;</span> command plays and
	      performs transformations on sound files. In fact,
	      the <code class="filename">/usr/bin/play</code> executable
	      (now deprecated) is nothing but a shell wrapper for
	      <em class="firstterm">sox</em>.</p><p>For example, <span class="command"><strong>sox soundfile.wav
	      soundfile.au</strong></span> changes a WAV sound file into a
	      (Sun audio format) AU sound file.</p><p>Shell scripts are ideally suited for batch-processing
	      <span class="command"><strong>sox</strong></span> operations on
	      sound files. For examples, see the <a class="ulink" href="http://osl.iu.edu/~tveldhui/radio/" target="_top"> Linux Radio
	      Timeshift HOWTO</a> and the <a class="ulink" href="http://savannah.nongnu.org/projects/audiodo" target="_top">MP3do
	      Project</a>.</p></dd></dl></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idm14109" class="footnote"><p><a href="#idm14109" class="para"><sup class="para">[82] </sup></a>This is actually a script adapted from
		the Debian Linux distribution.</p></div><div id="ftn.idm14218" class="footnote"><p><a href="#idm14218" class="para"><sup class="para">[83] </sup></a>The <em class="firstterm">print queue</em> is
	      the group of jobs <span class="quote">&#8220;<span class="quote">waiting in line</span>&#8221;</span> to be
	      printed.</p></div><div id="ftn.idm14222" class="footnote"><p><a href="#idm14222" class="para"><sup class="para">[84] </sup></a>Large mechanical <em class="firstterm">line
		printers</em> printed a single
		line of type at a time onto joined
		sheets of <em class="firstterm">greenbar</em>
		paper, to the accompaniment of <a class="ulink" href="http://www.columbia.edu/cu/computinghistory/1403.html" target="_top">a
		great deal of noise</a>. The hardcopy
		thusly printed was referred to as a
		<em class="firstterm">printout</em>.</p></div><div id="ftn.idm14284" class="footnote"><p><a href="#idm14284" class="para"><sup class="para">[85] </sup></a>For an excellent overview of this
		  topic, see Andy Vaught's article, <a class="ulink" href="http://www2.linuxjournal.com/lj-issues/issue41/2156.html" target="_top">Introduction
		  to Named Pipes</a>, in the September, 1997 issue of
		  <a class="ulink" href="http://www.linuxjournal.com" target="_top"><em class="citetitle">Linux
		  Journal</em></a>.</p></div><div id="ftn.idm14322" class="footnote"><p><a href="#idm14322" class="para"><sup class="para">[86] </sup></a><acronym class="acronym">EBCDIC</acronym> (pronounced
		  <span class="quote">&#8220;<span class="quote">ebb-sid-ick</span>&#8221;</span>) is an acronym for Extended
		  Binary Coded Decimal Interchange Code, an obsolete
                  IBM data format. A bizarre application of
                  the <code class="option">conv=ebcdic</code> option of
                  <span class="command"><strong>dd</strong></span> is as a quick 'n easy, but not
                  very secure text file encoder.
		    </p><pre class="programlisting">cat $file | dd conv=swab,ebcdic &gt; $file_encrypted
# Encode (looks like gibberish).		    
# Might as well switch bytes (swab), too, for a little extra obscurity.

cat $file_encrypted | dd conv=swab,ascii &gt; $file_plaintext
# Decode.</pre><p>
                </p></div><div id="ftn.idm14527" class="footnote"><p><a href="#idm14527" class="para"><sup class="para">[87] </sup></a>A <em class="firstterm">macro</em> is a
		 symbolic constant that expands into a command string
		 or a set of operations on parameters. Simply put,
		 it's a shortcut or abbreviation.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16s08.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch17.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8. Math Commands </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 17. System and Administrative Commands</td></tr></table></div></body></html>
