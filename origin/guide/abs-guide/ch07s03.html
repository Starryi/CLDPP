<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3. Other Comparison Operators</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Advanced Bash-Scripting Guide"><link rel="up" href="ch07.html" title="Chapter 7. Tests"><link rel="prev" href="ch07s02.html" title="2. File test operators"><link rel="next" href="ch07s04.html" title="4. Nested if/then Condition Tests"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Other Comparison Operators</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s02.html">Prev</a> </td><th width="60%" align="center">Chapter 7. Tests</th><td width="20%" align="right"> <a accesskey="n" href="ch07s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comparison-ops"></a>3. Other Comparison Operators</h2></div></div></div><p>A <em class="firstterm">binary</em> comparison operator
	  compares two variables or quantities. <span class="emphasis"><em>Note
	  that integer and string comparison use a different set of
	  operators.</em></span></p><div class="variablelist"><a name="icomparison"></a><p class="title"><b><a name="icomparison1"></a>integer comparison</b></p><dl class="variablelist"><dt><span class="term"><a name="equalref"></a><span class="token">-eq</span></span></dt><dd><p>is equal to</p><p><strong class="userinput"><code>if [ "$a" -eq "$b" ]</code></strong></p></dd><dt><span class="term"><a name="nequalref"></a><span class="token">-ne</span></span></dt><dd><p>is not equal to</p><p><strong class="userinput"><code>if [ "$a" -ne "$b" ]</code></strong></p></dd><dt><span class="term"><a name="gt0ref"></a><span class="token">-gt</span></span></dt><dd><p>is greater than</p><p><strong class="userinput"><code>if [ "$a" -gt "$b" ]</code></strong></p></dd><dt><span class="term"><a name="ge0ref"></a><span class="token">-ge</span></span></dt><dd><p>is greater than or equal to</p><p><strong class="userinput"><code>if [ "$a" -ge "$b" ]</code></strong></p></dd><dt><span class="term"><a name="lt0ref"></a><span class="token">-lt</span></span></dt><dd><p>is less than</p><p><strong class="userinput"><code>if [ "$a" -lt "$b" ]</code></strong></p></dd><dt><span class="term"><a name="le0ref"></a><span class="token">-le</span></span></dt><dd><p>is less than or equal to</p><p><strong class="userinput"><code>if [ "$a" -le "$b" ]</code></strong></p></dd><dt><span class="term"><a name="intlt"></a><span class="token">&lt;</span></span></dt><dd><p>is less than (within <a class="link" href="ch08s03.html" title="3. The Double-Parentheses Construct">double
	      parentheses</a>)</p><p><strong class="userinput"><code>(("$a" &lt; "$b"))</code></strong></p></dd><dt><span class="term"><a name="lteq"></a><span class="token">&lt;=</span></span></dt><dd><p>is less than or equal to (within double parentheses)</p><p><strong class="userinput"><code>(("$a" &lt;= "$b"))</code></strong></p></dd><dt><span class="term"><a name="intgt"></a><span class="token">&gt;</span></span></dt><dd><p>is greater than (within double parentheses)</p><p><strong class="userinput"><code>(("$a" &gt; "$b"))</code></strong></p></dd><dt><span class="term"><a name="gteq"></a><span class="token">&gt;=</span></span></dt><dd><p>is greater than or equal to (within double parentheses)</p><p><strong class="userinput"><code>(("$a" &gt;= "$b"))</code></strong></p></dd></dl></div><div class="variablelist"><a name="scomparison"></a><p class="title"><b><a name="scomparison1"></a>string comparison</b></p><dl class="variablelist"><dt><span class="term"><span class="token">=</span></span></dt><dd><p><a name="equalsignref"></a></p><p>is equal to</p><p><strong class="userinput"><code>if [ "$a" = "$b" ]</code></strong></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Note the <a class="link" href="ch03.html#whitespaceref">whitespace</a>
              framing the <span class="command"><strong>=</strong></span>.</p><p><strong class="userinput"><code>if [ "$a"="$b" ]</code></strong> is
              <span class="emphasis"><em>not</em></span> equivalent to the
              above.</p></div></dd><dt><span class="term"><a name="scomparison2"></a><span class="token">==</span></span></dt><dd><p>is equal to</p><p><strong class="userinput"><code>if [ "$a" == "$b" ]</code></strong></p><p>This is a synonym for <span class="token">=</span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
	      The <span class="token">==</span> comparison operator behaves differently
	      within a <a class="link" href="ch07s01.html#dblbrackets">double-brackets</a>
	      test than within single brackets.
              </p><pre class="programlisting">[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
[[ $a == "z*" ]] # True if $a is equal to z* (literal matching).

[ $a == z* ]     # File globbing and word splitting take place.
[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).

# Thanks, Stéphane Chazelas</pre><p>
              </p></div></dd><dt><span class="term"><a name="notequal"></a><span class="token">!=</span></span></dt><dd><p>is not equal to</p><p><strong class="userinput"><code>if [ "$a" != "$b" ]</code></strong></p><p>This operator uses pattern matching within a <a class="link" href="ch07s01.html#dblbrackets">[[ ... ]]</a> construct.</p></dd><dt><span class="term"><a name="ltref"></a><span class="token">&lt;</span></span></dt><dd><p>is less than, in <a class="link" href="ch03.html#asciidef">ASCII</a> alphabetical
		    order</p><p><strong class="userinput"><code>if [[ "$a" &lt; "$b" ]]</code></strong></p><p><strong class="userinput"><code>if [ "$a" \&lt; "$b" ]</code></strong></p><p>Note that the <span class="quote">&#8220;<span class="quote">&lt;</span>&#8221;</span> needs to be
	      <a class="link" href="ch05s02.html#escp">escaped</a> within a
	      <strong class="userinput"><code>[  ]</code></strong> construct.</p></dd><dt><span class="term"><a name="gtref"></a><span class="token">&gt;</span></span></dt><dd><p>is greater than, in ASCII alphabetical order</p><p><strong class="userinput"><code>if [[ "$a" &gt; "$b" ]]</code></strong></p><p><strong class="userinput"><code>if [ "$a" \&gt; "$b" ]</code></strong></p><p>Note that the <span class="quote">&#8220;<span class="quote">&gt;</span>&#8221;</span> needs to be
	      escaped within a <strong class="userinput"><code>[  ]</code></strong> construct.</p><p>See <a class="xref" href="ch27.html#bubble" title="Example 27.11. The Bubble Sort">Example 27.11, &#8220;The Bubble Sort&#8221;</a> for an application of this
	      comparison operator.</p></dd><dt><span class="term"><a name="stringnull"></a><span class="token">-z</span></span></dt><dd><p>string is <em class="firstterm">null</em>,
	        that is, has zero length</p><pre class="programlisting"> String=''   # Zero-length ("null") string variable.

if [ -z "$String" ]
then
  echo "\$String is null."
else
  echo "\$String is NOT null."
fi     # $String is null.</pre></dd><dt><span class="term"><a name="stringnotnull"></a><span class="token">-n</span></span></dt><dd><p>string is not <em class="firstterm">null.</em></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <strong class="userinput"><code>-n</code></strong> test
		requires that the string be quoted within the
		test brackets. Using an unquoted string with
		<em class="firstterm">! -z</em>, or even just the
		unquoted string alone within test brackets (see <a class="xref" href="ch07s03.html#strtest" title="Example 7.6. Testing whether a string is null">Example 7.6, &#8220;Testing whether a string is <em class="firstterm">null</em>&#8221;</a>) normally works, however, this is
		an unsafe practice. <span class="emphasis"><em>Always</em></span> quote
		a tested string.
		  <a href="#ftn.idm3669" class="footnote" name="idm3669"><sup class="footnote">[37]</sup></a>
		</p></div></dd></dl></div><div class="example"><a name="ex13"></a><p class="title"><b>Example 7.5. Arithmetic and string comparisons</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

a=4
b=5

#  Here "a" and "b" can be treated either as integers or strings.
#  There is some blurring between the arithmetic and string comparisons,
#+ since Bash variables are not strongly typed.

#  Bash permits integer operations and comparisons on variables
#+ whose value consists of all-integer characters.
#  Caution advised, however.

echo

if [ "$a" -ne "$b" ]
then
  echo "$a is not equal to $b"
  echo "(arithmetic comparison)"
fi

echo

if [ "$a" != "$b" ]
then
  echo "$a is not equal to $b."
  echo "(string comparison)"
  #     "4"  != "5"
  # ASCII 52 != ASCII 53
fi

# In this particular instance, both "-ne" and "!=" work.

echo

exit 0
</pre></div></div><br class="example-break"><div class="example"><a name="strtest"></a><p class="title"><b>Example 7.6. Testing whether a string is <em class="firstterm">null</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
#  str-test.sh: Testing null strings and unquoted strings,
#+ but not strings and sealing wax, not to mention cabbages and kings . . .

# Using   if [ ... ]

# If a string has not been initialized, it has no defined value.
# This state is called "null" (not the same as zero!).

if [ -n $string1 ]    # string1 has not been declared or initialized.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Wrong result.
# Shows $string1 as not null, although it was not initialized.

echo

# Let's try it again.

if [ -n "$string1" ]  # This time, $string1 is quoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Quote strings within test brackets!

echo

if [ $string1 ]       # This time, $string1 stands naked.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # This works fine.
# The [ ... ] test operator alone detects whether the string is null.
# However it is good practice to quote it (if [ "$string1" ]).
#
# As Stephane Chazelas points out,
#    if [ $string1 ]    has one argument, "]"
#    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 


echo


string1=initialized

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Again, gives correct result.
# Still, it is better to quote it ("$string1"), because . . .


string1="a = b"

if [ $string1 ]       # Again, $string1 stands unquoted.
then
  echo "String \"string1\" is not null."
else  
  echo "String \"string1\" is null."
fi                    # Not quoting "$string1" now gives wrong result!

exit 0   # Thank you, also, Florian Wisser, for the "heads-up".
</pre></div></div><br class="example-break"><div class="example"><a name="ex14"></a><p class="title"><b>Example 7.7. <em class="firstterm">zmore</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# zmore

# View gzipped files with 'more' filter.

E_NOARGS=85
E_NOTFOUND=86
E_NOTGZIP=87

if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
# $1 can exist, but be empty:  zmore "" arg2 arg3
then
  echo "Usage: `basename $0` filename" &gt;&amp;2
  # Error message to stderr.
  exit $E_NOARGS
  # Returns 85 as exit status of script (error code).
fi  

filename=$1

if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
then
  echo "File $filename not found!" &gt;&amp;2   # Error message to stderr.
  exit $E_NOTFOUND
fi  

if [ ${filename##*.} != "gz" ]
# Using bracket in variable substitution.
then
  echo "File $1 is not a gzipped file!"
  exit $E_NOTGZIP
fi  

zcat $1 | more

# Uses the 'more' filter.
# May substitute 'less' if desired.

exit $?   # Script returns exit status of pipe.
#  Actually "exit $?" is unnecessary, as the script will, in any case,
#+ return the exit status of the last command executed.
</pre></div></div><br class="example-break"><div class="variablelist"><a name="ccomparison"></a><p class="title"><b><a name="ccomparison1"></a>compound comparison</b></p><dl class="variablelist"><dt><span class="term"><a name="compoundand"></a><span class="token">-a</span></span></dt><dd><p>logical and</p><p><em class="replaceable"><code>exp1 -a exp2</code></em> returns true if
		<span class="emphasis"><em>both</em></span> exp1 and exp2 are true.</p></dd><dt><span class="term"><a name="compoundor"></a><span class="token">-o</span></span></dt><dd><p>logical or </p><p><em class="replaceable"><code>exp1 -o exp2</code></em> returns
		true if either exp1 <span class="emphasis"><em>or</em></span> exp2 is
		true.</p></dd></dl></div><p>
         These are similar to the Bash comparison operators
	 <span class="command"><strong>&amp;&amp;</strong></span> and <span class="command"><strong>||</strong></span>, used
	 within <a class="link" href="ch07s01.html#dblbrackets">double brackets</a>.
	   </p><pre class="programlisting">[[ condition1 &amp;&amp; condition2 ]]</pre><p>
       </p><p>
	 The <span class="command"><strong>-o</strong></span> and <span class="command"><strong>-a</strong></span> operators
	 work with the <a class="link" href="ch07s01.html#ttestref">test</a> command or
	 occur within single test brackets.
         </p><pre class="programlisting">if [ "$expr1" -a "$expr2" ]
then
  echo "Both expr1 and expr2 are true."
else
  echo "Either expr1 or expr2 is false."
fi</pre><p>
	   </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>But, as <span class="emphasis"><em>rihad</em></span> points out:
</p><pre class="programlisting">[ 1 -eq 1 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # true
[ 1 -eq 2 ] &amp;&amp; [ -n "`echo true 1&gt;&amp;2`" ]   # (no output)
# ^^^^^^^ False condition. So far, everything as expected.

# However ...
[ 1 -eq 2 -a -n "`echo true 1&gt;&amp;2`" ]       # true
# ^^^^^^^ False condition. So, why "true" output?

# Is it because both condition clauses within brackets evaluate?
[[ 1 -eq 2 &amp;&amp; -n "`echo true 1&gt;&amp;2`" ]]     # (no output)
# No, that's not it.

# Apparently &amp;&amp; and || "short-circuit" while -a and -o do not.</pre><p>
	   </p></div><p>Refer to <a class="xref" href="ch08s01.html#andor" title="Example 8.3. Compound Condition Tests Using &amp;&amp; and ||">Example 8.3, &#8220;Compound Condition Tests Using &amp;&amp; and ||&#8221;</a>, <a class="xref" href="ch27.html#twodim" title="Example 27.17. Simulating a two-dimensional array, then tilting it">Example 27.17, &#8220;Simulating a two-dimensional array, then tilting it&#8221;</a>,
	 and <a class="xref" href="apa.html#whx" title="Example A.29. Spammer Hunt">Example A.29, &#8220;Spammer Hunt&#8221;</a> to see compound comparison operators
	 in action.</p><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idm3669" class="footnote"><p><a href="#idm3669" class="para"><sup class="para">[37] </sup></a>As S.C. points out, in a compound test,
		    even quoting the string variable might not
		    suffice. <strong class="userinput"><code>[ -n "$string" -o "$a" = "$b" ]</code></strong>
		    may cause an error with some versions of Bash if
		    <code class="varname">$string</code> is empty. The safe way
		    is to append an extra character to possibly empty variables,
		    <strong class="userinput"><code>[ "x$string" != x -o "x$a" = "x$b" ]</code></strong>
		    (the <span class="quote">&#8220;<span class="quote">x's</span>&#8221;</span> cancel out).</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. File test operators </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. Nested <em class="replaceable"><code>if/then</code></em> Condition Tests</td></tr></table></div></body></html>
