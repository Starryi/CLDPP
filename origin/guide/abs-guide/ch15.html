<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 15. Internal Commands and Builtins</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Advanced Bash-Scripting Guide"><link rel="up" href="pt04.html" title="Part Part 4. Commands"><link rel="prev" href="pt04.html" title="Part Part 4. Commands"><link rel="next" href="ch15s01.html" title="1. Job Control Commands"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 15. Internal Commands and Builtins</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pt04.html">Prev</a> </td><th width="60%" align="center">Part Part 4. Commands</th><td width="20%" align="right"> <a accesskey="n" href="ch15s01.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="internal"></a>Chapter 15. Internal Commands and Builtins</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch15s01.html">1. Job Control Commands</a></span></dt></dl></div><a class="indexterm" name="idm8603"></a><p><a name="builtinref"></a>A <em class="firstterm">builtin</em>
	is a <span class="command"><strong>command</strong></span> contained within the Bash tool
	set, literally <em class="firstterm">built in</em>. This is either
	for performance reasons -- builtins execute faster than external
	commands, which usually require <em class="firstterm">forking off</em>
	  <a href="#ftn.idm8611" class="footnote" name="idm8611"><sup class="footnote">[58]</sup></a>
	a separate process -- or because a particular builtin needs
	direct access to the shell internals.</p><p><a name="forkref"></a></p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><b></b></p></div></div></div><p><a name="parentref"></a>When a command or
		   the shell itself initiates (or
		   <em class="firstterm">spawns</em>) a new
		   subprocess to carry out a task, this is called
		   <em class="firstterm">forking</em>. This new process
		   is the <em class="firstterm">child</em>, and the process
		   that <em class="firstterm">forked</em> it off is the
		   <em class="firstterm">parent</em>. While the <em class="firstterm">child
		   process</em> is doing its work, the
		   <em class="firstterm">parent process</em> is still
		   executing.</p><p>Note that while a <em class="firstterm">parent
		   process</em> gets the <em class="firstterm">process
		   ID</em> of the <em class="firstterm">child
		   process</em>, and can thus pass arguments to it,
		   <span class="emphasis"><em>the reverse is not true</em></span>. <a class="link" href="ch34.html#parchildprobref">This can create problems
		   that are subtle and hard to track down.</a></p><div class="example"><a name="spawnscr"></a><p class="title"><b>Example 15.1. A script that spawns multiple instances of itself</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# spawn.sh


PIDS=$(pidof sh $0)  # Process IDs of the various instances of this script.
P_array=( $PIDS )    # Put them in an array (why?).
echo $PIDS           # Show process IDs of parent and child processes.
let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
                                      # Why subtract 1?
echo "$instances instance(s) of this script running."
echo "[Hit Ctl-C to exit.]"; echo


sleep 1              # Wait.
sh $0                # Play it again, Sam.

exit 0               # Not necessary; script will never get to here.
                     # Why not?

#  After exiting with a Ctl-C,
#+ do all the spawned instances of the script die?
#  If so, why?

# Note:
# ----
# Be careful not to run this script too long.
# It will eventually eat up too many system resources.

#  Is having a script spawn multiple instances of itself
#+ an advisable scripting technique.
#  Why or why not?
</pre></div></div><br class="example-break"><p><a name="bltinfrk"></a></p><p>Generally, a Bash <em class="firstterm">builtin</em>
		   does not fork a subprocess when it executes within
		   a script. An external system command or filter in
		   a script usually <span class="emphasis"><em>will</em></span> fork a
		   subprocess.</p></div><p>A builtin may be a synonym to a system command of the same
	name, but Bash reimplements it internally.  For example,
	the Bash <span class="command"><strong>echo</strong></span> command is not the same as
	<code class="filename">/bin/echo</code>, although their behavior is
	almost identical.
	   </p><pre class="programlisting">#!/bin/bash

echo "This line uses the \"echo\" builtin."
/bin/echo "This line uses the /bin/echo system command."</pre><p>
	</p><p><a name="keywordref"></a>A <em class="firstterm">keyword</em>
	is a <em class="firstterm">reserved</em> word, token or
	operator. Keywords have a special meaning to the shell,
	and indeed are the building blocks of the shell's
	syntax. As examples, <em class="firstterm">for</em>,
	<em class="firstterm">while</em>, <em class="firstterm">do</em>,
	and <em class="firstterm">!</em> are keywords. Similar to a <a class="link" href="ch15.html#builtinref">builtin</a>, a keyword is hard-coded into
	Bash, but unlike a <em class="firstterm">builtin</em>, a keyword is
	not in itself a command, but <span class="emphasis"><em>a subunit of a command
	construct</em></span>.

	   <a href="#ftn.idm8654" class="footnote" name="idm8654"><sup class="footnote">[59]</sup></a>

	</p><div class="variablelist"><a name="intio"></a><p class="title"><b><a name="intio1"></a>I/O</b></p><dl class="variablelist"><dt><span class="term"><a name="echoref"></a><span class="command"><strong>echo</strong></span></span></dt><dd><a class="indexterm" name="idm8666"></a><a class="indexterm" name="idm8668"></a><p>prints (to <code class="filename">stdout</code>) an expression
	      or variable (see <a class="xref" href="ch04s01.html#ex9" title="Example 4.1. Variable assignment and substitution">Example 4.1, &#8220;Variable assignment and substitution&#8221;</a>). 
	      </p><pre class="programlisting">echo Hello
echo $a</pre><p>An <span class="command"><strong>echo</strong></span> requires the
	      <code class="option">-e</code> option to print escaped characters. See
	      <a class="xref" href="ch05s02.html#escaped" title="Example 5.2. Escaped Characters">Example 5.2, &#8220;Escaped Characters&#8221;</a>.</p><p>Normally, each <span class="command"><strong>echo</strong></span> command prints
	      a terminal newline, but the <code class="option">-n</code> option
	      suppresses this.</p><p><a name="echogrepref"></a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>An <span class="command"><strong>echo</strong></span> can be used to feed a
	      sequence of commands down a pipe.</p><pre class="programlisting">if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
then
  echo "$VAR contains the substring sequence \"txt\""
fi</pre></div><p><a name="echocs"></a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>An <span class="command"><strong>echo</strong></span>, in combination with
	      <a class="link" href="ch12.html#commandsubref">command substitution</a>
	      can set a variable.</p><p><strong class="userinput"><code>a=`echo
	      "HELLO" | tr A-Z a-z`</code></strong></p><p>See also <a class="xref" href="ch16s04.html#lowercase" title="Example 16.22. lowercase: Changes all filenames in working directory to lowercase.">Example 16.22, &#8220;<em class="firstterm">lowercase</em>: Changes all
	      filenames in working directory to lowercase.&#8221;</a>, <a class="xref" href="ch16s02.html#ex57" title="Example 16.3. Badname, eliminate file names in current directory containing bad characters and whitespace.">Example 16.3, &#8220;<em class="firstterm">Badname</em>, eliminate file names
		in current directory containing bad characters and whitespace.&#8221;</a>, <a class="xref" href="ch16s08.html#monthlypmt" title="Example 16.47. Monthly Payment on a Mortgage">Example 16.47, &#8220;Monthly Payment on a Mortgage&#8221;</a>, and <a class="xref" href="ch16s08.html#base" title="Example 16.48. Base Conversion">Example 16.48, &#8220;Base Conversion&#8221;</a>.</p></div><p>Be aware that <span class="command"><strong>echo `command`</strong></span>
	      deletes any linefeeds that the output
	      of <em class="replaceable"><code>command</code></em>
	      generates.</p><p>The <a class="link" href="ch09s01.html#ifsref">$IFS</a> (internal field
	      separator) variable normally contains
	      <span class="token">\n</span> (linefeed) as one of its set of
	      <a class="link" href="ch03.html#whitespaceref">whitespace</a>
	      characters. Bash therefore splits the output of
	      <em class="replaceable"><code>command</code></em> at linefeeds
	      into arguments to <span class="command"><strong>echo</strong></span>.  Then
	      <span class="command"><strong>echo</strong></span> outputs these arguments,
	      separated by spaces.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>ls -l /usr/share/apps/kjezz/sounds</code></strong>
<code class="computeroutput">-rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au</code>




<code class="prompt">bash$ </code><strong class="userinput"><code>echo `ls -l /usr/share/apps/kjezz/sounds`</code></strong>
<code class="computeroutput">total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root ...</code>
	      </pre><p>
	    </p><p>
              So, how can we embed a linefeed within an
	      <a class="link" href="ch15.html#echoref">echoed</a> character string?

	     </p><pre class="programlisting"># Embedding a linefeed?
echo "Why doesn't this string \n split on two lines?"
# Doesn't split.

# Let's try something else.

echo
	     
echo $"A line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# But, is the "$" variable prefix really necessary?

echo

echo "This string splits
on two lines."
# No, the "$" is not needed.

echo
echo "---------------"
echo

echo -n $"Another line of text containing
a linefeed."
# Prints as two distinct lines (embedded linefeed).
# Even the -n option fails to suppress the linefeed here.

echo
echo
echo "---------------"
echo
echo

# However, the following doesn't work as expected.
# Why not? Hint: Assignment to a variable.
string1=$"Yet another line of text containing
a linefeed (maybe)."

echo $string1
# Yet another line of text containing a linefeed (maybe).
#                                    ^
# Linefeed becomes a space.

# Thanks, Steve Parker, for pointing this out.</pre><p>
            </p><p><a name="binecho"></a></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This command is a shell builtin, and not the same as
	      <code class="filename">/bin/echo</code>, although its behavior is
	      similar.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>type -a echo</code></strong>
<code class="computeroutput">echo is a shell builtin
 echo is /bin/echo</code>
	      </pre><p>
	  </p></div></dd><dt><span class="term"><a name="printfref"></a><span class="command"><strong>printf</strong></span></span></dt><dd><a class="indexterm" name="idm8738"></a><a class="indexterm" name="idm8740"></a><p>The <span class="command"><strong>printf</strong></span>, formatted print, command is an
	      enhanced <span class="command"><strong>echo</strong></span>. It is a limited variant
	      of the <em class="firstterm">C</em> language
	      <code class="function">printf()</code> library function, and its
	      syntax is somewhat different.</p><div class="cmdsynopsis"><p><code class="command">printf</code>   <em class="replaceable"><code>format-string</code></em>...   <em class="replaceable"><code>parameter</code></em>... </p></div><p>This is the Bash <em class="firstterm">builtin</em> version
	      of the <code class="filename">/bin/printf</code> or
	      <code class="filename">/usr/bin/printf</code> command. See the
	      <span class="command"><strong>printf</strong></span> <a class="link" href="ch16s01.html#manref">manpage</a> (of the system command)
	      for in-depth coverage.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Older versions of Bash may not support
	      <span class="command"><strong>printf</strong></span>.</p></div><div class="example"><a name="ex47"></a><p class="title"><b>Example 15.2. <em class="firstterm">printf</em> in action</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# printf demo

declare -r PI=3.14159265358979     # Read-only variable, i.e., a constant.
declare -r DecimalConstant=31373

Message1="Greetings,"
Message2="Earthling."

echo

printf "Pi to 2 decimal places = %1.2f" $PI
echo
printf "Pi to 9 decimal places = %1.9f" $PI  # It even rounds off correctly.

printf "\n"                                  # Prints a line feed,
                                             # Equivalent to 'echo' . . .

printf "Constant = \t%d\n" $DecimalConstant  # Inserts tab (\t).

printf "%s %s \n" $Message1 $Message2

echo

# ==========================================#
# Simulation of C function, sprintf().
# Loading a variable with a formatted string.

echo 

Pi12=$(printf "%1.12f" $PI)
echo "Pi to 12 decimal places = $Pi12"      # Roundoff error!

Msg=`printf "%s %s \n" $Message1 $Message2`
echo $Msg; echo $Msg

#  As it happens, the 'sprintf' function can now be accessed
#+ as a loadable module to Bash,
#+ but this is not portable.

exit 0
</pre></div></div><br class="example-break"><p>Formatting error messages is a useful application of
	      <span class="command"><strong>printf</strong></span></p><p>
	        </p><pre class="programlisting">E_BADDIR=85

var=nonexistent_directory

error()
{
  printf "$@" &gt;&amp;2
  # Formats positional params passed, and sends them to stderr.
  echo
  exit $E_BADDIR
}

cd $var || error $"Can't cd to %s." "$var"

# Thanks, S.C.</pre><p>
            </p><p>See also <a class="xref" href="ch36s07.html#progressbar" title="Example 36.17. A Progress Bar">Example 36.17, &#8220;A Progress Bar&#8221;</a>.</p></dd><dt><span class="term"><a name="readref"></a><span class="command"><strong>read</strong></span></span></dt><dd><a class="indexterm" name="idm8778"></a><a class="indexterm" name="idm8780"></a><p><span class="quote">&#8220;<span class="quote">Reads</span>&#8221;</span> the value
	    of a variable from <code class="filename">stdin</code>, that
	    is, interactively fetches input from the keyboard. The
	    <code class="option">-a</code> option lets <span class="command"><strong>read</strong></span>
	    get array variables (see <a class="xref" href="ch27.html#ex67" title="Example 27.6. Some special properties of arrays">Example 27.6, &#8220;Some special properties of arrays&#8221;</a>).</p><div class="example"><a name="ex36"></a><p class="title"><b>Example 15.3. Variable assignment, using <em class="firstterm">read</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# "Reading" variables.

echo -n "Enter the value of variable 'var1': "
# The -n option to echo suppresses newline.

read var1
# Note no '$' in front of var1, since it is being set.

echo "var1 = $var1"


echo

# A single 'read' statement can set multiple variables.
echo -n "Enter the values of variables 'var2' and 'var3' "
echo =n "(separated by a space or tab): "
read var2 var3
echo "var2 = $var2      var3 = $var3"
#  If you input only one value,
#+ the other variable(s) will remain unset (null).

exit 0
</pre></div></div><br class="example-break"><p>A <span class="command"><strong>read</strong></span> without an associated variable
	      assigns its input to the dedicated variable <a class="link" href="ch09s01.html#replyref">$REPLY</a>.</p><div class="example"><a name="readnovar"></a><p class="title"><b>Example 15.4. What happens when <em class="firstterm">read</em> has no
	        variable</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# read-novar.sh

echo

# -------------------------- #
echo -n "Enter a value: "
read var
echo "\"var\" = "$var""
# Everything as expected here.
# -------------------------- #

echo

# ------------------------------------------------------------------- #
echo -n "Enter another value: "
read           #  No variable supplied for 'read', therefore...
               #+ Input to 'read' assigned to default variable, $REPLY.
var="$REPLY"
echo "\"var\" = "$var""
# This is equivalent to the first code block.
# ------------------------------------------------------------------- #

echo
echo "========================="
echo


#  This example is similar to the "reply.sh" script.
#  However, this one shows that $REPLY is available
#+ even after a 'read' to a variable in the conventional way.


# ================================================================= #

#  In some instances, you might wish to discard the first value read.
#  In such cases, simply ignore the $REPLY variable.

{ # Code block.
read            # Line 1, to be discarded.
read line2      # Line 2, saved in variable.
  } &lt;$0
echo "Line 2 of this script is:"
echo "$line2"   #   # read-novar.sh
echo            #   #!/bin/bash  line discarded.

# See also the soundcard-on.sh script.

exit 0
</pre></div></div><br class="example-break"><p>Normally, inputting a <strong class="userinput"><code>\</code></strong>
	      suppresses a newline during input to
	      a <span class="command"><strong>read</strong></span>. The <code class="option">-r</code>
	      option causes an inputted <strong class="userinput"><code>\</code></strong> to be
	      interpreted literally.</p><div class="example"><a name="readr"></a><p class="title"><b>Example 15.5. Multi-line input to <em class="firstterm">read</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

echo

echo "Enter a string terminated by a \\, then press &lt;ENTER&gt;."
echo "Then, enter a second string (no \\ this time), and again press &lt;ENTER&gt;."

read var1     # The "\" suppresses the newline, when reading $var1.
              #     first line \
              #     second line

echo "var1 = $var1"
#     var1 = first line second line

#  For each line terminated by a "\"
#+ you get a prompt on the next line to continue feeding characters into var1.

echo; echo

echo "Enter another string terminated by a \\ , then press &lt;ENTER&gt;."
read -r var2  # The -r option causes the "\" to be read literally.
              #     first line \

echo "var2 = $var2"
#     var2 = first line \

# Data entry terminates with the first &lt;ENTER&gt;.

echo 

exit 0
</pre></div></div><br class="example-break"><p><a name="readoptions"></a></p><p>The <span class="command"><strong>read</strong></span> command has some interesting
	      options that permit echoing a prompt and even reading keystrokes
	      without hitting <span class="keycap"><strong>ENTER</strong></span>.</p><pre class="programlisting"># Read a keypress without hitting ENTER.

read -s -n1 -p "Hit a key " keypress
echo; echo "Keypress was "\"$keypress\""."

# -s option means do not echo input.
# -n N option means accept only N characters of input.
# -p option means echo the following prompt before reading input.

# Using these options is tricky, since they need to be in the correct order.</pre><p><a name="readarrow"></a></p><p>The <code class="option">-n</code> option to <span class="command"><strong>read</strong></span>
	      also allows detection of the <span class="keycap"><strong>arrow keys</strong></span>
	      and certain of the other unusual keys.</p><div class="example"><a name="arrowdetect"></a><p class="title"><b>Example 15.6. Detecting the arrow keys</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# arrow-detect.sh: Detects the arrow keys, and a few more.
# Thank you, Sandro Magi, for showing me how.

# --------------------------------------------
# Character codes generated by the keypresses.
arrowup='\[A'
arrowdown='\[B'
arrowrt='\[C'
arrowleft='\[D'
insert='\[2'
delete='\[3'
# --------------------------------------------

SUCCESS=0
OTHER=65

echo -n "Press a key...  "
# May need to also press ENTER if a key not listed above pressed.
read -n3 key                      # Read 3 characters.

echo -n "$key" | grep "$arrowup"  #Check if character code detected.
if [ "$?" -eq $SUCCESS ]
then
  echo "Up-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowdown"
if [ "$?" -eq $SUCCESS ]
then
  echo "Down-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowrt"
if [ "$?" -eq $SUCCESS ]
then
  echo "Right-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$arrowleft"
if [ "$?" -eq $SUCCESS ]
then
  echo "Left-arrow key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$insert"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Insert\" key pressed."
  exit $SUCCESS
fi

echo -n "$key" | grep "$delete"
if [ "$?" -eq $SUCCESS ]
then
  echo "\"Delete\" key pressed."
  exit $SUCCESS
fi


echo " Some other key pressed."

exit $OTHER

# ========================================= #

#  Mark Alexander came up with a simplified
#+ version of the above script (Thank you!).
#  It eliminates the need for grep.

#!/bin/bash

  uparrow=$'\x1b[A'
  downarrow=$'\x1b[B'
  leftarrow=$'\x1b[D'
  rightarrow=$'\x1b[C'

  read -s -n3 -p "Hit an arrow key: " x

  case "$x" in
  $uparrow)
     echo "You pressed up-arrow"
     ;;
  $downarrow)
     echo "You pressed down-arrow"
     ;;
  $leftarrow)
     echo "You pressed left-arrow"
     ;;
  $rightarrow)
     echo "You pressed right-arrow"
     ;;
  esac

exit $?

# ========================================= #

# Antonio Macchi has a simpler alternative.

#!/bin/bash

while true
do
  read -sn1 a
  test "$a" == `echo -en "\e"` || continue
  read -sn1 a
  test "$a" == "[" || continue
  read -sn1 a
  case "$a" in
    A)  echo "up";;
    B)  echo "down";;
    C)  echo "right";;
    D)  echo "left";;
  esac
done

# ========================================= #

#  Exercise:
#  --------
#  1) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="option">-n</code> option to <span class="command"><strong>read</strong></span>
	      will not detect the <span class="keycap"><strong>ENTER</strong></span> (newline)
	      key.</p></div><p><a name="readtimed"></a></p><p>The <code class="option">-t</code> option to <span class="command"><strong>read</strong></span>
	      permits timed input (see <a class="xref" href="ch09s01.html#tout" title="Example 9.4. Timed read">Example 9.4, &#8220;Timed <em class="firstterm">read</em>&#8221;</a> and <a class="xref" href="apa.html#qky" title="Example A.41. Quacky: a Perquackey-type word game">Example A.41, &#8220;Quacky: a Perquackey-type word game&#8221;</a>).</p><p><a name="readfd"></a>The <code class="option">-u</code> option
                takes the <a class="link" href="ch20.html#fdref">file descriptor</a>
                of the target file.</p><p><a name="readredir0"></a></p><p>The <span class="command"><strong>read</strong></span> command may also
	      <span class="quote">&#8220;<span class="quote">read</span>&#8221;</span> its variable value from a file
	      <a class="link" href="ch20.html#ioredirref">redirected</a> to
	      <code class="filename">stdin</code>.  If the file contains
	      more than one line, only the first line is assigned
	      to the variable. If <span class="command"><strong>read</strong></span>
	      has more than one parameter, then each of
	      these variables gets assigned a successive <a class="link" href="ch03.html#whitespaceref">whitespace-delineated</a>
	      string. Caution!</p><div class="example"><a name="readredir"></a><p class="title"><b>Example 15.7. Using <em class="firstterm">read</em> with
	        <a class="link" href="ch20.html#ioredirref">file redirection</a></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

read var1 &lt;data-file
echo "var1 = $var1"
# var1 set to the entire first line of the input file "data-file"

read var2 var3 &lt;data-file
echo "var2 = $var2   var3 = $var3"
# Note non-intuitive behavior of "read" here.
# 1) Rewinds back to the beginning of input file.
# 2) Each variable is now set to a corresponding string,
#    separated by whitespace, rather than to an entire line of text.
# 3) The final variable gets the remainder of the line.
# 4) If there are more variables to be set than whitespace-terminated strings
#    on the first line of the file, then the excess variables remain empty.

echo "------------------------------------------------"

# How to resolve the above problem with a loop:
while read line
do
  echo "$line"
done &lt;data-file
# Thanks, Heiner Steven for pointing this out.

echo "------------------------------------------------"

# Use $IFS (Internal Field Separator variable) to split a line of input to
# "read", if you do not want the default to be whitespace.

echo "List of all users:"
OIFS=$IFS; IFS=:       # /etc/passwd uses ":" for field separator.
while read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.
IFS=$OIFS              # Restore original $IFS.
# This code snippet also by Heiner Steven.



#  Setting the $IFS variable within the loop itself
#+ eliminates the need for storing the original $IFS
#+ in a temporary variable.
#  Thanks, Dim Segebart, for pointing this out.
echo "------------------------------------------------"
echo "List of all users:"

while IFS=: read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done &lt;/etc/passwd   # I/O redirection.

echo
echo "\$IFS still $IFS"

exit 0
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><a name="pipereadref0"></a></p><p><a class="link" href="ch03.html#piperef">Piping</a> output
	      to a <em class="firstterm">read</em>, using <a class="link" href="ch15.html#echoref">echo</a> to set variables <a class="link" href="ch34.html#badread0">will fail</a>.</p><p><a name="readpiperef"></a>Yet, piping the output of <a class="link" href="ch16s01.html#catref">cat</a> <span class="emphasis"><em>seems</em></span> to
	      work.</p><p><a name="whilereadref"></a></p><pre class="programlisting">cat file1 file2 |
while read line
do
echo $line
done</pre><p>However, as Bjön Eriksson shows:</p><div class="example"><a name="readpipe"></a><p class="title"><b>Example 15.8. Problems reading from a pipe</b></p><div class="example-contents"><pre class="programlisting">#!/bin/sh
# readpipe.sh
# This example contributed by Bjon Eriksson.

### shopt -s lastpipe

last="(null)"
cat $0 |
while read line
do
    echo "{$line}"
    last=$line
done

echo
echo "++++++++++++++++++++++"
printf "\nAll done, last: $last\n" #  The output of this line
                                   #+ changes if you uncomment line 5.
                                   #  (Bash, version -ge 4.2 required.)

exit 0  # End of code.
        # (Partial) output of script follows.
        # The 'echo' supplies extra brackets.

#############################################

./readpipe.sh 

{#!/bin/sh}
{last="(null)"}
{cat $0 |}
{while read line}
{do}
{echo "{$line}"}
{last=$line}
{done}
{printf "nAll done, last: $lastn"}


All done, last: (null)

The variable (last) is set within the loop/subshell
but its value does not persist outside the loop.
</pre></div></div><br class="example-break"><p>The <em class="firstterm">gendiff</em> script, usually
              found in <code class="filename">/usr/bin</code> on
              many Linux distros, pipes the output of <a class="link" href="ch16s02.html#findref">find</a> to a <em class="firstterm">while
              read</em> construct.

	      </p><pre class="programlisting">find $1 \( -name "*$2" -o -name ".*$2" \) -print |
while read f; do
. . .</pre><p>
            </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>It is possible to <em class="firstterm">paste</em> text into
	        the input field of a <em class="firstterm">read</em> (but
		<span class="emphasis"><em>not</em></span> multiple lines!). See <a class="xref" href="apa.html#padsw" title="Example A.38. A pad file generator for shareware authors">Example A.38, &#8220;A <em class="firstterm">pad</em> file generator for shareware
        authors&#8221;</a>.</p></div></dd></dl></div><div class="variablelist"><a name="intfilesystem"></a><p class="title"><b><a name="intfilesystem1"></a>Filesystem</b></p><dl class="variablelist"><dt><span class="term"><a name="cdref"></a><span class="command"><strong>cd</strong></span></span></dt><dd><a class="indexterm" name="idm8895"></a><a class="indexterm" name="idm8897"></a><p>The familiar <span class="command"><strong>cd</strong></span> change directory
	      command finds use in scripts where execution of a command
	      requires being in a specified directory.</p><p>  
	      </p><pre class="programlisting">(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</pre><p>
	      [from the <a class="link" href="ch03.html#coxex">previously cited</a>
	      example by Alan Cox]</p><p>The <code class="option">-P</code> (physical) option to
	      <span class="command"><strong>cd</strong></span> causes it to ignore symbolic
	      links.</p><p><span class="command"><strong>cd -</strong></span> changes to <a class="link" href="ch09s01.html#oldpwd">$OLDPWD</a>, the previous working
	    directory.</p><p><a name="doubleslashref"></a></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <span class="command"><strong>cd</strong></span> command does not function
	      as expected when presented with two forward slashes.

	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>cd //</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>pwd</code></strong>
<code class="computeroutput">//</code>
	      </pre><p>
	      The output should, of course, be <code class="computeroutput">/</code>.
	      This is a problem both from the command-line and in a script.</p></div></dd><dt><span class="term"><a name="pwd2ref"></a><span class="command"><strong>pwd</strong></span></span></dt><dd><a class="indexterm" name="idm8928"></a><a class="indexterm" name="idm8930"></a><a class="indexterm" name="idm8933"></a><a class="indexterm" name="idm8935"></a><a class="indexterm" name="idm8938"></a><p>Print Working Directory. This gives the user's
	      (or script's) current directory (see <a class="xref" href="ch15.html#ex37" title="Example 15.9. Changing the current working directory">Example 15.9, &#8220;Changing the current working directory&#8221;</a>). The effect is identical to
	      reading the value of the builtin variable <a class="link" href="ch09s01.html#pwdref">$PWD</a>.</p></dd><dt><span class="term"><a name="dirsd"></a><span class="command"><strong>pushd</strong></span>, </span><span class="term"><span class="command"><strong>popd</strong></span>, </span><span class="term"><span class="command"><strong>dirs</strong></span></span></dt><dd><a class="indexterm" name="idm8953"></a><a class="indexterm" name="idm8955"></a><a class="indexterm" name="idm8958"></a><a class="indexterm" name="idm8960"></a><a class="indexterm" name="idm8963"></a><a class="indexterm" name="idm8965"></a><a class="indexterm" name="idm8968"></a><a class="indexterm" name="idm8971"></a><p>This command set is a mechanism for bookmarking
	      working directories, a means of moving back and forth
	      through directories in an orderly manner. A pushdown <a class="link" href="ch09s01.html#stackdefref">stack</a> is used to keep track
	      of directory names. Options allow various manipulations
	      of the directory stack.</p><p><a name="pushdref"></a><strong class="userinput"><code>pushd
	      dir-name</code></strong> pushes the path
	      <em class="replaceable"><code>dir-name</code></em> onto the directory
	      stack (to the <em class="firstterm">top</em> of the stack)
	      and simultaneously changes the current working directory
	      to <em class="replaceable"><code>dir-name</code></em></p><p><a name="popdref"></a><span class="command"><strong>popd</strong></span> removes
	      (pops) the top directory path name off the directory stack
	      and simultaneously changes the current working directory
	      to the directory now at the <em class="firstterm">top</em> of
	      the stack.</p><p><a name="dirsref"></a><span class="command"><strong>dirs</strong></span> lists
	      the contents of the directory stack (compare this
	      with the <a class="link" href="ch09s01.html#dirstackref">$DIRSTACK</a>
	      variable).  A successful <span class="command"><strong>pushd</strong></span>
	      or <span class="command"><strong>popd</strong></span> will automatically invoke
	      <span class="command"><strong>dirs</strong></span>.</p><p>Scripts that require various changes to the current
	      working directory without hard-coding the directory name
	      changes can make good use of these commands. Note that
	      the implicit <code class="varname">$DIRSTACK</code> array variable,
	      accessible from within a script, holds the contents of
	      the directory stack.
	    </p><div class="example"><a name="ex37"></a><p class="title"><b>Example 15.9. Changing the current working directory</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

dir1=/usr/local
dir2=/var/spool

pushd $dir1
# Will do an automatic 'dirs' (list directory stack to stdout).
echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.

# Now, do some stuff in directory 'dir1'.
pushd $dir2
echo "Now in directory `pwd`."

# Now, do some stuff in directory 'dir2'.
echo "The top entry in the DIRSTACK array is $DIRSTACK."
popd
echo "Now back in directory `pwd`."

# Now, do some more stuff in directory 'dir1'.
popd
echo "Now back in original working directory `pwd`."

exit 0

# What happens if you don't 'popd' -- then exit the script?
# Which directory do you end up in? Why?
</pre></div></div><br class="example-break"></dd></dl></div><div class="variablelist"><a name="intvar"></a><p class="title"><b><a name="intvar1"></a>Variables</b></p><dl class="variablelist"><dt><span class="term"><a name="letref"></a><span class="command"><strong>let</strong></span></span></dt><dd><a class="indexterm" name="idm9005"></a><a class="indexterm" name="idm9007"></a><p>The <span class="command"><strong>let</strong></span> command carries out
                    <em class="firstterm">arithmetic</em> operations on variables.

          <a href="#ftn.idm9013" class="footnote" name="idm9013"><sup class="footnote">[60]</sup></a>
			  
		    In many cases, it functions as a less complex version
                    of <a class="link" href="ch16s02.html#exprref">expr</a>.</p><div class="example"><a name="ex46"></a><p class="title"><b>Example 15.10. Letting <em class="firstterm">let</em> do arithmetic.</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

echo

let a=11            # Same as 'a=11'
let a=a+5           # Equivalent to  let "a = a + 5"
                    # (Double quotes and spaces make it more readable.)
echo "11 + 5 = $a"  # 16

let "a &lt;&lt;= 3"       # Equivalent to  let "a = a &lt;&lt; 3"
echo "\"\$a\" (=16) left-shifted 3 places = $a"
                    # 128

let "a /= 4"        # Equivalent to  let "a = a / 4"
echo "128 / 4 = $a" # 32

let "a -= 5"        # Equivalent to  let "a = a - 5"
echo "32 - 5 = $a"  # 27

let "a *=  10"      # Equivalent to  let "a = a * 10"
echo "27 * 10 = $a" # 270

let "a %= 8"        # Equivalent to  let "a = a % 8"
echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
                    # 6


# Does "let" permit C-style operators?
# Yes, just as the (( ... )) double-parentheses construct does.

let a++             # C-style (post) increment.
echo "6++ = $a"     # 6++ = 7
let a--             # C-style decrement.
echo "7-- = $a"     # 7-- = 6
# Of course, ++a, etc., also allowed . . .
echo


# Trinary operator.

# Note that $a is 6, see above.
let "t = a&lt;7?7:11"   # True
echo $t  # 7

let a++
let "t = a&lt;7?7:11"   # False
echo $t  #     11

exit
</pre></div></div><br class="example-break"><p><a name="exitvalanomaly02"></a></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <em class="firstterm">let</em> command can,
                      in certain contexts, return a surprising <a class="link" href="ch06.html#exitstatusref">exit status</a>.</p><pre class="programlisting"># Evgeniy Ivanov points out:

var=0
echo $?     # 0
            # As expected.

let var++
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???
            # Anomaly!

let var++
echo $?     # 0
            # As expected.


# Likewise . . .

let var=0
echo $?     # 1
            # The command was successful, so why isn't $?=0 ???

#  However, as Jeff Gorak points out,
#+ this is part of the design spec for 'let' . . .
# "If the last ARG evaluates to 0, let returns 1;
#  let returns 0 otherwise." ['help let']</pre></div></dd><dt><span class="term"><a name="evalref"></a><span class="command"><strong>eval</strong></span></span></dt><dd><a class="indexterm" name="idm9036"></a><a class="indexterm" name="idm9038"></a><p><strong class="userinput"><code>eval arg1 [arg2] ... [argN]</code></strong></p><p>Combines the arguments in an expression or list of
              expressions and <em class="replaceable"><code>evaluates</code></em> them.
              Any variables within the expression are expanded. The
	      net result is to <span class="command"><strong>convert a string into a
              command</strong></span>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>The <span class="command"><strong>eval</strong></span> command can be used for
	      code generation from the command-line or within a script.
	      </p></div><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>command_string="ps ax"</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>process="ps ax"</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>eval "$command_string" | grep "$process"</code></strong>
<code class="computeroutput">26973 pts/3    R+     0:00 grep --color ps ax
 26974 pts/3    R+     0:00 ps ax</code>
	      </pre><p>
	      </p><p><a name="evalforced"></a></p><p>Each invocation of <em class="firstterm">eval</em> forces
        a re-<span class="emphasis"><em>evaluation</em></span> of its arguments.
	</p><pre class="programlisting">a='$b'
b='$c'
c=d

echo $a             # $b
                    # First level.
eval echo $a        # $c
                    # Second level.
eval eval echo $a   # d
                    # Third level.

# Thank you, E. Choroba.</pre><p><a name="evaleff"></a></p><div class="example"><a name="ex43"></a><p class="title"><b>Example 15.11. Showing the effect of <em class="firstterm">eval</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# Exercising "eval" ...

y=`eval ls -l`  #  Similar to y=`ls -l`
echo $y         #+ but linefeeds removed because "echoed" variable is unquoted.
echo
echo "$y"       #  Linefeeds preserved when variable is quoted.

echo; echo

y=`eval df`     #  Similar to y=`df`
echo $y         #+ but linefeeds removed.

#  When LF's not preserved, it may make it easier to parse output,
#+ using utilities such as "awk".

echo
echo "==========================================================="
echo

eval "`seq 3 | sed -e 's/.*/echo var&amp;=ABCDEFGHIJ/'`"
# var1=ABCDEFGHIJ
# var2=ABCDEFGHIJ
# var3=ABCDEFGHIJ

echo
echo "==========================================================="
echo


# Now, showing how to do something useful with "eval" . . .
# (Thank you, E. Choroba!)

version=3.4     #  Can we split the version into major and minor
                #+ part in one command?
echo "version = $version"
eval major=${version/./;minor=}     #  Replaces '.' in version by ';minor='
                                    #  The substitution yields '3; minor=4'
                                    #+ so eval does minor=4, major=3
echo Major: $major, minor: $minor   #  Major: 3, minor: 4
</pre></div></div><br class="example-break"><p><a name="arrchoice0"></a></p><div class="example"><a name="arrchoice"></a><p class="title"><b>Example 15.12. Using <em class="firstterm">eval</em> to select
                      among variables</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# arr-choice.sh

#  Passing arguments to a function to select
#+ one particular variable out of a group.

arr0=( 10 11 12 13 14 15 )
arr1=( 20 21 22 23 24 25 )
arr2=( 30 31 32 33 34 35 )
#       0  1  2  3  4  5      Element number (zero-indexed)


choose_array ()
{
  eval array_member=\${arr${array_number}[element_number]}
  #                 ^       ^^^^^^^^^^^^
  #  Using eval to construct the name of a variable,
  #+ in this particular case, an array name.

  echo "Element $element_number of array $array_number is $array_member"
} #  Function can be rewritten to take parameters.

array_number=0    # First array.
element_number=3
choose_array      # 13

array_number=2    # Third array.
element_number=4
choose_array      # 34

array_number=3    # Null array (arr3 not allocated).
element_number=4
choose_array      # (null)

# Thank you, Antonio Macchi, for pointing this out.
</pre></div></div><br class="example-break"><div class="example"><a name="echoparams"></a><p class="title"><b>Example 15.13. <em class="firstterm">Echoing</em> the
	        <em class="firstterm">command-line parameters</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# echo-params.sh

# Call this script with a few command-line parameters.
# For example:
#     sh echo-params.sh first second third fourth fifth

params=$#              # Number of command-line parameters.
param=1                # Start at first command-line param.

while [ "$param" -le "$params" ]
do
  echo -n "Command-line parameter "
  echo -n \$$param     #  Gives only the *name* of variable.
#         ^^^          #  $1, $2, $3, etc.
                       #  Why?
                       #  \$ escapes the first "$"
                       #+ so it echoes literally,
                       #+ and $param dereferences "$param" . . .
                       #+ . . . as expected.
  echo -n " = "
  eval echo \$$param   #  Gives the *value* of variable.
# ^^^^      ^^^        #  The "eval" forces the *evaluation*
                       #+ of \$$
                       #+ as an indirect variable reference.

(( param ++ ))         # On to the next.
done

exit $?

# =================================================

$ sh echo-params.sh first second third fourth fifth
Command-line parameter $1 = first
Command-line parameter $2 = second
Command-line parameter $3 = third
Command-line parameter $4 = fourth
Command-line parameter $5 = fifth
</pre></div></div><br class="example-break"><div class="example"><a name="ex44"></a><p class="title"><b>Example 15.14. Forcing a log-off</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# Killing ppp to force a log-off.
# For dialup connection, of course.

# Script should be run as root user.

SERPORT=ttyS3
#  Depending on the hardware and even the kernel version,
#+ the modem port on your machine may be different --
#+ /dev/ttyS1 or /dev/ttyS2.


killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
#                     -------- process ID of ppp -------  

$killppp                     # This variable is now a command.


# The following operations must be done as root user.

chmod 666 /dev/$SERPORT      # Restore r+w permissions, or else what?
#  Since doing a SIGKILL on ppp changed the permissions on the serial port,
#+ we restore permissions to previous state.

rm /var/lock/LCK..$SERPORT   # Remove the serial port lock file. Why?

exit $?

# Exercises:
# ---------
# 1) Have script check whether root user is invoking it.
# 2) Do a check on whether the process to be killed
#+   is actually running before attempting to kill it.   
# 3) Write an alternate version of this script based on 'fuser':
#+      if [ fuser -s /dev/modem ]; then . . .
</pre></div></div><br class="example-break"><div class="example"><a name="rot14"></a><p class="title"><b>Example 15.15. A version of <em class="firstterm">rot13</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# A version of "rot13" using 'eval'.
# Compare to "rot13.sh" example.

setvar_rot_13()              # "rot13" scrambling
{
  local varname=$1 varvalue=$2
  eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
}


setvar_rot_13 var "foobar"   # Run "foobar" through rot13.
echo $var                    # sbbone

setvar_rot_13 var "$var"     # Run "sbbone" through rot13.
                             # Back to original variable.
echo $var                    # foobar

# This example by Stephane Chazelas.
# Modified by document author.

exit 0
</pre></div></div><br class="example-break"><p>Here is another example of using
              <em class="firstterm">eval</em> to
              <span class="emphasis"><em>evaluate</em></span> a complex expression,
              this one from an earlier version of YongYe's <a class="ulink" href="https://github.com/yongye/shell/blob/master/Tetris_Game.sh" target="_top">Tetris
			  game script</a>.</p><p>
           </p><pre class="programlisting">eval ${1}+=\"${x} ${y} \"</pre><p>
           </p><p><a class="xref" href="apa.html#samorse" title="Example A.53. Morse Code Practice">Example A.53, &#8220;Morse Code Practice&#8221;</a> uses
	      <em class="firstterm">eval</em> to convert <a class="link" href="ch27.html#arrayref">array</a> elements into a command
              list.</p><p>The <em class="firstterm">eval</em> command occurs
	      in the older version of <a class="link" href="ch28.html#ivrref">indirect
	      referencing</a>.
	      </p><pre class="programlisting">eval var=\$$var</pre><p> 
	      </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>The <em class="firstterm">eval</em> command can
                be used to <a class="link" href="ch37s02.html#braceexpref3">parameterize
                <em class="firstterm">brace expansion</em></a>.</p></div><p><a name="evalrisk"></a></p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>The <span class="command"><strong>eval</strong></span> command can be
	      risky, and normally should be avoided when there
	      exists a reasonable alternative. An <strong class="userinput"><code>eval
	      $COMMANDS</code></strong> executes the contents of
	      <em class="replaceable"><code>COMMANDS</code></em>, which may
	      contain such unpleasant surprises as <span class="command"><strong>rm -rf
	      *</strong></span>. Running an <span class="command"><strong>eval</strong></span> on
	      unfamiliar code written by persons unknown is living
	      dangerously.</p></div></dd><dt><span class="term"><a name="setref"></a><span class="command"><strong>set</strong></span></span></dt><dd><a class="indexterm" name="idm9121"></a><a class="indexterm" name="idm9123"></a><p>The <span class="command"><strong>set</strong></span> command changes
	      the value of internal script variables/options. One use for
	      this is to toggle <a class="link" href="ch33.html#optionsref">option
	      flags</a> which help determine the behavior of the
	      script. Another application for it is to reset the <a class="link" href="ch09s01.html#posparamref">positional parameters</a> that
	      a script sees as the result of a command (<strong class="userinput"><code>set
	      `command`</code></strong>). The script can then parse the
	      <a class="link" href="ch03.html#fieldref">fields</a> of the command
	      output.</p><div class="example"><a name="ex34"></a><p class="title"><b>Example 15.16. Using <em class="firstterm">set</em> with positional
	        parameters</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# ex34.sh
# Script "set-test"

# Invoke this script with three command-line parameters,
# for example, "sh ex34.sh one two three".

echo
echo "Positional parameters before  set \`uname -a\` :"
echo "Command-line argument #1 = $1"
echo "Command-line argument #2 = $2"
echo "Command-line argument #3 = $3"


set `uname -a` # Sets the positional parameters to the output
               # of the command `uname -a`

echo
echo +++++
echo $_        # +++++
# Flags set in script.
echo $-        # hB
#                Anomalous behavior?
echo

echo "Positional parameters after  set \`uname -a\` :"
# $1, $2, $3, etc. reinitialized to result of `uname -a`
echo "Field #1 of 'uname -a' = $1"
echo "Field #2 of 'uname -a' = $2"
echo "Field #3 of 'uname -a' = $3"
echo \#\#\#
echo $_        # ###
echo

exit 0
</pre></div></div><br class="example-break"><p>More fun with positional parameters.</p><div class="example"><a name="revposparams"></a><p class="title"><b>Example 15.17. Reversing the positional parameters</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# revposparams.sh: Reverse positional parameters.
# Script by Dan Jacobson, with stylistic revisions by document author.


set a\ b c d\ e;
#     ^      ^     Spaces escaped 
#       ^ ^        Spaces not escaped
OIFS=$IFS; IFS=:;
#              ^   Saving old IFS and setting new one.

echo

until [ $# -eq 0 ]
do          #      Step through positional parameters.
  echo "### k0 = "$k""     # Before
  k=$1:$k;  #      Append each pos param to loop variable.
#     ^
  echo "### k = "$k""      # After
  echo
  shift;
done

set $k  #  Set new positional parameters.
echo -
echo $# #  Count of positional parameters.
echo -
echo

for i   #  Omitting the "in list" sets the variable -- i --
        #+ to the positional parameters.
do
  echo $i  # Display new positional parameters.
done

IFS=$OIFS  # Restore IFS.

#  Question:
#  Is it necessary to set an new IFS, internal field separator,
#+ in order for this script to work properly?
#  What happens if you don't? Try it.
#  And, why use the new IFS -- a colon -- in line 17,
#+ to append to the loop variable?
#  What is the purpose of this?

exit 0

$ ./revposparams.sh

### k0 = 
### k = a b

### k0 = a b
### k = c a b

### k0 = c a b
### k = d e c a b

-
3
-

d e
c
a b
</pre></div></div><br class="example-break"><p>Invoking <span class="command"><strong>set</strong></span> without any options or
	      arguments simply lists all the <a class="link" href="ch04s04.html#envref">environmental</a> and other variables
	      that have been initialized.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>set</code></strong>
<code class="computeroutput">AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy</code>
	      </pre><p>
            </p><p>Using <span class="command"><strong>set</strong></span> with the <code class="option">--</code>
	      option explicitly assigns the contents of a variable to
	      the positional parameters. If no variable follows the
	      <code class="option">--</code> it <em class="firstterm">unsets</em>
	      the positional parameters.</p><div class="example"><a name="setpos"></a><p class="title"><b>Example 15.18. Reassigning the positional parameters</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

variable="one two three four five"

set -- $variable
# Sets positional parameters to the contents of "$variable".

first_param=$1
second_param=$2
shift; shift        # Shift past first two positional params.
# shift 2             also works.
remaining_params="$*"

echo
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two
echo "remaining parameters = $remaining_params"   # three four five

echo; echo

# Again.
set -- $variable
first_param=$1
second_param=$2
echo "first parameter = $first_param"             # one
echo "second parameter = $second_param"           # two

# ======================================================

set --
# Unsets positional parameters if no variable specified.

first_param=$1
second_param=$2
echo "first parameter = $first_param"             # (null value)
echo "second parameter = $second_param"           # (null value)

exit 0
</pre></div></div><br class="example-break"><p>See also <a class="xref" href="ch11s01.html#ex22a" title="Example 11.2. for loop with two parameters in each [list] element">Example 11.2, &#8220;<em class="firstterm">for</em> loop with two parameters in each
	      [list] element&#8221;</a> and <a class="xref" href="ch16s09.html#ex33a" title="Example 16.56. Using getopt to parse command-line options">Example 16.56, &#8220;Using <em class="firstterm">getopt</em> to parse command-line
	        options&#8221;</a>.</p></dd><dt><span class="term"><a name="unsetref"></a><span class="command"><strong>unset</strong></span></span></dt><dd><a class="indexterm" name="idm9164"></a><a class="indexterm" name="idm9166"></a><p>The <span class="command"><strong>unset</strong></span> command deletes a
	      shell variable, effectively setting it to
	      <em class="firstterm">null</em>. Note that this command does
	      not affect positional parameters.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>unset PATH</code></strong>

<code class="prompt">bash$ </code><strong class="userinput"><code>echo $PATH</code></strong>
<code class="computeroutput">


</code>
<code class="prompt">bash$ </code></pre><p>
	    </p><div class="example"><a name="uns"></a><p class="title"><b>Example 15.19. <span class="quote">&#8220;<span class="quote">Unsetting</span>&#8221;</span> a variable</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# unset.sh: Unsetting a variable.

variable=hello                       #  Initialized.
echo "variable = $variable"

unset variable                       #  Unset.
                                     #  In this particular context,
                                     #+ same effect as:   variable=
echo "(unset) variable = $variable"  #  $variable is null.

if [ -z "$variable" ]                #  Try a string-length test.
then
  echo "\$variable has zero length."
fi

exit 0
</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In most contexts, an <em class="firstterm">undeclared</em>
              variable and one that has been <em class="firstterm">unset</em>
	      are equivalent. However, the <a class="link" href="ch10s02.html#unddr">
              ${parameter:-default}</a> parameter substitution
              construct can distinguish between the two.</p></div></dd><dt><span class="term"><a name="exportref"></a><span class="command"><strong>export</strong></span></span></dt><dd><a class="indexterm" name="idm9194"></a><a class="indexterm" name="idm9196"></a><p><a name="exportref2"></a></p><p>The <span class="command"><strong>export</strong></span>

	      <a href="#ftn.idm9203" class="footnote" name="idm9203"><sup class="footnote">[61]</sup></a>
	  
	      command makes available variables to all child processes
	      of the running script or shell. One important use
	      of the <span class="command"><strong>export</strong></span> command is in <a class="link" href="aph.html#filesref1">startup files</a>, to initialize
	      and make accessible <a class="link" href="ch04s04.html#envref">environmental
	      variables</a> to subsequent user processes.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Unfortunately, <a class="link" href="ch34.html#parchildprobref">
	     there is no way to export variables back to the parent
	     process</a>, to the process that called or invoked the
	     script or shell.</p></div><p><a name="exportawk"></a></p><div class="example"><a name="coltotaler3"></a><p class="title"><b>Example 15.20. Using <em class="firstterm">export</em> to pass a variable to an
	      embedded <em class="firstterm">awk</em> script</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

#  Yet another version of the "column totaler" script (col-totaler.sh)
#+ that adds up a specified column (of numbers) in the target file.
#  This uses the environment to pass a script variable to 'awk' . . .
#+ and places the awk script in a variable.


ARGS=2
E_WRONGARGS=85

if [ $# -ne "$ARGS" ] # Check for proper number of command-line args.
then
   echo "Usage: `basename $0` filename column-number"
   exit $E_WRONGARGS
fi

filename=$1
column_number=$2

#===== Same as original script, up to this point =====#

export column_number
# Export column number to environment, so it's available for retrieval.


# -----------------------------------------------
awkscript='{ total += $ENVIRON["column_number"] }
END { print total }'
# Yes, a variable can hold an awk script.
# -----------------------------------------------

# Now, run the awk script.
awk "$awkscript" "$filename"

# Thanks, Stephane Chazelas.

exit 0
</pre></div></div><br class="example-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>It is possible to initialize and export
		  variables in the same operation, as in <span class="command"><strong>export
		  var1=xxx</strong></span>.</p><p>However, as Greg Keraunen points out, in certain
		  situations this may have a different effect than
		  setting a variable, then exporting it.</p><p>
	        </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>export var=(a b); echo ${var[0]}</code></strong>
<code class="computeroutput">(a b)</code>



<code class="prompt">bash$ </code><strong class="userinput"><code>var=(a b); export var; echo ${var[0]}</code></strong>
<code class="computeroutput">a</code>
	      </pre><p>
	    </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A variable to be exported may require special
                treatment.  See <a class="xref" href="apm.html#bashprof" title="Example M.2. .bash_profile file">Example M.2, &#8220;<code class="filename">.bash_profile</code> file&#8221;</a>.</p></div></dd><dt><span class="term"><a name="declare2ref"></a><span class="command"><strong>declare</strong></span>, </span><span class="term"><span class="command"><strong>typeset</strong></span></span></dt><dd><a class="indexterm" name="idm9242"></a><a class="indexterm" name="idm9244"></a><a class="indexterm" name="idm9247"></a><a class="indexterm" name="idm9249"></a><p>The <a class="link" href="ch09s02.html" title="2. Typing variables: declare or typeset">declare</a> and
	      <a class="link" href="ch09s02.html" title="2. Typing variables: declare or typeset">typeset</a> commands specify
	      and/or restrict properties of variables.</p></dd><dt><span class="term"><a name="readonlyref"></a><span class="command"><strong>readonly</strong></span></span></dt><dd><a class="indexterm" name="idm9260"></a><a class="indexterm" name="idm9262"></a><p>Same as <a class="link" href="ch09s02.html" title="2. Typing variables: declare or typeset">declare -r</a>,
	      sets a variable as read-only, or, in effect, as a
	      constant. Attempts to change the variable fail with
	      an error message. This is the shell analog of the
	      <em class="firstterm">C</em> language <span class="command"><strong>const</strong></span>
	      type qualifier.</p></dd><dt><span class="term"><a name="getoptsx"></a><span class="command"><strong>getopts</strong></span></span></dt><dd><a class="indexterm" name="idm9274"></a><a class="indexterm" name="idm9276"></a><a class="indexterm" name="idm9279"></a><a class="indexterm" name="idm9281"></a><a class="indexterm" name="idm9284"></a><a class="indexterm" name="idm9286"></a><p>This powerful tool parses command-line arguments passed
	      to the script. This is the Bash analog of the <a class="link" href="ch16s09.html#getopty">getopt</a> external command and the
	      <em class="firstterm">getopt</em> library function familiar to
	      <em class="firstterm">C</em> programmers. It permits passing
	      and concatenating multiple options

	      <a href="#ftn.idm9293" class="footnote" name="idm9293"><sup class="footnote">[62]</sup></a>

	      and associated arguments to a script (for
	      example <strong class="userinput"><code>scriptname -abc -e
	      /usr/local</code></strong>).</p><p><a name="getoptsopt"></a></p><p>The <span class="command"><strong>getopts</strong></span> construct uses two implicit
	      variables. <code class="varname">$OPTIND</code> is the argument
	      pointer (<em class="wordasword">OPTion INDex</em>)
	      and <code class="varname">$OPTARG</code> (<em class="wordasword">OPTion
	      ARGument</em>) the (optional) argument attached
	      to an option. A colon following the option name in the
	      declaration tags that option as having an associated
	      argument.</p><p>A <span class="command"><strong>getopts</strong></span> construct usually comes
	      packaged in a <a class="link" href="ch11s01.html#whileloopref">while
	      loop</a>, which processes the options and
	      arguments one at a time, then increments the implicit
	      <code class="varname">$OPTIND</code> variable to point to the
	      next.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
		</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The arguments passed from the command-line to
		      the script must be preceded by a
		      dash (<code class="option">-</code>). It is the
		      prefixed <code class="option">-</code> that lets
		      <span class="command"><strong>getopts</strong></span> recognize command-line
		      arguments as <em class="firstterm">options</em>.
		      In fact, <span class="command"><strong>getopts</strong></span> will not process
		      arguments without the prefixed <code class="option">-</code>,
		      and will terminate option processing at the first
		      argument encountered lacking them.</p></li><li class="listitem"><p>The <span class="command"><strong>getopts</strong></span> template
		      differs slightly from the standard <a class="link" href="ch11s01.html#whileloopref">while loop</a>, in that
		      it lacks condition brackets.</p></li><li class="listitem"><p>The <span class="command"><strong>getopts</strong></span> construct is a highly
		     functional replacement for the traditional
		     <a class="link" href="ch16s09.html#getopty">getopt</a> external
		     command.</p></li></ol></div><p>
	      </p></div><pre class="programlisting">
while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the options (flags) expected.
# The : after option 'e' shows it will have an argument passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with option 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.</pre><div class="example"><a name="ex33"></a><p class="title"><b>Example 15.21. Using <em class="firstterm">getopts</em> to read the
	        options/arguments passed to a script</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# ex33.sh: Exercising getopts and OPTIND
#          Script modified 10/09/03 at the suggestion of Bill Gradwohl.


# Here we observe how 'getopts' processes command-line arguments to script.
# The arguments are parsed as "options" (flags) and associated arguments.

# Try invoking this script with:
#   'scriptname -mn'
#   'scriptname -oq qOption' (qOption can be some arbitrary string.)
#   'scriptname -qXXX -r'
#
#   'scriptname -qr'
#+      - Unexpected result, takes "r" as the argument to option "q"
#   'scriptname -q -r' 
#+      - Unexpected result, same as above
#   'scriptname -mnop -mnop'  - Unexpected result
#   (OPTIND is unreliable at stating where an option came from.)
#
#  If an option expects an argument ("flag:"), then it will grab
#+ whatever is next on the command-line.

NO_ARGS=0 
E_OPTERROR=85

if [ $# -eq "$NO_ARGS" ]    # Script invoked with no command-line args?
then
  echo "Usage: `basename $0` options (-mnopqrs)"
  exit $E_OPTERROR          # Exit and explain usage.
                            # Usage: scriptname -options
                            # Note: dash (-) necessary
fi  


while getopts ":mnopq:rs" Option
do
  case $Option in
    m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
    n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
    p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
    q     ) echo "Scenario #4: option -q-\
                  with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
    #  Note that option 'q' must have an associated argument,
    #+ otherwise it falls through to the default.
    r | s ) echo "Scenario #5: option -$Option-";;
    *     ) echo "Unimplemented option chosen.";;   # Default.
  esac
done

shift $(($OPTIND - 1))
#  Decrements the argument pointer so it points to next argument.
#  $1 now references the first non-option item supplied on the command-line
#+ if one exists.

exit $?

#   As Bill Gradwohl states,
#  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
#+  but there is no reliable way to differentiate what came
#+ from where by using OPTIND."
#  There are, however, workarounds.
</pre></div></div><br class="example-break"></dd></dl></div><div class="variablelist"><a name="intscrbeh"></a><p class="title"><b><a name="intscrbeh1"></a>Script Behavior</b></p><dl class="variablelist"><dt><span class="term"><a name="sourceref"></a><span class="command"><strong>source</strong></span>, </span><span class="term"><span class="token">.</span> (<a class="link" href="ch03.html#dotref">dot</a> command)</span></dt><dd><a class="indexterm" name="idm9345"></a><a class="indexterm" name="idm9347"></a><a class="indexterm" name="idm9350"></a><a class="indexterm" name="idm9352"></a><p>This command, when invoked from the command-line,
	      executes a script. Within a script, a
	      <strong class="userinput"><code>source file-name</code></strong>
	      loads the file <code class="filename">file-name</code>.
	      <em class="firstterm">Sourcing</em> a file (dot-command)
	      <em class="firstterm">imports</em>
	     code into the script, appending to the script (same effect
	     as the <strong class="userinput"><code>#include</code></strong> directive in a
	     <em class="firstterm">C</em> program). The net result is the
	     same as if the <span class="quote">&#8220;<span class="quote">sourced</span>&#8221;</span> lines of code were
	     physically present in the body of the script. This is useful
	     in situations when multiple scripts use a common data file
	     or function library.</p><div class="example"><a name="ex38"></a><p class="title"><b>Example 15.22. <span class="quote">&#8220;<span class="quote">Including</span>&#8221;</span> a data file</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
#  Note that this example must be invoked with bash, i.e., bash ex38.sh
#+ not  sh ex38.sh !

. data-file    # Load a data file.
# Same effect as "source data-file", but more portable.

#  The file "data-file" must be present in current working directory,
#+ since it is referred to by its basename.

# Now, let's reference some data from that file.

echo "variable1 (from data-file) = $variable1"
echo "variable3 (from data-file) = $variable3"

let "sum = $variable2 + $variable4"
echo "Sum of variable2 + variable4 (from data-file) = $sum"
echo "message1 (from data-file) is \"$message1\""
#                                  Escaped quotes
echo "message2 (from data-file) is \"$message2\""

print_message This is the message-print function in the data-file.


exit $?
</pre><p>File <code class="filename">data-file</code> for <a class="xref" href="ch15.html#ex38" title="Example 15.22. &#8220;Including&#8221; a data file">Example 15.22, &#8220;<span class="quote">&#8220;<span class="quote">Including</span>&#8221;</span> a data file&#8221;</a>, above.  Must be present in same
		directory.</p><pre class="programlisting"># This is a data file loaded by a script.
# Files of this type may contain variables, functions, etc.
# It loads with a 'source' or '.' command from a shell script.

# Let's initialize some variables.

variable1=23
variable2=474
variable3=5
variable4=97

message1="Greetings from *** line $LINENO *** of the data file!"
message2="Enough for now. Goodbye."

print_message ()
{   # Echoes any message passed to it.

  if [ -z "$1" ]
  then
    return 1 # Error, if argument missing.
  fi

  echo

  until [ -z "$1" ]
  do             # Step through arguments passed to function.
    echo -n "$1" # Echo args one at a time, suppressing line feeds.
    echo -n " "  # Insert spaces between words.
    shift        # Next one.
  done  

  echo

  return 0
}
</pre></div></div><br class="example-break"><p>If the <em class="firstterm">sourced</em> file is itself
	       an executable script, then it will run, then return
	       control to the script that called it. A
	       <em class="firstterm">sourced</em> executable script may use a
	      <a class="link" href="ch24s01.html#returnref">return</a> for this
	      purpose.</p><p><a name="sourceparams"></a></p><p>
	      Arguments may be (optionally) passed to the
	      <em class="firstterm">sourced</em> file as <a class="link" href="ch04s04.html#posparamref1">positional parameters</a>.
	       </p><pre class="programlisting">source $filename $arg1 arg2</pre><p>
	    </p><p>It is even possible for a script to
	    <em class="firstterm">source</em> itself, though this does not
	    seem to have any practical applications.</p><div class="example"><a name="selfsource"></a><p class="title"><b>Example 15.23. A (useless) script that sources itself</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# self-source.sh: a script sourcing itself "recursively."
# From "Stupid Script Tricks," Volume II.

MAXPASSCNT=100    # Maximum number of execution passes.

echo -n  "$pass_count  "
#  At first execution pass, this just echoes two blank spaces,
#+ since $pass_count still uninitialized.

let "pass_count += 1"
#  Assumes the uninitialized variable $pass_count
#+ can be incremented the first time around.
#  This works with Bash and pdksh, but
#+ it relies on non-portable (and possibly dangerous) behavior.
#  Better would be to initialize $pass_count to 0 before incrementing.

while [ "$pass_count" -le $MAXPASSCNT ]
do
  . $0   # Script "sources" itself, rather than calling itself.
         # ./$0 (which would be true recursion) doesn't work here. Why?
done  

#  What occurs here is not actually recursion,
#+ since the script effectively "expands" itself, i.e.,
#+ generates a new section of code
#+ with each pass through the 'while' loop',
#  with each 'source' in line 20.
#
#  Of course, the script interprets each newly 'sourced' "#!" line
#+ as a comment, and not as the start of a new script.

echo

exit 0   # The net effect is counting from 1 to 100.
         # Very impressive.

# Exercise:
# --------
# Write a script that uses this trick to actually do something useful.
</pre></div></div><br class="example-break"></dd><dt><span class="term"><a name="exitref"></a><span class="command"><strong>exit</strong></span></span></dt><dd><a class="indexterm" name="idm9391"></a><a class="indexterm" name="idm9393"></a><p>Unconditionally terminates a script.
		    <a href="#ftn.idm9397" class="footnote" name="idm9397"><sup class="footnote">[63]</sup></a>
	        The <span class="command"><strong>exit</strong></span> command may optionally take an
		integer argument, which is returned to the shell as
		the <a class="link" href="ch06.html#exitstatusref">exit status</a>
		of the script. It is good practice to end all but the
		simplest scripts with an <strong class="userinput"><code>exit 0</code></strong>,
		indicating a successful run.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If a script terminates with an <span class="command"><strong>exit</strong></span>
	      lacking an argument, the exit status of the script is the exit
	      status of the last command executed in the script, not counting
	      the <span class="command"><strong>exit</strong></span>. This is equivalent to an
	      <span class="command"><strong>exit $?</strong></span>.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>An <span class="command"><strong>exit</strong></span> command may also be used to
	      terminate a <a class="link" href="ch21.html#subshellsref">subshell</a>.</p></div></dd><dt><span class="term"><a name="execref"></a><span class="command"><strong>exec</strong></span></span></dt><dd><a class="indexterm" name="idm9419"></a><a class="indexterm" name="idm9421"></a><p>
	      This shell builtin replaces the current process with
	      a specified command. Normally, when the shell encounters
	      a command, it <a class="link" href="ch15.html#forkref">forks off</a> a
	      child process to actually execute the command.  Using the
	      <span class="command"><strong>exec</strong></span> builtin, the shell does not fork,
	      and the command <em class="firstterm">exec</em>'ed replaces
	      the shell.  When used in a script, therefore, it forces an
	      exit from the script when the <span class="command"><strong>exec</strong></span>'ed
	      command terminates.
		<a href="#ftn.idm9429" class="footnote" name="idm9429"><sup class="footnote">[64]</sup></a>
	    </p><div class="example"><a name="ex54"></a><p class="title"><b>Example 15.24. Effects of <em class="firstterm">exec</em></b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash

exec echo "Exiting \"$0\" at line $LINENO."   # Exit from script here.
# $LINENO is an internal Bash variable set to the line number it's on.

# ----------------------------------
# The following lines never execute.

echo "This echo fails to echo."

exit 99                       #  This script will not exit here.
                              #  Check exit value after script terminates
                              #+ with an 'echo $?'.
                              #  It will *not* be 99.
</pre></div></div><br class="example-break"><div class="example"><a name="selfexec"></a><p class="title"><b>Example 15.25. A script that <em class="firstterm">exec's</em> itself</b></p><div class="example-contents"><pre class="programlisting">#!/bin/bash
# self-exec.sh

# Note: Set permissions on this script to 555 or 755,
#       then call it with ./self-exec.sh or sh ./self-exec.sh.

echo

echo "This line appears ONCE in the script, yet it keeps echoing."
echo "The PID of this instance of the script is still $$."
#     Demonstrates that a subshell is not forked off.

echo "==================== Hit Ctl-C to exit ===================="

sleep 1

exec $0   #  Spawns another instance of this same script
          #+ that replaces the previous one.

echo "This line will never echo!"  # Why not?

exit 99                            # Will not exit here!
                                   # Exit code will not be 99!
</pre></div></div><br class="example-break"><p>An <span class="command"><strong>exec</strong></span> also serves to <a class="link" href="ch20s01.html#usingexecref">reassign
	      file descriptors</a>.	For example, <strong class="userinput"><code>exec
	      &lt;zzz-file</code></strong> replaces <code class="filename">stdin</code>
	      with the file <code class="filename">zzz-file</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="option">-exec</code> option to
	      <a class="link" href="ch16s02.html#findref">find</a> is
	      <em class="replaceable"><code>not</code></em> the same as the
	      <span class="command"><strong>exec</strong></span> shell builtin.</p></div></dd><dt><span class="term"><a name="shoptref"></a><span class="command"><strong>shopt</strong></span></span></dt><dd><a class="indexterm" name="idm9458"></a><a class="indexterm" name="idm9460"></a><p>This command permits changing <em class="firstterm">shell
	      options</em> on the fly (see <a class="xref" href="ch25.html#al" title="Example 25.1. Aliases within a script">Example 25.1, &#8220;Aliases within a script&#8221;</a>
	      and <a class="xref" href="ch25.html#unal" title="Example 25.2. unalias: Setting and unsetting an alias">Example 25.2, &#8220;<em class="firstterm">unalias</em>: Setting and unsetting
      an alias&#8221;</a>).  It often appears in the Bash
	      <a class="link" href="aph.html#filesref1">startup files</a>, but also has
	      its uses in scripts. Needs <a class="link" href="ch37s01.html#bash2ref">version
	      2</a> or later of Bash.</p><pre class="programlisting">shopt -s cdspell
# Allows minor misspelling of directory names with 'cd'
# Option -s sets, -u unsets.

cd /hpme  # Oops! Mistyped '/home'.
pwd       # /home
          # The shell corrected the misspelling.</pre></dd><dt><span class="term"><span class="command"><strong>caller</strong></span><a name="callerref"></a></span></dt><dd><a class="indexterm" name="idm9476"></a><a class="indexterm" name="idm9478"></a><p>Putting a <span class="command"><strong>caller</strong></span> command
	       inside a <a class="link" href="ch24.html#functionref">function</a>
	       echoes to <code class="filename">stdout</code> information about
	       the <em class="firstterm">caller</em> of that function.</p><pre class="programlisting">#!/bin/bash

function1 ()
{
  # Inside function1 ().
  caller 0   # Tell me about it.
}

function1    # Line 9 of script.

# 9 main test.sh
# ^                 Line number that the function was called from.
#   ^^^^            Invoked from "main" part of script.
#        ^^^^^^^    Name of calling script.

caller 0     # Has no effect because it's not inside a function.</pre><p>A <span class="command"><strong>caller</strong></span> command can also return
	      <em class="firstterm">caller</em> information from a script <a class="link" href="ch15.html#sourceref">sourced</a> within another
	      script. Analogous to a function, this is a <span class="quote">&#8220;<span class="quote">subroutine
	      call.</span>&#8221;</span></p><p>You may find this command useful in debugging.</p></dd></dl></div><div class="variablelist"><a name="intcommand"></a><p class="title"><b><a name="intcommand1"></a>Commands</b></p><dl class="variablelist"><dt><span class="term"><a name="trueref"></a><span class="command"><strong>true</strong></span></span></dt><dd><a class="indexterm" name="idm9502"></a><a class="indexterm" name="idm9504"></a><p>A command that returns a successful
	    (<span class="returnvalue">zero</span>) <a class="link" href="ch06.html#exitstatusref">exit status</a>, but does
	    nothing else.
	  </p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>true</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $?</code></strong>
<code class="computeroutput">0</code>
	      </pre><p>
	    </p><pre class="programlisting"># Endless loop
while true   # alias for ":"
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop or script will hang.
done</pre></dd><dt><span class="term"><a name="falseref"></a><span class="command"><strong>false</strong></span></span></dt><dd><a class="indexterm" name="idm9524"></a><a class="indexterm" name="idm9526"></a><p>A command that returns an unsuccessful <a class="link" href="ch06.html#exitstatusref">exit status</a>,
	    but does nothing else.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>false</code></strong>
<code class="prompt">bash$ </code><strong class="userinput"><code>echo $?</code></strong>
<code class="computeroutput">1</code>
	      </pre><p>
	    </p><pre class="programlisting"># Testing "false" 
if false
then
  echo "false evaluates \"true\""
else
  echo "false evaluates \"false\""
fi
# false evaluates "false"


# Looping while "false" (null loop)
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   
</pre></dd><dt><span class="term"><a name="typeref"></a><span class="command"><strong>type [cmd]</strong></span></span></dt><dd><a class="indexterm" name="idm9545"></a><a class="indexterm" name="idm9547"></a><a class="indexterm" name="idm9550"></a><p>Similar to the <a class="link" href="ch16s05.html#whichref">which</a> external command,
	    <span class="command"><strong>type cmd</strong></span> identifies
	    <span class="quote">&#8220;<span class="quote">cmd.</span>&#8221;</span> Unlike <span class="command"><strong>which</strong></span>,
	    <span class="command"><strong>type</strong></span> is a Bash builtin. The useful
	    <code class="option">-a</code> option to <span class="command"><strong>type</strong></span>
	    identifies <em class="replaceable"><code>keywords</code></em>
	    and <em class="replaceable"><code>builtins</code></em>, and also locates
	    system commands with identical names.</p><p>
	      </p><pre class="screen">
<code class="prompt">bash$ </code><strong class="userinput"><code>type '['</code></strong>
<code class="computeroutput">[ is a shell builtin</code>
<code class="prompt">bash$ </code><strong class="userinput"><code>type -a '['</code></strong>
<code class="computeroutput">[ is a shell builtin
 [ is /usr/bin/[</code>


<code class="prompt">bash$ </code><strong class="userinput"><code>type type</code></strong>
<code class="computeroutput">type is a shell builtin</code>
	      </pre><p>
	    </p><p>The <span class="command"><strong>type</strong></span> command can be useful
              for <a class="link" href="ch03.html#devnullredirect">testing whether a
              certain command exists</a>.</p></dd><dt><span class="term"><a name="hashcmdref"></a><span class="command"><strong>hash [cmds]</strong></span></span></dt><dd><a class="indexterm" name="idm9582"></a><a class="indexterm" name="idm9584"></a><a class="indexterm" name="idm9587"></a><a class="indexterm" name="idm9589"></a><p>Records the <em class="firstterm">path</em>
	    name of specified commands -- in the shell <em class="firstterm">hash
	    table</em>

	        <a href="#ftn.idm9595" class="footnote" name="idm9595"><sup class="footnote">[65]</sup></a>
	      
              -- so the shell or script will not need to search the
              <a class="link" href="ch09s01.html#pathref">$PATH</a> on subsequent calls to those
              commands. When <span class="command"><strong>hash</strong></span> is called with no
	      arguments, it simply lists the commands that have been hashed.
	      The <code class="option">-r</code> option resets the hash table.</p></dd><dt><span class="term"><a name="bindref"></a><span class="command"><strong>bind</strong></span></span></dt><dd><a class="indexterm" name="idm9617"></a><a class="indexterm" name="idm9619"></a><p>The <span class="command"><strong>bind</strong></span> builtin displays or modifies
	  <em class="firstterm">readline</em>
	    <a href="#ftn.idm9625" class="footnote" name="idm9625"><sup class="footnote">[66]</sup></a>
	  key bindings.</p></dd><dt><span class="term"><a name="helpref"></a><span class="command"><strong>help</strong></span></span></dt><dd><a class="indexterm" name="idm9634"></a><a class="indexterm" name="idm9636"></a><p>Gets a short usage summary of a shell builtin. This is
	    the counterpart to <a class="link" href="ch16s05.html#whatisref">whatis</a>,
	    but for builtins. The display of <em class="firstterm">help</em>
	    information got a much-needed update in the <a class="link" href="ch37s03.html#bash4ref">version 4 release</a> of Bash.</p><p>
	      </p><pre class="screen"><code class="prompt">bash$ </code><strong class="userinput"><code>help exit</code></strong>
<code class="computeroutput">exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.</code>
	      </pre><p>
	      </p></dd></dl></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.idm8611" class="footnote"><p><a href="#idm8611" class="para"><sup class="para">[58] </sup></a>As Nathan Coulter points out, "while forking a
	  process is a low-cost operation, executing a new program in
	  the newly-forked child process adds more
	  overhead."</p></div><div id="ftn.idm8654" class="footnote"><p><a href="#idm8654" class="para"><sup class="para">[59] </sup></a>An exception to this is the <a class="link" href="ch16s03.html#timref">time</a> command, listed in the
	     official Bash documentation as a keyword (<span class="quote">&#8220;<span class="quote">reserved
	     word</span>&#8221;</span>).</p></div><div id="ftn.idm9013" class="footnote"><p><a href="#idm9013" class="para"><sup class="para">[60] </sup></a>Note that <em class="firstterm">let</em>
          <a class="link" href="ch34.html#letbad">cannot be used
          for setting <em class="firstterm">string</em>
          variables.</a></p></div><div id="ftn.idm9203" class="footnote"><p><a href="#idm9203" class="para"><sup class="para">[61] </sup></a>To <em class="firstterm">Export</em>
	      information is to make it available in a more general context.
	      See also <a class="link" href="ch21.html#scoperef">scope</a>.</p></div><div id="ftn.idm9293" class="footnote"><p><a href="#idm9293" class="para"><sup class="para">[62] </sup></a>An <em class="firstterm">option</em> is an
		argument that acts as a flag, switching script behaviors
		on or off. The argument associated with a particular
		option indicates the behavior that the option (flag)
		switches on or off.</p></div><div id="ftn.idm9397" class="footnote"><p><a href="#idm9397" class="para"><sup class="para">[63] </sup></a>Technically, an
		    <span class="command"><strong>exit</strong></span> only terminates the
		    process (or shell) in which it is running,
		    <span class="emphasis"><em>not</em></span> the <em class="firstterm">parent
		    process</em>.</p></div><div id="ftn.idm9429" class="footnote"><p><a href="#idm9429" class="para"><sup class="para">[64] </sup></a>Unless the <span class="command"><strong>exec</strong></span> is used
		   to <a class="link" href="ch20s01.html#usingexecref">reassign file
		   descriptors</a>.</p></div><div id="ftn.idm9595" class="footnote"><p><a href="#idm9595" class="para"><sup class="para">[65] </sup></a><a name="hashref"></a></p><p><em class="firstterm">Hashing</em> is a method of
		creating lookup keys for data stored in a table. The
		<span class="emphasis"><em>data items themselves</em></span> are
		<span class="quote">&#8220;<span class="quote">scrambled</span>&#8221;</span> to create keys, using one of
		a number of simple mathematical
		<em class="firstterm">algorithms</em> (methods, or
		recipes).</p><p>An advantage of <em class="firstterm">hashing</em> is that
		it is fast. A disadvantage is that
		<em class="firstterm">collisions</em> -- where a single key
		maps to more than one data item -- are possible.</p><p>For examples of hashing see <a class="xref" href="apa.html#hashlib" title="Example A.20. Library of hash functions">Example A.20, &#8220;Library of hash functions&#8221;</a> and
		  <a class="xref" href="apa.html#hashexample" title="Example A.21. Colorizing text using hash functions">Example A.21, &#8220;Colorizing text using hash functions&#8221;</a>.</p></div><div id="ftn.idm9625" class="footnote"><p><a href="#idm9625" class="para"><sup class="para">[66] </sup></a><a name="readlineref"></a>The
            <em class="firstterm">readline</em> library is what
            Bash uses for reading input in an
            interactive shell.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch15s01.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part Part 4. Commands </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 1. Job Control Commands</td></tr></table></div></body></html>
