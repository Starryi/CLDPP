<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>EVMS User Guide</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="evmsug"></a>EVMS User Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Christine</span> <span class="surname">Lorenz</span></h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Joy</span> <span class="surname">Goodreau</span></h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div><div class="author"><h3 class="author"><span class="firstname">Kylie</span> <span class="surname">Smith</span></h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div></div></div><div><p class="copyright">Copyright © 2004 IBM</p></div><div><div class="legalnotice"><a name="idm24"></a><p class="legalnotice-title"><b>Special Notices</b></p><p>The following terms are registered trademarks of International Business Machines corporation in the United States and/or other countries:  AIX, OS/2, System/390.  A full list of U.S. trademarks owned by IBM may be found at <a class="ulink" href="http://www.ibm.com/legal/copytrade.shtml" target="_top">http://www.ibm.com/legal/copytrade.shtml</a>.</p><p>Intel is a trademark or registered trademark of Intel Corporation in the United States, other countries, or both.</p><p>Windows is a trademark of Microsoft Corporation in the United States, other countries, or both. </p><p> Linux is a trademark of Linus Torvalds. </p><p>UNIX is a registered trademark of The Open Group in the United States and other countries.</p><p>Other company, product, and service names may be trademarks or service marks of others.</p><p>This document is provided "AS IS," with no express or implied warranties. Use the information in this document at your own risk. </p></div></div><div><div class="legalnotice"><a name="idm34"></a><p class="legalnotice-title"><b>License Information</b></p><p>This document may be reproduced or distributed in any form without prior permission provided the copyright notice is retained on all copies. Modified versions of this document may be freely distributed provided that they are clearly identified as such, and this copyright is included intact. </p></div></div><div><p class="pubdate">September 16, 2004</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#userguidepref">Preface</a></span></dt><dt><span class="chapter"><a href="#intro">1. What is EVMS?</a></span></dt><dd><dl><dt><span class="sect1"><a href="#cando">1. Why choose EVMS?</a></span></dt><dt><span class="sect1"><a href="#uis">2. The EVMS user interfaces</a></span></dt><dt><span class="sect1"><a href="#terminology">3. EVMS terminology</a></span></dt><dt><span class="sect1"><a href="#idm262">4. What makes EVMS so flexible?</a></span></dt><dt><span class="sect1"><a href="#LAYERDEF">5. Plug-in layer definitions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#evmscmuse">2. Using the EVMS interfaces</a></span></dt><dd><dl><dt><span class="sect1"><a href="#GUI">1. EVMS GUI</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GUITASKS">1.1. Using context sensitive and action menus</a></span></dt><dt><span class="sect2"><a href="#COMMIT">1.2. Saving changes</a></span></dt><dt><span class="sect2"><a href="#refresh">1.3. Refreshing changes</a></span></dt><dt><span class="sect2"><a href="#guiplus">1.4. Using the GUI "+"</a></span></dt><dt><span class="sect2"><a href="#idm364">1.5. Using the accelerator keys</a></span></dt></dl></dd><dt><span class="sect1"><a href="#NCURSES">2. EVMS Ncurses interface</a></span></dt><dd><dl><dt><span class="sect2"><a href="#NCURSESOVER">2.1. Navigating through EVMS Ncurses</a></span></dt><dt><span class="sect2"><a href="#NCURCHANGES">2.2. Saving changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#COMMANDLINE">3. EVMS Command Line Interpreter</a></span></dt><dd><dl><dt><span class="sect2"><a href="#CLITASKS">3.1. Using the EVMS CLI</a></span></dt><dt><span class="sect2"><a href="#NOTECOMMAND">3.2. Notes on commands and command files</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#debuglevels">3. The EVMS log file and error data collection</a></span></dt><dd><dl><dt><span class="sect1"><a href="#FSIMsupp">1. About the EVMS log file</a></span></dt><dt><span class="sect1"><a href="#loglevels">2. Log file logging levels</a></span></dt><dt><span class="sect1"><a href="#specifylevels">3. Specifying the logging levels</a></span></dt></dl></dd><dt><span class="chapter"><a href="#evmsmigrate">4. Viewing compatibility volumes after migrating</a></span></dt><dd><dl><dt><span class="sect1"><a href="#guimigrate">1. Using the EVMS GUI</a></span></dt><dt><span class="sect1"><a href="#ncurmigrate">2. Using Ncurses</a></span></dt><dt><span class="sect1"><a href="#climigrate">3. Using the CLI</a></span></dt></dl></dd><dt><span class="chapter"><a href="#displaydetails">5. Obtaining interface display details</a></span></dt><dd><dl><dt><span class="sect1"><a href="#displaygui">1. Using the EVMS GUI</a></span></dt><dt><span class="sect1"><a href="#displaydatancurses">2. Using Ncurses</a></span></dt><dt><span class="sect1"><a href="#idm812">3. Using the CLI</a></span></dt></dl></dd><dt><span class="chapter"><a href="#evmsassignseg">6. Adding and removing a segment manager</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whenassign">1. When to add a segment manager</a></span></dt><dt><span class="sect1"><a href="#smtypes">2. Types of segment managers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#defaultseg">2.1. DOS Segment Manager</a></span></dt><dt><span class="sect2"><a href="#gptseg">2.2. GUID Partitioning Table (GPT) Segment Manager</a></span></dt><dt><span class="sect2"><a href="#s390sm">2.3. S/390 Segment Manager</a></span></dt><dt><span class="sect2"><a href="#idm884">2.4. Cluster segment manager</a></span></dt><dt><span class="sect2"><a href="#idm899">2.5. BSD segment manager</a></span></dt><dt><span class="sect2"><a href="#idm902">2.6. MAC segment manager</a></span></dt><dt><span class="sect2"><a href="#idm905">2.7. BBR segment manager</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assignsegex">3. Adding a segment manager to an existing disk</a></span></dt><dt><span class="sect1"><a href="#assignsegnew">4. Adding a segment manager to a new disk</a></span></dt><dt><span class="sect1"><a href="#assignex">5. Example: add a segment manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assignseggui">5.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#assignsegncur">5.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#assignsegcli">5.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#removeseg">6. Removing a segment manager</a></span></dt><dt><span class="sect1"><a href="#rmvex">7. Example: remove a segment manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#removeseggui">7.1. Using the EVMS GUI context sensitive menu</a></span></dt><dt><span class="sect2"><a href="#removesegcur">7.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#removesegcli">7.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmscreateseg">7. Creating segments</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whyseg">1. When to create a segment</a></span></dt><dt><span class="sect1"><a href="#crsegex">2. Example: create a segment</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guiseg">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurseg">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#cliseg">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmscreatecont">8. Creating a container </a></span></dt><dd><dl><dt><span class="sect1"><a href="#whencont">1. When to create a container</a></span></dt><dt><span class="sect1"><a href="#contex">2. Example: create a container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guicont">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurcont">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clicont">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmscreatereg">9. Creating regions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1320">1. When to create regions</a></span></dt><dt><span class="sect1"><a href="#crregex">2. Example: create a region</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guireg">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurreg">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clireg">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmscreatedrivelinking">10. Creating drive links</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whatisdrivelinking">1. What is drive linking?</a></span></dt><dt><span class="sect1"><a href="#howimp">2. How drive linking is implemented</a></span></dt><dt><span class="sect1"><a href="#idm1453">3. Creating a drive link</a></span></dt><dt><span class="sect1"><a href="#drivelinkex">4. Example: create a drive link</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guidrivelinking">4.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncursdrivelink">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#drlinkseg">4.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#expandpartitions">5. Expanding a drive link</a></span></dt><dt><span class="sect1"><a href="#shrinkdrivelink">6. Shrinking a drive link</a></span></dt><dt><span class="sect1"><a href="#deletedrivelink">7. Deleting a drive link</a></span></dt></dl></dd><dt><span class="chapter"><a href="#evmscreatesnap">11. Creating snapshots</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whatissnapshotting">1. What is a snapshot?</a></span></dt><dt><span class="sect1"><a href="#createactivsnap">2. Creating snapshot objects</a></span></dt><dt><span class="sect1"><a href="#snapshotex">3. Example: create a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guisnapshot">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncursnapshot">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clisnapshot">3.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1717">4. Reinitializing a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1723">4.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1765">4.2. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1775">5. Expanding a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1784">5.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1835">5.2. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1843">6. Deleting a snapshot</a></span></dt><dt><span class="sect1"><a href="#idm1847">7. Rolling back a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1859">7.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1900">7.2. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmscreatevol">12. Creating volumes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1913">1. When to create a volume</a></span></dt><dt><span class="sect1"><a href="#crvolexcomp">2. Example: create an EVMS native volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#evmsguivol">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurevmsvol">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1987">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#crvolexevms">3. Example: create a compatibility volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guicompvol">3.1. Using the GUI</a></span></dt><dt><span class="sect2"><a href="#ncurcompatvol">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2064">3.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmsfsimops">13. FSIMs and file system operations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#FSIMsuppevms">1. The FSIMs supported by EVMS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fsimjfs">1.1. JFS</a></span></dt><dt><span class="sect2"><a href="#fsimxfs">1.2. XFS</a></span></dt><dt><span class="sect2"><a href="#fsimreiserfs">1.3. ReiserFS</a></span></dt><dt><span class="sect2"><a href="#fsimext23">1.4. Ext2/3</a></span></dt><dt><span class="sect2"><a href="#fsimswapfs">1.5. SWAPFS</a></span></dt><dt><span class="sect2"><a href="#fsimopengfs">1.6. OpenGFS</a></span></dt><dt><span class="sect2"><a href="#fsimntfs">1.7. NTFS</a></span></dt></dl></dd><dt><span class="sect1"><a href="#fsimmkfs">2. Example: add a file system to a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fsimmkfsgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#fsimmkfsncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#fsimmkfscli">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#fsimmkfsaex">3. Example: check a file system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#FSIMmkfsgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#fsimfsckncurses">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#FSIMmkfscli">3.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#clusterops">14. Clustering operations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm2372">1. Rules and restrictions for creating cluster containers</a></span></dt><dt><span class="sect1"><a href="#idm2382">2. Example: create a private cluster container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2394">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2432">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2490">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2496">3. Example: create a shared cluster container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2507">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2543">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2598">3.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2604">4. Example: convert a private container to a shared container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2617">4.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2638">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2683">4.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2688">5. Example: convert a shared container to a private container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2702">5.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2724">5.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2768">5.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2773">6. Example: deport a private or shared container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2782">6.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2803">6.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2845">6.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2849">7. Deleting a cluster container</a></span></dt><dt><span class="sect1"><a href="#idm2853">8. Failover and Failback of a private container on Linux-HA</a></span></dt><dt><span class="sect1"><a href="#idm2896">9. Remote configuration management</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2901">9.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2918">9.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2941">9.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2946">10. Forcing a cluster container to be active</a></span></dt></dl></dd><dt><span class="chapter"><a href="#evmsconvert">15. Converting volumes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm2974">1. When to convert volumes</a></span></dt><dt><span class="sect1"><a href="#comptoevms">2. Example: convert compatibility volumes to EVMS volumes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#c2egui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#c2encur">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3054">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#evmstocomp">3. Example: convert EVMS volumes to compatibility volumes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#e2cgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#e2cncur">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#e2ccli">3.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#expandshrink">16. Expanding and shrinking volumes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whyexpandshrink">1. Why expand and shrink volumes?</a></span></dt><dt><span class="sect1"><a href="#exshrink">2. Example: shrink a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#shrinkgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#shrinkncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#shrinkcli">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mkfs">3. Example: expand a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#expandgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#expandncurses">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#expandcli">3.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#addfeatures">17. Adding features to an existing volume</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whyadd">1. Why add features to a volume?</a></span></dt><dt><span class="sect1"><a href="#exaddfeature">2. Example: add drive linking to an existing volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#addfeaturegui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#addfeaturesncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#addfeaturescli">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#selectact">18. Selectively activating volumes and objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#initialactivation">1. Initial activation using /etc/evms.conf</a></span></dt><dt><span class="sect1"><a href="#idm3528">2. Activating and deactivating volumes and objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3531">2.1. Activation</a></span></dt><dt><span class="sect2"><a href="#idm3613">2.2. Deactivation</a></span></dt><dt><span class="sect2"><a href="#idm3695">2.3. Activation and deactivation dependencies</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#mountunmount">19. Mounting and unmounting volumes from within EVMS</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mntvol">1. Mounting a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mntgui">1.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#mountncurses">1.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3797">1.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm3804">2. Unmounting a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3807">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#unmountncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3858">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm3863">3. The SWAPFS file system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3868">3.1. Turning swap on</a></span></dt><dt><span class="sect2"><a href="#idm3939">3.2. Turning swap off</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#plugintasks">20. Plug-in operations tasks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#aboutplugintasks">1. What are plug-in tasks?</a></span></dt><dt><span class="sect1"><a href="#pluginexample">2. Example: complete a plug-in operations task</a></span></dt><dd><dl><dt><span class="sect2"><a href="#plugingui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#plugintasksncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#plugincli">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#deleterecurs">21. Deleting objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#howtodel">1. How to delete objects: delete and delete recursive</a></span></dt><dt><span class="sect1"><a href="#examdelrecur">2. Example: perform a delete recursive operation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mkfsgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#mkfsncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#deleterecurcli">2.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#evmsreplaceobjects">22. Replacing objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#whatisobjectreplace">1. What is object-replace?</a></span></dt><dt><span class="sect1"><a href="#replacedlchildobj">2. Replacing a drive-link child object</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guiobjectreplace">2.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#clireplace">2.2. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#segstorobjs">23. Moving segment storage objects</a></span></dt><dd><dl><dt><span class="sect1"><a href="#segmovewhatis">1. What is segment moving?</a></span></dt><dt><span class="sect1"><a href="#whymove">2. Why move a segment?</a></span></dt><dt><span class="sect1"><a href="#idm4331">3. Which segment manager plug-ins implement the move function?</a></span></dt><dt><span class="sect1"><a href="#movesegex">4. Example: move a DOS segment</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guimoveseg">4.1. Using the EVMS GUI context sensitive menu</a></span></dt><dt><span class="sect2"><a href="#ncursmoveseg">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clisegmove">4.3. Using the CLI</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appxdos">A. The DOS plug-in</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DOShow">1. How the DOS plug-in is implemented</a></span></dt><dt><span class="sect1"><a href="#assignDOS">2. Assigning the DOS plug-in</a></span></dt><dt><span class="sect1"><a href="#creatingDOS">3. Creating DOS partitions</a></span></dt><dt><span class="sect1"><a href="#expandDOS">4. Expanding DOS partitions</a></span></dt><dt><span class="sect1"><a href="#shrinkDOS">5. Shrinking DOS partitions</a></span></dt><dt><span class="sect1"><a href="#deleteDOS">6. Deleting partitions</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appxmdreg">B. The MD region manager</a></span></dt><dd><dl><dt><span class="sect1"><a href="#characraidlvls">1. Characteristics of Linux RAID levels</a></span></dt><dd><dl><dt><span class="sect2"><a href="#linearmode">1.1. Linear mode</a></span></dt><dt><span class="sect2"><a href="#raid0">1.2. RAID-0</a></span></dt><dt><span class="sect2"><a href="#raid1">1.3. RAID-1</a></span></dt><dt><span class="sect2"><a href="#raid45">1.4. RAID-4/5</a></span></dt><dt><span class="sect2"><a href="#multipath">1.5. Multipath</a></span></dt></dl></dd><dt><span class="sect1"><a href="#createmdreg">2. Creating an MD region</a></span></dt><dd><dl><dt><span class="sect2"><a href="#raid0options">2.1. RAID-0 options</a></span></dt><dt><span class="sect2"><a href="#raid2options">2.2. RAID-1 options</a></span></dt><dt><span class="sect2"><a href="#raid45options">2.3. RAID-4/5 options</a></span></dt></dl></dd><dt><span class="sect1"><a href="#activepsareobjs">3. Active and spare objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#addspareobjs">3.1. Adding spare objects</a></span></dt><dt><span class="sect2"><a href="#remspareobjs">3.2. Removing spare objects</a></span></dt><dt><span class="sect2"><a href="#addactobjsr1">3.3. Adding active objects to RAID-1</a></span></dt></dl></dd><dt><span class="sect1"><a href="#faultobjs">4. Faulty objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#remfaultyobjs">4.1. Removing faulty objects</a></span></dt><dt><span class="sect2"><a href="#fixtempfailedobjs">4.2. Fixing temporarily failed objects</a></span></dt><dt><span class="sect2"><a href="#markobjsfaulty">4.3. Marking objects faulty</a></span></dt></dl></dd><dt><span class="sect1"><a href="#resizemdreg">5. Resizing MD regions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#linear">5.1. Linear</a></span></dt><dt><span class="sect2"><a href="#resizeraid0">5.2. RAID-0</a></span></dt><dt><span class="sect2"><a href="#resizeraid1">5.3. RAID-1</a></span></dt><dt><span class="sect2"><a href="#resizeRAID-45">5.4. RAID-4/5</a></span></dt></dl></dd><dt><span class="sect1"><a href="#replaceobjs">6. Replacing objects</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appxlvm">C. The LVM plug-in</a></span></dt><dd><dl><dt><span class="sect1"><a href="#lvmimp">1. How LVM is implemented</a></span></dt><dt><span class="sect1"><a href="#containerops">2. Container operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#createlvmconts">2.1. Creating LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4729">2.2. Adding objects to LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4732">2.3. Removing objects from LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4736">2.4. Expanding consumed objects in LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4742">2.5. Shrinking consumed objects in LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4749">2.6. Deleting LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4752">2.7. Renaming LVM containers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm4759">3. Region operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4761">3.1. Creating LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4798">3.2. Expanding LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4815">3.3. Shrinking LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4830">3.4. Deleting LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4833">3.5. Moving LVM regions</a></span></dt><dt><span class="sect2"><a href="#renamereg">3.6. Renaming LVM regions</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appxlvm2">D. The LVM2 plug-in</a></span></dt><dd><dl><dt><span class="sect1"><a href="#contops">1. Container operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4909">1.1. Creating LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4922">1.2. Adding objects to LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4925">1.3. Removing objects from LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4929">1.4. Expanding consumed objects in LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4935">1.5. Shrinking consumed objects in LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4942">1.6. Deleting LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4945">1.7. Renaming LVM2 containers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#regionops">2. Region operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4954">2.1. Creating LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm4979">2.2. Expanding LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm4999">2.3. Shrinking LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm5008">2.4. Deleting LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#renamereg2">2.5. Renaming LVM2 regions</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appxcsm">E. The CSM plug-in</a></span></dt><dd><dl><dt><span class="sect1"><a href="#csmassn">1. Assigning the CSM plug-in</a></span></dt><dt><span class="sect1"><a href="#unassignCSM">2. Unassigning the CSM plug-in</a></span></dt><dt><span class="sect1"><a href="#idm5078">3. Deleting a CSM container</a></span></dt></dl></dd><dt><span class="appendix"><a href="#jfsfsim">F. JFS file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createjfsfsim">1. Creating JFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkjfsfsim">2. Checking JFS file systems</a></span></dt><dt><span class="sect1"><a href="#removejfsfsim">3. Removing JFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandjfsfsim">4. Expanding JFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkjfsfsim">5. Shrinking JFS file systems</a></span></dt></dl></dd><dt><span class="appendix"><a href="#xfsfsim">G. XFS file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createxfsfsim">1. Creating XFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkxfsfsim">2. Checking XFS file systems</a></span></dt><dt><span class="sect1"><a href="#removexfsfsim">3. Removing XFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandxfsfsim">4. Expanding XFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkxfsfsim">5. Shrinking XFS file systems</a></span></dt></dl></dd><dt><span class="appendix"><a href="#reiserfsim">H. ReiserFS file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createreiserfsim">1. Creating ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkreiserfsim">2. Checking ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#removexreiserfsim">3. Removing ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandreiserFSfsim">4. Expanding ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkreiserfsim">5. Shrinking ReiserFS file systems</a></span></dt></dl></dd><dt><span class="appendix"><a href="#ext23fsim">I. Ext-2/3 file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createext23fsim">1. Creating Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#checkext23fsim">2. Checking Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#removeext23fsim">3. Removing Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkext23fsim">4. Expanding and shrinking Ext-2/3 
file systems</a></span></dt></dl></dd><dt><span class="appendix"><a href="#gfsfsim">J. OpenGFS file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createopengfsfsim">1. Creating OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkopengfsfsim">2. Checking OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#removeopengfsfsim">3. Removing OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkopengfsfsim">4. Expanding and shrinking OpenGFS
file systems</a></span></dt></dl></dd><dt><span class="appendix"><a href="#ntfsfsim">K. NTFS file system interface module</a></span></dt><dd><dl><dt><span class="sect1"><a href="#createntfsfsim">1. Creating NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#fixntfsfsim">2. Fixing NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#clonentfsfsim">3. Cloning NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#removentfsfsim">4. Removing NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkntfsfsim">5. Expanding and shrinking NTFS
file systems</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>4.1. <a href="#idm726">GUI start-up window</a></dt><dt>4.2. <a href="#idm737">Ncurses start-up window</a></dt><dt>4.3. <a href="#idm756">CLI volume query results</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1. <a href="#bookorg">Organization of the EVMS User Guide</a></dt><dt>1.1. <a href="#userinterf">EVMS user interfaces</a></dt><dt>2.1. <a href="#idm370">Accelerator keys in the Main Window</a></dt><dt>2.2. <a href="#idm384">Accelerator keys in the views</a></dt><dt>2.3. <a href="#idm430">Accelerator keys in the selection window</a></dt><dt>2.4. <a href="#idm454">Accelerator keys in the configuration options window</a></dt><dt>2.5. <a href="#idm476">Widget navigation keys in the configuration options window </a></dt><dt>3.1. <a href="#idm645">EVMS logging levels</a></dt><dt>16.1. <a href="#idm3141">FSIM support for expand and shrink operations</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>6.1. <a href="#idm929">Add the DOS Segment Manager</a></dt><dt>6.2. <a href="#idm1049">Remove the DOS Segment Manager</a></dt><dt>7.1. <a href="#idm1122">Create a 100MB segment</a></dt><dt>8.1. <a href="#idm1231">Create "Sample Container"</a></dt><dt>9.1. <a href="#idm1327">Create "Sample Region"</a></dt><dt>10.1. <a href="#idm1461">Create a drive link</a></dt><dt>11.1. <a href="#idm1607">Create a snapshot of a volume</a></dt><dt>12.1. <a href="#idm1923">Create an EVMS native volume </a></dt><dt>12.2. <a href="#idm2001">Create a compatibility volume</a></dt><dt>13.1. <a href="#idm2167">Add a JFS File System to a Volume</a></dt><dt>13.2. <a href="#idm2277">Check a JFS File System</a></dt><dt>14.1. <a href="#idm2386">Create a private cluster container</a></dt><dt>14.2. <a href="#idm2500">Create a shared cluster container</a></dt><dt>14.3. <a href="#idm2608">Convert a private container to shared</a></dt><dt>14.4. <a href="#idm2692">Convert a shared container to private</a></dt><dt>14.5. <a href="#idm2777">Deport a cluster container</a></dt><dt>15.1. <a href="#idm2988">Convert a compatibility volume</a></dt><dt>15.2. <a href="#idm3066">Convert an EVMS volume</a></dt><dt>16.1. <a href="#idm3186">Shrink a volume</a></dt><dt>16.2. <a href="#idm3297">Expand a volume</a></dt><dt>17.1. <a href="#idm3410">Add drive linking to an existing volume</a></dt><dt>20.1. <a href="#idm4012">Add a spare disk to a compatibility volume made from an MDRaid5 region</a></dt><dt>21.1. <a href="#idm4143">Destroy a volume and the region and container below it</a></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="userguidepref"></a>Preface</h1></div></div></div><p>This guide tells how to configure and manage Enterprise
Volume Management System (EVMS).  EVMS is a storage management program
that provides a single framework for managing and administering your system's storage.</p><p>This guide is intended for Linux system administrators and users who are
responsible for setting up and maintaining EVMS.</p><p>For additional information about EVMS or to ask questions specific to 
your distribution, refer to the EVMS mailing lists. You can view  the list 
archives or subscribe to the lists from 
the <a class="ulink" href="http://evms.sourceforge.net/mailinglists.html" target="_top">EVMS Project 
web site</a>.</p><p>The following table shows how this guide is organized:</p><div class="table"><a name="bookorg"></a><p class="title"><b>Table 1. Organization of the EVMS User Guide</b></p><div class="table-contents"><table class="table" summary="Organization of the EVMS User Guide" border="1"><colgroup><col width="1.5in"><col width="3.5in"></colgroup><thead><tr><th>Chapter or appendix title</th><th>Contents</th></tr></thead><tbody><tr><td>1. What is EVMS?</td><td>Discusses general EVMS concepts and terms.</td></tr><tr><td>2. Using the EVMS interfaces</td><td>Describes the three EVMS user interfaces and how to use them.</td></tr><tr><td>3. The EVMS log file and error data collection</td><td>Discusses the EVMS information and error log file and explains how to change the logging level.</td></tr><tr><td>4. Viewing compatibility volumes after migrating</td><td>Tells how to view existing files that have been migrated to EVMS.</td></tr><tr><td>5. Obtaining interface display details</td><td>Tells how to view detailed information about EVMS objects.</td></tr><tr><td>6. Adding and removing a segment manager</td><td>Discusses segments and explains how to add and remove a segment manager.</td></tr><tr><td>7. Creating segments</td><td>Explains when and how to create segments.</td></tr><tr><td>8. Creating containers</td><td>Discusses containers and explains when and how to create them.</td></tr><tr><td>9. Creating regions</td><td>Discusses regions and explains when and how to create them.</td></tr><tr><td>10. Creating drive links</td><td>Discusses the drive linking feature and tells how to create a drive link.</td></tr><tr><td>11. Creating snapshots</td><td>Discusses snapshotting and tells how to create a snapshot.</td></tr><tr><td>12. Creating volumes</td><td>Explains when and how to create volumes.</td></tr><tr><td>13. FSIMs and file system operations</td><td>Discusses the standard FSIMs shipped with EVMS and provides examples of adding file systems and coordinating file checks with the FSIMs.</td></tr><tr><td>14. Clustering operations</td><td>Describes EVMS clustering and how to create private and shared containers.</td></tr><tr><td>15. Converting volumes</td><td>Explains how to convert EVMS native volumes to compatibility volumes and compatibility volumes to EVMS native volumes.</td></tr><tr><td>16. Expanding and shrinking volumes</td><td>Tells how to expand and shrink EVMS volumes with the various EVMS user interfaces.</td></tr><tr><td>17. Adding features to an existing volume</td><td>Tells how to add additional features, such as drive linking, to an 
existing volume.</td></tr><tr><td>18. Selectively activating volumes and objects</td><td>Explains how to selectively activate and deactive volumes
and options.</td></tr><tr><td>19. Mounting and unmounting volumes from within EVMS.</td><td>Tells how to have EVMS mount and unmount volumes so you do not have to open a separate terminal session.</td></tr><tr><td>20. Plug-in operations tasks</td><td>Discusses the plug-in tasks that are available within the context of a particular plug-in.</td></tr><tr><td>21. Deleting objects</td><td>Tells how to safely delete EVMS objects.</td></tr><tr><td>22. Replacing objects</td><td>Tells how to change the 
configuration of a volume or storage object.</td></tr><tr><td>23. Moving segment storage objects</td><td>Discusses how to use
the move function for moving segments.</td></tr><tr><td>A. The DOS plug-in</td><td>Provides details about the DOS plug-in, which is a segment manager plug-in.</td></tr><tr><td>B. The MD region manager</td><td>Explains the Multiple Disks (MD) support in Linux that is a software implementation of RAID.</td></tr><tr><td>C. The LVM plug-in</td><td>Tells how the LVM plug-in is implemented and how to perform container operations.</td></tr><tr><td>D. The LVM2 plug-in</td><td>Tells how the LVM2 plug-in is implemented and how to perform container operations on
LVM2 containers.</td></tr><tr><td>E. The CSM plug-in</td><td>Explains how the Cluster Segment Manager (CSM) plug-in is implemented and how to perform CSM operations.</td></tr><tr><td>F. JFS file system interface module</td><td>Provides information about the JFS FSIM.</td></tr><tr><td>G. XFS file system interface module</td><td>Provides information about the XFS FSIM.</td></tr><tr><td>H. ReiserFS file system interface module</td><td>Provides information about the ReiserFS FSIM.</td></tr><tr><td>I. Ext-2/3 file system interface module</td><td>Provides information about the Ext-2/3 FSIM.</td></tr><tr><td>J. OpenGFS file system interface module</td><td>Provides information about the OpenGFS FSIM.</td></tr><tr><td>K. NTFS file system interface module</td><td>Provides information about the NTFS FSIM.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>Chapter 1. What is EVMS?</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#cando">1. Why choose EVMS?</a></span></dt><dt><span class="sect1"><a href="#uis">2. The EVMS user interfaces</a></span></dt><dt><span class="sect1"><a href="#terminology">3. EVMS terminology</a></span></dt><dt><span class="sect1"><a href="#idm262">4. What makes EVMS so flexible?</a></span></dt><dt><span class="sect1"><a href="#LAYERDEF">5. Plug-in layer definitions</a></span></dt></dl></div><p>EVMS brings a new model of volume management to Linux®. 
EVMS integrates all aspects of volume management, 
such as disk partitioning, Linux logical volume manager (LVM) and 
multi-disk (MD) management, and file system operations into a single 
cohesive package. 
With EVMS, various volume management technologies are accessible through 
one interface, and new technologies can be added as plug-ins as they are developed.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cando"></a>1. Why choose EVMS?</h2></div></div></div><p>EVMS lets you manage storage space in a way that is more 
intuitive and flexible than many other Linux volume management systems. 
Practical tasks, such as migrating disks or adding new disks to your 
Linux system, become more manageable with EVMS because EVMS can  
recognize and read from different volume types and file systems. 
EVMS provides additional safety controls by not allowing commands that are
unsafe.
These controls help maintain the integrity of the data stored on the system.</p><p>You can use EVMS  to create and manage data storage. 
With EVMS, you can use multiple volume management technologies under one 
framework while ensuring your system still interacts correctly with 
stored data. 
With EVMS, you are can use drive linking, shrink and expand volumes, 
create snapshots of your volumes, and set up RAID 
(redundant array of independent devices) features for your system. 
You can also use many types of file systems and manipulate these storage pieces 
in ways that best meet the needs of your particular work environment.</p><p>EVMS also provides the capability to manage data on storage that is
physically shared by nodes in a cluster.  This shared storage allows data to
be highly available from different nodes in the cluster.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="uis"></a>2. The EVMS user interfaces</h2></div></div></div><p>There are currently three user interfaces available for EVMS: graphical (GUI), text mode (Ncurses), and the Command Line Interpreter (CLI). 
Additionally, you can use the EVMS Application Programming Interface to implement your own customized user interface. </p><p><a class="xref" href="#userinterf" title="Table 1.1. EVMS user interfaces">Table 1.1, &#8220;EVMS user interfaces&#8221;</a> tells more about each of the EVMS user interfaces.

</p><div class="table"><a name="userinterf"></a><p class="title"><b>Table 1.1. EVMS user interfaces</b></p><div class="table-contents"><table class="table" summary="EVMS user interfaces" border="1"><colgroup><col width="1in"><col width="1.5in"><col width="1in"><col width="2.5in"></colgroup><thead><tr><th>User interface</th><th>Typical user</th><th>Types of use</th><th>Function</th></tr></thead><tbody><tr><td>GUI</td><td>All</td><td>All uses except automation</td><td>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </td></tr><tr><td>Ncurses</td><td>Users who don't have GTK libraries or X Window Systems on their machines</td><td>All uses except automation</td><td>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </td></tr><tr><td>Command Line</td><td>Expert</td><td>All uses</td><td>Allows easy automation of  tasks</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="terminology"></a>3. EVMS terminology</h2></div></div></div><p>To avoid confusion with other terms that describe volume 
	management in general, EVMS uses a specific set of terms. 
	These terms are listed, from most fundamental to most comprehensive, 
	as follows:
	</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Logical disk</span></dt><dd><p>Representation of anything EVMS can access as a physical disk. 
		In EVMS, physical disks are logical disks.</p></dd><dt><span class="term">Sector</span></dt><dd><p>The lowest level of addressability on a block
		device. This definition is in keeping with the standard
		meaning found in other management systems.</p></dd><dt><span class="term">Disk segment</span></dt><dd><p>An ordered set of physically contiguous
		sectors residing on the same storage object. 
		The general analogy for a segment is to a traditional disk
		partition, such as DOS or OS/2 ®</p></dd><dt><span class="term">Storage region</span></dt><dd><p>An ordered set of logically contiguous sectors
		that  are not necessarily physically contiguous. </p></dd><dt><span class="term">Storage object</span></dt><dd><p>Any persistent memory structure in EVMS that can be used to 
		build objects or create a volume. Storage object is a  generic term for disks, segments, regions, and feature objects.</p></dd><dt><span class="term">Storage container</span></dt><dd><p>A collection of storage objects. A storage
		container consumes one set of storage objects and produces new 
		storage objects. One common subset of storage containers is volume groups, 
		such as AIX®  or LVM.</p><p>Storage containers can be either of type private or cluster.</p></dd><dt><span class="term">Cluster storage container</span></dt><dd><p>Specialized storage containers that consume only disk objects 
	that are physically accessible from all nodes of a cluster.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Private storage container</span></dt><dd><p>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by a single node of the cluster at any given time.</p></dd><dt><span class="term">Shared storage container</span></dt><dd><p>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by all nodes of the cluster simultaneously.</p></dd><dt><span class="term">Deported storage container</span></dt><dd><p>A shared cluster container that is not owned by any node of the cluster.</p></dd></dl></div></dd><dt><span class="term">Feature object</span></dt><dd><p>A storage object that contains an EVMS native feature. 
		</p><p>An <em class="glossterm">EVMS Native Feature</em> is a  function of volume management designed 
		and implemented by 
		EVMS. These features are not intended to be backward compatible with other 
		volume management technologies. </p></dd><dt><span class="term">Logical volume</span></dt><dd><p>A volume that consumes a storage object and exports 
		something mountable. There are two varieties of logical volumes: <em class="glossterm">EVMS Volumes</em> 
		and <em class="glossterm">Compatibility volumes</em>.</p><p> <em class="glossterm">EVMS  Volumes</em> contain EVMS native metadata and can support all 
		EVMS features. <code class="filename">/dev/evms/my_volume</code> would be an example 
		of an EVMS Volume.</p><p><em class="glossterm">Compatibility volumes</em> do not contain any EVMS native metadata. 
		Compatibility volumes are backward compatible to their particular scheme, but 
		they cannot support EVMS features. <code class="filename">/dev/evms/md/md0</code> would 
		be an example of a compatibility  volume. </p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm262"></a>4. What makes EVMS so flexible?</h2></div></div></div><p>There are numerous drivers in the Linux kernel, such as Device
Mapper and MD (software RAID), that implement volume management schemes.  EVMS is built
on top of these drivers to provide one framework for combining and
accessing the capabilities.</p><p>The EVMS Engine handles the creation,
configuration, and management of volumes, segments, and disks.
The EVMS Engine is a programmatic interface to the EVMS system.
User interfaces and programs that use EVMS must go through the Engine.</p><p>EVMS provides the capacity for plug-in modules to the Engine that
allow EVMS to perform specialized tasks without altering the core code.
These plug-in modules allow EVMS to be more extensible and customizable than
other volume management systems.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="LAYERDEF"></a>5. Plug-in layer definitions</h2></div></div></div><p>EVMS defines a layered architecture where plug-ins in each layer
		create abstractions of the layer or layers below. EVMS also allows most plug-ins
		to create abstractions of objects within the same layer. The following
		list defines these layers from the bottom up.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Device managers</span></dt><dd><p>The first (bottom) layer consists
			of device managers.
			These plug-ins communicate with hardware device drivers to
			create the first EVMS objects. Currently, all devices are handled by a single plug-in.
			Future releases of EVMS might need additional device managers
			for network device management (for example, to manage
			disks on a storage area network (SAN)).</p></dd><dt><span class="term">Segment managers</span></dt><dd><p>The second layer consists of segment 
			managers. These plug-ins
			 handle the segmenting, or partitioning,
			of disk drives. The Engine components can replace partitioning
			programs, such as <span class="command"><strong>fdisk</strong></span> and
			<span class="application">Disk Druid</span>, and EVMS
			uses Device Mapper to replace the in-kernel disk
			partitioning code. 
			Segment managers can also be "stacked," meaning that 
			one segment manager
			can take as input the output from another segment 
			manager.</p><p> EVMS provides the following segment managers: 
			DOS, GPT, System/390® (S/390), Cluster, BSD,
			Mac, and BBR. Other segment manager
			plug-ins can be added to support other 
			partitioning schemes.</p></dd><dt><span class="term">Region managers</span></dt><dd><p>The third layer consists of region 
			managers. 
			This layer provides a place for plug-ins that ensure
			compatibility with existing volume management schemes 
			in Linux and other operating systems. 
			Region managers are intended to model systems that 
			provide a logical abstraction above disks
			or partitions.</p><p>Like segment managers, region managers can 
			also be stacked. 
			Therefore, the input object(s) to a region manager can
			be disks, segments, or other regions.</p><p>There are currently three region manager plug-ins in EVMS: 
			Linux LVM, LVM2, and Multi-Disk (MD).
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Linux LVM</span></dt><dd><p>The Linux LVM plug-in provides compatibility with
				the Linux LVM and allows the creation of volume groups 
				(known in EVMS as containers) and logical volumes 
				(known in EVMS as regions). </p></dd><dt><span class="term">LVM2</span></dt><dd><p>
				The LVM2 plug-in provides compatibility with the
new volume format introduced by the LVM2 tools from Red Hat.  This plug-in
is very similar in functionality to the LVM plug-in.  The primary difference
is the new, improved metadata format.	
				</p></dd><dt><span class="term">MD</span></dt><dd><p>The Multi-Disk (MD) plug-in for RAID provides 
				RAID levels linear, 0, 1, 4, and 5 in 
				software. MD is one plug-in that displays as four region
				managers that you can choose from.</p></dd></dl></div></dd><dt><span class="term">EVMS features</span></dt><dd><p>The next layer consists of EVMS 
			features. This layer is
			where new EVMS-native functionality is implemented. EVMS
			features can be built on any object in the system, including
			disks, segments, regions, or other feature objects. 
			All EVMS features share a common type of metadata, 
			which makes discovery of feature objects much more 
			efficient, and recovery
			of broken features objects much more reliable. There are three 
			features currently available in EVMS: drive linking, Bad 
			Block Relocation, and snapshotting. </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Drive Linking</span></dt><dd><p>Drive linking allows any
			number of objects to be linearly concatenated together into a
			single object. A drive linked volume can be expanded by 
			adding another storage object to the end or shrunk by removing the last object.</p></dd><dt><span class="term">Bad Block Relocation</span></dt><dd><p>Bad Block Relocation (BBR)
			monitors its I/O path and detects write failures (which can be
			caused by a damaged disk). In the event of such a failure, the
			data from that request is stored in a new location. BBR keeps
			track of this remapping. Additional I/Os to that
			location are redirected to the new location.</p></dd><dt><span class="term">Snapshotting</span></dt><dd><p>The Snapshotting feature provides
			a mechanism for creating a "frozen" copy of a volume at a single
			instant in time, without having to take that volume off-line.
			This is useful for performing backups on a live system.
			Snapshots work with any volume (EVMS or compatibility), and can
			use any other available object as a backing store. After a
			snapshot is created and made into an EVMS volume, writes to the "original" volume cause the
			original contents of that location to be copied to the snapshot's
			storage object. Reads to the snapshot volume look like they
			come from the original at the time the snapshot was created.
</p></dd></dl></div></dd><dt><span class="term">File System Interface Modules</span></dt><dd><p>File System Interface Modules (FSIMs) 
			provide coordination with the
			file systems during certain volume management 
			operations. For
			instance, when expanding or shrinking a volume, 
			the file system
			must also be expanded or shrunk to the appropriate size.
			Ordering in this example is also important; 
			a file system cannot
			be expanded before the volume, and a volume cannot 
			be shrunk before the file system. 
			The FSIMs allow EVMS to ensure this
			coordination and ordering.</p><p>FSIMs also perform file system
			operations from one of the EVMS user interfaces. For instance,
			a user can make new file systems and check existing file systems
			by interacting with the FSIM.</p></dd><dt><span class="term">Cluster Manager Interface Modules</span></dt><dd><p>Cluster Manager Interface Modules, also
		known as the EVMS Clustered Engine (ECE), interface
		with the local cluster manager installed on the system.
		The ECE provides a standardized ECE API to the Engine
		while hiding cluster manager details from the Engine.</p></dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscmuse"></a>Chapter 2. Using the EVMS interfaces</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#GUI">1. EVMS GUI</a></span></dt><dd><dl><dt><span class="sect2"><a href="#GUITASKS">1.1. Using context sensitive and action menus</a></span></dt><dt><span class="sect2"><a href="#COMMIT">1.2. Saving changes</a></span></dt><dt><span class="sect2"><a href="#refresh">1.3. Refreshing changes</a></span></dt><dt><span class="sect2"><a href="#guiplus">1.4. Using the GUI "+"</a></span></dt><dt><span class="sect2"><a href="#idm364">1.5. Using the accelerator keys</a></span></dt></dl></dd><dt><span class="sect1"><a href="#NCURSES">2. EVMS Ncurses interface</a></span></dt><dd><dl><dt><span class="sect2"><a href="#NCURSESOVER">2.1. Navigating through EVMS Ncurses</a></span></dt><dt><span class="sect2"><a href="#NCURCHANGES">2.2. Saving changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#COMMANDLINE">3. EVMS Command Line Interpreter</a></span></dt><dd><dl><dt><span class="sect2"><a href="#CLITASKS">3.1. Using the EVMS CLI</a></span></dt><dt><span class="sect2"><a href="#NOTECOMMAND">3.2. Notes on commands and command files</a></span></dt></dl></dd></dl></div><p>This chapter explains how to use the EVMS GUI, Ncurses, and CLI interfaces.
This chapter also
includes information about basic navigation and commands available through
the CLI. </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GUI"></a>1. EVMS GUI</h2></div></div></div><p>The EVMS GUI is a flexible and easy-to-use
	interface for administering volumes and storage objects. 
	Many users find the EVMS GUI easy to use because it displays which
	storage objects, actions, and plug-ins are acceptable for a
	particular task.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="GUITASKS"></a>1.1. Using context sensitive and action menus</h3></div></div></div><p>The EVMS GUI lets you accomplish most
		tasks in one of two ways: context sensitive menus or the
		<span class="guimenu">Actions</span> menu.</p><p>Context sensitive menus are available from any
		of the main "views." Each view corresponds to a
		page in a notebook widget located on the EVMS
		GUI main window. These views are made up of different
		trees or lists that visually represent the organization of
		different object types, including volumes,
		feature objects, regions, containers, segments, or disks. </p><p>You can view the context
		sensitive menu for an object by right-clicking on that
		object. The actions that are available
		for that object display on
		the screen. The GUI will only present actions that are 
		acceptable for the selected object at that point in the 
		process. These actions are not always a complete set. </p><p>To use the <span class="guimenuitem">Actions</span> menu,
		choose <span class="guimenuitem">Action</span> &#8594; <span class="guimenuitem">&lt;the action you want
				to accomplish&gt;</span> &#8594; <span class="guimenuitem">&lt;options&gt;</span>. 
			The <span class="guimenuitem">Actions</span> menu 
		provides a more guided path for
		completing a task than do context sensitive menus. The
			<span class="guimenu">Actions</span> option is similar to the 
		wizard or druid approach used by many GUI applications.</p><p>All of the operations you need to
			perform as an administrator are available through
			the <span class="guimenuitem">Actions</span> menu.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="COMMIT"></a>1.2. Saving changes</h3></div></div></div><p>All of the changes that you make while in the EVMS
		GUI are only in memory until you save the changes.
		In order to make your changes
		permanent, you must save
		all changes before exiting. If you
		forget to save the changes and decide to exit or close the
		EVMS GUI, you are reminded to save any
		pending changes.</p><p>To explicitly save all the changes you
		made, select <span class="guimenu">Action</span> &#8594; <span class="guimenuitem">Save</span>, and click
		the <span class="guibutton">Save</span> button.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="refresh"></a>1.3. Refreshing changes</h3></div></div></div><p>The <span class="guibutton">Refresh</span> button updates the view and allows 
you to see changes, like mount points, that might have changed outside of 
the GUI.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guiplus"></a>1.4. Using the GUI "+"</h3></div></div></div><p>Along the left hand side of the panel views in the GUI is a "+" that resides
beside each item.  When you click the "+,"  the objects that are included
in the item are displayed.  If any of the objects that display also have a "+" beside them, you can expand them further by clicking on the "+" next to each object name.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm364"></a>1.5. Using the accelerator keys</h3></div></div></div><p>You can avoid using a mouse for navigating the EVMS GUI by using a series of
key strokes, or "accelerator keys," instead.  The following sections tell how to use
accelerator keys in the EVMS Main Window, the Selection Window, and the Configuration
Options Window.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm367"></a>1.5.1. Main Window accelerator keys</h4></div></div></div><p>In the Main Window view, use the following keys to navigate:

</p><div class="table"><a name="idm370"></a><p class="title"><b>Table 2.1. Accelerator keys in the Main Window</b></p><div class="table-contents"><table class="table" summary="Accelerator keys in the Main Window" border="1"><colgroup><col class="C1"><col class="C2"></colgroup><tbody><tr><td>Left and right arrow keys</td><td>Navigate between the notebook tabs of the different views.</td></tr><tr><td>Down arrow and <span class="keycap"><strong>Spacebar</strong></span></td><td>Bring keyboard focus into the view.</td></tr></tbody></table></div></div><p><br class="table-break">
</p><p>
While in a view, use the following keys to navigate:

</p><div class="table"><a name="idm384"></a><p class="title"><b>Table 2.2. Accelerator keys in the views</b></p><div class="table-contents"><table class="table" summary="Accelerator keys in the views" border="1"><colgroup><col class="C1"><col class="C2"></colgroup><tbody><tr><td>up and down arrows</td><td>Allow movement around the window.</td></tr><tr><td>"+"</td><td>Opens an object tree.</td></tr><tr><td>"-"</td><td>Collapses an object tree.</td></tr><tr><td><span class="keycap"><strong>ENTER</strong></span></td><td>Brings up the context menu (on a row).</td></tr><tr><td>Arrows</td><td>Navigate a context menu.</td></tr><tr><td><span class="keycap"><strong>ENTER</strong></span></td><td><p>Activates an item.</p></td></tr><tr><td><span class="keycap"><strong>ESC</strong></span></td><td>Dismisses the context menu.</td></tr><tr><td><span class="keycap"><strong>Tab</strong></span></td><td>Gets you out of the view and moves you back up to the notebook tab.</td></tr></tbody></table></div></div><p><br class="table-break">
 
</p><p>
To access the action bar menu, press <span class="keycap"><strong>Alt</strong></span> and 
then the underlined
accelerator key for the menu choice (for example, "A" for the 
<span class="guimenuitem">Actions</span>
dropdown menu).
</p><p>In a dropdown menu, you can use the up and down arrows
to navigate.  You could also just type the accelerator key for the menu
item, which is the character with the underscore.  For example, to initiate
a command to delete a container, type <span class="keycap"><strong>Alt</strong></span> + "A" + "D" + "C."</p><p>
<span class="keycap"><strong>Ctrl-S</strong></span> is a shortcut to initiate saving changes.  
<span class="keycap"><strong>Ctrl-Q</strong></span> is a shortcut to initiate quitting the EVMS GUI.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm427"></a>1.5.2. Accelerator keys in the selection window </h4></div></div></div><p>
A selection window typically contains a selection list, plus four to five
buttons below it.  Use the following keys to navigate in the selection window:

</p><div class="table"><a name="idm430"></a><p class="title"><b>Table 2.3. Accelerator keys in the selection window</b></p><div class="table-contents"><table class="table" summary="Accelerator keys in the selection window" border="1"><colgroup><col class="C1"><col class="C2"></colgroup><tbody><tr><td><span class="keycap"><strong>Tab</strong></span></td><td>Navigates (changes keyboard focus) between the list and the buttons.</td></tr><tr><td>Up and down arrows</td><td>Navigates within the selection list.</td></tr><tr><td><span class="keycap"><strong>Spacebar</strong></span></td><td>Selects and deselects items in the selection list.</td></tr><tr><td><span class="keycap"><strong>Enter</strong></span> on the button or type the accelerator character (if one exists)</td><td>Activates a button</td></tr></tbody></table></div></div><p><br class="table-break">

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm451"></a>1.5.3. Configuration options window accelerator keys</h4></div></div></div><p>
Use the following keys to navigate in the configuration options window:

</p><div class="table"><a name="idm454"></a><p class="title"><b>Table 2.4. Accelerator keys in the configuration options window</b></p><div class="table-contents"><table class="table" summary="Accelerator keys in the configuration options window" border="1"><colgroup><col class="C1"><col class="C2"></colgroup><tbody><tr><td><span class="keycap"><strong>Tab</strong></span></td><td>Cycles focus between fields and buttons</td></tr><tr><td>Left and right arrows</td><td>Navigate the folder tabs if the window has a widget notebook.</td></tr><tr><td><span class="keycap"><strong>Spacebar</strong></span> or the down arrow</td><td>Switches focus to a different notebook page.</td></tr><tr><td><span class="keycap"><strong>Enter</strong></span> or type the accelerator character (if one exists)</td><td>Activates a button</td></tr></tbody></table></div></div><p><br class="table-break">

</p><p>For widgets, use the following keys to navigate:

</p><div class="table"><a name="idm476"></a><p class="title"><b>Table 2.5. Widget navigation keys in the configuration options window </b></p><div class="table-contents"><table class="table" summary="Widget navigation keys in the configuration options window " border="1"><colgroup><col class="C1"><col class="C2"></colgroup><tbody><tr><td><span class="keycap"><strong>Tab</strong></span></td><td>Cycles forward through a set of widgets</td></tr><tr><td><span class="keycap"><strong>Shift-Tab</strong></span></td><td>Cycles backward through a set of widgets.</td></tr></tbody></table></div></div><p><br class="table-break">

</p><p>
The widget navigation, selection, and activation is the same in all dialog
windows.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NCURSES"></a>2. EVMS Ncurses interface</h2></div></div></div><p>The EVMS Ncurses (<span class="command"><strong>evmsn</strong></span>) user interface is a menu-driven
	interface with characteristics similar to those of the EVMS GUI. 
	Like the EVMS GUI,
	<span class="command"><strong>evmsn</strong></span> can accommodate new plug-ins and features without requiring any code
	changes.</p><p>The EVMS Ncurses user interface
	allows you to manage volumes on systems that do not have the X
	and GTK+ libraries that are required by the EVMS GUI.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="NCURSESOVER"></a>2.1. Navigating through EVMS Ncurses</h3></div></div></div><p>The EVMS Ncurses user interface initially
	     	displays a list of logical volumes similar to the
	     logical volumes view in the EVMS GUI.  Ncurses also provides
		a menu bar similar to the menu bar in the EVMS GUI.</p><p>A general guide to navigating through the layout of the
		Ncurses window is listed below:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="keycap"><strong>Tab</strong></span> cycles you through the available 
			views.</p></li><li class="listitem"><p>Status messages and tips are displayed on
			the last line of the screen.</p></li><li class="listitem"><p>Typing the accelerator character (the
			letter highlighted in red) for any menu item activates
			that item.  For example, typing <span class="keycap"><strong>A</strong></span> in any view brings
			down the <span class="guimenuitem">Actions</span> menu.</p></li><li class="listitem"><p>Typing <span class="keycap"><strong>A</strong></span> + <span class="keycap"><strong>Q</strong></span> in a view 
			quits the application.</p></li><li class="listitem"><p>Typing <span class="keycap"><strong>A</strong></span> + <span class="keycap"><strong>S</strong></span> in a view 
			saves changes
			made during an <span class="command"><strong>evmsn</strong></span> session.</p></li><li class="listitem"><p>Use the <span class="keycap"><strong>up</strong></span> and <span class="keycap"><strong>down</strong></span> 
			arrows to highlight an object in a view.  Pressing
			<span class="keycap"><strong>Enter</strong></span> while an object in a view is
			highlighted presents a context popup menu.</p></li><li class="listitem"><p>Dismiss a context popup menu by pressing
			<span class="keycap"><strong>Esc</strong></span> or by selecting a menu item with the
			<span class="keycap"><strong>up</strong></span> and <span class="keycap"><strong>down</strong></span> arrows and pressing 
			<span class="keycap"><strong>Enter</strong></span> to 
			activate the menu item.</p></li></ul></div><p>Dialog windows are similar in design to the EVMS GUI
dialogs, which allow a user to navigate forward and backward through a series
of dialogs using <span class="guibutton">Next</span> and <span class="guibutton">Previous</span>.  A general
guide to dialog windows is listed below:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="keycap"><strong>Tab</strong></span> cycles you through the available buttons.  Note
that some buttons might not be available until a valid selection is made.</p></li><li class="listitem"><p>The <span class="keycap"><strong>left</strong></span> and <span class="keycap"><strong>right</strong></span> arrows can also be used
to move to an available button.</p></li><li class="listitem"><p>Navigate a selection list with the <span class="keycap"><strong>up</strong></span> and 
<span class="keycap"><strong>down</strong></span> arrows.</p></li><li class="listitem"><p>Toggle the selection of an item in a list with <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Activate a button that has the current focus with <span class="keycap"><strong>Enter</strong></span>.  If the button has
an accelerator character (highlighted in red), you can also activate the button
by typing the accelerator character regardless of whether the button has the current
focus.</p></li></ul></div><p>The EVMS Ncurses user interface, like the EVMS GUI, provides context menus
for actions that are available only to the selected object in a view.  Ncurses also provides
context menus for items that are
available from the <span class="guimenuitem">Actions</span> menu.  These context menus present
a list of commands available for a certain object.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="NCURCHANGES"></a>2.2. Saving changes</h3></div></div></div><p>All changes you make while in the EVMS
		Ncurses are only in memory until you save the changes.
		In order to make the changes permanent, save
		all changes before exiting. If you
		forget to save the changes and decide to exit the EVMS Ncurses
		interface, you will be reminded of the unsaved changes and
		be given the chance to save or discard the changes before exiting.</p><p>To explicitly save all changes,  press <span class="keycap"><strong>A</strong></span> + <span class="keycap"><strong>S</strong></span> and confirm
		that you want to save changes.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="COMMANDLINE"></a>3. EVMS Command Line Interpreter</h2></div></div></div><p>The EVMS Command Line Interpreter (EVMS CLI) provides a
	command-driven user interface for EVMS. The EVMS CLI 
	helps automate volume management tasks
	and provides an interactive mode in situations where the
	EVMS GUI is not available.</p><p>Because the EVMS CLI is an interpreter, it operates
	differently than command line utilities for the
	operating system. The options you specify 
	on the EVMS CLI command line to invoke the EVMS 
	CLI control how the EVMS CLI operates. For example, the 
	command line options tell the CLI where to go for commands to 
	interpret and how
	often the EVMS CLI must save changes to disk. 
	When invoked, the EVMS CLI prompts for commands. </p><p>The volume management commands the EVMS CLI understands
	are specified in the <code class="filename">/usr/src/evms-2.2.0/engine2/ui/cli/grammar.ps</code> 
	file that accompanies the EVMS
	package.  These commands are described in detail in the EVMS
	man page, and help on these commands is available from within the EVMS
	CLI. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="CLITASKS"></a>3.1. Using the EVMS CLI</h3></div></div></div><p>Use the <span class="command"><strong>evms</strong></span> command to start
	  the EVMS CLI. If you do not enter an option with
	  <span class="command"><strong>evms</strong></span>, the EVMS CLI starts in
	  interactive mode. In interactive mode, the EVMS CLI prompts
	  you for commands. The result of each command is immediately saved
	  to disk. The EVMS CLI exits when you type <strong class="userinput"><code>exit</code></strong>. 
	You can modify this behavior by using
	  the following options with <span class="command"><strong>evms</strong></span>: 

	  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-b</span></dt><dd><p>This option indicates that you are running in
		batch mode and anytime there is a prompt for input from the user,
		the default value is accepted automatically.  This is the
		default behavior with the <span class="command"><strong>-f</strong></span> option.</p></dd><dt><span class="term">-c</span></dt><dd><p>This option saves changes to disk
		only when EVMS CLI exits, not after
		each command.</p></dd><dt><span class="term">-f <em class="replaceable"><code>filename</code></em></span></dt><dd><p>This option tells the EVMS CLI to use
		<em class="replaceable"><code>filename</code></em> as the source of
		commands. The EVMS CLI exits when it reaches the
		end of
		<em class="replaceable"><code>filename</code></em>.
		</p></dd><dt><span class="term">-p</span></dt><dd><p>This option only parses commands; it does
		not execute them.
		When combined with the <span class="command"><strong>-f</strong></span> option, the 
		<span class="command"><strong>-p</strong></span> option detects syntax errors in 
		command files. </p></dd><dt><span class="term">-h</span></dt><dd><p>This option displays help information
		for options used with the <span class="command"><strong>evms</strong></span>
		command.</p></dd><dt><span class="term">-rl</span></dt><dd><p>This option tells the CLI that all remaining items on the 
		command line are replacement parameters for use with 
		EVMS commands. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Replacement parameters are accessed in EVMS commands using the 
		<code class="option">$(x)</code> notation, where <em class="replaceable"><code>x</code></em> is the number identifying which 
		replacement parameter to use. Replacement parameters are assigned 
		numbers (starting with 1) as they are encountered on the command line. 
		Substitutions are not made within comments or quoted strings. </p><p>An example would be:</p><pre class="programlisting">evms -c -f testcase -rl sda sdb</pre><p>
		<code class="option">sda</code> is the replacement for <em class="replaceable"><code>parameter1</code></em> and 
		<code class="option">sdb</code> is the replacement for <em class="replaceable"><code>parameter2</code></em></p></div></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Information on less commonly used options is available 
		in the EVMS man page. </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="NOTECOMMAND"></a>3.2. Notes on commands and command files</h3></div></div></div><p>The EVMS CLI allows multiple commands to be displayed
		on a command line.  When you specify multiple commands on a
		single command line, separate the commands with
		a colon ( : ).  This is
		important for command files because the EVMS CLI sees
		a command file as a single long command line.  The
		EVMS CLI has no concept of lines in the file and
		ignores spaces. These features allow a command in
		a command file to span several lines and use whatever
		indentation or margins that are convenient. The only
		requirement is that the command separator (the colon) be present
		between commands.</p><p>The EVMS CLI ignores spaces unless they 
		occur within quote marks. Place in quotation marks a name that contains
		spaces or other non-printable or control characters.  If the name
		contains a quotation mark as part of the name, the
		quotation mark must be "doubled," as shown in the following 
		example:</p><pre class="programlisting">"This is a name containing ""embedded"" quote marks."</pre><p>EVMS CLI keywords are not case sensitive, but EVMS
		names are case sensitive. Sizes can be input in any units with a unit label, such as KB, MB, GB, or TB.</p><p>Finally, C programming language style comments
		are supported by the EVMS CLI.  Comments can begin and
		end anywhere except within a quoted string, as shown in the
		following example:</p><pre class="programlisting">/* This is a comment */
Create:Vo/*This is a silly place for a comment, but it is
allowed.*/lume,"lvm/Sample Container/My LVM
Volume",compatibility</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="debuglevels"></a>Chapter 3. The EVMS log file and error data collection</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#FSIMsupp">1. About the EVMS log file</a></span></dt><dt><span class="sect1"><a href="#loglevels">2. Log file logging levels</a></span></dt><dt><span class="sect1"><a href="#specifylevels">3. Specifying the logging levels</a></span></dt></dl></div><p>This chapter discusses the EVMS information and error log file and the various logging levels.  It also explains how to change the logging level.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="FSIMsupp"></a>1. About the EVMS log file</h2></div></div></div><p>The EVMS Engine creates a log file called <code class="filename">/var/log/evmsEngine.log</code> every time the Engine is opened.  The Engine also saves copies of up to nine previous Engine sessions in the files <code class="filename">/var/log/evmsEngine.n.log</code>, where <code class="filename">n</code> is the number of the session between 1 and 9.  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="loglevels"></a>2. Log file logging levels</h2></div></div></div><p>There are several possible logging levels that you can choose to be collected in <code class="filename">/var/log/evmsEngine.log</code>.  The "lowest" logging level, <code class="filename">critical</code>, collects only messages about serious system problems, whereas the "highest" level, <code class="filename">everything</code>, collects all logging related messages.  When you specify a particular logging level, the Engine collects messages for that level and all the levels below it.  </p><p>The following table lists the allowable log levels and the information they provide:</p><div class="table"><a name="idm645"></a><p class="title"><b>Table 3.1. EVMS logging levels</b></p><div class="table-contents"><table class="table" summary="EVMS logging levels" border="1"><colgroup><col class="C1"><col class="C2"></colgroup><thead><tr><th>Level name</th><th>Description</th></tr></thead><tbody><tr><td>Critical</td><td>The health of the system or the Engine is in jeopardy; for example, an operation has failed because there is not enough memory.</td></tr><tr><td>Serious</td><td>An operation did not succeed.</td></tr><tr><td>Error</td><td>The user has caused an error.  The error messages are provided to help the user correct the problem.</td></tr><tr><td>Warning</td><td>An error has occurred that the system might or might not be able to work around.</td></tr><tr><td>Default</td><td>An error has occurred that the system has already worked around.</td></tr><tr><td>Details</td><td>Detailed information about the system.</td></tr><tr><td>Entry_Exit</td><td>Traces the entries and exits of functions.</td></tr><tr><td>Debug</td><td>Information that helps the user debug a problem.</td></tr><tr><td>Extra</td><td>More information that helps the user debug a problem than the "Debug" level provides.</td></tr><tr><td>Everything</td><td>Verbose output.</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="specifylevels"></a>3. Specifying the logging levels</h2></div></div></div><p>By default, when any of the EVMS interfaces is opened, the Engine logs the <code class="filename">Default</code> level of messages into the <code class="filename">/var/log/evmsEngine.log</code> file.  However, if your system is having problems and you want to see more of what is happening, you can change the logging level to be higher; if you want fewer logging messages, you can change the logging level to be lower.  To change the logging level, specify the <span class="command"><strong>-d</strong></span> parameter and the log level on the interface open call.  The following examples show how to open the various interfaces with the highest logging level (<code class="filename">everything</code>):</p><pre class="programlisting">GUI:		evmsgui -d everything</pre><pre class="programlisting">Ncurses:	evmsn -d everything</pre><pre class="programlisting">CLI:		evms -d everything</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>If you use the EVMS mailing list for help with a problem, providing to us
the log file that is created when you open one of the interfaces (as shown 
in the previous commands) makes it easier for us to help you.
</p></div><p>The EVMS GUI lets you change the logging level during an Engine session.  To do so, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Settings</span> &#8594; <span class="guimenuitem">Log Level</span> &#8594; <span class="guimenuitem">Engine</span>.
	</p></li><li class="listitem"><p>Click the <span class="guibutton">Level</span> you want.
	</p></li></ol></div><p>The CLI command, <span class="command"><strong>probe</strong></span>, opens and closes the Engine, which causes a new log to start.  The log that existed before the <span class="command"><strong>probe</strong></span> command was issued is renamed <code class="filename">/var/log/evmsEngine.1.log</code> and the new log is named <code class="filename">/var/log/evmsEngine.log</code>.</p><p>
If you will be frequently using a different log level than the default,
you can specify the default logging level in 
<code class="filename">/etc/evms.conf</code> rather than
having to use the <span class="command"><strong>-d</strong></span> option when starting the user interface.
The "debug_level" option in the "engine" section sets the default
logging level for when the Engine is opened.  
Using the <span class="command"><strong>-d</strong></span> option
during the command invocation overrides the setting in
<code class="filename">/etc/evms.conf</code>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmsmigrate"></a>Chapter 4. Viewing compatibility volumes after migrating</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#guimigrate">1. Using the EVMS GUI</a></span></dt><dt><span class="sect1"><a href="#ncurmigrate">2. Using Ncurses</a></span></dt><dt><span class="sect1"><a href="#climigrate">3. Using the CLI</a></span></dt></dl></div><p>Migrating to EVMS allows you to have the flexibility of EVMS without losing the integrity of your existing data. EVMS discovers existing volume management volumes as compatibility volumes. After you have installed EVMS, you can view your existing volumes with the interface of your choice. </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="guimigrate"></a>1. Using the EVMS GUI</h2></div></div></div><p>If you are using the EVMS GUI as your preferred interface, you can view your migrated volumes by typing <span class="command"><strong>evmsgui</strong></span> at the command prompt. The following window opens, listing your migrated volumes. </p><div class="figure"><a name="idm726"></a><p class="title"><b>Figure 4.1. GUI start-up window</b></p><div class="figure-contents"><div class="mediaobject"><img src="gui_active.png" alt="GUI start-up window"></div></div></div><br class="figure-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ncurmigrate"></a>2. Using Ncurses</h2></div></div></div><p>If you are using the Ncurses interface, you can view your migrated volumes by 
	typing <span class="command"><strong>evmsn</strong></span> at the command prompt. The following window opens, listing your migrated volumes. </p><div class="figure"><a name="idm737"></a><p class="title"><b>Figure 4.2. Ncurses start-up window</b></p><div class="figure-contents"><div class="mediaobject"><img src="ncurses_active.png" alt="Ncurses start-up window"></div></div></div><br class="figure-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="climigrate"></a>3. Using the CLI</h2></div></div></div><p>If you are using the Command Line Interpreter (CLI) interface, you can view 
	your migrated volumes by following these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start the Command Line Interpreter by typing 
		<span class="command"><strong>evms</strong></span> at the command line.</p></li><li class="listitem"><p>Query the volumes by typing the following at the 
		<code class="prompt">EVMS</code> prompt:</p><pre class="programlisting">query:volumes</pre><p>Your migrated volumes are displayed as results of the 
		query. </p></li></ol></div><div class="figure"><a name="idm756"></a><p class="title"><b>Figure 4.3. CLI volume query results</b></p><div class="figure-contents"><div class="mediaobject"><img src="cli_active.png" alt="CLI volume query"></div></div></div><br class="figure-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="displaydetails"></a>Chapter 5. Obtaining interface display details</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#displaygui">1. Using the EVMS GUI</a></span></dt><dt><span class="sect1"><a href="#displaydatancurses">2. Using Ncurses</a></span></dt><dt><span class="sect1"><a href="#idm812">3. Using the CLI</a></span></dt></dl></div><p>The EVMS interfaces let you view more detailed information about an EVMS object than 
what is readily available from the main views of the EVMS user interfaces.  The type and extent
of additional information available is dependent on the interface you use.  For example, the
EVMS GUI provides more in-depth information than does the CLI.</p><p>The following sections show how to find detailed information on the region
<code class="filename">lvm/Sample Container/Sample Region</code>, which is part of
volume <code class="filename">/dev/evms/Sample Volume</code> (created in section 10.2).</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="displaygui"></a>1. Using the EVMS GUI</h2></div></div></div><p>With the EVMS GUI, it is only possible to display additional details on an object through
the Context Sensitive Menus, as shown in the following steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Looking at the <span class="guibutton">volumes view</span>, click the "+" next
to volume <code class="filename">/dev/evms/Sample Volume</code>.  Alternatively, look at the <span class="guimenu">regions</span> view.</p></li><li class="listitem"><p>Right click <code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Point at <span class="guibutton">Display Details...</span> and click.  A new window opens
with additional information about the selected region.</p></li><li class="listitem"><p>Click <span class="guimenu">More</span> by the <span class="guibutton">Logical Extents box</span>.  Another window opens that displays the mappings of logical extents to physical extents.</p></li></ol></div><p>


</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="displaydatancurses"></a>2. Using Ncurses</h2></div></div></div><p>Follow these steps to display additional details on an object with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Press
	<span class="keycap"><strong>Tab</strong></span> to reach the Storage Regions view.
	</p></li><li class="listitem"><p>Scroll down using the <span class="keycap"><strong>down</strong></span> arrow until
	 <code class="filename">lvm/Sample Container/Sample Region</code> is highlighted.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>In the context menu, scroll down using the <span class="keycap"><strong>down</strong></span> arrow 
	to highlight "Display Details..."
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span> to activate the menu item.
	</p></li><li class="listitem"><p>In the Detailed Information dialog, use the <span class="keycap"><strong>down</strong></span> arrow to
	highlight the "Logical Extents" item and then use <span class="keycap"><strong>spacebar</strong></span> to open
	another window that displays the mappings of logical extents to physical extents.
	</p></li></ol></div><p>
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm812"></a>3. Using the CLI</h2></div></div></div><p>Use the
	<span class="command"><strong>query</strong></span> command (abbreviated <span class="command"><strong>q</strong></span>) with filters to display details about EVMS objects.  There are two filters that are especially helpful for navigating
within the command line: <span class="command"><strong>list options</strong></span> (abbreviated <span class="command"><strong>lo</strong></span>) and <span class="command"><strong>extended info</strong></span> (abbreviated <span class="command"><strong>ei</strong></span>). </p><p>The <span class="command"><strong>list options</strong></span> command tells you what can currently be done and what options you
can specify.  To use this command, first build a traditional query command starting with the command name <span class="command"><strong>query</strong></span>, followed by a colon (<span class="command"><strong>:</strong></span>), and then the type of object you
want to query (for example, volumes, objects, plug-ins).  Then, you can use filters to narrow
the search to only the area you are interested in.  For example, to determine the acceptable
actions at the current time on <code class="filename">lvm/Sample Container/Sample Region</code>, enter the following command:</p><pre class="programlisting">query: regions, region="lvm/Sample Container/Sample Region", list options</pre><p>The <span class="command"><strong>extended info</strong></span> filter is the equivalent of Display Details in the EVMS GUI and Ncurses interfaces.  The command takes the following form: <span class="command"><strong>query</strong></span>, followed by a colon (<span class="command"><strong>:</strong></span>), the filter (<span class="command"><strong>extended info</strong></span>), a comma (<span class="command"><strong>,</strong></span>), and the object you want more information about.  The command returns a list containing the field names, titles, descriptions and values for each field defined for the object.  For example, to obtain details on <code class="filename">lvm/Sample Container/Sample Region</code>, enter the following command:</p><pre class="programlisting">query: extended info, "lvm/Sample Container/Sample Region"</pre><p>Many of  the field names that are returned by the <span class="command"><strong>extended info</strong></span> filter can be expanded
further by specifying the field name or names at the end of the command, separated
by commas.  For example, if you wanted additional information about logical extents, the query would look like the following:</p><pre class="programlisting">query: extended info, "lvm/Sample Container/Sample Region", Extents</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmsassignseg"></a>Chapter 6. Adding and removing a segment manager</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whenassign">1. When to add a segment manager</a></span></dt><dt><span class="sect1"><a href="#smtypes">2. Types of segment managers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#defaultseg">2.1. DOS Segment Manager</a></span></dt><dt><span class="sect2"><a href="#gptseg">2.2. GUID Partitioning Table (GPT) Segment Manager</a></span></dt><dt><span class="sect2"><a href="#s390sm">2.3. S/390 Segment Manager</a></span></dt><dt><span class="sect2"><a href="#idm884">2.4. Cluster segment manager</a></span></dt><dt><span class="sect2"><a href="#idm899">2.5. BSD segment manager</a></span></dt><dt><span class="sect2"><a href="#idm902">2.6. MAC segment manager</a></span></dt><dt><span class="sect2"><a href="#idm905">2.7. BBR segment manager</a></span></dt></dl></dd><dt><span class="sect1"><a href="#assignsegex">3. Adding a segment manager to an existing disk</a></span></dt><dt><span class="sect1"><a href="#assignsegnew">4. Adding a segment manager to a new disk</a></span></dt><dt><span class="sect1"><a href="#assignex">5. Example: add a segment manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#assignseggui">5.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#assignsegncur">5.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#assignsegcli">5.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#removeseg">6. Removing a segment manager</a></span></dt><dt><span class="sect1"><a href="#rmvex">7. Example: remove a segment manager</a></span></dt><dd><dl><dt><span class="sect2"><a href="#removeseggui">7.1. Using the EVMS GUI context sensitive menu</a></span></dt><dt><span class="sect2"><a href="#removesegcur">7.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#removesegcli">7.3. Using the CLI</a></span></dt></dl></dd></dl></div><p> This chapter discusses when to use a segment manager, what the different types of segment managers are, how to add a segment manager to a disk, and how to remove a
segment manager. </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whenassign"></a>1. When to add a segment manager</h2></div></div></div><p>Adding a segment manager to a disk allows the disk to be subdivided into 
	smaller storage objects called disk segments. The 
	<span class="command"><strong>add</strong></span> command causes a 
	segment manager to create appropriate metadata and expose freespace 
	that the segment manager  
	finds on the disk. You need to add segment managers when you 
	have a new disk or 
	when you are switching from one partitioning scheme to another. </p><p>EVMS displays disk segments as the following types: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Data: a set of contiguous sectors that has been allocated 
		from a disk and can be used to construct a volume or object.</p></li><li class="listitem"><p>Freespace: a set of contiguous sectors that are unallocated 
		or not in use. Freespace can be used to create a segment.</p></li><li class="listitem"><p>Metadata: a set of contiguous sectors that contain 
		information needed by the segment manager.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="smtypes"></a>2. Types of segment managers</h2></div></div></div><p>There are seven types of segment managers in EVMS: DOS, GPT, S/390, Cluster,  BSD, MAC, and BBR. </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="defaultseg"></a>2.1. DOS Segment Manager</h3></div></div></div><p>The most
		commonly used segment manager is the DOS Segment Manager. This plug-in
		provides support for traditional DOS disk partitioning. The 
		DOS Segment Manager also recognizes and supports the following variations 
		of the DOS partitioning scheme:
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>OS/2:  an OS/2 disk has additional metadata 
		sectors that contain information needed to reconstruct disk segments.</p></li><li class="listitem"><p>Embedded partitions: support for BSD, SolarisX86, and UnixWare  
			is sometimes found embedded in primary DOS partitions. 
			The DOS Segment Manager  recognizes and supports these 
			slices as disk segments.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="gptseg"></a>2.2. GUID Partitioning Table (GPT) Segment Manager</h3></div></div></div><p>The GUID Partitioning Table (GPT) Segment Manager handles the 
		new GPT partitioning scheme 
		on IA-64 machines. The Intel 
		<em class="citetitle">Extensible Firmware Interface Specification</em>
 		requires that firmware be able to discover partitions and produce logical devices that 
		correspond to disk partitions.  The partitioning scheme described in 
		the specification is called GPT due to the extensive use of 
		Globally Unique Identifier (GUID) tagging. GUID is a 128 bit long 
		identifier, also referred to as a Universally Unique Identifier (UUID).   
		As described in the Intel <em class="citetitle">Wired For Management Baseline Specification</em>,  
		a GUID is a combination of  time and space fields that produce an 
		identifier that is unique across an entire UUID space.  
		These identifiers are used extensively on GPT partitioned disks 
		for tagging entire disks and individual partitions. 
		GPT partitioned disks serve several functions, such as:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>keeping a primary and backup copy of metadata</p></li><li class="listitem"><p>replacing msdos partition nesting by allowing many partitions</p></li><li class="listitem"><p>using 64 bit logical block addressing</p></li><li class="listitem"><p>tagging partitions and disks with GUID descriptors</p></li></ul></div><p>The GPT Segment Manager scales better to large disks. It provides more redundancy with added reliability and uses unique names. However, the GPT Segment Manager is not compatible with DOS, OS/2, or Windows®. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="s390sm"></a>2.3. S/390 Segment Manager</h3></div></div></div><p>The S/390 Segment Manager is used exclusively on System/390 
		mainframes.  The S/390 Segment Manager has the ability to recognize 
		various disk layouts found on an S/390 machine, and provide 
		disk segment support for this architecture. The two most common disk 
		layouts are Linux Disk Layout (LDL) and Common Disk Layout (CDL). </p><p>The principle difference between LDL and CDL is that an LDL disk 
		cannot be further subdivided. An LDL disk will produce a single metadata 
		disk segment and a single data disk segment. There is no freespace on an 
		LDL disk, and you cannot delete or re-size the data segment. A CDL disk can 
		be subdivided into multiple data disk segments 
		because it contains metadata that is missing from an LDL disk, specifically 
		the Volume Table of Contents (vtoc) information.</p><p>The S/390 Segment  Manager is the only segment manager plug-in 
		capable of understanding the unique S/390 disk layouts. The S/390 Segment Manager 
		cannot be added or removed from a disk. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm884"></a>2.4. Cluster segment manager</h3></div></div></div><p>The cluster segment manager (CSM) supports high availability clusters.  When the
CSM is added to a shared storage disk, it writes metadata on the disk that:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>provides a unique disk ID (guid)</p></li><li class="listitem"><p>names the EVMS container the disk will reside within</p></li><li class="listitem"><p>specifies the cluster node (nodeid) that owns the disk</p></li><li class="listitem"><p>specifies the cluster (clusterid)</p></li></ul></div><p>This metadata allows the CSM to build containers for supporting failover situations.
It does so by constructing an EVMS container object that consumes all shared disks
discovered by the CSM and belonging to the same container.  These shared storage
disks are consumed by the container and a single data segment is produced by the
container for each consumed disk.  A failover of the EVMS resource is
accomplished by simply reassigning the CSM container to the standby cluster node and
having that node re-run its discovery process.</p><p>Adding disks to CSM containers implies that only disk storage objects are
acceptable to the CSM.  This is an important aspect of the CSM.  Other segment
managers can be embedded within storage objects and used to further subdivide them. 
However, the CSM cannot add any other kind of storage object to a CSM container
because the container is meant to be a disk group and the entire disk group is
reassigned during a failover.  So, the CSM only accepts disks when constructing
containers.  This is important to remember when adding the CSM to a disk.  If you
choose <span class="command"><strong>Add</strong></span> and the CSM does not appear in the list of selectable plug-ins when you know you have a disk, you should look at the Volume list and see if the disk has
already been listed as a compatibility volume.  If you simply delete the volume, the disk will
become an available object and the CSM will then appear in the list of plug-ins
because it now has an available disk that it can add to a container.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm899"></a>2.5. BSD segment manager</h3></div></div></div><p>BSD refers to the Berkeley Software Distribution UNIX® operating system.  The EVMS
BSD segment manager is responsible for recognizing and producing EVMS segment
storage objects that map BSD partitions.  A BSD disk may have a slice table in the
very first sector on the disk for compatibility purposes with other operating systems.
For example, a DOS slice table might be found in the usual MBR sector.  The BSD disk
would then be found within a disk slice that is located using the compatibility slice table.
However, BSD has no need for the slice table and can fully dedicate the disk to
itself by placing the disk label in the very first sector.  This is called a "fully dedicated
disk" because BSD uses the entire disk and does not provide a compatibility slice table.
The BSD segment manager recognizes such "fully dedicated disks" and provides mappings for
the BSD partitions.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm902"></a>2.6. MAC segment manager</h3></div></div></div><p>Apple-partitioned disks use a disk label that is recognized by the MAC segment
manager.  The MAC segment manager recognizes the disk label during discovery and 
creates EVMS
segments to map the MacOS disk partitions.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm905"></a>2.7. BBR segment manager</h3></div></div></div><p>The bad block replacement (BBR) segment manager enhances the reliability of
a disk by remapping bad storage blocks.  When BBR is added to a disk, it writes
metadata on the disk that:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>reserves replacement blocks</p></li><li class="listitem"><p>maps bad blocks to reserved blocks</p></li></ul></div><p>Bad blocks occur when an I/O error is detected for a write operation.
When this happens, I/O normally fails and the failure code is returned to the
calling program code.  BBR detects failed write operations and remaps the I/O to a
reserved block on the disk.  Afterward, BBR restarts the I/O using the reserve block.</p><p>Every block of storage has an address, called a logical block address, or LBA.
When BBR is added to a disk, it provides two critical functions: remap and recovery.
When an I/O operation is sent to disk, BBR inspects the LBA in the I/O command to see
if the LBA has been remapped to a reserve block due to some earlier I/O error.
If BBR finds a mapping between the LBA and a reserve block, it updates the I/O
command with the LBA of the reserve block before sending it on to the disk.
Recovery occurs when BBR detects an I/O error and remaps the bad block to a 
reserve block.  The new LBA mapping is saved in BBR metadata so that subsequent
I/O to the LBA can be remapped.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assignsegex"></a>3. Adding a segment manager to an existing disk</h2></div></div></div><p>When you add a segment manager to a disk, the segment manager 
	needs to change the basic 
	layout of the disk. This change means that some sectors are 
	reserved for metadata and the remaining sectors are
  made available for creating data disk segments. Metadata sectors 
	are written to disk to save information
	needed by the segment manager;  previous information found on the 
	disk is lost. Before adding a 
	segment manager to an existing disk, you must remove any existing 
	volume management structures, including any previous segment manager.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assignsegnew"></a>4. Adding a segment manager to a new disk</h2></div></div></div><p>When a new disk is added to a system,
	the disk usually contains no data and has not
	  been partitioned. If this is the case, the disk shows up in EVMS as a compatibility volume because 
	  EVMS cannot tell if the disk is being used as a volume. To add a segment manager to the disk so that it 
	can be subdivided into smaller disk segment objects, tell EVMS that the disk is not a
	compatibility volume by deleting the volume information.</p><p>If the new disk was moved from another system, chances are good that the disk already contains 
	metadata. If the disk does contain metadata, the disk shows up in EVMS with storage objects that 
	were produced from the existing metadata. Deleting these objects will allow you to add a different 
	segment manager to the disk, and you lose any old data. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assignex"></a>5. Example: add a segment manager</h2></div></div></div><p>This section shows how to add 
a segment manager with EVMS.</p><p>EVMS initially displays the
	physical disks it sees as volumes. Assume that you have added a new 
	disk to the system that EVMS 
	sees as <code class="filename">sde</code>. 
	This disk contains no data and has not been subdivided 
	(no partitions). EVMS assumes that this 
	disk is a compatibility volume known as <code class="filename">/dev/evms/sde</code>. </p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm929"></a><p class="title"><b>Example 6.1. Add the DOS Segment Manager</b></p><div class="example-contents"><p>Add the DOS Segment Manager to disk <code class="filename">sde</code>.</p></div></div><br class="example-break"></blockquote></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>In the following example, the DOS Segment
		Manager creates two segments on the disk:
		a metadata segment known as <code class="filename">sde_mbr</code>, and a
		segment to represent the available space on
		the drive, <code class="filename">sde_freespace1</code>. This freespace
		segment (<code class="filename">sde_freespace1</code>) can be 
		divided into
		other segments because it represents space on
		the drive that is not in use.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="assignseggui"></a>5.1. Using the EVMS GUI</h3></div></div></div><p>To add the DOS Segment Manager to <code class="filename">sde</code>, first 
remove the volume, <code class="filename">/dev/evms/sde</code>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Volume</span>.</p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/sde</code>.</p></li><li class="listitem"><p>Click <span class="guibutton">Delete</span>.</p></li></ol></div><p>Alternatively, you can remove the volume through the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes tab</span>, right click <code class="filename">/dev/evms/sde</code>.</p></li><li class="listitem"><p>Click <span class="guibutton">Delete</span>.</p></li></ol></div><p>After the volume is removed, add the DOS Segment Manager:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Add</span> &#8594; <span class="guimenuitem">Segment Manager to Storage Object</span>.</p></li><li class="listitem"><p>Select <span class="guilabel">DOS Segment Manager</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guilabel">sde</span></p></li><li class="listitem"><p>Click <span class="guibutton">Add</span></p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="assignsegncur"></a>5.2. Using Ncurses</h3></div></div></div><p>To add the DOS Segment Manager to <code class="filename">sde</code>, first remove the 
volume <code class="filename">/dev/evms/sde</code>:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Segment Manager to Storage Object</span>.</p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/sde</code>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Delete</span>.</p></li></ol></div><p>Alternatively, you can remove the volume through the context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Logical Volumes view, press <span class="keycap"><strong>Enter</strong></span> on 
<code class="filename">/dev/evms/sde</code>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Delete</span>.</p></li></ol></div><p>After the volume is removed, add the DOS Segment Manager:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Add</span> &#8594; <span class="guimenuitem">Segment Manager to Storage Object</span></p></li><li class="listitem"><p>Select <span class="guilabel">DOS Segment Manager</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guilabel">sde</span>.
</p></li><li class="listitem"><p>Activate <span class="guibutton">Add</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="assignsegcli"></a>5.3. Using the CLI</h3></div></div></div><p>To add the DOS Segment Manager to sde, first tell EVMS that this disk is not a 
volume and is available for use:</p><pre class="programlisting">Delete:/dev/evms/sde</pre><p>Next, add the DOS Segment Manager to sde by typing the following:</p><pre class="programlisting">Add:DosSegMgr={},sde</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removeseg"></a>6. Removing a segment manager</h2></div></div></div><p>When a segment manager is removed from a disk, the disk can be reused by
other plug-ins.  The <span class="command"><strong>remove</strong></span> command causes the segment manager to remove its
partition or slice table from the disk, leaving the raw disk storage object that then
becomes an available EVMS storage object.  As an available storage object,
the disk is free to be used by any plug-in when storage objects are created or expanded.
You can also add any of the segment managers to the available disk storage object
to subdivide the disk into segments.</p><p>Most segment manager plug-ins check to determine if any of the segments are still in
use by other plug-ins or are still part of volumes.  If a segment manager determines
that there are no disks from which it can safely remove itself, it will not be listed
when you use the <span class="command"><strong>remove</strong></span> command.  In this case, you should delete the
volume or storage object that is consuming segments from the disk you want to reuse.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rmvex"></a>7. Example: remove a segment manager</h2></div></div></div><p>This section shows how to remove 
a segment manager with EVMS.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1049"></a><p class="title"><b>Example 6.2. Remove the DOS Segment Manager</b></p><div class="example-contents"><p>Remove the DOS Segment Manager from disk <code class="filename">sda</code>.</p></div></div><br class="example-break"></blockquote></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>In the following example, the DOS Segment
		Manager has one primary partition on disk <code class="filename">sda</code>.
		The segment is a compatibility volume known as
		<code class="filename">/dev/evms/sda1</code>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="removeseggui"></a>7.1. Using the EVMS GUI context sensitive menu</h3></div></div></div><p>Follow these steps to remove a segment manager with the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click <code class="filename">/dev/evms/sda1</code>..</p></li><li class="listitem"><p>Click <span class="guibutton">Delete</span>.</p></li><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Remove</span> &#8594; <span class="guimenuitem">Segment Manager from Storage Object</span>.</p></li><li class="listitem"><p>Select <span class="guimenuitem">DOS Segment Manager, sda</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Remove</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="removesegcur"></a>7.2. Using Ncurses</h3></div></div></div><p>Follow these steps to remove a segment manager with the Ncurses interface:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Volume</span>.</p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/sda1</code>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Delete</span>.</p></li><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Remove</span> &#8594; <span class="guimenuitem">Segment Manager from Storage Object</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Remove</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="removesegcli"></a>7.3. Using the CLI</h3></div></div></div><p>Follow these steps to remove a segment manager with the CLI:</p><pre class="programlisting">Delete:/dev/evms/sda1</pre><pre class="programlisting">Remove: sda</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreateseg"></a>Chapter 7. Creating segments</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whyseg">1. When to create a segment</a></span></dt><dt><span class="sect1"><a href="#crsegex">2. Example: create a segment</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guiseg">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurseg">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#cliseg">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses when to use segments and how to create them using 
different EVMS interfaces.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whyseg"></a>1. When to create a segment</h2></div></div></div><p>A disk can be subdivided into smaller storage objects called disk segments. A segment manager plug-in provides this capability. Another reason for creating disk segments is to maintain compatibility on a dual boot system where the other operating system requires disk partitions. Before creating a disk segment, you must choose a segment manager plug-in to manage the disk and assign 
the segment manager to the disk. An explanation of when and how to assign segment managers can be found in <a class="xref" href="#evmsassignseg" title="Chapter 6. Adding and removing a segment manager">Chapter 6, <i>Adding and removing a segment manager</i></a>.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="crsegex"></a>2. Example: create a segment</h2></div></div></div><p> This section provides a detailed explanation of how to create a 
segment with EVMS by providing instructions to help you complete the following task:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1122"></a><p class="title"><b>Example 7.1. Create a 100MB segment</b></p><div class="example-contents"><p>Create a 100MB segment from the freespace segment sde_freespace1. This
	freespace segment lies on a drive controlled by the DOS Segment Manager. </p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guiseg"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>To create a segment using the GUI, follow the steps below:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Segment</span>
		to see a list of segment manager plug-ins.
		</p></li><li class="listitem"><p>Select
		<span class="guimenuitem">DOS Segment Manager</span>.
		Click <span class="guibutton">Next</span>.</p><p>The next dialog window lists
		the free space storage objects suitable for creating
		a new segment.</p></li><li class="listitem"><p>Select <code class="filename">sde_freespace1</code>. Click
		<span class="guibutton">Next</span>. </p><p>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</p></li><li class="listitem"><p>Enter 100 MB. Required fields are denoted by the
		"*" in front of the field description. The DOS Segment
		Manager provides default values, but you might want to change
		some of these values.</p><p>After you have filled in
		information for all the required
		fields, the <span class="guibutton">Create</span>
		button becomes available.</p></li><li class="listitem"><p>Click 
		<span class="guibutton">Create</span>.
		A window opens to display the
		outcome.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a segment from the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Segments</span> tab, right click 
on <code class="filename">sde_freespace1</code>.</p></li><li class="listitem"><p>Click <span class="guibutton">Create Segment...</span></p></li><li class="listitem"><p>Continue beginning with step 4 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncurseg"></a>2.2. Using Ncurses</h3></div></div></div><p>To create a segment using Ncurses, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Segment</span> to see a list of segment manager plug-ins.</p></li><li class="listitem"><p>Select <span class="guimenuitem">DOS Segment Manager</span>. 
	Activate <span class="guibutton">Next</span>.</p><p>The next dialog window
	lists free space
	storage objects suitable for creating
	a new segment. </p></li><li class="listitem"><p>Select <code class="filename">sde_freespace1</code>.  Activate <span class="keycap"><strong>Next</strong></span>.</p></li><li class="listitem"><p>Highlight the <span class="guilabel">size field</span> and press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>At the "::" prompt enter <strong class="userinput"><code>100MB</code></strong>. 
	Press <span class="keycap"><strong>Enter</strong></span>. </p></li><li class="listitem"><p>After all required values have been completed, the <span class="guibutton">Create</span>
	button becomes available.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a segment from the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Segments view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">sde_freespace1</code>.</p></li><li class="listitem"><p>Activate <span class="guimenuitem">Create Segment</span>.</p></li><li class="listitem"><p>Continue beginning with step 4 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cliseg"></a>2.3. Using the CLI</h3></div></div></div><p>To create a data segment from a
	freespace segment, use the
	<span class="command"><strong>Create</strong></span> command. The arguments the
	<span class="command"><strong>Create</strong></span> command accepts vary
	depending on what is being created.  The first
	argument to the <span class="command"><strong>Create</strong></span>
	command indicates what is to be created, which
	in the above example is a segment. The
	remaining arguments are the freespace segment
	to allocate from and a list of options to pass
	to the segment manager. The command to
	accomplish this is:</p><pre class="programlisting">Create: Segment,sde_freespace1, size=100MB</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>The <span class="command"><strong>Allocate</strong></span> command also works to create a segment. </p></div><p>The previous example accepts the default values for all options you don't specify. To see the options for this command type:</p><pre class="programlisting">query:plugins,plugin=DosSegMgr,list options</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreatecont"></a>Chapter 8. Creating a container </h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whencont">1. When to create a container</a></span></dt><dt><span class="sect1"><a href="#contex">2. Example: create a container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guicont">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurcont">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clicont">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses when and how to create a container. </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whencont"></a>1. When to create a container</h2></div></div></div><p>Segments and disks can be combined to form a container. Containers allow 
	you to combine
	storage objects and then subdivide those combined storage objects 
	into new storage objects. You can 
	combine storage objects to implement the volume group concept
	as found in the AIX and Linux logical volume managers.</p><p>Containers are the beginning of more flexible 
volume management. You might want to create a container in order to account for flexibility in your future storage needs. For example, you might 
need to add additional disks when your applications or users need more storage. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contex"></a>2. Example: create a container</h2></div></div></div><p>This section provides a detailed explanation of how to create a container with EVMS by providing instructions 
to help you complete the following task.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1231"></a><p class="title"><b>Example 8.1. Create "Sample Container"</b></p><div class="example-contents"><p>Given a system with three available disk drives 
(<code class="filename">sdc</code>, <code class="filename">sdd</code>, <code class="filename">hdc</code>),
 use the EVMS LVM Region Manager to combine these disk drives into a 
container called "Sample Container" with a PE size of 16 MB. </p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guicont"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>To create a container using the EVMS GUI, follow these steps:	
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span>
		to see a list plug-ins that support container creation.</p></li><li class="listitem"><p>Select the
		<span class="guimenu">LVM Region Manager</span>. Click
		<span class="guibutton">Next</span>.</p><p>The next dialog window contains a list of storage objects
		that the LVM Region Manager can use to create a container. </p></li><li class="listitem"><p>Select <span class="guilabel">sdc</span>, <span class="guilabel">sdd</span>, and 
		<span class="guilabel">hdc</span> from the list. Click
		<span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Enter the name <strong class="userinput"><code>Sample Container</code></strong> 
		for the container and <strong class="userinput"><code>16MB</code></strong> in the 
		<span class="guilabel">PE size</span> field.</p></li><li class="listitem"><p>Click
		<span class="guibutton">Create</span>.
		A window opens to display the
		outcome.</p></li></ol></div><p>
	</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncurcont"></a>2.2. Using Ncurses</h3></div></div></div><p>To create a container using the Ncurses interface, follow these 
steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span>
		to see a list of plug-ins that support container creation.</p></li><li class="listitem"><p>Select the
 		<span class="guimenuitem">LVM Region Manager</span>. Activate
 		<span class="keycap"><strong>Next</strong></span>. </p><p>The next dialog window contains a list
		of storage objects that the LVM Region Manager can use to
		create the container.</p></li><li class="listitem"><p>Select <span class="guilabel">sdc</span>, <span class="guilabel">sdd</span>, and 
		<span class="guilabel">hdc</span> from the list.  Activate
		<span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span> to select the field for
		the container name.	</p></li><li class="listitem"><p>Type <strong class="userinput"><code>Sample Container</code></strong> at the "::" prompt. Press
		<span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll down until <span class="guilabel">PE Size</span> is highlighted. 
		Press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Scroll down until <span class="guilabel">16MB</span> is highlighted. 
		Press  <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">OK</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="clicont"></a>2.3. Using the CLI</h3></div></div></div><p>The <span class="command"><strong>Create</strong></span> command 
	creates containers.  The first argument
	in the <span class="command"><strong>Create</strong></span> command is the type of object to
	produce, in this case a container.  The
	<span class="command"><strong>Create</strong></span> command then accepts
	the following arguments: the region manager to
	use along with any parameters it might need, and
	the segments or disks to create the container
	from. The command to complete the previous example is:</p><pre class="programlisting">Create:Container,LvmRegMgr={name="Sample Container",pe_size=16MB},sdc,sdd,hdc
</pre><p>The previous example accepts the default values for all options 
you don't specify. To see the options for this command type:
 </p><pre class="programlisting">query:plugins,plugin=LvmRegMgr,list options</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreatereg"></a>Chapter 9. Creating regions</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1320">1. When to create regions</a></span></dt><dt><span class="sect1"><a href="#crregex">2. Example: create a region</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guireg">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurreg">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clireg">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>Regions can be created from containers, but they can also be created from other
regions, segments, or disks.  Most region managers that support containers create one or more
freespace regions to represent the freespace within the container. This function is
analogous to the way a segment manager creates a freespace segment to represent unused disk
space.  </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1320"></a>1. When to create regions</h2></div></div></div><p>You can create regions because you want the features provided by 
a certain region manager or because you want the features provided by 
that region manager. You can also create regions to be compatible with 
other volume management technologies, such as MD or LVM. 
For example, if you wanted to make a volume that is compatible with Linux LVM, 
you would create a region out of a Linux LVM container and then a compatibility volume from that region.  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="crregex"></a>2. Example: create a region</h2></div></div></div><p>This section tells how to create a region with EVMS by 
providing instructions to help you complete the following task.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1327"></a><p class="title"><b>Example 9.1. Create "Sample Region"</b></p><div class="example-contents"><p>Given the container "Sample Container," which has a freespace region of 
8799 MB, create a data region 1000 MB in size named "Sample Region."</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guireg"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>To create a region, follow these steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Region</span>
</p></li><li class="listitem"><p>Select
		the <span class="guisubmenu">LVM Region
		Manager</span>. Click <span class="guibutton">Next</span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>You might
		see additional region managers that were
			not in the selection list when you were creating the storage container
			 because not all region
			managers are required to support containers.</p></div></li><li class="listitem"><p>Select the freespace region from
			the container you created in 
			<a class="xref" href="#evmscreatecont" title="Chapter 8. Creating a container">Chapter 8, <i>Creating a container </i></a>.
			Verify that the region is named  
			<code class="filename">lvm/Sample Container/Freespace</code>.
				Click <span class="guibutton">Next</span>.</p><p>The fields in the next window are the options for the
				LVM Region Manager plug-in, the options marked with an "*" are required. </p></li><li class="listitem"><p>Fill in the name, <strong class="userinput"><code>Sample Region</code></strong>.</p></li><li class="listitem"><p>Enter <strong class="userinput"><code>1000MB</code></strong> in the <span class="guilabel">size</span> field.</p></li><li class="listitem"><p>Click the
				<span class="guibutton">Create</span> button to complete the
				operation. A window opens to display the outcome.</p></li></ol></div><p>
		      </p><p>Alternatively, you can perform some of the steps for creating a region with the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Regions</span> tab, right click 
	<code class="filename">lvm/Sample Container/Freespace</code>.</p></li><li class="listitem"><p>Click <span class="guibutton">Create Region</span>.</p></li><li class="listitem"><p>Continue beginning with step 4 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncurreg"></a>2.2. Using Ncurses</h3></div></div></div><p>To create a region, follow these steps:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
				<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Region</span>.</p></li><li class="listitem"><p>Select the
				<span class="guimenuitem">LVM Region
				Manager</span>. Activate <span class="keycap"><strong>Next</strong></span>.</p></li><li class="listitem"><p>Select the freespace
				region from the container you created
				earlier in <a class="xref" href="#evmscreatecont" title="Chapter 8. Creating a container">Chapter 8, <i>Creating a container </i></a>. Verify that
				the region is named 
				<code class="filename">lvm/Sample Container/Freespace</code>.</p></li><li class="listitem"><p>Scroll to the <span class="guilabel">Name</span> field, and press 
				<span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>Sample Region</code></strong> at the "::" prompt. 
				Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll to the <span class="guilabel">size</span> field, 
				and press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>1000MB</code></strong> at the "::" prompt. 
				Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>
			</p><p>Alternatively, you can perform some of the steps for creating a region with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Storage Regions view, press <span class="keycap"><strong>Enter</strong></span> on
<code class="filename">lvm/Sample Container/Freespace</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Create Region</span> menu item.</p></li><li class="listitem"><p>Continue beginning with step 4 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="clireg"></a>2.3. Using the CLI</h3></div></div></div><p>Create regions with the <span class="command"><strong>Create</strong></span>
			command. Arguments to the <span class="command"><strong>Create </strong></span>command are
			the following: keyword Region, the name of the
			region manager to use, the region managers
			options, and the objects to consume. The form of this command is:</p><pre class="programlisting">Create:region, LvmRegMgr={name="Sample Region", size=1000MB},
"lvm/Sample Container/Freespace"</pre><p>The LVM Region Manager supports many
			options for creating regions. To see the
			available options for creating regions and
			containers, use the following <span class="command"><strong>Query</strong></span>:</p><pre class="programlisting">query:plugins,plugin=LvmRegMgr,list options</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreatedrivelinking"></a>Chapter 10. Creating drive links</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whatisdrivelinking">1. What is drive linking?</a></span></dt><dt><span class="sect1"><a href="#howimp">2. How drive linking is implemented</a></span></dt><dt><span class="sect1"><a href="#idm1453">3. Creating a drive link</a></span></dt><dt><span class="sect1"><a href="#drivelinkex">4. Example: create a drive link</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guidrivelinking">4.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncursdrivelink">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#drlinkseg">4.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#expandpartitions">5. Expanding a drive link</a></span></dt><dt><span class="sect1"><a href="#shrinkdrivelink">6. Shrinking a drive link</a></span></dt><dt><span class="sect1"><a href="#deletedrivelink">7. Deleting a drive link</a></span></dt></dl></div><p>This chapter discusses the EVMS drive linking feature, which is
implemented by the drive link plug-in, and tells how to create, expand, shrink,
and delete a drive link.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatisdrivelinking"></a>1. What is drive linking?</h2></div></div></div><p>Drive linking linearly concatenates objects, allowing you to
create larger storage objects and volumes from smaller individual pieces.
For example, say you need a 1 GB volume but do
not have contiguous space available of that length.  Drive linking lets you 
link two or more objects together to form the 1 GB volume.</p><p>
The types of objects that can be drive linked include disks, segments, 
regions, and other feature objects. 
</p><p>
Any resizing of an existing drive link, whether to grow it or shrink it,
must be coordinated with the appropriate file system operations.
EVMS handles these file system operations automatically.
</p><p> 
Because drive linking is an EVMS-specific feature that contains EVMS metadata, 
it is not backward compatible with other volume-management schemes.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="howimp"></a>2. How drive linking is implemented</h2></div></div></div><p>The drive link plug-in consumes storage objects, called link
objects, which produce a larger drive link object whose address space spans
the link objects.
The drive link plug-in knows how to assemble the link objects so as to 
create the exact same address space every time.
The information required to do this is kept on each link child as persistent
drive-link metadata.
During discovery, the drive link plug-in inspects each known storage
object for this metadata.
The presence of this metadata identifies the storage object as a link object.
The information contained in the metadata is sufficient to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Identify the link object itself.</p></li><li class="listitem"><p>Identify the drive link storage object that the link object belongs to.
</p></li><li class="listitem"><p>Identify all link objects belonging to the drive link storage.
object</p></li><li class="listitem"><p>Establish the order in which to combine the child link objects.</p></li></ul></div><p>If any link objects are missing at the conclusion of the discovery
process, the drive link storage object contains gaps where the missing
link objects occur.
In such cases, the drive link plug-in attempts to fill in the gap with a
substitute link object and construct the drive link storage object in
read-only mode, which allows for recovery action.
The missing object might reside on removable storage that has been removed or
perhaps a lower layer plug-in failed to produce the missing object.
Whatever the reason, a read-only drive link storage object, together
logging errors, help you take the appropriate actions to recover the drive link.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1453"></a>3. Creating a drive link</h2></div></div></div><p>The drive link plug-in provides a list of acceptable objects from
which it can create a drive-link object.
When you create an EVMS storage object and then choose the drive
link plug-in, a list of acceptable objects is provided that you can choose
from.
The ordering of the drive link is implied by the order in which you pick 
objects from the provided list.
After you provide a name for the new drive-link object, the identified
link objects are consumed and the new drive-link object is produced. 
The name for the new object is the only option when creating a drive-link.
</p><p>Only the last object in a drive link
can be expanded, shrunk or removed.  Additionally, a new object can be added to the
end of an existing drive link only if the file system (if one exists) permits.
Any resizing of a drive link, whether to grow it or shrink it, must be coordinated with the
appropriate file system operations.  EVMS handles these file system operations
automatically.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="drivelinkex"></a>4. Example: create a drive link</h2></div></div></div><p> This section shows how to create a drive link with EVMS:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1461"></a><p class="title"><b>Example 10.1. Create a drive link</b></p><div class="example-contents"><p>Create a new drive link consisting of <code class="filename">sde4</code> and <code class="filename">hdc2</code>, and call it "dl."</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guidrivelinking"></a>4.1. Using the EVMS GUI</h3></div></div></div><p>To create the drive link using the GUI, follow these steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Feature Object</span>
		to see a list of EVMS features.
		</p></li><li class="listitem"><p>Select
		<span class="guimenuitem">Drive Linking Feature</span>.
		</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Click the objects you want to compose the drive link: 
		sde4 and hdc2.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Type <code class="filename">dl</code> in the "name" field</p></li><li class="listitem"><p>Click
		<span class="guibutton">Create</span>. </p><p>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a drive link with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Available Objects</span> tab, 
	right click <code class="filename">sde4</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Create Feature Object...</span></p></li><li class="listitem"><p>Continue creating the drive link beginning with step 2 of the GUI
	instructions.  In step 4, <code class="filename">sde4</code> is selected for you.  You can also
	select <code class="filename">hdc2</code>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncursdrivelink"></a>4.2. Using Ncurses</h3></div></div></div><p>To create the drive link, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Feature Object</span> to see a list of EVMS features.</p></li><li class="listitem"><p>Select <span class="guimenuitem">Drive Linking Feature</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Use <span class="keycap"><strong>spacebar</strong></span> 
			 to select the objects you want to compose the drive
				link from: <code class="filename">sde4</code> and <code class="filename">hdc2</code>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Press 
				<span class="keycap"><strong>spacebar</strong></span> to edit the Name field.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>dl</code></strong> at the "::" prompt. 
				Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a drive link with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Available Objects view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">sde4</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Create Feature Object</span> menu item.</p></li><li class="listitem"><p>Continue creating the drive link beginning with step 4 of the Ncurses
instructions.  <code class="filename">sde4</code> will be pre-selected.  You can also select <code class="filename">hdc2</code>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="drlinkseg"></a>4.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>create</strong></span> command to create a drive link through the CLI.  You pass the "object" keyword to the <span class="command"><strong>create</strong></span> command, followed by the plug-in and its options, and finally the objects.</p><p>To determine the options for the plug-in you are going to use, issue the following command:</p><pre class="programlisting">query: plugins, plugin=DriveLink, list options</pre><p>Now construct the <span class="command"><strong>create</strong></span> command, as follows:</p><pre class="programlisting">create: object, DriveLink={Name=dl}, sde4, hdc2</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandpartitions"></a>5. Expanding a drive link</h2></div></div></div><p>
A drive link is an aggregating storage object that is built by combining a number of
storage objects into a larger resulting object.  A drive link consumes link objects in order
to produce a larger storage object.  The ordering of the link objects as well as the
number of sectors they each contribute is described by drive link metadata.  The metadata
allows the drive link plug-in to recreate the drive link, spanning the link objects in a
consistent manner.  Allowing any of these link objects to expand would corrupt the
size and ordering of link objects; the ordering of link objects is vital to the correct
operation of the drive link.  However, expanding a drive link can be controlled by only
allowing sectors to be added at the end of the drive link storage object.  This does not
disturb the ordering of link objects in any manner and, because sectors are only added
at the end of the drive link, existing sectors have the same address (logical sector
number) as before the expansion.  Therefore, a drive link can be expanded by adding
additional sectors in two different ways:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
By adding an additional storage object to the end of the drive link.
</p></li><li class="listitem"><p>
By expanding the last storage object in the drive link.
</p></li></ul></div><p>
If the expansion point is the drive link storage object, you can perform the
expansion by adding an additional storage object to the drive link.  This is done
by choosing from a list of acceptable objects during the expand operation. Multiple objects 
can be selected and added to the drive link.
</p><p>
If the expansion point is the last storage object in the drive link, then you expand the
drive link by interacting with the plug-in that produced the object.  For example, if
the link was a segment, then the segment manager plug-in that produced the storage
object expands the link object.  Afterwords, the drive link plug-in notices the size
difference and updates the drive link metadata to reflect the resize of the child object.</p><p>
There are no expand options.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shrinkdrivelink"></a>6. Shrinking a drive link</h2></div></div></div><p>
Shrinking a drive link has the same restrictions as expanding a drive link.  A drive link
object can only be shrunk by removing sectors from the end of the drive link.  This can
be done in the following ways:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>By removing link objects from the end of the drive link.</p></li><li class="listitem"><p>By shrinking the last storage object in the drive link.</p></li></ul></div><p>
</p><p>
The drive link plug-in attempts to orchestrate the shrinking of a 
drive-link storage object by only listing the last link object.
If you select this object, the drive link plug-in then lists the next-to-last 
link object, and so forth, moving backward through the link
objects to satisfy the shrink command.
</p><p>If the shrink point is the last storage object in the drive link, then you shrink the
drive link by interacting with the plug-in that produced the object.</p><p>
There are no shrink options.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deletedrivelink"></a>7. Deleting a drive link</h2></div></div></div><p>
A drive link can be deleted as long as it is not currently a
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
</p><p>
No options are available for deleting a drive link storage object.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreatesnap"></a>Chapter 11. Creating snapshots</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whatissnapshotting">1. What is a snapshot?</a></span></dt><dt><span class="sect1"><a href="#createactivsnap">2. Creating snapshot objects</a></span></dt><dt><span class="sect1"><a href="#snapshotex">3. Example: create a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guisnapshot">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncursnapshot">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clisnapshot">3.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1717">4. Reinitializing a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1723">4.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1765">4.2. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1775">5. Expanding a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1784">5.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1835">5.2. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1843">6. Deleting a snapshot</a></span></dt><dt><span class="sect1"><a href="#idm1847">7. Rolling back a snapshot</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1859">7.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1900">7.2. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses snapshotting and tells how to create 
a snapshot.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatissnapshotting"></a>1. What is a snapshot?</h2></div></div></div><p>A snapshot represents a frozen image of a volume.  
The source of a snapshot is
called an "original."  
When a snapshot is created, it looks exactly like the original
at that point in time.  
As changes are made to the original, the snapshot remains the
same and looks exactly like the original at the time the snapshot was 
created.
</p><p>
Snapshotting allows you to keep a volume online while a backup is created.
This method is much more convenient than a data backup where a volume
must be taken offline to perform a consistent backup.
When snapshotting, a snapshot of the volume is created and the backup
is taken from the snapshot, while the original remains in active use.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createactivsnap"></a>2. Creating snapshot objects</h2></div></div></div><p>You can create a snapshot object from any unused storage object in EVMS
(disks, segments, regions, or feature objects).  
The size of this consumed object is
the size available to the snapshot object.  The snapshot object can be smaller
or larger than the original volume.  
If the object is smaller, the snapshot volume could fill up as data is copied
from the original to the snapshot, given sufficient activity on the original. 
In this situation, the snapshot is deactivated and additional 
I/O to the snapshot fails.
</p><p>Base the size of the snapshot object on the amount of activity that 
is likely to take place on the original during the lifetime of the snapshot.  
The more changes that occur on the
original and the longer the snapshot is expected to remain active, 
the larger the snapshot object should be.  
Clearly, determining this calculation is not simple and requires trial and 
error to determine the correct snapshot object size to use for a 
particular situation.  
The goal is to create a snapshot object large enough to prevent the 
shapshot from being
deactivated if it fills up, yet small enough to not waste disk space.  
If the snapshot
object is the same size as the original volume, or a little larger, 
to account for the snapshot mapping tables, the snapshot is 
never deactivated.
</p><p>After you've created the snapshot object and saved the changes, the
snapshot will be activated (as long as the snapshot child object is already active).
This is a change from snapshots in EVMS 2.3.x and earlier, where the snapshot
would not be activated until the object was made into an EVMS volume.  If you
wish to have an inactive snapshot, please add the name of the snapshot object
to the "activate.exclude" line in the EVMS configuration file (see section about
selective-activation for more details).  If at any point you decide to deactivate a
snapshot object while the original volume is still active, the snapshot will be reset.
The next time that the snapshot object is activated, it will reflect the state of the
original volume at that point in time, just as if the snapshot had just been created.</p><p>In order to mount the snapshot, the snapshot object must still be made into an
EVMS volume.  The name of this volume can be the same as or different than the
name of the snapshot object.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="snapshotex"></a>3. Example: create a snapshot</h2></div></div></div><p> This section shows how to create a snapshot with EVMS:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1607"></a><p class="title"><b>Example 11.1. Create a snapshot of a volume</b></p><div class="example-contents"><p>Create a new snapshot of <code class="filename">/dev/evms/vol</code> on 
<code class="filename">lvm/Sample Container/Sample Region</code>, and call 
it "snap."</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guisnapshot"></a>3.1. Using the EVMS GUI</h3></div></div></div><p>To create the snapshot using the GUI, follow these steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Feature Object</span>
		to see a list of EVMS feature objects.
		</p></li><li class="listitem"><p>Select
		<span class="guimenuitem">Snapshot Feature</span>.
		</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guimenuitem">lvm/Sample Container/Sample Region</span>. 			</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guimenuitem">/dev/evms/vol</span> from the list in the
		"Volume to be Snapshotted" field.</p></li><li class="listitem"><p>Type <code class="filename">snap</code> in the "Snapshot Object Name" field.
		</p></li><li class="listitem"><p>Click <span class="guibutton">Create</span>.
		</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a snapshot with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Available Objects</span> tab, right click
	<span class="guimenuitem">lvm/Sample Container/Sample Region</span>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Create Feature Object...</span></p></li><li class="listitem"><p>Continue creating the snapshot beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncursnapshot"></a>3.2. Using Ncurses</h3></div></div></div><p>To create the snapshot, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Feature Object</span>
			to see a list of EVMS feature objects.</p></li><li class="listitem"><p>Select <span class="guimenuitem">Snapshot Feature</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <code class="filename">lvm/Sample Container/Sample Region.</code></p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Press 
				<span class="keycap"><strong>spacebar</strong></span> to edit the "Volume to be Snapshotted" field.</p></li><li class="listitem"><p>Highlight <code class="filename">/dev/evms/vol</code> and press <span class="keycap"><strong>spacebar</strong></span> to select.</p></li><li class="listitem"><p>Activate <span class="guibutton">OK</span>.</p></li><li class="listitem"><p>Highlight "Snapshot Object Name" and press <span class="keycap"><strong>spacebar</strong></span> to edit.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>snap</code></strong> at the "::" prompt. 
				Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a snapshot with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Available Objects view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Create Feature Object</span> menu item.</p></li><li class="listitem"><p>Continue creating the snapshot beginning with step 6 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="clisnapshot"></a>3.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>create</strong></span> command to create a snapshot through the CLI.  You pass the "Object" keyword to the <span class="command"><strong>create</strong></span> command, followed by the plug-in and its options, and finally the objects. </p><p>To determine the options for the plug-in you are going to use, issue the following command:</p><pre class="programlisting">query: plugins, plugin=Snapshot, list options</pre><p>Now construct the <span class="command"><strong>create</strong></span> command, as follows:</p><pre class="programlisting">create: object, Snapshot={original=/dev/evms/vol, snapshot=snap}, 
"lvm/Sample Container/Sample Region"</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1717"></a>4. Reinitializing a snapshot</h2></div></div></div><p>Snapshots can be reinitialized. Reinitializing causes all of the 
saved data to be erased and
starts the snapshot from the current point in time.  
A reinitialized snapshot has the same
original, chunk size, and writeable flags as the original 
snapshot.</p><p>To reinitialize a snapshot, use the <span class="command"><strong>Reset</strong></span> 
command on the snapshot object
(not the snapshot volume).  
This command reinitializes the snapshot without requiring you to
manually deactivate and reactivate the volume.
The snapshot must be active but unmounted for it to be reinitialized.
</p><p>This section continues the example from the previous section, 
where a snapshot object and volume were created.  
The snapshot object is called "snap" and the volume
is called "/dev/evms/snap."</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1723"></a>4.1. Using the EVMS GUI or Ncurses</h3></div></div></div><p>To reinitialize a snapshot, follow these steps:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Storage Object Tasks</span>
		</p></li><li class="listitem"><p>Select the volume "snap."</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guibutton">Reset</span>.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Reset</span> on the action panel.
		</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Reset</span> on the warning panel.</p></li></ol></div><p>

</p><p>Alternatively, you can perform these same steps with the context sensitive menus:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Feature Objects panel, right click (or press <span class="keycap"><strong>Enter</strong></span> on) 
the object <span class="guimenuitem">snap</span>.
</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Reset</span> on the popup menu.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Reset</span> on the action panel.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Reset</span> on the warning panel.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1765"></a>4.2. Using the CLI</h3></div></div></div><p>Follow these steps to reinitialize a snapshot with the CLI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Issue the following command to the CLI:</p><pre class="programlisting">task:reset,snap</pre></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span> to select "Reset" (the default choice) at the warning message.</p></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1775"></a>5. Expanding a snapshot</h2></div></div></div><p>
As mentioned in <a class="xref" href="#createactivsnap" title="2. Creating snapshot objects">Section 2, &#8220;Creating snapshot objects&#8221;</a>, as data is 
copied from the original volume to the snapshot, the space available
for the snapshot might fill up, causing the snapshot to be invalidated.
This situation might cause your data backup to end prematurely, as the
snapshot volume begins returning I/O errors after it is invalidated.
</p><p>
To solve this problem, EVMS now has the ability to expand the storage
space for a snapshot object while the snapshot volume is active and mounted.
This feature allows you to initially create a small snapshot object and expand
the object as necessary as the space begins to fill up.
</p><p>
In order to expand the snapshot object, the underlying object must
be expandable.
Continuing the example from the previous sections, the object "snap" is
built on the LVM region <code class="filename">lvm/Sample Container/Sample Region</code>.
When we refer to expanding the "snap" object, the region
<code class="filename">lvm/Sample Container/Sample Region</code> is the 
object that actually gets
expanded, and the object "snap" simply makes use of the new space on
that region.
Thus, to have expandable snapshots, you will usually want to build
your snapshot objects on top of LVM regions that have extra freespace
available in their LVM container.  DriveLink objects and some disk
segments also work in certain situations.
</p><p>
One notable quirk about expanding snapshots is that the snapshot
object and volume do not actually appear to expand after the operation
is complete.
Because the snapshot volume is supposed to be a frozen image of the original
volume, the snapshot volume always has the same size as the original,
even if the snapshot has been expanded.
However, you can verify that the snapshot object is using the
additional space by displaying the details for the snapshot object
and comparing the percent-full field before and after the expand operation.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1784"></a>5.1. Using the EVMS GUI or Ncurses</h3></div></div></div><p>To create the snapshot using the GUI or Ncurses, follow these steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Expand</span> &#8594; <span class="guimenuitem">Volume</span>
		to see a list of EVMS feature objects.
		</p></li><li class="listitem"><p>Select the volume <span class="guimenuitem">/dev/evms/snap</span>.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guimenuitem">lvm/Sample Container/Sample Region</span>.
		This object is the object that will actually be expanded.	</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the options for expanding the LVM region,
		including the amount of extra space to add to the region.
		</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Expand</span>.
		</p></li></ol></div><p>Alternatively, you can perform the same steps using the context sensitive menus.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guilabel">Volumes</span> panel, right click (or press <span class="keycap"><strong>Enter</strong></span> on) 
<span class="guimenuitem">/dev/evms/snap</span>.
</p></li><li class="listitem"><p>Select <span class="guibutton">Expand</span> from the popup menu.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the region <span class="guimenuitem">lvm/Sample Container/Sample Region</span>. This is the object that will
actually be expanded.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the options for expanding the LVM region, including the
amount of extra space to add to the region.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Expand</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1835"></a>5.2. Using the CLI</h3></div></div></div><p>The CLI expands volumes by targeting the object to be
expanded.
The CLI automatically handles expanding the volume and other objects above the volume
in the volume stock.  As with a regular expand operation, the options are determined
by the plug-in that owns the object being expanded.</p><p>Issue the following command to determine the expand options for the
region <code class="filename">lvm/Sample Container/Sample Region</code>:</p><pre class="programlisting">query:region,region="lvm/Sample Container/Sample Region",lo</pre><p>The option to use for expanding this region is called "add_size."
Issue the following command to expand the snapshot by 100 MB:</p><pre class="programlisting">expand:"lvm/Sample Container/Sample Region", add_size=100MB</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1843"></a>6. Deleting a snapshot</h2></div></div></div><p>When a snapshot is no longer needed, you can remove it by deleting the EVMS
volume from the snapshot object, and then deleting the snapshot object.  Because the
snapshot saved the initial state of the original volume (and not the changed state),
the original is always up-to-date and does not need any modifications when a snapshot
is deleted.</p><p>No options are available for deleting snapshots.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1847"></a>7. Rolling back a snapshot</h2></div></div></div><p>Situations can arise where a user wants to restore the original volume to
the saved state of the snapshot.  This action is called a rollback.  One such scenario
is if the data on the original is lost or corrupted.  Snapshot rollback acts as a quick
backup and restore mechanism, and allows the user to avoid a more lengthy restore
operation from tapes or other archives.</p><p>Another situation where rollback can be particularly useful is when you are
testing new software.  Before you install a new software package, create a writeable
snapshot of the target volume.  You can then install the software to the snapshot
volume, instead of to the original, and then test and verify the new software on the
snapshot.  If the testing is successful, you can then roll back the snapshot to the
original and effectively install the software on the regular system.  If there is a problem
during the testing, you can simply delete the snapshot without harming the original
volume.</p><p>You can perform a rollback when the following conditions are met:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Both the snapshot and the original volumes
are unmounted and otherwise not in use.  
</p></li><li class="listitem"><p>
There is only a single snapshot of an original.</p><p>
If an original has multiple snapshots,
all but the desired snapshot must be deleted before rollback can take place.
</p></li></ul></div><p>No options are available for rolling back snapshots.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1859"></a>7.1. Using the EVMS GUI or Ncurses</h3></div></div></div><p>Follow these steps to roll back a snapshot with the EVMS GUI or Ncurses:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Storage Object Tasks</span>.</p></li><li class="listitem"><p>Select the object "snap."</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <span class="guibutton">Rollback</span>.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Rollback</span> on the action panel.
</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Rollback</span> on the warning panel.
</p></li></ol></div><p>Alternatively, you can perform these same steps with the context-sensitive menus:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Feature Objects panel, right click (or press 
<span class="keycap"><strong>Enter</strong></span> on) the object "snap."</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Rollback</span> on the popup menu.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Rollback</span> on the action panel.</p></li><li class="listitem"><p>Click or activate <span class="guibutton">Rollback</span> on the warning panel.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1900"></a>7.2. Using the CLI</h3></div></div></div><p>Follow these steps to roll back a snapshot with the CLI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Issue the following command to the CLI:</p><pre class="programlisting">task:rollback,snap</pre></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span> to select "Rollback" (the default choice) at the warning message.</p></li></ol></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmscreatevol"></a>Chapter 12. Creating volumes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1913">1. When to create a volume</a></span></dt><dt><span class="sect1"><a href="#crvolexcomp">2. Example: create an EVMS native volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#evmsguivol">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#ncurevmsvol">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm1987">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#crvolexevms">3. Example: create a compatibility volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guicompvol">3.1. Using the GUI</a></span></dt><dt><span class="sect2"><a href="#ncurcompatvol">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2064">3.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses when and how to create volumes.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1913"></a>1. When to create a volume</h2></div></div></div><p>EVMS treats volumes and storage objects separately. 
A storage object does not automatically 
become a volume; it must be made into a volume.</p><p>Volumes are created from storage objects.
	Volumes are either EVMS native volumes or compatibility volumes.  Compatibility volumes
	are intended to be compatible with a volume manager other than EVMS, such as the Linux
	LVM, MD, OS/2 or AIX. Compatibility volumes might have restrictions on what EVMS can do with
	them.  EVMS native volumes have no such restrictions, but they can be used only by an
	EVMS equipped system. Volumes are mountable and can contain file systems.</p><p>EVMS native volumes contain EVMS-specific information to identify
	the volume name.  After this volume information is
	applied, the volume is no longer fully backward compatible
	with existing volume types.</p><p>Instead of
	adding EVMS metadata to an existing object, you can tell EVMS to make an object directly available as a volume. This type of
	volume is known as a compatibility volume. Using this method, the final product is fully
	backward-compatible with the desired system. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="crvolexcomp"></a>2. Example: create an EVMS native volume</h2></div></div></div><p>This section provides a detailed explanation of how to create an EVMS native
	volume with EVMS by providing instructions to help you complete the following task.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm1923"></a><p class="title"><b>Example 12.1. Create an EVMS native volume </b></p><div class="example-contents"><p>Create an EVMS native volume called "Sample Volume" from the region, <code class="filename">/lvm/Sample Container/Region</code>, you created in <a class="xref" href="#evmscreatereg" title="Chapter 9. Creating regions">Chapter 9, <i>Creating regions</i></a>.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="evmsguivol"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these instructions to create an EVMS volume:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">EVMS Volume</span>.</p></li><li class="listitem"><p>Choose <code class="filename">lvm/Sample Container/Sample Region</code>.
			</p></li><li class="listitem"><p>Type <strong class="userinput"><code>Sample Volume</code></strong> in the 
			<span class="guilabel">name field</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Create</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create an EVMS
volume from the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Available Options</span> tab, right click
	<code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Create EVMS Volume...</span></p></li><li class="listitem"><p>Continue beginning with step 3 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncurevmsvol"></a>2.2. Using Ncurses</h3></div></div></div><p>To create a volume, follow these steps:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">EVMS Volume</span>.</p></li><li class="listitem"><p>Enter <strong class="userinput"><code>Sample Volume</code></strong> at the "name" prompt. 
		Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>
   	</p><p>Alternatively, you can perform some of the steps to create an EVMS volume
from the context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Available Objects view, press <span class="keycap"><strong>Enter</strong></span> on 
<code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Create EVMS Volume</span> menu item.</p></li><li class="listitem"><p>Continue beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1987"></a>2.3. Using the CLI</h3></div></div></div><p>To create a volume, use the <span class="command"><strong>Create</strong></span> command. The arguments 
		the <span class="command"><strong>Create</strong></span> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <code class="option">volume</code> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <code class="option">lvm/Sample Container/Sample Region</code>. 
		The third argument is type specific for an EVMS 
		volume, <code class="option">Name=</code>, followed by what 
		you want to call the volume, in this case <code class="option">Sample Volume</code>. The following command 
		creates the volume from the example. </p><pre class="programlisting">Create: Volume, "lvm/Sample Container/Sample Region", Name="Sample Volume"</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="crvolexevms"></a>3. Example: create a compatibility volume</h2></div></div></div><p>This section provides a detailed explanation of how to create a compatibility 
	volume with EVMS by providing instructions to help you complete the following task.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2001"></a><p class="title"><b>Example 12.2. Create a compatibility volume</b></p><div class="example-contents"><p>Create a compatibility volume called "Sample Volume" from 
	the region, <code class="filename">/lvm/Sample Container/Region</code>, you created in <a class="xref" href="#evmscreatereg" title="Chapter 9. Creating regions">Chapter 9, <i>Creating regions</i></a>.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guicompvol"></a>3.1. Using the GUI</h3></div></div></div><p>To create a compatibility volume, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select 
			<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Compatibility Volume</span>.
			</p></li><li class="listitem"><p>Choose the region <code class="filename">lvm/Sample Container/Sample Region</code> 
			from the list.</p></li><li class="listitem"><p>Click the <span class="guibutton">Create</span> button.</p></li><li class="listitem"><p>Click the <span class="guilabel">Volume</span> tab in the GUI to
			see a volume named <code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code>. 
			This volume is your compatibility volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a compatibility volume from
the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Available Objects</span> tab, right click
	<code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Create Compatibility Volume...</span></p></li><li class="listitem"><p>Continue beginning with step 3 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncurcompatvol"></a>3.2. Using Ncurses</h3></div></div></div><p>To create a compatibility volume, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Compatibility Volume</span>.</p></li><li class="listitem"><p>Choose the region <code class="filename">lvm/Sample Container/Storage Region</code> from the list.. 
			</p></li><li class="listitem"><p>Activate <span class="guibutton">Create</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a compatibility volume from
the context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Available Objects view, press <span class="keycap"><strong>Enter</strong></span> on 
<code class="filename">lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Create Compatibility Volume</span> menu item.</p></li><li class="listitem"><p>Continue beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2064"></a>3.3. Using the CLI</h3></div></div></div><p>To create a volume, use the <span class="command"><strong>Create</strong></span> command. The arguments 
		the <span class="command"><strong>Create</strong></span> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <code class="option">volume</code> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <code class="option">lvm/Sample Container/Sample Region</code>. 
		The third argument, <code class="option">compatibility</code>, indicates that this is a compatibility 
		volume and should be named as such. </p><pre class="programlisting">Create:Volume,"lvm/Sample Container/Sample Region",compatibility</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmsfsimops"></a>Chapter 13. FSIMs and file system operations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#FSIMsuppevms">1. The FSIMs supported by EVMS</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fsimjfs">1.1. JFS</a></span></dt><dt><span class="sect2"><a href="#fsimxfs">1.2. XFS</a></span></dt><dt><span class="sect2"><a href="#fsimreiserfs">1.3. ReiserFS</a></span></dt><dt><span class="sect2"><a href="#fsimext23">1.4. Ext2/3</a></span></dt><dt><span class="sect2"><a href="#fsimswapfs">1.5. SWAPFS</a></span></dt><dt><span class="sect2"><a href="#fsimopengfs">1.6. OpenGFS</a></span></dt><dt><span class="sect2"><a href="#fsimntfs">1.7. NTFS</a></span></dt></dl></dd><dt><span class="sect1"><a href="#fsimmkfs">2. Example: add a file system to a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#fsimmkfsgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#fsimmkfsncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#fsimmkfscli">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#fsimmkfsaex">3. Example: check a file system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#FSIMmkfsgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#fsimfsckncurses">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#FSIMmkfscli">3.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses the seven File System Interface Modules (FSIMs) shipped with EVMS, and then provides examples of adding file systems and coordinating file system checks with the FSIMs.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="FSIMsuppevms"></a>1. The FSIMs supported by EVMS</h2></div></div></div><p>EVMS currently ships with seven FSIMs.  These file system modules allow EVMS to interact with file system utilities such as <span class="command"><strong>mkfs</strong></span> and <span class="command"><strong>fsck</strong></span>.  Additionally, the FSIMs ensure that EVMS safely performs operations, such as expanding and shrinking file systems, by coordinating these actions with the file system. </p><p>You can invoke operations such as <span class="command"><strong>mkfs</strong></span> and <span class="command"><strong>fsck</strong></span> through the various EVMS user interfaces.  Any actions you initiate through an FSIM are not saved to disk until the changes are saved in the user interface.  Later in this chapter we provide examples of creating a new file system and coordinating file system checks through the EVMS GUI, Ncurses, and command-line interfaces.</p><p>The FSIMs supported by EVMS are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JFS</p></li><li class="listitem"><p>XFS</p></li><li class="listitem"><p>ReiserFS</p></li><li class="listitem"><p>Ext2/3</p></li><li class="listitem"><p>SWAPFS</p></li><li class="listitem"><p>OpenGFS</p></li><li class="listitem"><p>NTFS</p></li></ul></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimjfs"></a>1.1. JFS</h3></div></div></div><p>
The JFS module supports the IBM journaling file system (JFS). 
Current support includes <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>, 
<span class="command"><strong>fsck</strong></span>, and online file system expansion.   
You must
have at least version 1.0.9 of the JFS utilities for your system
to work with this EVMS FSIM.  You can download the latest utilities
from the <a class="ulink" href="http://oss.software.ibm.com/jfs" target="_top">JFS for Linux</a> 
site.  
</p><p>
For more information on the JFS FSIM, refer to <a class="xref" href="#jfsfsim" title="Appendix F. JFS file system interface module">Appendix F, <i>JFS file system interface module</i></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimxfs"></a>1.2. XFS</h3></div></div></div><p>
The XFS FSIM supports the XFS file system from SGI.
Command support includes <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>, 
<span class="command"><strong>fsck</strong></span>, and online expansion.  Use version 1.2 or higher, which you can download from <a class="ulink" href="ftp://oss.sgi.com/projects/xfs/download" target="_top">the SGI open source FTP directory.</a>
</p><p>
For more information on the XFS FSIM, refer to <a class="xref" href="#xfsfsim" title="Appendix G. XFS file system interface module">Appendix G, <i>XFS file system interface module</i></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimreiserfs"></a>1.3. ReiserFS</h3></div></div></div><p>
The ReiserFS module supports the ReiserFS journaling file system.
This module supports <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>, <span class="command"><strong>fsck</strong></span>, online and offline 
expansion and offline shrinkage.  You need version 3.x.1a or higher
of the ReiserFS utilities for use with the EVMS FSIM modules.  You can download
the ReiserFS utilities from <a class="ulink" href="http://www.namesys.com" target="_top">The Naming 
System Venture (Namesys) </a> Web site.
</p><p>
For more information on the ReiserFS FSIM, refer to <a class="xref" href="#reiserfsim" title="Appendix H. ReiserFS file system interface module">Appendix H, <i>ReiserFS file system interface module</i></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimext23"></a>1.4. Ext2/3</h3></div></div></div><p>
The EXT2/EXT3 FSIM supports both the ext2 and ext3 file system formats.
The FSIM supports <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>, 
<span class="command"><strong>fsck</strong></span>, and offline shrinkage and expansion.
</p><p>
For more information on the Ext2/3 FSIM, refer to <a class="xref" href="#ext23fsim" title="Appendix I. Ext-2/3 file system interface module">Appendix I, <i>Ext-2/3 file system interface module</i></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimswapfs"></a>1.5. SWAPFS</h3></div></div></div><p>
The SWAPFS FSIM supports Linux swap devices.  The FSIM lets you create
and delete swap devices, and supports <span class="command"><strong>mkfs</strong></span>, 
<span class="command"><strong>unmkfs</strong></span>, shrinkage and expansion.  
Currently, you are responsible for issuing the
<span class="command"><strong>swapon</strong></span> and <span class="command"><strong>swapoff</strong></span> commands either in 
the startup scripts or manually.
You can resize swap device with the SWAPFS FSIM as long as the device is
not in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimopengfs"></a>1.6. OpenGFS</h3></div></div></div><p>
The OpenGFS module supports the OpenGFS clustered journaling file system.
This module supports <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>,
<span class="command"><strong>fsck</strong></span>, and online expansion.
You need the OpenGFS utilities for use with the EVMS FSIM module.
You can download the OpenGFS utilities from the 
<a class="ulink" href="http://sourceforge.net/projects/opengfs" target="_top">OpenGFS project on SourceForge</a>.
</p><p>
For more information on the OpenGFS FSIM, refer to <a class="xref" href="#gfsfsim" title="Appendix J. OpenGFS file system interface module">Appendix J, <i>OpenGFS file system interface module</i></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimntfs"></a>1.7. NTFS</h3></div></div></div><p>
The NTFS FSIM supports the NTFS file system format.
The FSIM supports <span class="command"><strong>mkfs</strong></span>, <span class="command"><strong>unmkfs</strong></span>,
and offline shrinkage and expansion.
It also has support for running the <span class="command"><strong>ntfsfix</strong></span> and
<span class="command"><strong>netfsclone</strong></span> from the <span class="command"><strong>ntfsprogs</strong></span> utilities.
You can download the <span class="command"><strong>ntfsprogs</strong></span> utilities from the
<a class="ulink" href="http://linux-ntfs.sourceforge.net/" target="_top">Linux NTFS project web site</a>.
</p><p>
For more information on the NTFS FSIM, refer 
to <a class="xref" href="#ntfsfsim" title="Appendix K. NTFS file system interface module">Appendix K, <i>NTFS file system interface module</i></a>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fsimmkfs"></a>2. Example: add a file system to a volume</h2></div></div></div><p>After you have made an EVMS or compatibility volume, add a file system to the volume before mounting it.  You can add a file system to a volume through the EVMS interface of your choice.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2167"></a><p class="title"><b>Example 13.1. Add a JFS File System to a Volume</b></p><div class="example-contents"><p>This example creates a new JFS file system, named <code class="filename">jfs_vol</code>, on volume <code class="filename">/dev/evms/my_vol</code>.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimmkfsgui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to create a JFS file system with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File Systems</span> &#8594; <span class="guimenuitem">Make</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">JFS File System Interface Module</span>.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">/dev/evms/my_vol</span>.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Type  <strong class="userinput"><code>jfs_vol</code></strong> in the "Volume Label" 
	field. Customize any other options you are interested in.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Make</span>.
	</p></li><li class="listitem"><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to create a file system with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click 
	<code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Make Filesystem...</span></p></li><li class="listitem"><p>Continue creating the file system beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimmkfsncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to create a JFS file system with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File Systems</span> &#8594; <span class="guimenuitem">Make</span>.
	</p></li><li class="listitem"><p>Select JFS File System Interface Module.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Scroll down using the <span class="keycap"><strong>down</strong></span> arrow until
	 <span class="guimenuitem">Volume Label</span> is highlighted.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Spacebar</strong></span>.
	</p></li><li class="listitem"><p>At the "::" prompt enter <strong class="userinput"><code>jfs_vol</code></strong>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Make</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to create a file system with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on 
<code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Make Filesystem</span> menu item.</p></li><li class="listitem"><p>Continue creating the file system beginning with step 2 of the
Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimmkfscli"></a>2.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>mkfs</strong></span> command to create the new file system.  
The arguments to <span class="command"><strong>mkfs</strong></span> include the FSIM type (in our example, JFS), followed
by any option pairs, and then the volume name.  The command to accomplish
this is:</p><pre class="programlisting">mkfs: JFS={vollabel=jfs_vol}, /dev/evms/my_vol</pre><p>The command is completed upon saving.</p><p>If you are interested in other options that <span class="command"><strong>mkfs</strong></span> can 
use, look at the results of the following query:</p><pre class="programlisting">query: plugins, plugin=JFS, list options</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fsimmkfsaex"></a>3. Example: check a file system</h2></div></div></div><p>You can also coordinate file system checks from the EVMS user interfaces.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2277"></a><p class="title"><b>Example 13.2. Check a JFS File System</b></p><div class="example-contents"><p>This example shows how to perform a file system check on a JFS file system, named <code class="filename">jfs_vol</code>, on volume <code class="filename">/dev/evms/my_vol</code>, with verbose output.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="FSIMmkfsgui"></a>3.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to check a JFS file system with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File Systems</span> &#8594; <span class="guimenuitem">Check/Repair</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">/dev/evms/my_vol</span>.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Click the <span class="keycap"><strong>Yes</strong></span>  button by <span class="guimenu">Verbose Output</span>.  
	 Customize any other options you are interested in.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Check</span>.
	</p></li><li class="listitem"><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to check a file system with the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click
	<code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Click <code class="filename">Check/Repair File System...</code>
	</p></li><li class="listitem"><p>Continue checking the file system beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fsimfsckncurses"></a>3.2. Using Ncurses</h3></div></div></div><p>Follow these steps to check a JFS file system with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File System</span> &#8594; <span class="guimenuitem">Check/Repair</span>
	</p></li><li class="listitem"><p>Select
	<code class="filename"> /dev/evms/my_vol</code>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Scroll down using the <span class="keycap"><strong>down</strong></span> arrow until
	<span class="guimenuitem">Verbose Output</span> is highlighted.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Spacebar</strong></span> to change <span class="guimenuitem">Verbose Output</span> to <span class="keycap"><strong>Yes</strong></span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Check</span>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to check a file system with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Check/Repair File System</span> menu item.</p></li><li class="listitem"><p>Continue checking the file system beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="FSIMmkfscli"></a>3.3. Using the CLI</h3></div></div></div><p>The CLI <span class="command"><strong>check</strong></span> command takes a volume name and options as
	 input.  The command to check the file system on <code class="filename">/dev/evms/my_vol</code> is the following:
	</p><pre class="programlisting">check: /dev/evms/my_vol, verbose=TRUE</pre><p>Currently, a query command for viewing additional options is not available.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="clusterops"></a>Chapter 14. Clustering operations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm2372">1. Rules and restrictions for creating cluster containers</a></span></dt><dt><span class="sect1"><a href="#idm2382">2. Example: create a private cluster container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2394">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2432">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2490">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2496">3. Example: create a shared cluster container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2507">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2543">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2598">3.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2604">4. Example: convert a private container to a shared container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2617">4.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2638">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2683">4.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2688">5. Example: convert a shared container to a private container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2702">5.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2724">5.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2768">5.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2773">6. Example: deport a private or shared container</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2782">6.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2803">6.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2845">6.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2849">7. Deleting a cluster container</a></span></dt><dt><span class="sect1"><a href="#idm2853">8. Failover and Failback of a private container on Linux-HA</a></span></dt><dt><span class="sect1"><a href="#idm2896">9. Remote configuration management</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2901">9.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#idm2918">9.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm2941">9.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2946">10. Forcing a cluster container to be active</a></span></dt></dl></div><p>This chapter discusses how to configure cluster storage containers (referred to throughout
this chapter as "cluster containers"), a feature provided by the EVMS Cluster Segment
Manager (CSM).</p><p>Disks that are physically accessible from all of the nodes of the cluster can be
grouped together as a single manageable entity.  EVMS storage objects can then be
created using storage from these containers.</p><p>Ownership is assigned to a container to make the container either private or shared.
A container that is owned by any one node of the cluster is called a private container.
EVMS storage objects and storage volumes created using space from a private
container are accessible from only the owning node.</p><p>A container that is owned by all the nodes in a cluster is called a shared container.
EVMS storage objects and storage volumes created using space from a shared
container are accessible from all nodes of the cluster simultaneously.</p><p>EVMS provides the tools to convert a private container to a shared container, and
a shared container to a private container.  EVMS also provides the flexibility to
change the ownership of a private container from one cluster node to another
cluster node.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2372"></a>1. Rules and restrictions for creating cluster containers</h2></div></div></div><p>Note the following rules and limitations for creating cluster containers:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Do not assign non-shared disks to a cluster container.
</p></li><li class="listitem"><p>Storage objects and volumes created on a cluster container must not 
span across multiple cluster containers.  
The EVMS Engine enforces this rule by disallowing such configurations.
</p></li><li class="listitem"><p>Do not assign RAID-1, RAID-5, BBR, or snapshotting
to storage objects on a shared cluster container. These plug-ins
can be used on private cluster containers.
</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2382"></a>2. Example: create a private cluster container</h2></div></div></div><p>This section tells how to create a sample private
container and provides instructions for completing the following task:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2386"></a><p class="title"><b>Example 14.1. Create a private cluster container</b></p><div class="example-contents"><p>Given a system with three available shared disks 
(<code class="filename">sdd</code>, <code class="filename">sde</code>, and 
<code class="filename">sdf</code>),
use the EVMS Cluster Segment Manager to combine these disk drives into a
container called <code class="filename">Priv1</code> owned by <code class="filename">node1</code>.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2394"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>To create a container with the EVMS GUI, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span> to see a list of plug-ins that support container creation.
</p></li><li class="listitem"><p>Select the <span class="guimenuitem">Cluster Segment Manager</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p><p>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</p></li><li class="listitem"><p>Select <code class="filename">sdd</code>, <code class="filename">sde</code>, and <code class="filename">sdf</code> from the list.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>In the first pull-down menu, select the "Node Id" of the cluster node that
owns this container (<span class="guimenuitem">node1</span>).  Select "Storage Type" as 
<span class="guimenuitem">private</span> from the second pull-down menu.</p></li><li class="listitem"><p>Enter the name <strong class="userinput"><code>Priv1</code></strong> for the Container Name.</p></li><li class="listitem"><p>Click <span class="guibutton">Create</span>.</p><p>A window opens that displays the outcome.</p></li><li class="listitem"><p>Commit the changes.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2432"></a>2.2. Using Ncurses</h3></div></div></div><p>To create the private container with the Ncurses interface, follow these steps:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span> to see a list 
of plug-ins that support container creation.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and select Cluster Segment Manager by
pressing <span class="keycap"><strong>spacebar</strong></span>.  The plug-in you selected is marked with an "x."  </p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p><p>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</p></li><li class="listitem"><p>Use <span class="keycap"><strong>spacebar</strong></span> to select <code class="filename">sdd</code>, <code class="filename">sde</code>, 
and <code class="filename">sdf</code> from the list.  The disks you select are marked with an "x."</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>On the Create Storage Container - Configuration Options menu, press 
<span class="keycap"><strong>spacebar</strong></span> on the Node Id, which will provide a list of nodes from
which to select.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span> on the node <code class="filename">node1</code> and 
then press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and press <span class="keycap"><strong>spacebar</strong></span> on the
Storage Type.  A list of storage types opens.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow to 
<span class="guimenuitem">private entry</span> and press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow to 
<span class="guimenuitem">Container Name</span> and press <span class="keycap"><strong>spacebar</strong></span>.</p><p>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <strong class="userinput"><code>Priv1</code></strong>, and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span> to complete the operation.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2490"></a>2.3. Using the CLI</h3></div></div></div><p>An operation to create a private cluster container with the CLI takes three parameters: the name 
of the container, the type of the container, and the nodeid to which the container belongs.
</p><p>On the CLI, type the following command to create the private container
<code class="filename">Priv1</code>:</p><pre class="programlisting">create: container,CSM={name="Priv1",type="private",nodeid="node1"},sdd,sde,sdf</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2496"></a>3. Example: create a shared cluster container</h2></div></div></div><p>This section tells how to create a sample shared container and provides
instructions to help you complete the following task:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2500"></a><p class="title"><b>Example 14.2. Create a shared cluster container</b></p><div class="example-contents"><p>Given a system with three available shared disks 
(<code class="filename">sdd</code>, <code class="filename">sde</code>, and 
<code class="filename">sdf</code>),
use the EVMS Cluster Segment Manager to combine these disk drives into a shared
container called <code class="filename">Shar1</code>.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2507"></a>3.1. Using the EVMS GUI</h3></div></div></div><p>To create a shared cluster container with the EVMS GUI, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span> to see a list of plug-ins that support container creation.
</p></li><li class="listitem"><p>Select the <span class="guimenuitem">Cluster Segment Manager</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p><p>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</p></li><li class="listitem"><p>Select <code class="filename">sdd</code>, <code class="filename">sde</code>, and <code class="filename">sdf</code> from the list.</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>You do not need to change the "Node Id" field. Select 
Storage Type as 
<span class="guimenuitem">shared</span> from the second pull-down menu.</p></li><li class="listitem"><p>Enter the name <strong class="userinput"><code>Shar1</code></strong> for the Container Name.</p></li><li class="listitem"><p>Click <span class="guibutton">Create</span>.  A window opens to display the outcome.</p></li><li class="listitem"><p>Commit the changes.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2543"></a>3.2. Using Ncurses</h3></div></div></div><p>To create a shared cluster contained with the Ncurses interface, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span> to see a list of plug-ins that support container creation.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and select Cluster Segment Manager by
pressing <span class="keycap"><strong>spacebar</strong></span>.  The plug-in you selected is marked with an "x."  </p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p><p>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</p></li><li class="listitem"><p>Use <span class="keycap"><strong>spacebar</strong></span> to select <code class="filename">sdd</code>, <code class="filename">sde</code>, 
and <code class="filename">sdf</code> from the list.  The disks you select are marked with an "x."</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The Create Storage Container - Configuration Options menu open;
ignore the "Node Id" menu.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and press <span class="keycap"><strong>spacebar</strong></span> on the
Storage Type.  A list of storage types opens.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow to 
<span class="guimenuitem">shared entry</span> and press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow to 
<span class="guimenuitem">Container Name</span> and press <span class="keycap"><strong>spacebar</strong></span>.</p><p>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <strong class="userinput"><code>Shar1</code></strong>, and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span> to complete the operation.</p></li><li class="listitem"><p>Quit Ncurses and run <span class="command"><strong>evms_activate</strong></span> on each of the cluster 
nodes.  This process will be automated in future releases of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2598"></a>3.3. Using the CLI</h3></div></div></div><p>An operation to create a shared cluster container with the CLI takes two parameters:
the name of the container and the type of the container.</p><p>On the CLI,  type the following command to create shared container <code class="filename">Shar1</code>:</p><pre class="programlisting">create: container,CSM={name="Shar1",type="shared"},sdd,sde,sdf</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2604"></a>4. Example: convert a private container to a shared container</h2></div></div></div><p>This section tells how to convert a sample private container to a shared
container and provides instructions for completing the following task:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2608"></a><p class="title"><b>Example 14.3. Convert a private container to shared</b></p><div class="example-contents"><p>Given a system with a private storage container <code class="filename">Priv1</code> owned 
by <code class="filename">evms1</code>, convert
<code class="filename">Priv1</code> to a shared storage container with the same name.</p></div></div><br class="example-break"></blockquote></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">CAUTION</h3><p>Ensure that no application
is using the volumes on the container on any node of the cluster.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2617"></a>4.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to convert a private cluster container to a shared cluster 
container with the EVMS GUI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Modify</span> &#8594; <span class="guimenuitem">Container</span> to see a list of containers.</p></li><li class="listitem"><p>Select the container <span class="guimenuitem">Priv1</span> and press <span class="keycap"><strong>Next</strong></span>.</p><p>A Modify Properties dialog box opens.</p></li><li class="listitem"><p>Change "Type" to "shared" and click <span class="keycap"><strong>Modify</strong></span>.</p><p>A window opens that displays the outcome.</p></li><li class="listitem"><p>Commit the changes.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2638"></a>4.2. Using Ncurses</h3></div></div></div><p>Follow these steps to convert a private cluster container to a shared cluster
container with the Ncurses interface:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Modify</span> &#8594; <span class="guimenuitem">Container</span> to see a list of containers.</p></li><li class="listitem"><p>The Modify Container Properties dialog opens.  Select the container 
<code class="filename">Priv1</code> by
pressing <span class="keycap"><strong>spacebar</strong></span>.  The container you selected is marked with an "x."</p><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Use <span class="keycap"><strong>spacebar</strong></span> to select <code class="filename">sdd</code>, <code class="filename">sde</code>, 
and <code class="filename">sdf</code> from the list.  The disks you select are marked with an "x."</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The Modify Container Properties - Configuration Options" dialog opens. Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and press <span class="keycap"><strong>spacebar</strong></span> on "Type".</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>The Change Option Value dialog opens.  Type <strong class="userinput"><code>shared</code></strong> and press <span class="keycap"><strong>Enter</strong></span>.</p><p>The changed value now displays in the Modify Container Properties -
Configuration Options dialog.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p><p>The outcome of the command is displayed at the bottom of the screen.</p></li><li class="listitem"><p>Save the changes by clicking <span class="keycap"><strong>Save</strong></span> in the <span class="guimenuitem">Actions</span> pulldown menu.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2683"></a>4.3. Using the CLI</h3></div></div></div><p>The <span class="command"><strong>modify</strong></span> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the private container to a shared container in the example is:</p><pre class="programlisting">modify: Priv1,type=shared</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2688"></a>5. Example: convert a shared container to a private container</h2></div></div></div><p>This section tells how to convert a sample shared container to a private
container and provides instructions for completing the following task:</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2692"></a><p class="title"><b>Example 14.4. Convert a shared container to private</b></p><div class="example-contents"><p>Given a system with a shared storage container <code class="filename">Shar1</code>, convert
<code class="filename">Shar1</code> to a private storage container owned by node <code class="filename">node1</code> (where
<code class="filename">node1</code> is the nodeid of one of the cluster nodes).</p></div></div><br class="example-break"></blockquote></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">CAUTION</h3><p>Ensure that no application
is using the volumes on the container of any node in the cluster.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2702"></a>5.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to convert a shared cluster container to a private cluster 
container with the EVMS GUI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Modify</span> &#8594; <span class="guimenuitem">Container</span> to see a list of containers.</p></li><li class="listitem"><p>Select the container <span class="guimenuitem">Shar1</span> and press <span class="keycap"><strong>Next</strong></span>.</p><p>A Modify Properties dialog opens.</p></li><li class="listitem"><p>Change "Type" to "private" and the "Node" field to <code class="filename">node1</code>.  Click <span class="keycap"><strong>Modify</strong></span>.</p><p>A window opens that displays the outcome.</p></li><li class="listitem"><p>Commit the changes.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2724"></a>5.2. Using Ncurses</h3></div></div></div><p>Follow these steps to convert a shared cluster container to a private cluster
container with the Ncurses interface:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Modify</span> &#8594; <span class="guimenuitem">Container</span></p></li><li class="listitem"><p>The Modify Container Properties dialog opens.  Select the container 
<code class="filename">Shar1</code> by
pressing <span class="keycap"><strong>spacebar</strong></span>.  The container you selected is marked with an "x."</p><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The Modify Container Properties - Configuration Options" dialog opens. Scroll down with the <span class="keycap"><strong>down</strong></span> arrow and press <span class="keycap"><strong>spacebar</strong></span> on the "Type" field.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>The Change Option Value dialog opens.  Select <strong class="userinput"><code>private</code></strong> and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The Modify Container Properties -
Configuration Options dialog opens.  Scroll down the list to <span class="guimenuitem">NodeId</span> 
with the <span class="keycap"><strong>down</strong></span> arrow 
and press <span class="keycap"><strong>spacebar</strong></span>.</p></li><li class="listitem"><p>The Change Option Value dialog opens.  Select <strong class="userinput"><code>node1</code></strong> and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The changed values now display in the Modify Container Properties -
Configuration Options dialog.  Press <span class="keycap"><strong>Enter</strong></span>. </p><p>The outcome of the command is displayed at the bottom of the screen.</p></li><li class="listitem"><p>Save the changes by clicking <span class="keycap"><strong>Save</strong></span> in the <span class="guimenuitem">Actions</span> pulldown.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2768"></a>5.3. Using the CLI</h3></div></div></div><p>The <span class="command"><strong>modify</strong></span> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the shared container to a private container in the example is:</p><pre class="programlisting">modify: Shar1,type=private,node=node1</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2773"></a>6. Example: deport a private or shared container</h2></div></div></div><p>
When a container is deported, the node disowns the container and deletes
all the objects created in memory that belong to that container.  
No node in
the cluster can discover objects residing on a deported container or
create objects for a deported container.
This section explains how to deport a private or shared container.  
</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2777"></a><p class="title"><b>Example 14.5. Deport a cluster container</b></p><div class="example-contents"><p>Given a system with a private or shared  storage container named 
<code class="filename">c1</code>, deport <code class="filename">c1</code>.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2782"></a>6.1. Using the EVMS GUI</h3></div></div></div><p>
To deport a container with the EVMS GUI, follow these steps:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Modify</span> &#8594; <span class="guimenuitem">Container</span>.
</p></li><li class="listitem"><p>Select the container <code class="filename">c1</code> and press 
<span class="keycap"><strong>Next</strong></span>.
</p><p>
A Modify Properties dialog opens.
</p></li><li class="listitem"><p>Change "Type" to "deported."  Click <span class="keycap"><strong>Modify</strong></span>.
</p><p>
A window opens that displays the outcome.
</p></li><li class="listitem"><p>Commit the changes.
</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2803"></a>6.2. Using Ncurses</h3></div></div></div><p>
To deport a container with Ncurses, follow these steps: 
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Scroll down the list with the <span class="keycap"><strong>down</strong></span> arrow to
<span class="guimenuitem">Modify</span>.  Press <span class="keycap"><strong>Enter</strong></span>.
</p><p>
A submenu is displayed.
</p></li><li class="listitem"><p>Scroll down until Container is highlighted.  Press <span class="keycap"><strong>Enter</strong></span>.
</p><p>
The Modify Container Properties dialog opens.
</p></li><li class="listitem"><p>Select the container <code class="filename">csm/c1</code> by pressing
<span class="keycap"><strong>spacebar</strong></span>.  The container you selected is marked with an "x."
</p></li><li class="listitem"><p>
Press <span class="keycap"><strong>Enter</strong></span>.
</p><p>
The Modify Container Properties - Configuration Options dialog opens.
</p></li><li class="listitem"><p>Scroll down and press <span class="keycap"><strong>spacebar</strong></span> on the "Type" field.  
</p></li><li class="listitem"><p>
Press <span class="keycap"><strong>spacebar</strong></span>.
</p><p>
The Change Option Value dialog opens.
</p></li><li class="listitem"><p>Type <strong class="userinput"><code>deported</code></strong> and press <span class="keycap"><strong>Enter</strong></span>.
</p><p>
The changed value is displayed in the Modify Container Properties -
Configuration Options dialog.
</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
</p><p>
The outcome of the command is displayed at the bottom of the screen.
</p></li><li class="listitem"><p>Commit the changes by clicking <span class="keycap"><strong>Save</strong></span> in the 
<span class="guimenuitem">Actions</span> pulldown.
</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2845"></a>6.3. Using the CLI</h3></div></div></div><p>
To deport a container from the CLI, execute the following command
at the CLI prompt:
</p><pre class="programlisting">
modify: c1,type=deported
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2849"></a>7. Deleting a cluster container</h2></div></div></div><p>
The procedure for deleting a cluster container is the same for deleting
any container.  See <a class="xref" href="#examdelrecur" title="2. Example: perform a delete recursive operation">Section 2, &#8220;Example: perform a delete recursive operation&#8221;</a>





</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2853"></a>8. Failover and Failback of a private container on Linux-HA</h2></div></div></div><p>EVMS supports the Linux-HA cluster manager in EVMS V2.0 and later.  Support for 
the RSCT cluster
manager is also available as of EVMS V2.1, but is not as widely tested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Ensure that <span class="command"><strong>evms_activate</strong></span> is called in one of the startup scripts
before the <span class="command"><strong>heartbeat</strong></span> startup script is called. If <span class="command"><strong>evms_activate</strong></span> is not called, failover
might not work correctly. </p></div><p>Follow these steps to set up failover and failback of a private container:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Add an entry in <code class="filename">/etc/ha.d/haresources</code> for each 
private container to be failed over.  For example, if <code class="filename">container1</code> and 
<code class="filename">container2</code> are to
be failed over together to the same node with <code class="filename">node1</code> as the owning node, add the
following entry to <code class="filename">/etc/ha.d/haresources</code>:</p><pre class="programlisting">node1 evms_failover::container1 evms_failover::container2</pre><p><code class="filename">node1</code> is the cluster node that owns this resource.  The resource is failed over
to the other node when <code class="filename">node1</code> dies.</p><p>Similarly, if <code class="filename">container3</code> and <code class="filename">container4</code> are to be failed over together to the same
node with <code class="filename">node2</code> as the owning node, then add the following entry to 
<code class="filename">/etc/ha.d/haresources</code>:</p><pre class="programlisting">node2 evms_failover::container3 evms_failover::container4</pre><p>Refer to 
<a class="ulink" href="http://www.linux-ha.org/download/GettingStarted.html" target="_top">http://www.linux-ha.org/download/GettingStarted.html</a> for more details on the
semantics of resource groups.</p></li><li class="listitem"><p>Validate that the <code class="filename">/etc/ha.d</code>, <code class="filename">/etc/ha.cf</code> and <code class="filename">/etc/ha.d/haresources</code> files are the same
on all the nodes of the cluster.</p></li><li class="listitem"><p>The heartbeat cluster manager must be restarted, as follows, after the
<code class="filename">/etc/ha.d/haresources</code> file has been changed:</p><pre class="programlisting">/etc/init.d/heartbeat restart</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
Do not add shared containers to the list of failover resources; doing so causes
EVMS to respond unpredictably.</p></div></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2896"></a>9. Remote configuration management</h2></div></div></div><p>EVMS supports the administration of cluster nodes by any node in the cluster.  For
example, storage on remote cluster node <code class="filename">node1</code> can be administered from cluster node
<code class="filename">node2</code>.  The following sections show how to set up remote administration
through the various EVMS user interfaces.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2901"></a>9.1. Using the EVMS GUI</h3></div></div></div><p>To designate <code class="filename">node2</code> as the node to administer from the GUI, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Settings</span> &#8594; <span class="guimenuitem">Node Administered...</span></p></li><li class="listitem"><p>Select <code class="filename">node2</code>.</p></li><li class="listitem"><p>Click <span class="keycap"><strong>Administer</strong></span> to switch to the new node.</p></li></ol></div><p>
The GUI gathers information about the objects, containers, and volumes on 
the other node. The status
bar displays the message "Now administering node node2," which indicates
that the GUI is switched over to node node2.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2918"></a>9.2. Using Ncurses</h3></div></div></div><p>To designate <code class="filename">node2</code> as the node to administer from Ncurses, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Go to the <span class="guimenuitem">Settings</span> pulldown menu.</p></li><li class="listitem"><p>Scroll down with the <span class="keycap"><strong>down</strong></span> arrow to the "Node Administered" option and
press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>The Administer Remote Node dialog opens.  Select <code class="filename">node2</code> and press
<span class="keycap"><strong>spacebar</strong></span>.</p><p>The node you selected is marked with an "x."</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>After a while, you will be switched over to 
the node <code class="filename">node2</code>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2941"></a>9.3. Using the CLI</h3></div></div></div><p>To designate <code class="filename">node2</code> as a node administrator from the CLI, issue this command:</p><pre class="programlisting">evms -n node2</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2946"></a>10. Forcing a cluster container to be active</h2></div></div></div><p>
A private container and its objects are made active on a node if:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
the private container is owned by the node
</p></li><li class="listitem"><p>
the container is not deported
</p></li><li class="listitem"><p>
the node is in a cluster membership that currently has quorum
</p></li></ul></div><p>
Similarly, a shared container and its objects are made active on a node if
the node is in a cluster that currently has quorum. 
However, the administrator can force the
activation of private and shared containers by overriding these rules.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
Use extreme caution when performing this operation by ensuring that the
node on which the cluster container resides is the only active node in the
cluster.  Otherwise, the data in volumes on shared and private containers
on the node can get corrupted.
</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Enabling maintenance mode in the <code class="filename">/etc/evms.conf</code> file.
The option to modify in the <code class="filename">/etc/evms.conf</code> file is the 
following:
</p><pre class="programlisting">
# cluster segment manager section
csm {
#	admin_mode=yes	# values are: yes or no
				# The default is no. Set this key to
				# yes when you wish to force the CSM
				# to discover objects from all cluster
				# containers, allowing you to perform
				# configuration and maintenance.  Setting
				# admin_mode to yes will cause the CSM
				# to ignore container ownership, which
				# will allow you to configure storage
				# in a maintenance mode.
</pre><p>
</p></li><li class="listitem"><p>
Running <span class="command"><strong>evms_activate</strong></span> on the node.
</p></li></ol></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmsconvert"></a>Chapter 15. Converting volumes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm2974">1. When to convert volumes</a></span></dt><dt><span class="sect1"><a href="#comptoevms">2. Example: convert compatibility volumes to EVMS volumes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#c2egui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#c2encur">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3054">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#evmstocomp">3. Example: convert EVMS volumes to compatibility volumes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#e2cgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#e2cncur">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#e2ccli">3.3. Using the CLI</a></span></dt></dl></dd></dl></div><p> This chapter discusses converting compatibility volumes to EVMS
volumes and converting EVMS volumes to compatibility volumes. For a discussion 
of the differences between compatibility and EVMS volumes, see <a class="xref" href="#evmscreatevol" title="Chapter 12. Creating volumes">Chapter 12, <i>Creating volumes</i></a>.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2974"></a>1. When to convert volumes</h2></div></div></div><p>There are several different scenarios that might help you determine 
what type of volumes you need. 
For example, if you wanted persistent names or to make full use of 
EVMS features, such as Drive Linking or Snapshotting, you would convert 
your compatibility volumes to EVMS volumes. 
In another situation, you might decide that a volume needs to be 
read by a system that understands the underlying volume management scheme. 
In this case, you would convert your EVMS volume to a 
compatibility volume.</p><p>A volume can only be converted when it is offline.  
This means the volume must be unmounted and otherwise not in use.  
The volume must be unmounted because the conversion operation changes both 
the name and the device number of the volume.  
Once the volume is converted, you can remount it using its new name.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="comptoevms"></a>2. Example: convert compatibility volumes to EVMS volumes</h2></div></div></div><p>A compatibility volume 
can be converted to an EVMS volume in the following situations:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The compatibility volume has no file system (FSIM) on it.</p></li><li class="listitem"><p>The compatibility volume has a file system, but the file system can be shrunk (if necessary) to make 
room for the EVMS metadata.</p></li></ul></div><p>This section provides a detailed explanation of how to convert compatibility 
	volumes to EVMS volumes and provides instructions to help you complete the following task.  </p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm2988"></a><p class="title"><b>Example 15.1. Convert a compatibility volume</b></p><div class="example-contents"><p>You have a compatibility volume <code class="filename">/dev/evms/hda3</code>
	that you want to make into an EVMS volume named <code class="filename">my_vol</code>.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="c2egui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to convert a compatibility volume with the EVMS GUI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Choose <span class="guimenu">Action</span> &#8594; <span class="guimenuitem">Convert </span> &#8594; <span class="guimenuitem">Compatibility Volume to EVMS</span>.  </p></li><li class="listitem"><p>Select  <code class="filename">/dev/evms/hda3</code> 
		from the list of available volumes.</p></li><li class="listitem"><p>Type <code class="filename">my_vol</code> in the name field.</p></li><li class="listitem"><p>Click the <span class="guibutton">Convert</span> button 
		to convert the volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume from the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click 
	on <code class="filename">/dev/evms/hda3</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Convert to EVMS Volume...</span></p></li><li class="listitem"><p>Continue to convert the volume beginning with step 3 of the GUI 
	instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="c2encur"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these instructions to convert a compatibility volume to an EVMS volume
	with the Ncurses
	interface:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Choose <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Convert</span> &#8594; <span class="guimenuitem">Compatibility Volume to EVMS Volume</span></p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/hda3</code> from the list
		of available volumes.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>my_vol</code></strong> when prompted for the name.
		Press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Convert</span>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume from the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">/dev/evms/hda3</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Convert to EVMS Volume</span> menu item.</p></li><li class="listitem"><p>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3054"></a>2.3. Using the CLI</h3></div></div></div><p>To convert a volume, use the <span class="command"><strong>Convert</strong></span> command. 
		The <span class="command"><strong>Convert</strong></span> command takes the name of a volume as its first argument, and 
		then <code class="option">name=</code> for what you want to name the new volume 
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <code class="prompt">EVMS:</code> prompt:</p><pre class="programlisting">convert: /dev/evms/hda3, Name=my_vol</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="evmstocomp"></a>3. Example: convert EVMS volumes to compatibility volumes</h2></div></div></div><p>An EVMS volume can be converted to a compatibility volume only if the volume does not have EVMS 
	features on it. This section provides a detailed explanation of how to convert EVMS volumes to compatibility volumes 
	by providing instructions to help you complete the following task. </p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm3066"></a><p class="title"><b>Example 15.2. Convert an EVMS volume</b></p><div class="example-contents"><p>You have an EVMS volume, <code class="filename">/dev/evms/my_vol</code>,
	that you want to make a compatibility volume.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="e2cgui"></a>3.1. Using the EVMS GUI</h3></div></div></div><p>Follow these instructions to convert an EVMS volume to a compatibility
	volume with the EVMS GUI:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Choose <span class="guimenu">Action</span> &#8594; <span class="guimenuitem">Convert </span> &#8594; <span class="guimenuitem">EVMS Volume to Compatibility Volume</span>.  </p></li><li class="listitem"><p>Select  <code class="filename">/dev/evms/my_vol</code> 
		from the list of available volumes.</p></li><li class="listitem"><p>Click the <span class="guibutton">Convert</span> button 
		to convert the volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume through
	the GUI context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click 
	<code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Convert to Compatibility Volume...</span></p></li><li class="listitem"><p>Continue converting the volume beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="e2cncur"></a>3.2. Using Ncurses</h3></div></div></div><p>Follow these instructions to convert an EVMS volume to a compatibility volume
with the Ncurses interface:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Choose <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Convert</span> &#8594; <span class="guimenuitem">EVMS Volume to 
		Compatibility Volume</span></p></li><li class="listitem"><p>Select <code class="filename">/dev/evms/my_vol</code> from the
		list of available volumes.</p></li><li class="listitem"><p>Activate <span class="guibutton">Convert</span>. 
		</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume through
the context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">/dev/evms/my_vol</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Convert to Compatibility Volume</span> menu item.</p></li><li class="listitem"><p>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="e2ccli"></a>3.3. Using the CLI</h3></div></div></div><p>To convert a volume use the <span class="command"><strong>Convert</strong></span> command. 
		The <span class="command"><strong>Convert</strong></span> command takes the name of a volume as its first argument, and 
		the keyword <code class="option">compatibility</code> to indicate  a change to a compatibility volume  
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <code class="prompt">EVMS:</code> prompt:</p><pre class="programlisting">convert: /dev/evms/my_vol, compatibility</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="expandshrink"></a>Chapter 16. Expanding and shrinking volumes</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whyexpandshrink">1. Why expand and shrink volumes?</a></span></dt><dt><span class="sect1"><a href="#exshrink">2. Example: shrink a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#shrinkgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#shrinkncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#shrinkcli">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mkfs">3. Example: expand a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#expandgui">3.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#expandncurses">3.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#expandcli">3.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter tells how to expand and shrink EVMS volumes with the EVMS 
GUI, Ncurses, and CLI interfaces.  Note that you can also expand and shrink compatibility volumes and EVMS objects.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whyexpandshrink"></a>1. Why expand and shrink volumes?</h2></div></div></div><p>Expanding and shrinking volumes are common volume operations on most systems.  For example, it might be necessary to shrink a particular volume to create
free space for another volume to expand into or to create a new volume.</p><p>EVMS simplifies the process for expanding and shrinking volumes, and
protects the integrity of your data, by coordinating expand and shrink
operations with the volume's file system.  For example, when shrinking a
volume, EVMS first shrinks the underlying file system appropriately to protect
the data.  When expanding a volume, EVMS expands the file system automatically
when new space becomes available.</p><p>Not all file system interface modules (FSIM) types supported by EVMS 
allow shrink and expand operations, and some only perform the operations when
the file system is mounted ("online").  The following table details the 
shrink and expand options available for each type of FSIM.
</p><div class="table"><a name="idm3141"></a><p class="title"><b>Table 16.1. FSIM support for expand and shrink operations</b></p><div class="table-contents"><table class="table" summary="FSIM support for expand and shrink operations" border="1"><colgroup><col class="C1"><col class="C2"><col class="C3"></colgroup><thead><tr><th>FSIM type</th><th>Shrinks</th><th>Expands</th></tr></thead><tbody><tr><td>JFS</td><td>No</td><td>Online only</td></tr><tr><td>XFS</td><td>No</td><td>Online only</td></tr><tr><td>ReiserFS</td><td>Offline only</td><td>Offline and online</td></tr><tr><td>ext2/3</td><td>Offline only</td><td>Offline only</td></tr><tr><td>SWAPFS</td><td>Offline only</td><td>Offline only</td></tr><tr><td>OpenGFS</td><td>No</td><td>Online only</td></tr><tr><td>NTFS</td><td>Offline only</td><td>Offline only</td></tr></tbody></table></div></div><p><br class="table-break">

</p><p>You can perform all of the supported shrink and expand operations with each of the EVMS user interfaces.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exshrink"></a>2. Example: shrink a volume</h2></div></div></div><p>This section tells how to shrink a compatibility volume by 500 MB.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm3186"></a><p class="title"><b>Example 16.1. Shrink a volume</b></p><div class="example-contents"><p>Shrink the volume 
<code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code>, which
is the compatibility volume that was created in the chapter entitled 
"Creating Volumes," by 500 MB.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="shrinkgui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to shrink the volume with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Shrink</span> &#8594; <span class="guimenuitem">Volume...</span></p></li><li class="listitem"><p>Select <span class="guimenu">/dev/evms/lvm/Sample Container/Sample Region</span> 
	from the list of volumes.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">/lvm/Sample Container/Sample Region</span> from the list of volumes.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Enter <strong class="userinput"><code>500MB</code></strong> in the "Shrink by Size" field.</p></li><li class="listitem"><p>Click <span class="guibutton">Shrink</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to shrink the volume with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click
	<code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code></p></li><li class="listitem"><p>Click <span class="guimenuitem">Shrink...</span></p></li><li class="listitem"><p>Continue the operation beginning with step 3 of the GUI
	instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="shrinkncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to shrink a volume with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Shrink</span> &#8594; <span class="guimenuitem">Volume</span>.
	</p></li><li class="listitem"><p>Select
	 <span class="guimenuitem">/dev/evms/lvm/Sample Container/Sample Region</span> from the
	list of volumes.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select
	 <span class="guimenuitem">lvm/Sample Container/Sample Region</span> from the
	shrink point selection list.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Scroll down using the <span class="keycap"><strong>down</strong></span> arrow until
	<span class="guimenuitem">Shrink by Size</span> is highlighted.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>At the "::" prompt enter <strong class="userinput"><code>500MB</code></strong>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Shrink</span>.
	</p></li></ol></div><p>
</p><p>
Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Shrink</span> menu item.</p></li><li class="listitem"><p>Continue the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="shrinkcli"></a>2.3. Using the CLI</h3></div></div></div><p>The <span class="command"><strong>shrink</strong></span> command takes a shrink point followed by an optional name
value pair or an optional shrink object.  To find the shrink point, use the <span class="command"><strong>query</strong></span> command with the shrink points filter on the object or volume you plan to shrink.  For example:</p><pre class="programlisting">query: shrink points, "/dev/evms/lvm/Sample Container/Sample Region"</pre><p>Use a list options filter on the object of the shrink point to determine the name-value pair to use, as follows:</p><pre class="programlisting">query: objects, object="lvm/Sample Container/Sample Region", list options</pre><p>With the option information that is returned, you can construct the command, as follows:</p><pre class="programlisting">shrink: "lvm/Sample Container/Sample Region", remove_size=500MB</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mkfs"></a>3. Example: expand a volume</h2></div></div></div><p>This section tells how to expand a volume a compatibility volume by 500 MB.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm3297"></a><p class="title"><b>Example 16.2. Expand a volume</b></p><div class="example-contents"><p>Expand the volume <code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code>, which is the compatibility volume that was created in the chapter entitled "Creating Volumes," by 500 MB.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="expandgui"></a>3.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to expand the volume with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
	<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Expand</span> &#8594; <span class="guimenuitem">Volume...</span>
	</p></li><li class="listitem"><p>Select 
	<span class="guimenu">/dev/evms/lvm/Sample Container/Sample Region</span>
	from the list of volumes.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">lvm/Sample Container/Sample Region</span>  from the list as the expand point.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Enter <strong class="userinput"><code>500MB</code></strong> in the "Additional Size" field.</p></li><li class="listitem"><p>Click <span class="guibutton">Expand.</span></p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to expand the volume with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click
	<code class="filename">/dev/evms/lvm/Sample Container/Sample Region</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Expand...</span></p></li><li class="listitem"><p>Continue the operation to expand the volume beginning with step 3
	of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="expandncurses"></a>3.2. Using Ncurses</h3></div></div></div><p>Follow these steps to expand a volume with Ncurses:

	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Expand</span> &#8594; <span class="guimenuitem">Volume</span>.
	</p></li><li class="listitem"><p>Select
	 <span class="guimenuitem">/dev/evms/lvm/Sample Container/Sample Region</span> from the
	list of volumes.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select	<span class="guimenuitem">lvm/Sample Container/Sample Region</span> from
	the list of expand points.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Press <span class="keycap"><strong>spacebar</strong></span> on the <span class="guimenuitem">Additional Size</span> field.
	</p></li><li class="listitem"><p>At the "::" prompt enter <strong class="userinput"><code>500MB</code></strong>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Expand</span>.
	</p></li></ol></div><p>


</p><p>Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on /<span class="guimenuitem">dev/evms/lvm/Sample Container/Sample Region</span>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Expand</span> menu item.</p></li><li class="listitem"><p>Continue the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="expandcli"></a>3.3. Using the CLI</h3></div></div></div><p>The <span class="command"><strong>expand</strong></span> command takes an expand point followed by an optional name
value pair and an expandable object.  To find the expand point, use the <span class="command"><strong>query</strong></span> command with the Expand Points filter on the object or volume you plan to expand.  For example:</p><pre class="programlisting">query: expand points, "/dev/evms/lvm/Sample Container/Sample Region"</pre><p>Use a list options filter on the object of the expand point to determine the name-value pair to use, as follows:</p><pre class="programlisting">query: objects, object="lvm/Sample Container/Sample Region", list options</pre><p>The free space in your container is the container name plus <code class="filename">/Freespace</code>.</p><p>With the option information that is returned, you can construct the command, as follows:</p><pre class="programlisting">expand: "lvm/Sample Container/Sample Region", add_size=500MB, 
"lvm/Sample Container/Freespace"</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="addfeatures"></a>Chapter 17. Adding features to an existing volume</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whyadd">1. Why add features to a volume?</a></span></dt><dt><span class="sect1"><a href="#exaddfeature">2. Example: add drive linking to an existing volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#addfeaturegui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#addfeaturesncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#addfeaturescli">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter tells how to add additional EVMS features to an
already existing EVMS volume.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whyadd"></a>1. Why add features to a volume?</h2></div></div></div><p>EVMS lets you add features such as drive linking to 
a volume that already exists.  By adding features, you avoid having to potentially
destroy the volume and recreate it from scratch.  For example, take the
scenario of a volume that contains important data but is almost full.
If you wanted to add more data to that volume but no free space existed on the
disk immediately after the segment, you could add a drive link to the volume.
The drive link concatenates another object to the end of the volume and 
continues seamlessly.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exaddfeature"></a>2. Example: add drive linking to an existing volume</h2></div></div></div><p> The following example shows how to add drive linking to a volume with
the EVMS GUI, Ncurses, and CLI interfaces.
</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm3410"></a><p class="title"><b>Example 17.1. Add drive linking to an existing volume</b></p><div class="example-contents"><p>The following sections show how to add a drive link to volume
<code class="filename">/dev/evms/vol</code> and call the drive link "DL."  

</p></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Drive linking can be done only on
EVMS volumes; therefore, <code class="filename">/dev/evms/vol</code> must be converted to an EVMS volume if it is not
already. </p></div></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="addfeaturegui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to add a drive link to the volume with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Add</span> &#8594; <span class="guimenuitem">Feature to Volume</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenuitem">/dev/evms/vol</span>
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.  
	</p></li><li class="listitem"><p>Select <span class="guimenuitem">Drive Linking Feature</span>. 
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Type <strong class="userinput"><code>DL</code></strong> in the Name Field.</p></li><li class="listitem"><p>Click <span class="guibutton">Add</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to add a drive link with the GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click
	<code class="filename">/dev/evms/vol</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Add feature...</span></p></li><li class="listitem"><p>Continue adding the drive link beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="addfeaturesncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to add a drive link to a volume with Ncurses:

	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Add</span> &#8594; <span class="guimenuitem">Feature to Volume</span>.

	</p></li><li class="listitem"><p>Select
	 <span class="guimenuitem">/dev/evms/vol</span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select 
	<span class="guimenuitem">Drive Linking Feature</span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Spacebar</strong></span> to edit the Name field.
	</p></li><li class="listitem"><p>At the "::" prompt enter <strong class="userinput"><code>DL</code></strong>.
	</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Add</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to add a drive link with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <span class="guimenuitem">/dev/evms/vol</span>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Add feature</span> menu item.</p></li><li class="listitem"><p>Continue adding the drive link beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="addfeaturescli"></a>2.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>add feature</strong></span> to add a feature to an existing volume.
	Specify the command name followed by a colon, followed by any options
	and the volume to operate on.  To determine the options for a given
	feature, use the following query:
	</p><pre class="programlisting">query: plugins, plugin=DriveLink, list options</pre><p>
The option names and descriptions are listed to help you construct
your command.  For our example, the command would look like the following:
</p><pre class="programlisting">add feature: DriveLink={ Name="DL }, /dev/evms/vol</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="selectact"></a>Chapter 18. Selectively activating volumes and objects</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#initialactivation">1. Initial activation using /etc/evms.conf</a></span></dt><dt><span class="sect1"><a href="#idm3528">2. Activating and deactivating volumes and objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3531">2.1. Activation</a></span></dt><dt><span class="sect2"><a href="#idm3613">2.2. Deactivation</a></span></dt><dt><span class="sect2"><a href="#idm3695">2.3. Activation and deactivation dependencies</a></span></dt></dl></dd></dl></div><p>This chapter discusses selective activation and
deactivation of EVMS volumes and objects.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="initialactivation"></a>1. Initial activation using /etc/evms.conf</h2></div></div></div><p>
There is a section in the EVMS configuration file,
<code class="filename">/etc/etc/evms.conf</code>, named "activate."  
This section has two entries: "include" and "exclude."  The
"include" entry lists the volumes and objects that should be activated.
The "exclude" entry lists the volumes and objects that should not be
activated.
</p><p>
Names in either of the entries can be specified using "*", "?", and
"[...]" notation.  For example, the following entry will activate
all the volumes:
</p><pre class="programlisting">
include = [/dev/evms/*]
</pre><p>
The next entry specifies that objects sda5 and sda7 not be activated:
</p><pre class="programlisting">
exclude = [ sda[57] ]
</pre><p>When EVMS is started, it first reads the include entry and builds a list
of the volumes and objects that it should activate.  It then reads the
exclude entry and removes from the list any names found in the exclude list.
For example, an activation section that activates all of the volumes
except <code class="filename">/dev/evms/temp</code> looks like this:
</p><pre class="programlisting">
activate {
	include = [/dev/evms/*]
	exclude = [/dev/evms/temp]
}
</pre><p>
If <code class="filename">/etc/evms.conf</code> does not contain an activate
section, the default behavior is to activate everything.  This
behavior is consistent with versions of EVMS prior to 2.4.
</p><p>
Initial activation via <code class="filename">/etc/evms.conf</code> does not
deactivate any volumes or objects.  It only determines which ones
should be active.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm3528"></a>2. Activating and deactivating volumes and objects</h2></div></div></div><p>
The EVMS user interfaces offer the ability to activate or deactivate
a particular volume or object.  The volume or object will be
activated or deactivated when the changes are saved.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3531"></a>2.1. Activation</h3></div></div></div><p>
You can activate inactive volumes and objects using the various EVMS
user interfaces.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
EVMS does not currently update the EVMS configuration file
(<code class="filename">/etc/evms.conf</code>) when volumes and objects are
activated.  If you activate a volume or object that is not initially
activated and do not make the corresponding change in
<code class="filename">/etc/evms.conf</code>, the volume or object will not be
activated the next time the system is booted and you run
<span class="command"><strong>evms_activate</strong></span> or one of the user interfaces.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3540"></a>2.1.1. Using the EVMS GUI</h4></div></div></div><p>To activate volumes or objects with the GUI, follow these steps:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select  
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Activation</span> &#8594; <span class="guimenuitem">Activate...</span>
</p></li><li class="listitem"><p>Select the volume(s) and object(s) you want to activate.
</p></li><li class="listitem"><p>
Click <span class="guibutton">Activate</span>.
</p></li><li class="listitem"><p>Click <span class="guibutton">Save</span> to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3558"></a>2.1.2. Using the EVMS GUI context-sensitive menu</h4></div></div></div><p>To activate with the GUI context-sensitive menu, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Right click the volume or object you want to activate.
</p></li><li class="listitem"><p>
Click "Activate."
</p></li><li class="listitem"><p>
Click <span class="guibutton">Activate</span>.
</p></li><li class="listitem"><p>Click <span class="guibutton">Save</span> to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3572"></a>2.1.3. Using Ncurses</h4></div></div></div><p>To activate a volume or object with Ncurses, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select  
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Activation</span> &#8594; <span class="guimenuitem">Activate...</span>
</p></li><li class="listitem"><p>Select the volume(s) and object(s) you want to activate.
</p></li><li class="listitem"><p>
Select <span class="guibutton">Activate</span>.
</p></li><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Save</span> 
to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3592"></a>2.1.4. Using the Ncurses context-sensitive menu</h4></div></div></div><p>To enable activation on a volume or object with the 
Ncurses context-sensitive menu, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Highlight the volume or object you want to activate and press
<span class="keycap"><strong>Enter</strong></span>.
</p></li><li class="listitem"><p>
Select "Activate."
</p></li><li class="listitem"><p>
Select <span class="guibutton">Activate</span>.
</p></li><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Save</span> 
to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3609"></a>2.1.5. Using the CLI</h4></div></div></div><p>To activate a volume or object with the CLI, 
issue the following command to the CLI (where "name" is the name of
the volume or object you want to activate):</p><pre class="programlisting">
Activate:name
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3613"></a>2.2. Deactivation</h3></div></div></div><p>
You can deactivate active volumes and objects using the various EVMS
user interfaces.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
EVMS does not currently update the EVMS configuration file
(<code class="filename">/etc/evms.conf</code>) when a volume or object is
deactivated.
If you deactivate a volume or object that is initially activated and
do not make the corresponding change in <code class="filename">/etc/evms.conf</code>,
then the volume or object will be activated the next time you run
<span class="command"><strong>evms_activate</strong></span> or one of the user interfaces.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3622"></a>2.2.1. Using the EVMS GUI</h4></div></div></div><p>To deactivate a volume or object with the GUI, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select  
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Activation</span> &#8594; <span class="guimenuitem">Deactivate...</span>
</p></li><li class="listitem"><p>Select the volume(s) and object(s) you want to deactivate.
</p></li><li class="listitem"><p>
Click <span class="guibutton">Deactivate</span>.
</p></li><li class="listitem"><p>Click <span class="guibutton">Save</span> to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3640"></a>2.2.2. Using the EVMS GUI context-sensitive menu</h4></div></div></div><p>To deactivate a volume or object with the GUI 
context-sensitive menu, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Right click the volume or object you want to deactivate.
</p></li><li class="listitem"><p>
Click "Deactivate."
</p></li><li class="listitem"><p>
Click <span class="guibutton">Deactivate</span>.
</p></li><li class="listitem"><p>Click <span class="guibutton">Save</span> to save the changes and
activate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3654"></a>2.2.3. Using Ncurses</h4></div></div></div><p>To deactive a volume or object with Ncurses, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select  
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Activation</span> &#8594; <span class="guimenuitem">Deactivate...</span>
</p></li><li class="listitem"><p>Select the volume(s) and object(s) you want to deactivate.
</p></li><li class="listitem"><p>
Select <span class="guibutton">Deactivate</span>.
</p></li><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Save</span>
to save the changes and
deactivate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3674"></a>2.2.4. Using the Ncurses context-sensitive menu</h4></div></div></div><p>To deactivate a volume or object with the 
Ncurses context-sensitive menu, follow these steps:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Highlight the volume or object you want to deactivate and press
<span class="keycap"><strong>Enter</strong></span>.
</p></li><li class="listitem"><p>
Select "Deactivate."
</p></li><li class="listitem"><p>
Select <span class="guibutton">Deactivate</span>.
</p></li><li class="listitem"><p>Select 
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Save</span> 
to save the changes and
deactivate the volume(s) and object(s).
</p></li></ol></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3691"></a>2.2.5. Using the CLI</h4></div></div></div><p>To deactivate a volume or object with the CLI, 
issue the following command to the CLI (where "name" is the name of
the volume or object you want to deactivate):</p><pre class="programlisting">
Deactivate:name
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3695"></a>2.3. Activation and deactivation dependencies</h3></div></div></div><p>
In order for a volume or object to be active, all of its children
must be active.  When you activate a volume or object, EVMS will
activate all the objects that the volume or object comprises.
</p><p>
Similarly, in order for an object to be inactive, all of its
parents cannot be activate.  When you deactivate an object, EVMS
will deactivate all of the objects and volumes that are built from
that object.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3699"></a>2.3.1. Dependencies during initial activation</h4></div></div></div><p>
As discussed in <a class="xref" href="#initialactivation" title="1. Initial activation using /etc/evms.conf">Section 1, &#8220;Initial activation using /etc/evms.conf&#8221;</a>, 
when EVMS starts, it builds an initial list of
volumes and objects whose names match the "include" entry in the
activation section of <code class="filename">/etc/evms.conf</code>.  Because those
volumes and objects cannot be active unless the objects they comprise are
active, EVMS then adds to the list all the objects that are comprised by
the volumes and objects that were found in the initial match.
</p><p>
EVMS then removes from the list the volumes and objects whose names
match the "exclude" entry in the activation section of
<code class="filename">/etc/evms.conf</code>.  Because any volumes or objects
that are built from the excluded ones cannot be active, EVMS removes
them from the list as well.
</p><p>
The enforcement of the dependencies can result in behavior that is not
immediately apparent.
Let's say, for example, that segment hda7 is made into volume
<code class="filename">/dev/evms/home</code>. and the activation section in
<code class="filename">/etc/evms.conf</code> looks like this:
</p><pre class="programlisting">
activate {
	include = [*]
	exclude = [hda*]
}
</pre><p>
When EVMS builds the list of volumes and objects to activate,
everything is included.  EVMS next removes all objects whose names
start with "hda."  hda7 will be removed from the list.
Next, because volume <code class="filename">/dev/evms/home</code> is built
from hda7, it will also be removed from the list and will not be
activated.
So, although volume <code class="filename">/dev/evms/home</code> is not
explicitly in the exclude list, it is not activated because it
depends on an object that will not be activated.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3713"></a>2.3.2. Dependencies for compatibility volumes</h4></div></div></div><p>
Compatibility volumes are made directly from the volume's object.
That is, the device node for the volume points directly to the device
for the volume's object.
Because a compatibility volume is inseparable from its object, a
compatibility volume itself cannot be deactivated.
To deactivate a compatibility volume you must deactivate the volume's object.
</p><p>
Similarly, if a compatibility volume and its object are not active
and you activate the volume's object, the compatibility volume will be
active as well.
</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="mountunmount"></a>Chapter 19. Mounting and unmounting volumes from within EVMS</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#mntvol">1. Mounting a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mntgui">1.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#mountncurses">1.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3797">1.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm3804">2. Unmounting a volume</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3807">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#unmountncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#idm3858">2.3. Using the CLI</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm3863">3. The SWAPFS file system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm3868">3.1. Turning swap on</a></span></dt><dt><span class="sect2"><a href="#idm3939">3.2. Turning swap off</a></span></dt></dl></dd></dl></div><p>
Some volume operations, such as expanding and shrinking, may require that
the volume be mounted or unmounted before you can perform the operation.
EVMS lets you mount and unmount volumes from within EVMS without having
to go to a separate terminal session.
</p><p>
EVMS performs the mount and unmount operations immediately.
It does not wait until the changes are saved.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mntvol"></a>1. Mounting a volume</h2></div></div></div><p>This section tells how to mount a volume through the various EVMS
user interfaces.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mntgui"></a>1.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to mount a volume with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File System</span> &#8594; <span class="guimenuitem">Mount</span>.
	</p></li><li class="listitem"><p>Select the volume you want to mount.
	</p></li><li class="listitem"><p>In the Mount Point box, enter the directory
	on which you want to mount the volume.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Options</span> if you
	want to enter additional options for the mount.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Mount</span>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can mount a volume from the EVMS GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Right click the volume you want to mount.
	</p></li><li class="listitem"><p>Click <span class="guimenuitem">Mount...</span></p></li><li class="listitem"><p>In the Mount Point box, enter the directory
	on which you want to mount the volume.
	</p></li><li class="listitem"><p>
	Click <span class="guibutton">Options</span> if you want to enter
	additional options for the mount.</p></li><li class="listitem"><p>
	Click <span class="guibutton">Mount</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mountncurses"></a>1.2. Using Ncurses</h3></div></div></div><p>Follow these steps to mount a volume with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File System</span> &#8594; <span class="guimenuitem">Mount...</span>.
	</p></li><li class="listitem"><p>Select the volume you want to mount.</p></li><li class="listitem"><p>At the Mount Point prompt, enter the directory
on which you want to mount the volume and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Select <span class="guimenuitem">Mount Options</span> 
if you want to enter
additional options for the mount.</p></li><li class="listitem"><p>Select <span class="guibutton">Mount</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can mount a volume with the Ncurses
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Highlight the volume you want to mount and press <span class="keycap"><strong>Enter</strong></span>.
</p></li><li class="listitem"><p>Select <span class="guimenuitem">Mount File System</span>.</p></li><li class="listitem"><p>At the Mount Point prompt, enter the directory on which you
want to mount the volume and press <span class="keycap"><strong>Enter</strong></span>.
</p></li><li class="listitem"><p>
Select <span class="guimenuitem">Mount Options</span> if you want to enter 
additional options for the mount.
</p></li><li class="listitem"><p>
Select <span class="guimenuitem">Mount</span>.
</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3797"></a>1.3. Using the CLI</h3></div></div></div><p>To mount a volume with the CLI, use the following command:</p><pre class="programlisting">mount:&lt;volume&gt;, &lt;mount point&gt;, [ &lt;mount options&gt; ]</pre><p>&lt;volume&gt; is the name of the volume to be mounted.</p><p>&lt;mount point&gt; is the name of the directory on which to mount the volume.</p><p>&lt;mount options&gt; is a string of options to be passed to the &lt;command&gt;mount&lt;/command&gt;
command.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm3804"></a>2. Unmounting a volume</h2></div></div></div><p>This section tells how to unmount a volume through the various EVMS user interfaces.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3807"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to unmount a volume with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File System</span> &#8594; <span class="guimenuitem">Unmount</span>.
	</p></li><li class="listitem"><p>Select the volume you want to unmount.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Unmount</span>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can unmount a volume from the EVMS GUI
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Right click the volume you want to unmount.
	</p></li><li class="listitem"><p>Click <span class="guimenuitem">Unmount...</span></p></li><li class="listitem"><p>
	Click <span class="guibutton">Unmount</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="unmountncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to unmount a volume with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">File System</span> &#8594; <span class="guimenuitem">Unmount...</span>.
	</p></li><li class="listitem"><p>Select the volume you want to unmount.</p></li><li class="listitem"><p>Select <span class="guibutton">Unmount</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can unmount a volume with the Ncurses
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Highlight the volume you want to unmount and press <span class="keycap"><strong>Enter</strong></span>.
</p></li><li class="listitem"><p>Select <span class="guimenuitem">Unmount File System....</span>.</p></li><li class="listitem"><p>
Select <span class="guimenuitem">Unmount</span>.
</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3858"></a>2.3. Using the CLI</h3></div></div></div><p>To unmount a volume with the CLI, use the following command:</p><pre class="programlisting">unmount:&lt;volume&gt;</pre><p>&lt;volume&gt; is the name of the volume to be unmounted.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm3863"></a>3. The SWAPFS file system</h2></div></div></div><p>A volume with the SWAPFS file system is not mounted or unmounted.
Rather, swapping is turned on for the volume using the 
<span class="command"><strong>sbin/swapon</strong></span> command and turned off using the
&lt;command&gt;sbin/swapoff&lt;/command&gt;.  EVMS lets you turn swapping on or off
for a volume from within EVMS without having to go to a separate terminal session.</p><p>As with mounting and unmounting, EVMS performs the swapon and swapoff
operations immediately.  It does not wait until the changes are saved.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3868"></a>3.1. Turning swap on</h3></div></div></div><p>This section tells how to turn swap on using the various EVMS user interfaces.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3871"></a>3.1.1. Using the EVMS GUI</h4></div></div></div><p>Follow these steps to turn swap on with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Volume tasks...</span>.
	</p></li><li class="listitem"><p>Select the volume you want to turn on swapping and click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select "Swap on" and click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the priority for the swap.  If you select "High" you will 
	get an additional prompt for the priority level.  
	The priority level must be a number in the range of 0 to 32767.  
	The default is 0.</p></li><li class="listitem"><p>Click <span class="guibutton">Swap on</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can turn swap on from the EVMS GUI
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Right click the volume with the SWAPFS you want to turn on.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Swap on...</span></p></li><li class="listitem"><p>Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number
	in the range of 0 to 32767.  The default is 0.</p></li><li class="listitem"><p>
	Click <span class="guibutton">Swap on</span>.</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3904"></a>3.1.2. Using Ncurses</h4></div></div></div><p>Follow these steps to turn swap on with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Volume tasks...</span>.
	</p></li><li class="listitem"><p>Select the volume on which you want to turn on swapping and select
<span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select "Swap on" and select <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number in
	the range of 0 to 32767.  The default is 0.</p></li><li class="listitem"><p>Select "Swap on."</p></li></ol></div><p>
</p><p>Alternatively, you can turn swap on with the Ncurses
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Highlight the volume with the SWAPFS you want to turn on.
</p></li><li class="listitem"><p>Select "Swap on...."</p></li><li class="listitem"><p>
Select the priority for the swap.  If you select "High" you will get an
	additional prompt for the priority level.  The priority level must be a number in
	the range of 0 to 32767.  The default is 0.
</p></li><li class="listitem"><p>Select "Swap on."</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3934"></a>3.1.3. Using the CLI</h4></div></div></div><p>To turn swap on with the CLI, use the following command:</p><pre class="programlisting">
Task: swapon, &lt;volume&gt;[, priority=low | , priority=high [level=0..32767]]
</pre><p>&lt;volume&gt; is the name of the volume with SWAPFS you want to turn on.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm3939"></a>3.2. Turning swap off</h3></div></div></div><p>This section tells how to turn swap off using the various EVMS user interfaces.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3942"></a>3.2.1. Using the EVMS GUI</h4></div></div></div><p>Follow these steps to turn swap off with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Volume tasks...</span>.
	</p></li><li class="listitem"><p>Select the volume you want to turn off swapping and click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select "Swap off" and click <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Swap off</span>.</p></li></ol></div><p>
</p><p>Alternatively, you can turn swap off from the EVMS GUI
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Right click the volume with the SWAPFS you want to turn off.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Swap off...</span></p></li><li class="listitem"><p>
	Click <span class="guibutton">Swap off</span>.</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3971"></a>3.2.2. Using Ncurses</h4></div></div></div><p>Follow these steps to turn swap off with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Other</span> &#8594; <span class="guimenuitem">Volume tasks...</span>.
	</p></li><li class="listitem"><p>Select the volume on which you want to turn off swapping and select
<span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select "Swap off" and select <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select "Swap off."</p></li></ol></div><p>
</p><p>Alternatively, you can turn swap on with the Ncurses
context-sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Highlight the volume with the SWAPFS you want to turn off.
</p></li><li class="listitem"><p>Select "Swap off...."</p></li><li class="listitem"><p>Select "Swap off."</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm3997"></a>3.2.3. Using the CLI</h4></div></div></div><p>To turn swap on with the CLI, use the following command:</p><pre class="programlisting">
Task: swapoff, &lt;volume&gt;
</pre><p>&lt;volume&gt; is the name of the volume with SWAPFS you want to turn off.</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="plugintasks"></a>Chapter 20. Plug-in operations tasks</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#aboutplugintasks">1. What are plug-in tasks?</a></span></dt><dt><span class="sect1"><a href="#pluginexample">2. Example: complete a plug-in operations task</a></span></dt><dd><dl><dt><span class="sect2"><a href="#plugingui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#plugintasksncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#plugincli">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses plug-in operations tasks and shows how to complete a plug-in task with the EVMS GUI, Ncurses, and CLI interfaces.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aboutplugintasks"></a>1. What are plug-in tasks?</h2></div></div></div><p>Plug-in tasks are functions that are available only within the context of a particular plug-in.  These functions are not common to all plug-ins.  For example, tasks to add spare disks to a RAID array make sense only in the context of the MD plug-in, and tasks to reset a snapshot make sense only in the context of the Snapshot plug-in.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pluginexample"></a>2. Example: complete a plug-in operations task</h2></div></div></div><p> This section shows how to complete a plug-in operations task with the EVMS GUI, Ncurses, and CLI interfaces.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm4012"></a><p class="title"><b>Example 20.1. Add a spare disk to a compatibility volume made from an MDRaid5 region</b></p><div class="example-contents"><p>This example adds disk <code class="filename">sde</code> as a spare disk onto volume <code class="filename">/dev/evms/md/md0</code>, which is a compatibility volume that was created from an MDRaid5 region.</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="plugingui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to add <code class="filename">sde</code> to <code class="filename">/dev/evms/md/md0</code>  with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Other</span> &#8594; <span class="guimenuitem">Storage Object Tasks...</span>
	</p></li><li class="listitem"><p>Select <span class="guimenu">md/md0</span>.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">Add spare object</span>.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select <span class="guimenu">sde</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Add</span>.
	</p></li><li class="listitem"><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you could use context-sensitive menus to 
complete the task, as follows:		

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>View the region <code class="filename">md/md0</code>.  You can view the region either 
	by clicking on the small plus sign beside the volume name 
	(<code class="filename">/dev/evms/md/md0</code>) on the <span class="guimenu">volumes tab</span>, 
	or by selecting the <span class="guimenu">regions tab</span>.</p></li><li class="listitem"><p>Right click the region (<code class="filename">md/md0</code>).  A list of acceptable
	Actions and Navigational shortcuts displays.  The last items on the
	list are the tasks that are acceptable at this time.</p></li><li class="listitem"><p>Point to <span class="guimenu">Add spare object</span> and 
	left click.</p></li><li class="listitem"><p>Select <span class="guimenu">sde</span>.</p></li><li class="listitem"><p>Click <span class="guibutton">Add</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="plugintasksncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to add <code class="filename">sde</code> to <code class="filename">/dev/evms/md/md0</code> with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Other</span> &#8594; <span class="guimenuitem">Storage Object Tasks</span>
	</p></li><li class="listitem"><p>Select
	<span class="guimenuitem">md/md0</span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select
	<span class="guimenuitem">Add spare object</span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.
	</p></li><li class="listitem"><p>Select
	<span class="guimenuitem">sde</span>.
	</p></li><li class="listitem"><p>Activate <span class="guibutton">Add</span>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can use the context sensitive menu to complete the task:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Regions view, press <span class="keycap"><strong>Enter</strong></span> on <span class="guimenuitem">md/md0</span>.</p></li><li class="listitem"><p>Activate the <span class="guimenuitem">Add spare object</span> menu item.</p></li><li class="listitem"><p>Select <span class="guimenuitem">sde</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Add</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="plugincli"></a>2.3. Using the CLI</h3></div></div></div><p>With the EVMS CLI, all plug-in tasks must be 
accomplished with the <span class="command"><strong>task</strong></span> command.  Follow these steps 
to add <code class="filename">sde</code> to <code class="filename">/dev/evms/md/md0</code> 
with the CLI:
	
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The following query command with the list 
	options filter to determines 
	the acceptable tasks for a particular object and the name-value 
	pairs it supports. The command returns information about which
	plug-in tasks are available at the current time and provides
	the information necessary for you to complete the command.
	</p><pre class="programlisting">query: objects, object=md/md0, list options</pre></li><li class="listitem"><p>The command takes the name of the task 
	(returned from the previous query), the object to operate on 
	(in this case, md/md0), any required options (none in this case) 
	and, if necessary, another object to be manipulated 
	(in our example, <code class="filename">sde</code>, which is the spare disk 
	we want to add):

	</p><pre class="programlisting">task: addspare, md/md0, sde</pre><p>

	The command is completed upon saving.</p></li></ol></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="deleterecurs"></a>Chapter 21. Deleting objects</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#howtodel">1. How to delete objects: delete and delete recursive</a></span></dt><dt><span class="sect1"><a href="#examdelrecur">2. Example: perform a delete recursive operation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mkfsgui">2.1. Using the EVMS GUI</a></span></dt><dt><span class="sect2"><a href="#mkfsncurses">2.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#deleterecurcli">2.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter tells how to delete EVMS objects through the delete and
delete recursive operations.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="howtodel"></a>1. How to delete objects: delete and delete recursive</h2></div></div></div><p>There are two ways in EVMS that you can destroy objects that you 
no longer want: Delete and Delete Recursive.  
The Delete option destroys only the specific object you specify.  
The Delete Recursive option destroys the object you specify and its 
underlying objects, down to the container, if one exists, or else 
down to the disk.  
In order for a volume to be deleted, it must not be mounted.  
EVMS verifies that the volume you are attempting to delete is not 
mounted and does not perform the deletion if the volume is mounted.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examdelrecur"></a>2. Example: perform a delete recursive operation</h2></div></div></div><p> The following example shows how to destroy a volume and the objects below it with the EVMS GUI, Ncurses, and CLI interfaces.</p><div class="blockquote"><blockquote class="blockquote"><div class="example"><a name="idm4143"></a><p class="title"><b>Example 21.1. Destroy a volume and the region and container below it</b></p><div class="example-contents"><p>This example uses the delete recursive operation to destroy volume <code class="filename">/dev/evms/Sample Volume</code> and the region and container below it.  Volume <code class="filename">/dev/evms/Sample Volume</code> is the volume that was created in earlier.  Although we could also use the delete option on each of the objects, the delete recursive option takes fewer steps.  Note that because we intend to delete the container as well as the volume, the operation needs to be performed in two steps: one to delete the volume and its contents, and one to delete the container and its contents.
</p></div></div><br class="example-break"></blockquote></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mkfsgui"></a>2.1. Using the EVMS GUI</h3></div></div></div><p>Follow these steps to delete the volume and the container with the EVMS GUI:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Volume</span>.
	</p></li><li class="listitem"><p>Select volume <span class="guimenuitem">/dev/evms/Sample Volume</span>
	from the list.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Recursive Delete</span>.  This step deletes the volume 
	and the region <code class="filename">lvm/Sample Container/Sample Region</code>.  If you want to 
	keep the 
	underlying pieces or want to delete each piece separately, you would click 
	<span class="guibutton">Delete</span> instead of <span class="guibutton">Delete Recursive</span>.
	</p></li><li class="listitem"><p>Assuming you chose Delete Recursive (if not, delete the region before
	continuing with these steps), select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Container</span>.
	</p></li><li class="listitem"><p>Select container <span class="guimenuitem">lvm/Sample Container</span> from the list.
	</p></li><li class="listitem"><p>Click <span class="guibutton">Recursive Delete</span> to destroy the container and anything
	under it.  Alternatively, click <span class="guibutton">Delete</span> to destroy only the container (if you built the container on
	 disks as in the example, either command has the same effect).
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the volume deletion steps with the GUI context
sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Volumes</span> tab, right click 
	<code class="filename">/dev/evms/Sample Volume</code>.</p></li><li class="listitem"><p>Click <span class="guimenuitem">Delete...</span></p></li><li class="listitem"><p>Continue with the operation beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="mkfsncurses"></a>2.2. Using Ncurses</h3></div></div></div><p>Follow these steps to delete the volume and the container with Ncurses:

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Volume</span>.
	</p></li><li class="listitem"><p>Select volume
	 <span class="guimenuitem">/dev/evms/Sample Volume</span> from the list.
	</p></li><li class="listitem"><p>Activate 
	<span class="guibutton">Delete Volume Recursively</span>. 
	This step deletes the volume and the region 
	<code class="filename">lvm/Sample Container/Sample Region</code>.  If you want to keep the 
	underlying pieces or want to delete each piece separately, activate 
	<span class="guibutton">Delete</span> instead of <span class="guibutton">Delete Recursive</span>.
	</p></li><li class="listitem"><p>Assuming you chose <span class="guimenuitem">Delete Volume Recursively</span> 
	(if not, delete the region before continuing with 
	these steps), select <span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Delete</span> &#8594; <span class="guimenuitem">Container</span>.
	</p></li><li class="listitem"><p>Select container
	<span class="guimenuitem">lvm/Sample Container</span> from the list.
	</p></li><li class="listitem"><p>Click 
	<span class="guimenuitem">Recursive Delete</span> to destroy the container and
	everything under it.  Alternatively, activate <span class="guibutton">Delete</span> to delete
	only the container (if you built the container on disks as in the
	example, either command has the same effect).</p></li><li class="listitem"><p>Press <span class="keycap"><strong>Enter</strong></span>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the volume deletion steps with the
context sensitive menu:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the Volumes view, press <span class="keycap"><strong>Enter</strong></span> on <span class="guimenuitem">/dev/evms/Sample Volume</span>.</p></li><li class="listitem"><p>Activate <span class="guibutton">Delete</span>.</p></li><li class="listitem"><p>Continue with the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="deleterecurcli"></a>2.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>delete</strong></span> and <span class="command"><strong>delete recursive</strong></span> 
	commands to destroy EVMS objects.
	Specify the command name followed by a colon, and then specify the 
	volume, object, or container name.  For example: 

</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Enter this command to perform the delete recursive 
operation:</p><pre class="programlisting">delete recursive: "/dev/evms/Sample Volume"</pre><p>This step deletes the volume and the region 
<code class="filename">/lvm/Sample Container/Sample Region</code>.  If you wanted to keep the
underlying pieces or wanted to delete each piece separately, use the <span class="command"><strong>delete</strong></span> command, as follows:</p><pre class="programlisting">delete: "/dev/evms/Sample Volume"</pre></li><li class="listitem"><p>Assuming you chose <span class="guimenuitem">Delete Volume Recursively</span> (if not, delete the region before
continuing with these steps) enter the following to destroy the container and everything under it:</p><pre class="programlisting">delete recursive: "lvm/Sample Container"</pre><p>To destroy only the container, enter the following:</p><pre class="programlisting">delete: "lvm/Sample Container"</pre></li></ol></div><p>
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="evmsreplaceobjects"></a>Chapter 22. Replacing objects</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#whatisobjectreplace">1. What is object-replace?</a></span></dt><dt><span class="sect1"><a href="#replacedlchildobj">2. Replacing a drive-link child object</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guiobjectreplace">2.1. Using the EVMS GUI or Ncurses</a></span></dt><dt><span class="sect2"><a href="#clireplace">2.2. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses how to replace objects.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whatisobjectreplace"></a>1. What is object-replace?</h2></div></div></div><p>Occasionally, you might wish to change the configuration of a volume or
storage object.  For instance, you might wish to replace one of the disks in a
drive-link or RAID-0 object with a newer, faster disk.  As another example, you
might have an EVMS volume created from a simple disk segment, and want to
switch that segment for a RAID-1 region to provide extra data redundancy.  
Object-replace accomplishes such tasks.</p><p>
Object-replace gives you the ability to swap one object for another object.
The new object is added while the original object is still in place.  The data is
then copied from the original object to the new object.  When this is complete,
the original object is removed.  This process can be performed while the volume is
mounted and in use.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replacedlchildobj"></a>2. Replacing a drive-link child object</h2></div></div></div><p>For this example, we will start with a drive-link object named <code class="filename">link1</code>, 
which is composed of two disk segments named sda1 and sdb1.  The goal is to replace
sdb1 with another segment named sdc1.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The drive-linking plug-in allows the target object (sdc1 in this
example) to be the same size or larger than the source object.
If the target is larger, the extra space will be unused.  Other plug-ins
have different restrictions and might require that both objects be the 
same size.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guiobjectreplace"></a>2.1. Using the EVMS GUI or Ncurses</h3></div></div></div><p>Follow these steps to replace sdb1 with sdc1:
	</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Select
		<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Replace.</span>
		</p></li><li class="listitem"><p>In the "Replace Source Object" panel select
		<span class="guimenuitem">sdb1</span>.
		</p></li><li class="listitem"><p>Activate <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>In the "Select Replace Target Object" panel, select 
		<span class="guimenuitem">sdc1</span>. 			</p></li><li class="listitem"><p>Activate <span class="guibutton">Replace</span>.</p></li></ol></div><p>Alternatively, you can perform these same steps with the
context sensitive menus:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the "Disk Segments" panel, right click (or Press
	<span class="keycap"><strong>Enter</strong></span> on) the object 
	<span class="guimenuitem">sdb1</span>.</p></li><li class="listitem"><p>Choose <span class="guimenuitem">Replace</span> on the popup menu.</p></li><li class="listitem"><p>In the "Select Replace Target Object" panel, select
	<span class="guimenuitem">sdc1.</span></p></li><li class="listitem"><p>Activate <span class="guibutton">Replace</span>.</p></li></ol></div><p>When you save changes, EVMS begins to copy the data from sdb1 to sdc1.
The status bar at the bottom of the UI will reflect the percent-complete of the
copy operation.  The UI must remain open until the copy is finished.  At that time,
the object sdb1 will be moved to the "Available Objects" panel.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="clireplace"></a>2.2. Using the CLI</h3></div></div></div><p>Use the <span class="command"><strong>Replace</strong></span> to replace objects with
the CLI:</p><pre class="programlisting">
Replace:source_object_name, target_object_name
</pre><p>
"source_object_name" is the name of the object you wish to replace with
"target_object_name."  In the following example, sdb1 is replaced with
sdc1.
</p><pre class="programlisting">
Replace:sdb1,sdc1
</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="segstorobjs"></a>Chapter 23. Moving segment storage objects</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#segmovewhatis">1. What is segment moving?</a></span></dt><dt><span class="sect1"><a href="#whymove">2. Why move a segment?</a></span></dt><dt><span class="sect1"><a href="#idm4331">3. Which segment manager plug-ins implement the move function?</a></span></dt><dt><span class="sect1"><a href="#movesegex">4. Example: move a DOS segment</a></span></dt><dd><dl><dt><span class="sect2"><a href="#guimoveseg">4.1. Using the EVMS GUI context sensitive menu</a></span></dt><dt><span class="sect2"><a href="#ncursmoveseg">4.2. Using Ncurses</a></span></dt><dt><span class="sect2"><a href="#clisegmove">4.3. Using the CLI</a></span></dt></dl></dd></dl></div><p>This chapter discusses how and why to move segments.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="segmovewhatis"></a>1. What is segment moving?</h2></div></div></div><p>A segment move is when a data segment is relocated to another
location on the underlying storage object.  The new location of
the segment cannot overlap with the current segment location.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="whymove"></a>2. Why move a segment?</h2></div></div></div><p>
Segments are moved for a variety of reasons.  The most compelling among
them is to make better use of disk freespace.  Disk freespace is an unused
contiguous extent of sectors on a disk that has been identified by EVMS
as a freespace segment.  A data segment can only be expanded by adding
sectors to the end of the segment, moving the end of the data segment
up into the freespace that immediately follows the data segment.  However,
what if there is no freespace following the data segment?  A segment or
segments could
be moved around to put freespace after the segment that is to be
expanded.  For example:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The segment following the segment to be expanded can be moved
elsewhere on the disk, thus freeing up space after the segment that
is to be expanded.</p></li><li class="listitem"><p>The segment to be expanded can be moved into freespace where
there is more room for the segment to be expanded.
</p></li><li class="listitem"><p>The segment can be moved into freespace that precedes the
segment so that after the move the data segment can be expanded into the freespace
created by the move.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm4331"></a>3. Which segment manager plug-ins implement the move function?</h2></div></div></div><p>The following segment manager plug-ins support the move function:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
DOS
</p></li><li class="listitem"><p>
s390
</p></li><li class="listitem"><p>
GPT
</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="movesegex"></a>4. Example: move a DOS segment</h2></div></div></div><p> This section shows how to move a DOS segment:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
In the following example, the DOS segment manager has a single
primary partition on disk sda that is located at the very end of the disk.
We want to move it to the front of the drive because we want to expand
the segment but there is currently no freespace following the segment.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="guimoveseg"></a>4.1. Using the EVMS GUI context sensitive menu</h3></div></div></div><p>To move the DOS segment through the GUI context sensitive menu,
follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>From the <span class="guimenuitem">Segments</span> 
		tab, right click
		<code class="filename">sda1</code>.
		</p></li><li class="listitem"><p>Click <span class="guibutton">Move</span>.</p></li><li class="listitem"><p>Select <code class="filename">sda_freespace1</code>.
		</p></li><li class="listitem"><p>Click <span class="guibutton">Move</span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="ncursmoveseg"></a>4.2. Using Ncurses</h3></div></div></div><p>To move the DOS segment, follow these steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Use <span class="keycap"><strong>Tab</strong></span> 
		 to select the Disk Segments view.
		</p></li><li class="listitem"><p>Scroll down with the down arrow and
		select <code class="filename">sda1</code>.</p></li><li class="listitem"><p>Press 
		<span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Scroll down with the down arrow and
		select <span class="guibutton">Move</span> by pressing
		<span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Use the spacebar to select
		<code class="filename">sda_freespace1</code>.</p></li><li class="listitem"><p>Use <span class="keycap"><strong>Tab</strong></span> 
		 to select <span class="guibutton">Move</span> and press
		<span class="keycap"><strong>Enter</strong></span>.
		</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="clisegmove"></a>4.3. Using the CLI</h3></div></div></div><p>Use the
	<span class="command"><strong>task</strong></span> command to move a DOS segment with the CLI.  
</p><pre class="programlisting">task:Move,sda1,sda_freespace1</pre></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appxdos"></a>Appendix A. The DOS plug-in</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#DOShow">1. How the DOS plug-in is implemented</a></span></dt><dt><span class="sect1"><a href="#assignDOS">2. Assigning the DOS plug-in</a></span></dt><dt><span class="sect1"><a href="#creatingDOS">3. Creating DOS partitions</a></span></dt><dt><span class="sect1"><a href="#expandDOS">4. Expanding DOS partitions</a></span></dt><dt><span class="sect1"><a href="#shrinkDOS">5. Shrinking DOS partitions</a></span></dt><dt><span class="sect1"><a href="#deleteDOS">6. Deleting partitions</a></span></dt></dl></div><p>The DOS plug-in is the most commonly used EVMS segment manager
plug-in.  The DOS plug-in supports DOS disk partitioning as well as:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>OS/2 partitions that require extra metadata sectors.</p></li><li class="listitem"><p>Embedded partition tables: SolarisX86, BSD, and UnixWare.</p></li></ul></div><p>The DOS plug-in reads metadata and constructs segment storage
objects that provide mappings to disk partitions.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DOShow"></a>1. How the DOS plug-in is implemented</h2></div></div></div><p>The DOS plug-in provides compatibility with DOS partition tables.
The plug-in produces EVMS segment storage objects that map primary partitions
described by the MBR partition table and logical partitions
described by EBR partition tables.
</p><p>DOS partitions have names that are constructed from two pieces
of information:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The device they are found on.</p></li><li class="listitem"><p>The partition table entry that provided the information.</p></li></ul></div><p>Take, for example, partition name <code class="filename">hda1</code>, which 
describes a partition that is found on device <code class="filename">hda</code> 
in the MBR partition table.
DOS partition tables can hold four entries.
Partition numbers 1-4 refer to MBR partition records.  Therefore, our
example is telling us that partition <code class="filename">hda1</code> is described
by the very first partition record entry in the MBR partition table.
Logical partitions, however, are different than primary partitions.
EBR partition tables are scattered across a disk but are linked together
in a chain that is first located using an extended partition record found
in the MBR partition table.
Each EBR partition table contains a partition record that describes a logical
partition on the disk.
The name of the logical partition reflects its position in the EBR chain.
Because the MBR partition table reserves numerical names 1-4, the very
first logical partition is always named 5.
The next logical partition, found by following the EBR chain, is called 6,
and so forth.
So, the partition <code class="filename">hda5</code> is a logical partition that is
described by a partition record in the very first EBR partition table.
</p><p>While discovering DOS partitions, the DOS plug-in also looks for
OS/2 DLAT metadata to further determine if the disk is an OS/2 disk.
An OS/2 disk has additional metadata and the metadata is validated during
recovery.
This information is important for the DOS plug-in to know because an OS/2 
disk must maintain additional partition information.  (This is why the 
DOS plug-in asks, when being assigned to a disk, if the disk is a
Linux disk or an OS/2 disk.)  The DOS plug-in needs to know how much
information must be kept on the disk and what kind of questions it should
ask the user when obtaining the information.
</p><p>
An OS/2 disk can contain compatibility volumes as well as logical volumes.
A compatibility volume is a single partition with an assigned drive
letter that can be mounted.  An OS/2 logical volume is a drive link of 1
or more partitions that have software bad-block relocation at the
partition level.
</p><p>
Embedded partitions, like those found on a SolarisX86 disk or a BSD
compatibility disk, are found within a primary partition.
Therefore, the DOS plug-in inspects primary partitions that it has
just discovered to further determine if any embedded partitions exist.
Primary partitions that hold embedded partition tables have partition
type fields that indicate this. 
For example, a primary partition of type 0xA9 probably has a BSD partition
table that subdivides the primary partition into BSD partitions.
The DOS plug-in looks for a BSD disk label and BSD data partitions in the
primary partition.
If the DOS plug-in finds a BSD disk label, it exports the BSD partitions.  Because
this primary partition is actually just a container that holds the BSD
partitions, and not a data partition itself, it is not exported by the
DOS plug-in.
Embedded partitions are named after the primary partition they were
discovered within.  As an example, <code class="filename">hda3.1</code> is
the name of the first embedded partition found within primary partition
<code class="filename">hda3</code>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="assignDOS"></a>2. Assigning the DOS plug-in</h2></div></div></div><p>
Assigning a segment manager to a disk means that you want the plug-in
to manage partitions on the disk.
In order to assign a segment manager to a disk, the plug-in needs to 
create and maintain the appropriate metadata, which is accomplished
through the "disk type" option.
When you specify the "disk type" option and choose
Linux or OS/2, the plug-in knows what sort of metadata it needs to keep
and what sort of questions it should ask when creating partitions.
</p><p>
An additional OS/2 option is the "disk name" option, by which you can 
provide a name for the disk that will be saved in OS/2 metadata and that
will be persistent across reboots.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="creatingDOS"></a>3. Creating DOS partitions</h2></div></div></div><p>
There are two basic DOS partition types:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A primary partition, which is described by a partition record
in the MBR partition table.</p></li><li class="listitem"><p>A logical partition, which is described by a partition record
in the EBR partition table.</p></li></ol></div><p>Every partition table has room for four partition records; however,
there are a few rules that impose limits on this.
</p><p>
An MBR partition table can hold four primary partition records unless you
also have logical partitions.
In this case, one partition record is used to describe an extended
partition and the start of the EBR chain that in turn describes
logical partitions.
</p><p>
Because all logical partitions must reside in the extended partition, you
cannot allocate room for a primary partition within the extended partition 
and you
cannot allocate room for a logical partition outside or adjacent to this area.
</p><p>
Lastly, an EBR partition table performs two functions:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>It describes a logical partition and therefore uses a partition
record for this purpose.</p></li><li class="listitem"><p>It uses a partition record to locate the next EBR partition table.</p></li></ol></div><p>
EBR partition tables use at most two entries.</p><p>
When creating a DOS partition, the options you are presented with depend
on the kind of disk you are working with.  However, both OS/2 disks and
Linux disks require that you choose a freespace segment on the disk
within which to create the new data segment.  The create options are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">size</span></dt><dd><p>The size of the partition you are creating.
Any adjustments that are needed for alignment are performed by the
DOS plug-in and the resulting size might differ slightly from the
value you enter.
</p></dd><dt><span class="term">offset</span></dt><dd><p>Lets you skip sectors and
start the new partition within the freespace area by specifying a
sector offset.
</p></dd><dt><span class="term">type</span></dt><dd><p>Lets you enter a partition type or choose from a list of
partition types; for example, native Linux.
</p></dd><dt><span class="term">primary</span></dt><dd><p>Lets you  choose between creating a primary or logical partition.
Due to the rules outlined above, you might or might not have a choice.
The DOS plug-in can determine if a primary or logical partition can be
created in the freespace area you chose and disable this choice.
</p></dd><dt><span class="term">bootable</span></dt><dd><p>Lets you  enable the sys_ind flag field in a primary partition
and disable it when creating a logical partition.
The sys_ind flag field identifies the active primary partition for booting.
</p></dd></dl></div><p>
Additional OS/2 options are the following:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">partition name</span></dt><dd><p>
An OS/2 partition can have a name, like Fred or Part1.
</p></dd><dt><span class="term">volume name</span></dt><dd><p>
OS/2 partitions belong to volumes, either
compatibility or logical, and volumes have names.  However, because
the DOS plug-in is not a logical volume manager, it cannot actually
create OS/2 logical volumes.
</p></dd><dt><span class="term">drive letter</span></dt><dd><p>You can specify the drive letter for an OS/2 partition, but it
is not a required field.  Valid drive letters are: C,D...Z.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandDOS"></a>4. Expanding DOS partitions</h2></div></div></div><p>
A partition is a physically contiguous run of sectors on a disk.
You can expand a partition by adding unallocated sectors to the initial
run of sectors on the disk.  Because the partition must remain physically
contiguous, a partition can only be expanded by growing into an unused
area on the disk.
These unused areas are exposed by the DOS plug-in as freespace segments.
Therefore, a data segment is only expandable if a freespace segment
immediately follows it.  Lastly, because a DOS partition must end on a
cylinder boundary, DOS segments are expanded in
cylinder size increments.  This means that if the DOS segment you want
to expand is followed by a freespace segment, you might be unable to
expand the DOS segment if the freespace segment is less than a cylinder
in size.
</p><p>
There is one expand option, as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">size</span></dt><dd><p>
This is the amount by which you want to expand the data segment.  The amount must
be a multiple of the disk's cylinder size.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shrinkDOS"></a>5. Shrinking DOS partitions</h2></div></div></div><p>
A partition is shrunk when sectors are removed from the end of the
partition.
Because a partition must end on a cylinder boundary, a partition is
shrunk by removing cylinder amounts from the end of the segment.</p><p>
There is one shrink option, as follows:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">size</span></dt><dd><p>The amount by which you want to reduce the size of the segment.
Because a segment ends on a cylinder boundary, this value must be
some multiple of the disk's cylinder size.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deleteDOS"></a>6. Deleting partitions</h2></div></div></div><p>You can delete an existing DOS data segment as long as it is not
currently a compatibility volume, an EVMS volume, or consumed by another
EVMS plug-in.
No options are available for deleting partitions.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appxmdreg"></a>Appendix B. The MD region manager</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#characraidlvls">1. Characteristics of Linux RAID levels</a></span></dt><dd><dl><dt><span class="sect2"><a href="#linearmode">1.1. Linear mode</a></span></dt><dt><span class="sect2"><a href="#raid0">1.2. RAID-0</a></span></dt><dt><span class="sect2"><a href="#raid1">1.3. RAID-1</a></span></dt><dt><span class="sect2"><a href="#raid45">1.4. RAID-4/5</a></span></dt><dt><span class="sect2"><a href="#multipath">1.5. Multipath</a></span></dt></dl></dd><dt><span class="sect1"><a href="#createmdreg">2. Creating an MD region</a></span></dt><dd><dl><dt><span class="sect2"><a href="#raid0options">2.1. RAID-0 options</a></span></dt><dt><span class="sect2"><a href="#raid2options">2.2. RAID-1 options</a></span></dt><dt><span class="sect2"><a href="#raid45options">2.3. RAID-4/5 options</a></span></dt></dl></dd><dt><span class="sect1"><a href="#activepsareobjs">3. Active and spare objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#addspareobjs">3.1. Adding spare objects</a></span></dt><dt><span class="sect2"><a href="#remspareobjs">3.2. Removing spare objects</a></span></dt><dt><span class="sect2"><a href="#addactobjsr1">3.3. Adding active objects to RAID-1</a></span></dt></dl></dd><dt><span class="sect1"><a href="#faultobjs">4. Faulty objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#remfaultyobjs">4.1. Removing faulty objects</a></span></dt><dt><span class="sect2"><a href="#fixtempfailedobjs">4.2. Fixing temporarily failed objects</a></span></dt><dt><span class="sect2"><a href="#markobjsfaulty">4.3. Marking objects faulty</a></span></dt></dl></dd><dt><span class="sect1"><a href="#resizemdreg">5. Resizing MD regions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#linear">5.1. Linear</a></span></dt><dt><span class="sect2"><a href="#resizeraid0">5.2. RAID-0</a></span></dt><dt><span class="sect2"><a href="#resizeraid1">5.3. RAID-1</a></span></dt><dt><span class="sect2"><a href="#resizeRAID-45">5.4. RAID-4/5</a></span></dt></dl></dd><dt><span class="sect1"><a href="#replaceobjs">6. Replacing objects</a></span></dt></dl></div><p>
The Multi-Disk (MD) driver in the Linux kernel and the MD plug-in in
EVMS provide a software implementation of RAID (Redundant Array of
Inexpensive Disks).  The basic idea of software RAID is to combine
multiple hard disks into an array of disks in order to improve capacity,
performance, and reliability.
</p><p>
The RAID standard defines a wide variety of methods for combining disks
into a RAID array.
In Linux, MD implements a subset of the full RAID standard, including
RAID-0, RAID-1, RAID-4, and RAID-5.  In addition, MD also supports
additional combinations called Linear-RAID and Multipath.
</p><p>
In addition to this appendix, more information about RAID and the
Linux MD driver can be found in the Software RAID HOWTO at
<a class="ulink" href="http://www.tldp.org/HOWTO/Software-RAID-HOWTO.html" target="_top">www.tldp.org/HOWTO/Software-RAID-HOWTO.html</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="characraidlvls"></a>1. Characteristics of Linux RAID levels</h2></div></div></div><p>
All RAID levels are used to combine multiple devices into a single MD
array.
The MD plug-in is a region-manager, so EVMS refers to MD arrays as "regions."
MD can create these regions using disks, segments or other regions.
This means that it's possible to create RAID regions using other RAID
regions, and thus combine multiple RAID levels within a single volume stack.
</p><p>
The following subsections describe the characteristics of each Linux RAID
level.
Within EVMS, these levels can be thought of as sub-modules of the MD plug-in.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="linearmode"></a>1.1. Linear mode</h3></div></div></div><p>
Linear-RAID regions combine objects by appending them to each other.
Writing (or reading) linearly to the MD region starts by writing to the
first child object.
When that object is full, writes continue on the second child object, and so
on until the final child object is full.
Child objects of a Linear-RAID region do not have to be the same size.
</p><p>
Advantage:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Linear-RAID provides a simple method for building very large regions
using several small objects.
</p></li></ul></div><p>
Disadvantages:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Linear-RAID is not "true" RAID, in the sense that there is no data
redundancy.  If one disk crashes, the RAID region will be unavailable,
and will result in a loss of some or all data on that region.
</p></li><li class="listitem"><p>
Linear-RAID provides little or no performance benefit.
The objects are combined in a simple, linear fashion that doesn't allow
for much (if any) I/O in parallel to multiple child objects.
The performance of a Linear-RAID will generally be equivalent to
the performance of a single disk.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid0"></a>1.2. RAID-0</h3></div></div></div><p>
RAID-0 is usually referred to as "striping."
This means that data in a RAID-0 region is evenly distributed and
interleaved on all the child objects.
For example, when writing 16 KB of data to a RAID-0 region with
three child objects and a chunk-size of 4 KB, the data would be written
as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
4 KB to object 0
</p></li><li class="listitem"><p>
4 KB to object 1
</p></li><li class="listitem"><p>
4 KB to object 2
</p></li><li class="listitem"><p>
4 KB to object 0
</p></li></ul></div><p>
Advantages:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Like Linear-RAID, RAID-0 provides a simple method for building very
large regions using several small objects.
</p></li><li class="listitem"><p>
In general, RAID-0 provides I/O performance improvements, because it can
break large I/O requests up and submit them in parallel across
several disks.
</p></li></ul></div><p>
Disadvantage:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Also like Linear-RAID, RAID-0 is not "true" RAID, in the sense that there
is no data redundancy (hence the name RAID "zero").  If one disk crashes,
the RAID region will be unavailable, and will likely result in a loss of all
data on that region.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid1"></a>1.3. RAID-1</h3></div></div></div><p>
RAID-1 is usually referred to as "mirroring."  Each child object in a
RAID-1 region contains an identical copy of the data in the region.
A write to a RAID-1 region results in that data being written
simultaneously to all child objects.
A read from a RAID-1 region can result in reading the data from any
one of the child objects.
Child objects of a RAID-1 region do not have to be the same size, but the
size of the region will be equal to the size of the smallest child object.
</p><p>
Advantages:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
RAID-1 provides complete data redundancy. In a RAID-1 region made from
N child objects, up to N-1 of those objects can crash and the region will
still be operational, and can retrieve data from the remaining objects.
</p></li><li class="listitem"><p>
RAID-1 can provide improved performance on I/O-reads.  Because all child
objects contain a full copy of the data, multiple read requests can be
load-balanced among all the objects.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
RAID-1 can cause a decrease in performance on I/O-writes.
Because each child object must have a full copy of the data, each
write to the region must be duplicated and sent to each object.
A write request cannot be completed until all duplicated writes to
the child objects are complete.
</p></li><li class="listitem"><p>
A RAID-1 region with N disks costs N times as much as a single disk, but
only provides the storage space of a single disk.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid45"></a>1.4. RAID-4/5</h3></div></div></div><p>
RAID-4/5 is often referred to as "striping with parity."  Like RAID-0,
the data in a RAID-4/5 region is striped, or interleaved, across all the
child objects.
However, in RAID-4/5, parity information is also calculated and recorded
for each stripe of data in order to provide redundancy in case one of
the objects is lost.
In the event of a disk crash, the data from that disk can be recovered
based on the data on the remaining disks and the parity information.
</p><p>
In RAID-4 regions, a single child object is used to store the parity
information for each data stripe.  However, this can cause an I/O
bottleneck on this one object, because the parity information must be
updated for each I/O-write to the region.
</p><p>
In RAID-5 regions, the parity is spread evenly across all the child
objects in the region, thus eliminating the parity bottleneck in RAID-4.
RAID-5 provides four different algorithms for how the parity is
distributed.  In fact, RAID-4 is often thought of as a special case of
RAID-5 with a parity algorithm that simply uses one object instead of
all objects.  This is the viewpoint that Linux and EVMS use.
Therefore, the RAID-4/5 level is often just referred to as RAID-5, with
RAID-4 simply being one of the five available parity algorithms.
</p><p>Advantages and disadvantages</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Like RAID-1, RAID-4/5 provides redundancy in the event of a hardware
failure.
However, unlike RAID-1, RAID-4/5 can only survive the loss of a
single object.
This is because only one object's worth of parity is recorded.
If more than one object is lost, there isn't enough parity information
to recover the lost data.
</p></li><li class="listitem"><p>
RAID-4/5 provides redundancy more cost effectively than RAID-1.
A RAID-4/5 region with N disks provides N-1 times the storage space of a
single disk.
The redundancy comes at the cost of only a single disk in the region.
</p></li><li class="listitem"><p>
Like RAID-0, RAID-4/5 can generally provide an I/O performance
improvement, because large I/O requests can be broken up and submitted
in parallel to the multiple child objects.  However, on I/O-writes the
performance improvement will be less than that of RAID-0, because the
parity information must be calculated and rewritten each time a write
request is serviced.
In addition, in order to provide any performance improvement on 
I/O-writes, an in-memory cache must be maintained for recently accessed
stripes so the parity information can be quickly recalculated.
If a write request is received for a stripe of data that isn't in the
cache, the data chunks for the stripe must first be read from disk in
order to calculate the parity.  If such cache-misses occur too often,
the I/O-write performance could potentially be worse than even a
Linear-RAID region.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="multipath"></a>1.5. Multipath</h3></div></div></div><p>
A multipath region consists of one or more objects, just like the other
RAID levels.  However, in multipath, the child objects actually
represent multiple physical paths to the same physical disk.  Such setups
are often found on systems with fiber-attached storage devices or SANs.
</p><p>
Multipath is not actually part of the RAID standard, but was added
to the Linux MD driver because it provides a convenient place to create
"virtual" devices that consist of multiple underlying devices.
</p><p>
The previous RAID levels can all be created using a wide variety of
storage devices, including generic, locally attached disks (for example, 
IDE and SCSI).  However, Multipath can only be used if the hardware
actually contains multiple physical paths to the storage device, and
such hardware is usually available on high-end systems with fiber-or 
network-attached storage.  Therefore, if you don't know whether you
should be using the Multipath module, chances are you don't need to use it.
</p><p>
Like RAID-1 and RAID-4/5, Multipath provides redundancy against
hardware failures.
However, unlike these other RAID levels, Multipath protects against
failures in the paths to the device, and not failures in the device
itself.  If one of the paths is lost (for example, a network adapter
breaks or a fiber-optic cable is removed), I/O will be redirected to the
remaining paths.
</p><p>
Like RAID-0 and RAID-4/5, Multipath can provide I/O performance
improvements by load balancing I/O requests across the various paths.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createmdreg"></a>2. Creating an MD region</h2></div></div></div><p>
The procedure for creating a new MD region is very similar for all the
different RAID levels.
When using the EVMS GUI or Ncurses, first choose the 
<span class="guimenu">Actions</span><span class="guimenuitem">Create</span>
<span class="guimenuitem">Region</span> menu item.
A list of region-managers will open, and each RAID level will appear
as a separate plug-in in this list.
Select the plug-in representing the desired RAID level.
The next panel will list the objects available for creating a new RAID
region.
Select the desired objects to build the new region.
If the selected RAID level does not support any additional options,
then there are no more steps, and the region will be created.
If the selected RAID level has extra creation options, the next
panel will list those options.
After selecting the options, the region will be created.
</p><p>
When using the CLI, use the following command to create a new region:
</p><pre class="programlisting">
create:region,&lt;plugin&gt;={&lt;option_name&gt;=&lt;value&gt;[,&lt;option_name&gt;=&lt;value&gt;]*},
   &lt;object_name&gt;[,&lt;object_name&gt;]*
</pre><p>
For &lt;plugin&gt;, the available plug-in names are "MDLinearRegMgr,"
"MDRaid0RegMgr," "MDRaid1RegMgr," "MDRaid5RegMgr," and "MD Multipath."
The available options are listed in the following sections.
If no options are available or desired, simply leave the space blank
between the curly braces.
</p><p>
The Linear-RAID and Multipath levels provide no extra options for
creation.  The remaining RAID levels provide the options listed below.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid0options"></a>2.1. RAID-0 options</h3></div></div></div><p>
RAID-0 has the following option:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">chunksize</span></dt><dd><p>
This option represents the granularity of the striped data.
In other words, the amount of data that is written to one child
object before moving to the next object.  The range of valid values is
4 KB to 4096 KB, and must be a power of 2.  If the option is not
specified, the default chunk size of 32 KB will be used.
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid2options"></a>2.2. RAID-1 options</h3></div></div></div><p>
RAID-1 has the following option:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">sparedisk</span></dt><dd><p>
This option is the name of another object to use as a "hot-spare."
This object cannot be one of the objects selected in the initial
object-selection list.
If no object is selected for this option, then the new region will
simply not initially have a spare.
More information about spare objects is in the following sections.
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="raid45options"></a>2.3. RAID-4/5 options</h3></div></div></div><p>
RAID-4/5 have the following options:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">chunksize</span></dt><dd><p>
This is the same as the chunksize option for RAID-0.
</p></dd><dt><span class="term">sparedisk</span></dt><dd><p>
This is the same as the sparedisk option for RAID-1.
</p></dd><dt><span class="term">level</span></dt><dd><p>
Choose between RAID4 and RAID5.  The default value for this option is RAID5.
</p></dd><dt><span class="term">algorithm</span></dt><dd><p>
If the RAID-5 level is chosen, this option allows choosing the
desired parity algorithm.
Valid choices are "Left Symmetric" (which is the default),
"Right Symmetric," "Left Asymmetric, and "Right Asymmetric."
If the RAID-4 level is chosen, this option is not available.
</p></dd></dl></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="activepsareobjs"></a>3. Active and spare objects</h2></div></div></div><p>
An active object in a RAID region is one that is actively used by the
region and contains data or parity information.
When creating a new RAID region, all the objects selected from the
main available-objects panel will be active objects.
Linear-RAID and RAID-0 regions only have active objects, and if any
of those active objects fail, the region is unavailable.
</p><p>
On the other hand, the redundant RAID levels (1 and 4/5) can have spare
objects in addition to their active objects.
A spare is an object that is assigned to the region, but does not
contain any live data or parity.  Its primary purpose is to act as a
"hot standby" in case one of the active objects fails.
</p><p>
In the event of a failure of one of the child objects, the MD kernel
driver removes the failed object from the region.
Because these RAID levels provide redundancy (either in the form of
mirrored data or parity information), the whole region can continue
providing normal access to the data.
However, because one of the active objects is missing, the region is
now "degraded."
</p><p>
If a region becomes degraded and a spare object has been assigned to
that region, the kernel driver will automatically activate that spare object.
This means the spare object is turned into an active object.  However,
this newly active object does not have any data or parity information,
so the kernel driver must "sync" the data to this object.
For RAID-1, this means copying all the data from one of the current
active objects to this new active object.
For RAID-4/5, this means using the data and parity information from the
current active objects to fill in the missing data and parity on the
new active object.
While the sync process is taking place, the region remains in the
degraded state.
Only when the sync is complete does the region return to the full
"clean" state.
</p><p>
You can follow the progress of the sync process by examining the
<code class="filename">/proc/mdstat</code> file.
You can also control the speed of the sync process using the files
<code class="filename">/proc/sys/dev/raid/speed_limit_min</code> and
<code class="filename">/proc/sys/dev/raid/speed_limit_max</code>.  To speed up the
process, echo a larger number into the <code class="filename">speed_limit_min</code>
file.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="addspareobjs"></a>3.1. Adding spare objects</h3></div></div></div><p>
As discussed above, a spare object can be assigned to a RAID-1 or 
RAID-4/5 region when the region is created.
In addition, a spare object can also be added to an already existing
RAID region.
The effect of this operation is the same as if the object were
assigned when the region was created.
</p><p>
If the RAID region is clean and operating normally, the kernel driver
will add the new object as a regular spare, and it will act as a hot-standby
for future failures.
If the RAID region is currently degraded, the kernel driver will
immediately activate the new spare object and begin syncing the data
and parity information.
</p><p>
For both RAID-1 and RAID-4/5 regions, use the "addspare" plug-in function
to add a new spare object to the region.  The only argument is the
name of the desired object, and only one spare object can be added at a time.
For RAID-1 regions, the new spare object must be at least as big as the
region, and for RAID-4/5 regions, the new spare object must be at least
as big as the smallest active object.
</p><p>
Spare objects can be added while the RAID region is active and in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="remspareobjs"></a>3.2. Removing spare objects</h3></div></div></div><p>
If a RAID-1 or RAID-4/5 region is clean and operating normally, and
that region has a spare object, the spare object can be removed from
the region if you need to use that object for another purpose.
</p><p>
For both RAID-1 and RAID-4/5 regions, use the "remspare" plug-in
function to remove a spare object from the region.
The only argument is the name of the desired object, and only one spare
object can be removed at a time.
After the spare is removed, that object will show up in the Available-Objects
list in the EVMS user interfaces.
</p><p>
Spare objects can be removed while the RAID region is active and in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="addactobjsr1"></a>3.3. Adding active objects to RAID-1</h3></div></div></div><p>
In RAID-1 regions, every active object has a full copy of the data for
the region.
This means it is easy to simply add a new active object, sync the
data to this new object, and thus increase the "width" of the mirror.
For instance, if you have a 2-way RAID-1 region, you can add a new
active object, which will increase the region to a 3-way mirror, which
increases the amount of redundancy offered by the region.
</p><p>
The first process of adding a new active object can be done in one of
two ways.  First, the "addactive" plug-in function adds any
available object in EVMS to the region as a new active object.
The new object must be at least as big as the size of the RAID-1 region.
Second, if the RAID-1 region has a spare object, that object can be
converted to an active member of the region using the "activatespare"
plug-in function.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="faultobjs"></a>4. Faulty objects</h2></div></div></div><p>
As discussed in the previous section, if one of the active objects in a
RAID-1 or RAID-4/5 region has a problem, that object will be kicked out and
the region will become degraded.
A problem can occur with active objects in a variety of ways.
For instance, a disk can crash, a disk can be pulled out of the
system, a drive cable can be removed, or one or more I/Os can cause errors.
Any of these will result in the object being kicked out and the RAID
region becoming degraded.
</p><p>
If a disk has completely stopped working or has been removed from the
machine, EVMS obviously will no longer recognize that disk, and it will
not show up as part of the RAID region when running the EVMS user interfaces.
However, if the disk is still available in the machine, EVMS will likely
be able to recognize that the disk is assigned to the RAID region, but has
been removed from any active service by the kernel. 
This type of disk is referred to as a faulty object.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="remfaultyobjs"></a>4.1. Removing faulty objects</h3></div></div></div><p>
Faulty objects are no longer usable by the RAID region, and should be
removed.
You can remove faulty objects with the "remfaulty" plug-in function
for both RAID-1 and RAID-4/5.  This operation is very similar to
removing spare objects.  After the object is removed, it will appear
in the Available-Objects list in the EVMS user interfaces.
</p><p>
Faulty objects can be removed while the RAID region is active and in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="fixtempfailedobjs"></a>4.2. Fixing temporarily failed objects</h3></div></div></div><p>
Sometimes a disk can have a temporary problem that causes the disk to be
marked faulty and the RAID region to become degraded.
For instance, a drive cable can come loose, causing the MD kernel driver
to think the disk has disappeared.
However, if the cable is plugged back in, the disk should be available
for normal use.
However, the MD kernel driver and the EVMS MD plug-in will continue to
indicate that the disk is a faulty object because the disk might have
missed some writes to the RAID region and would therefore be out of
sync with the rest of the disks in the region.
</p><p>
In order to correct this situation, the faulty object should be
removed from the RAID region (as discussed in the previous section).
The object will then show up as an Available-Object.
Next, that object should be added back to the RAID region as a spare 
(as discussed in <a class="xref" href="#addspareobjs" title="3.1. Adding spare objects">Section 3.1, &#8220;Adding spare objects&#8221;</a>.  When the
changes are saved, the MD kernel driver will activate the spare and
sync the data and parity.
When the sync is complete, the RAID region will be operating in its
original, normal configuration.
</p><p>
This procedure can be accomplished while the RAID region is active and
in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="markobjsfaulty"></a>4.3. Marking objects faulty</h3></div></div></div><p>
EVMS provides the ability to manually mark a child of a RAID-1 or
RAID-4/5 region as faulty.
This has the same effect as if the object had some problem or
caused I/O errors.
The object will be kicked out from active service in the region, and
will then show up as a faulty object in EVMS.
It can then be removed from the region as discussed in the previous
sections.
</p><p>
There are a variety of reasons why you might want to manually mark an
object faulty.
One example would be to test failure scenarios to learn how Linux and
EVMS deal with the hardware failures.
Another example would be that you want to replace one of the current
active objects with a different object.
To do this, you would add the new object as a spare, then mark the
current object faulty (causing the new object to be activated and
the data to be resynced), and finally remove the faulty object.
</p><p>
EVMS allows you to mark an object faulty in a RAID-1 region if there
are more than one active objects in the region.
EVMS allows you to mark an object faulty in a RAID-4/5 region if the
region has a spare object.
</p><p>
Use the "markfaulty" plug-in function for both RAID-1 and RAID-4/5. 
This command can be used while the RAID region is active and in use.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resizemdreg"></a>5. Resizing MD regions</h2></div></div></div><p>
RAID regions can be resized in order to expand or shrink the available
data space in the region.
Each RAID level has different characteristics, and thus each RAID level
has different requirements for when and how they can expand or shrink.
</p><p>
See <a class="xref" href="#expandshrink" title="Chapter 16. Expanding and shrinking volumes">Chapter 16, <i>Expanding and shrinking volumes</i></a> for general information about
resizing EVMS volumes and objects.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="linear"></a>5.1. Linear</h3></div></div></div><p>
A Linear-RAID region can be expanded in two ways.
First, if the last child object in the Linear-RAID region is
expandable, then that object can be expanded, and the RAID region
can expand into that new space.
Second, one or more new objects can be added to the end of the region.
</p><p>
Likewise, a Linear-RAID region can be shrunk in two ways.
If the last child object in the region is shrinkable, then that object
can be shrunk, and the RAID region will shrink by the same amount.
Also, one or more objects can be removed from the end of the RAID
region (but the first object in the region cannot be removed).
</p><p>
Linear-RAID regions can be resized while they are active and in use.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="resizeraid0"></a>5.2. RAID-0</h3></div></div></div><p>
You can expand a RAID-0 region by adding one new object to the region.
You can shrink a RAID-0 region by removing up to N-1 of the current
child objects in a region with N objects.
</p><p>
Because RAID-0 regions stripe across the child objects, when a RAID-0
region is resized, the data must be "re-striped" to account for the new
number of objects.
This means the MD plug-in will move each chunk of data from its
location in the current region to the appropriate location in the
expanded region.
Be forewarned, the re-striping process can take a long time.
At this time, there is no mechanism for speeding up or slowing down
the re-striping process.
The EVMS GUI and text-mode user interface will indicate the progress
of the re-striping.
Please do not attempt to interrupt the re-striping before it is
complete, because the data in the RAID-0 region will likely become
corrupted.
</p><p>
RAID-0 regions must be deactivated before they are resized in order to
prevent data corruption while the data is being re-striped.
</p><p>
IMPORTANT: Please have a suitable backup available before attempting
a RAID-0 resize.  If the re-striping process is interrupted before it
completes (for example, the EVMS process gets killed, the machine
crashes, or a child object in the RAID region starts returning I/O
errors), then the state of that region cannot be ensured in all situations.
</p><p>
EVMS will attempt to recover following a problem during a RAID-0 resize.
The MD plug-in does keep track of the progress of the resize in the MD
metadata.
Each time a data chunk is moved, the MD metadata is updated to
reflect which chunk is currently being processed.
If EVMS or the machine crashes during a resize, the next time you run
EVMS the MD plug-in will try to restore the state of that region based
on the latest metadata information.
If an expand was taking place, the region will be "rolled back" to its
state before the expand.
If a shrink was taking place, the shrink will continue from the
point it stopped.
However, this recovery is not always enough to ensure that the entire
volume stack is in the correct state.
If the RAID-0 region is made directly into a volume, then it will
likely be restored to the correct state.
On the other hand, if the RAID region is a consumed-object in an
LVM container, or a child-object of another RAID region, then the
metadata for those plug-ins might not always be in the correct state
and might be at the wrong location on the RAID region.
Thus, the containers, objects, and volumes built on top of the RAID-0
region might not reflect the correct size and might not even be discovered.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="resizeraid1"></a>5.3. RAID-1</h3></div></div></div><p>
A RAID-1 region can be resized if all of the child objects can be
simultaneously resized by the same amount.
</p><p>
RAID-1 regions cannot be resized by adding additional objects.
This type of operation is referred to as "adding active objects," and
is discussed in <a class="xref" href="#addactobjsr1" title="3.3. Adding active objects to RAID-1">Section 3.3, &#8220;Adding active objects to RAID-1&#8221;</a>.
</p><p>
RAID-1 regions must be deactivated before they are resized.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="resizeRAID-45"></a>5.4. RAID-4/5</h3></div></div></div><p> 
Resizing a RAID-4/5 region follows the same rules and restrictions 
for resizing a RAID-0 region.  Expand a RAID-4/5 region by 
adding one new object to the region.   
Shrink a RAID-4/5 region by removing up to N-1 of the current child objects in a region
with N objects. 
</p><p> 
See <a class="xref" href="#resizeraid0" title="5.2. RAID-0">Section 5.2, &#8220;RAID-0&#8221;</a> for information about how to perform this function.
</p><p>
Like RAID-0, RAID-4/5 regions must be deactivated before they are resized.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="replaceobjs"></a>6. Replacing objects</h2></div></div></div><p>The MD plug-in allows the child objects of a RAID region to be replaced with
other available objects.
This is accomplished using the general EVMS replace function.
Please see <a class="xref" href="#evmsreplaceobjects" title="Chapter 22. Replacing objects">Chapter 22, <i>Replacing objects</i></a> for more detailed information about how to
perform this function.</p><p>For all RAID levels, the replacement object must be at least as big as the
child object being replaced.  If the replacement object is bigger than the
child object being replaced, the extra space on the replacement object will be unused.
In order to perform a replace operation, any volumes that comprise the
RAID region must be unmounted.
</p><p>This capability is most useful for Linear-RAID and RAID-0 regions.  It is also allowed
with RAID-1 and RAID-4/5, but those two RAID levels offer the ability to mark objects faulty,
which accomplishes the same end result.
Because that process can be done while the region is in use, it is generally preferable
to object-replace, which must be done with the region deactivated.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appxlvm"></a>Appendix C. The LVM plug-in</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#lvmimp">1. How LVM is implemented</a></span></dt><dt><span class="sect1"><a href="#containerops">2. Container operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#createlvmconts">2.1. Creating LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4729">2.2. Adding objects to LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4732">2.3. Removing objects from LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4736">2.4. Expanding consumed objects in LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4742">2.5. Shrinking consumed objects in LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4749">2.6. Deleting LVM containers</a></span></dt><dt><span class="sect2"><a href="#idm4752">2.7. Renaming LVM containers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm4759">3. Region operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4761">3.1. Creating LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4798">3.2. Expanding LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4815">3.3. Shrinking LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4830">3.4. Deleting LVM regions</a></span></dt><dt><span class="sect2"><a href="#idm4833">3.5. Moving LVM regions</a></span></dt><dt><span class="sect2"><a href="#renamereg">3.6. Renaming LVM regions</a></span></dt></dl></dd></dl></div><p>The LVM plug-in combines storage objects into groups called containers.
From these containers, new storage objects can be created, with a variety of
mappings to the consumed objects.  Containers allow the storage capacity of
several objects to be combined, allow additional storage to be added in the future,
and allow for easy resizing of the produced objects.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lvmimp"></a>1. How LVM is implemented</h2></div></div></div><p>The Linux LVM plug-in is compatible with volumes and volume groups from
the original Linux LVM tools from Sistina Software.  The original LVM is based on the
concept of volume groups.  A volume group (VG) is a grouping of physical volumes 
(PVs), which are usually disks or disk partitions.  The volume group is not directly
usable as storage space; instead, it represents a pool of available storage.
You create logical volumes (LVs) to use this storage.  The storage space of the LV can 
map to one or more of the group's PVs.</p><p>The Linux LVM concepts are represented by similar concepts in the EVMS LVM plug-in.
A volume group is called a container, and the logical volumes that are produced are
called regions.  The physical volumes can be disks, segments, or other regions.
Just as in the original LVM, regions can map to the consumed objects in a variety of ways.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="containerops"></a>2. Container operations</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="createlvmconts"></a>2.1. Creating LVM containers</h3></div></div></div><p>Containers are created with an initial set of objects.  In the LVM plug-in, the
objects can be disks, segments, or regions.  LVM has two options for creating containers.
The value of these options cannot be changed after the container has been created.  The
options are:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">name</span></dt><dd><p>The name of the new container.</p></dd><dt><span class="term">pe_size</span></dt><dd><p>The physical extent (PE) size, which is the granularity with which regions can be created.  The default is 16 MB.  Each region must have a whole number of extents.  
Also, each region can have only up to 65534 extents.  Thus, the PE size for the container
limits the maximum size of a region in that container.  With the default PE size, an LVM
region can be, at most 1 TB.  In addition, each object consumed by the container must
be big enough to hold at least five extents.  Thus, the PE size cannot be arbitrarily large.  Choose wisely.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4729"></a>2.2. Adding objects to LVM containers</h3></div></div></div><p>You can add objects to existing LVM containers in order to increase the pool of
storage that is available for creating regions.  A single container can consume up to 256
objects.  Because the name and PE size of the containers are set when the container is
created, no options are available when you add new objects to a container.  Each object
must be large enough to hold five physical extents.  If an object is not large enough to
satisfy this requirement, the LVM plug-in will not allow the object to be added to the container.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4732"></a>2.3. Removing objects from LVM containers</h3></div></div></div><p>You can remove a consumed object from its container as long as no regions
are mapped to that object.  The LVM plug-in does not allow objects that are in use to
be removed from their container.  If an object must be removed, you can delete or
shrink regions, or move extents, in order to free the object from use.</p><p>No options are available for removing objects from LVM containers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4736"></a>2.4. Expanding consumed objects in LVM containers</h3></div></div></div><p>In addition to adding new objects to an LVM container, 
you can also expand
the space in a container by expanding one of the existing consumed 
objects (PVs).
For example, if a PV is a disk-segment with freespace immediately 
following it on
the disk, you can expand that segment, which will increase the 
amount of freespace in the container.  
Likewise, if a PV is a RAID-0 or RAID-5 region, you can expand
that region by adding additional objects, which in turn increases the 
freespace in the container.</p><p>When using the GUI or text-mode UIs, PV-expand is performed by expanding
the container.  
If any of the existing PVs are expandable, they will appear in the
expand-points list.  
Choose the PV to expand, and then the options for expanding
that object.  After the PV has expanded, the container's 
freespace will reflect the additional space available on that PV.</p><p>When using the CLI, PV-expand is performed by expanding the 
appropriate object directly.  
The CLI and the EVMS engine will route the necessary commands so the
container is expanded at the same time.</p><p>The options for expanding a PV are dependent on the plug-in 
that owns that PV object.
Please see the appropriate plug-in's appendix for more details on 
options for that object.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4742"></a>2.5. Shrinking consumed objects in LVM containers</h3></div></div></div><p>
In addition to removing existing objects from an LVM container, 
you can
also reduce the size of a container by shrinking one of the existing
consumed objects (PVs).  
This is only allowed if the consumed object
has physical extents (PEs) at the end of the object that are not allocated
to any LVM regions.  
In this case, LVM2 will allow the object to
shrink by the number of unused PEs at the end of that object.
</p><p>
For example, if a PV is a desk-segment, you can shrink that segment,
which will decrease the amount of freespace in the container.  Likewise,
if a PV is a RAID-0 or RAID-5 region, you can shrink that region by
removing one of the objects, which in turn decreases the freespace in
the container.
</p><p>
When using the GUI or text-mode UIs, PV-shrink is performed by shrinking
the container.  If any of the existing PVs are shrinkable, they will
appear in the shrink-points list.  Choose the PV to shrink, and then the
options for shrinking that object.  After the PV has shrunk, the container's
freespace will reflect the reduced space available on that PV.
</p><p>
When using the CLI, PV-shrink is performed by shrinking the appropriate
object directly.  The CLI and the EVMS engine will route the necessary
commands so the container is shrunk at the same time.
</p><p>
The options for shrinking a PV are dependent on the plug-in that owns
that PV object.  Please see the appropriate plug-in's appendix for more
details on options for that object.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4749"></a>2.6. Deleting LVM containers</h3></div></div></div><p>You can delete a container as long as the container does not have any produced
regions.  The LVM plug-in does not allow containers to be deleted if they have any
regions.  No options are available for deleting LVM containers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4752"></a>2.7. Renaming LVM containers</h3></div></div></div><p>You can rename an existing LVM container.  When renaming an LVM container,
all of the regions produced from that container will automatically have their names changed as
well, because the region names include the container name.
In the EVMS GUI and text-mode UIs, this is done using the 
<span class="command"><strong>modify properties</strong></span> command,
which is available through the "Actions" menu or the context-sensitive pop-up menus.
In the EVMS CLI, this is done using the <span class="command"><strong>set </strong></span>command.</p><p>See <a class="xref" href="#renamereg" title="3.6. Renaming LVM regions">Section 3.6, &#8220;Renaming LVM regions&#8221;</a> for more information about the effects of renaming the regions.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm4759"></a>3. Region operations</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4761"></a>3.1. Creating LVM regions</h3></div></div></div><p>You create LVM regions from the freespace in LVM containers.  If there is at least
one extent of freespace in the container, you can create a new region.</p><p>The following options are available for creating LVM regions:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">name</span></dt><dd><p>The name of the new region.</p></dd><dt><span class="term">extents</span></dt><dd><p>The number of extents to allocate to the new region.  A new region must
have at least one extent and no more than the total available free extents in the container,
or 65534 (whichever is smaller).  If you use the <code class="filename">extents</code> option, the appropriate value
for the size option is automatically calculated.  By default, a new region uses all
available extents in the container.</p></dd><dt><span class="term">size</span></dt><dd><p>The size of the new region.  This size must be a multiple of the
container's PE size.  If you use the <code class="filename">size</code> option, the appropriate value for the
extents options is automatically calculated.  By default, a new region uses all
available freespace in the container.</p></dd><dt><span class="term">stripes</span></dt><dd><p>If the container consumes two or more objects, and each object has
unallocated extents, then the new region can be striped across multiple objects.
This is similar to RAID-0 striping and achieves an increased amount of I/O
throughput across multiple objects.  This option specifies how many objects the
new region should be striped across.  By default, new regions are not striped, and
this value is set to 1.</p></dd><dt><span class="term">stripe_size</span></dt><dd><p>The granularity of striping.  The default value is 16 KB.  Use this option
only if the <code class="filename">stripes</code> option is greater than 1.</p></dd><dt><span class="term">contiguous</span></dt><dd><p>This option specifies that the new region must be allocated on a single
object, and that the extents on that object must be physically contiguous.  By default,
this is set to false, which allows regions to span objects.  This option cannot be used
if the <code class="filename">stripes</code> option is greater than 1.</p></dd><dt><span class="term">pv_names</span></dt><dd><p>A list of names of the objects the new region should map to.  By default,
this list is empty, which means all available objects will be used to allocate space
to the new region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4798"></a>3.2. Expanding LVM regions</h3></div></div></div><p>You can expand an existing LVM region if there are unused extents in the
container.  If a region is striped, you can expand it only by using free space on
the objects it is striped across.  If a region was created with the contiguous option,
you can only expand it if there is physically contiguous space following the
currently allocated space.</p><p>The following options are available for expanding LVM regions:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">add_extents</span></dt><dd><p>The number of extents to add to the region.  If you specify this
option, the appropriate value for the add_size option is automatically
calculated.  By default, the region will expand to use all free extents in the
container.</p></dd><dt><span class="term">add_size</span></dt><dd><p>The amount of space to add to the region.  If you specify this option,
the appropriate value for the add_extents option is automatically calculated.
By default, the region will expand to use all freespace in the container.</p></dd><dt><span class="term">pv_names</span></dt><dd><p>A list of names of the objects to allocate the additional space from.
By default,  this list is empty, which means all available objects will be used to
allocate new space to the region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4815"></a>3.3. Shrinking LVM regions</h3></div></div></div><p>You can shrink an existing LVM region by removing extents from the end of the
region.  Regions must have at least one extent, so regions cannot be shrunk to zero.</p><p>The following options are available when shrinking LVM regions.  Because regions
are always shrunk by removing space from the end of the region, a list of objects
cannot be specified in this command.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">remove_extents</span></dt><dd><p>The number of extents to remove from the region.  If you specify this option,
the appropriate value for the <code class="filename">remove_size</code> option is automatically calculated.  By
default, one extent is removed from the region.</p></dd><dt><span class="term">remove_size</span></dt><dd><p>The amount of space to shrink the region by.  If you specify this option,
the appropriate value for the <code class="filename">remove_extents</code> option is automatically calculated.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4830"></a>3.4. Deleting LVM regions</h3></div></div></div><p>You can delete an existing LVM region as long as it is not currently a 
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
No options are available for deleting LVM regions.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4833"></a>3.5. Moving LVM regions</h3></div></div></div><p>The LVM plug-in lets you change the logical-to-physical mapping
for an LVM region and move the necessary data in the process.
This capability is most useful if a PV needs to be removed from a container.
There are currently two LVM plug-in functions for moving regions: 
<span class="command"><strong>move_pv</strong></span> and <span class="command"><strong>move_extent</strong></span>.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4838"></a>3.5.1. move_pv</h4></div></div></div><p>When a PV needs to be removed from a container, all PEs on that PV that are
allocated to regions must be moved to other PVs.  The <span class="command"><strong>move_pv</strong></span> command lets you move PEs to other PVs. 
<span class="command"><strong>move_pv</strong></span> is targeted at the LVM container and the desired PV is used as 
the selected object.  The following options are available:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">target_pvs</span></dt><dd><p>By default, all remaining PVs in the container are used to find
available extents to move the PEs.  You can specify a subset of the PVs with this option.</p></dd><dt><span class="term">maintain_stripes</span></dt><dd><p>When the target PV contains striped regions, there are three choices
for handling moving extents that belong to those regions:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">no</span></dt><dd><p>Don't bother to maintain true striping.  This choice allows
extents to be moved to PVs that the region already uses for other stripes.
This means that the performance will not be as optimal as it is with true
striping, but allows the most flexibility in performing the move operation.
This choice is the default for the <span class="command"><strong>maintain_stripes</strong></span> option.</p></dd><dt><span class="term">loose</span></dt><dd><p>Ensure that moved extents do not end up on any PVs that the
striped region already uses.  However, this does not ensure that all moved
extents end up on the same PV.  For example, a region with three stripes may
end up mapping to four or more PVs.</p></dd><dt><span class="term">strict</span></dt><dd><p>Ensure that all moved extents end up on the same PV, thus ensuring
true striping with the same number of PVs that the striped region originally used.
This is the most restricted choice, and may prevent the <span class="command"><strong>move_pv</strong></span> operation from
proceeding (depending on the particular configuration of the container).</p></dd></dl></div><p>If the target PV has no striped regions, the <span class="command"><strong>maintain_stripes</strong></span> option is ignored.</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm4869"></a>3.5.2. move_extent</h4></div></div></div><p>In addition to moving all the extents from one PV, the LVM plug-in provides
the ability to move single extents.
This allows a fine-grain tuning of the allocation of extents.
This command is targeted at the region owning the extent to move.  There are
three required options for the <span class="command"><strong>move_extent</strong></span> command:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">le</span></dt><dd><p>The number of the logical extent to move.  LE numbers start at 0.</p></dd><dt><span class="term">pv</span></dt><dd><p>The target object to move the extent to.</p></dd><dt><span class="term">pe</span></dt><dd><p>The target physical extent on the target object.  PE numbers
also start at 0.</p></dd></dl></div><p>To determine the source LE and target PE, it is often helpful to view the
extended information about the region and container in question.
The following are command-line options that can be used to gather this
information:</p><p>To view the map of LEs in the region, enter this command:</p><pre class="programlisting">query:ei,&lt;region_name&gt;,Extents</pre><p>To view the list of PVs in the container, enter this command:</p><pre class="programlisting">query:ei,&lt;container_name&gt;,Current_PVs</pre><p>To view the current PE map for the desired target PV, enter this command:</p><pre class="programlisting">query:ei,&lt;container_name&gt;,PEMapPV#</pre><p># is the number of the target PV in the container.</p><p>This information is also easily obtainable in the GUI and Text-Mode UIs by
using the "Display Details" item in the context-popup menus for the desired
region and container.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="renamereg"></a>3.6. Renaming LVM regions</h3></div></div></div><p>You can rename an existing LVM region.  In the EVMS GUI and text-mode UIs, this
is done using the <span class="command"><strong>modify properties</strong></span> command, which is available through the "Actions"
menu or the context-sensitive pop-up menus.  In the EVMS CLI, this is done using the
<span class="command"><strong>set</strong></span> command.</p><p>If the renamed LVM region has a compatibility volume on it, then the name of that
compatibility volume will also change.  In order for this to work correctly, that volume must
be unmounted before the name is changed.  Also, be sure to update your
<code class="filename">/etc/fstab</code> file if the volume is listed, or the volume won't be mounted properly the next
time the system boots.</p><p>If the renamed LVM region has an EVMS volume or another storage object built on it,
then the region's name change will be transparent to the upper layers.  In this case, the
rename can be done while the volume is mounted.</p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appxlvm2"></a>Appendix D. The LVM2 plug-in</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#contops">1. Container operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4909">1.1. Creating LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4922">1.2. Adding objects to LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4925">1.3. Removing objects from LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4929">1.4. Expanding consumed objects in LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4935">1.5. Shrinking consumed objects in LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4942">1.6. Deleting LVM2 containers</a></span></dt><dt><span class="sect2"><a href="#idm4945">1.7. Renaming LVM2 containers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#regionops">2. Region operations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm4954">2.1. Creating LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm4979">2.2. Expanding LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm4999">2.3. Shrinking LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#idm5008">2.4. Deleting LVM2 regions</a></span></dt><dt><span class="sect2"><a href="#renamereg2">2.5. Renaming LVM2 regions</a></span></dt></dl></dd></dl></div><p>The LVM2 plug-in provides compatibility with the new volume format
introduced by the LVM2 tools from Red Hat (previously Sistina).
This plug-in is very similar in functionality to the LVM plug-in.  The primary
difference is the new, improved metadata format.
LVM2 is still based on the concept of volume groups (VGs), which are constructed
from physical volumes (PVs) and produce logical volumes (LVs).</p><p>Just like the LVM plug-in, the LVM2 plug-in represents volume groups as EVMS containers
and represents logical volumes as EVMS regions.
LVM2 containers combine storage objects (disks, segments, or other regions) to
create a pool of freespace.  Regions are then created from this freespace, with a variety
of mappings to the consumed objects.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contops"></a>1. Container operations</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4909"></a>1.1. Creating LVM2 containers</h3></div></div></div><p>Containers are created with an initial set of objects.
These objects can be disks, segments, or regions.  There are two options
available when creating an LVM2 container:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">name</span></dt><dd><p>The name of the new container.
</p></dd><dt><span class="term">extent_size</span></dt><dd><p>The physical-extent (PE) size, which is the granularity with which regions
can be created.  The default is 32 MB.  Unlike the LVM1 plug-in, there is no
limitation to the number of extents that can be allocated to an LVM2 region.
</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4922"></a>1.2. Adding objects to LVM2 containers</h3></div></div></div><p>You can add objects to existing LVM containers in order to increase
the pool of storage that is available for creating regions.
Because the name and extent-size are set when the container is created,
no options are available when you add new objects to a container.
Each object must be large enough to hold at least one physical extent.
If an object is not large enough to satisfy this requirement, the LVM2 plug-in
will not allow the object to be added to the container.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4925"></a>1.3. Removing objects from LVM2 containers</h3></div></div></div><p>You can remove a consumed object from its container as long as no regions
are mapped to that object.
The LVM2 plug-in does not allow objects that are in use to be removed from their
container.  If an object must be removed, you can delete or shrink regions, or
move extents, in order to free the object from use.</p><p>No options are available for removing objects from LVM containers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4929"></a>1.4. Expanding consumed objects in LVM2 containers</h3></div></div></div><p>In addition to adding new objects to an LVM2 container, you can also expand
the space in a container by expanding one of the existing consumed objects (PVs).
For example, if a PV is a disk-segment with freespace immediately following it on
the disk, you can expand that segment, which will increase the amount of freespace
in the container.  Likewise, if a PV is a RAID-0 or RAID-5 region, you can expand
that region by adding additional objects, which in turn increases the freespace in the
container.</p><p>When using the GUI or text-mode UIs, PV-expand is performed by expanding
the container.  If any of the existing PVs are expandable, they will appear in the
expand-points list.  Choose the PV to expand, and then the options for expanding
that object.  After the PV has expanded, the container's freespace will reflect the
additional space available on that PV.</p><p>When using the CLI, PV-expand is performed by expanding the appropriate object
directly.  The CLI and the EVMS engine will route the necessary commands so the
container is expanded at the same time.</p><p>The options for expanding a PV are dependent on the plug-in that owns that PV object.
Please see the appropriate plug-in's appendix for more details on options for that object.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4935"></a>1.5. Shrinking consumed objects in LVM2 containers</h3></div></div></div><p>
In addition to removing existing objects from an LVM2 container, you can
also reduce the size of a container by shrinking one of the existing
consumed objects (PVs).  This is only allowed if the consumed object
has physical extents (PEs) at the end of the object that are not allocated
to any LVM2 regions.  In this case, LVM2 will allow the object to
shrink by the number of unused PEs at the end of that object.
</p><p>
For example, if a PV is a desk-segment, you can shrink that segment,
which will decrease the amount of freespace in the container.  Likewise,
if a PV is a RAID-0 or RAID-5 region, you can shrink that region by
removing one of the objects, which in turn decreases the freespace in
the container.
</p><p>
When using the GUI or text-mode UIs, PV-shrink is performed by shrinking
the container.  If any of the existing PVs are shrinkable, they will
appear in the shrink-points list.  Choose the PV to shrink, and then the
options for shrinking that object.  After the PV has shrunk, the container's
freespace will reflect the reduced space available on that PV.
</p><p>
When using the CLI, PV-shrink is performed by shrinking the appropriate
object directly.  The CLI and the EVMS engine will route the necessary
commands so the container is shrunk at the same time.
</p><p>
The options for shrinking a PV are dependent on the plug-in that owns
that PV object.  Please see the appropriate plug-in's appendix for more
details on options for that object.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4942"></a>1.6. Deleting LVM2 containers</h3></div></div></div><p>You can delete a container as long as the container does not have any produced
regions.
The LVM2 plug-in does not allow containers to be deleted if they have any regions.
No options are available for deleting LVM2 containers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4945"></a>1.7. Renaming LVM2 containers</h3></div></div></div><p>You can rename an existing LVM2 container.  
When renaming an LVM2 container,
all of the regions produced from that container will automatically have their names changed as
well, because the region names include the container name.
In the EVMS GUI and text-mode UIs, this is done using the 
<span class="command"><strong>modify properties</strong></span> command,
which is available through the "Actions" menu or the context-sensitive pop-up menus.
In the EVMS CLI, this is done using the <span class="command"><strong>set </strong></span>command.</p><p>See <a class="xref" href="#renamereg2" title="2.5. Renaming LVM2 regions">Section 2.5, &#8220;Renaming LVM2 regions&#8221;</a> for more information about the effects of renaming the regions.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regionops"></a>2. Region operations</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4954"></a>2.1. Creating LVM2 regions</h3></div></div></div><p>You create LVM2 regions from the freespace in LVM2 containers.
If there is at least one extent of freespace in the container, you can create a new region.</p><p>The following options are available for creating LVM2 regions:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">name</span></dt><dd><p>The name of the new region.</p></dd><dt><span class="term">size</span></dt><dd><p>The size of the new region.  This size must be a multiple of the
container's extent-size.  If it isn't, the size will be rounded down as appropriate.
By default, all of the available freespace in the container will be used for the new region.</p></dd><dt><span class="term">stripes</span></dt><dd><p>If the container consumes two or more objects, and each object has unallocated
extents, then the new region can be striped across multiple objects.  This is similar to
RAID-0 striping and achieves an increased amount of I/O throughput.  This option
specifies how many objects the new region should be striped across.  By default, new
regions are not striped, and this value is set to 1.</p></dd><dt><span class="term">stripe_size</span></dt><dd><p>The granularity of striping.  The default value is 64 KB.  Use this option only if the
stripes option is greater than 1.</p></dd><dt><span class="term">pvs</span></dt><dd><p>A list of names of the objects the new region should map to.  By default, this
list is empty, which means all available objects will be used to allocate space to the new region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4979"></a>2.2. Expanding LVM2 regions</h3></div></div></div><p>You can expand an existing LVM region if there are any unused extents in the 
container.  The following options are available for expanding LVM regions.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">size</span></dt><dd><p>The amount of space to add to the region.  This is a delta-size,
not the new absolute size of the region.  As with creating new regions,
this size must be a multiple of the container's extent-size, and will be rounded
down if necessary.</p></dd><dt><span class="term">stripes</span></dt><dd><p>The number of objects to stripe this new portion of the region across.
This value can be different than the number of stripes in the existing region.
For example, if the region was created originally with three stripes, but now only
two objects are available, then the new portion of the region could be striped
across just those two objects.  The number of stripes for the last mapping in the
region will be used as the default.</p></dd><dt><span class="term">stripe_size</span></dt><dd><p>The granularity of striping. As with the number of stripes, this value
can be different than the stripe-size for the existing region.  By default, the
stripe-size of the last mapping in the region is used.</p></dd><dt><span class="term">pvs</span></dt><dd><p>A list of names of the objects the region should be expanded onto.
By default, this list is empty, which means all available objects will be used to
allocate additional space for the region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm4999"></a>2.3. Shrinking LVM2 regions</h3></div></div></div><p>You can shrink an existing LVM region by removing extents from the end of
the region.  Regions must have at least one extent, so regions cannot be
shrunk to zero.</p><p>The following options are available when shrinking LVM regions.
Because regions are always shrunk by removing space from the end of the region,
a list of objects cannot be specified in this command.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">size</span></dt><dd><p>The amount of space to remove from the region.
This is a delta-size, not the new absolute size of the region.
As with creating and expanding regions, this size must be a multiple of
the container's extent-size, and will be rounded down if necessary.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm5008"></a>2.4. Deleting LVM2 regions</h3></div></div></div><p>You can delete an existing LVM region as long as it is not currently a
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
No options are available for deleting LVM regions.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="renamereg2"></a>2.5. Renaming LVM2 regions</h3></div></div></div><p>You can rename an existing LVM2 region.  In the EVMS GUI and text-mode UIs, this
is done using the <span class="command"><strong>modify properties</strong></span> command, which is available through the "Actions"
menu or the context-sensitive pop-up menus.  In the EVMS CLI, this is done using the
<span class="command"><strong>set</strong></span> command.</p><p>If the renamed LVM2 region has a compatibility volume on it, then the name of that
compatibility volume will also change.  In order for this to work correctly, that volume must
be unmounted before the name is changed.  Also, be sure to update your
<code class="filename">/etc/fstab</code> file if the volume is listed, or the volume won't be mounted properly the next
time the system boots.</p><p>If the renamed LVM2 region has an EVMS volume or another storage object built on it,
then the region's name change will be transparent to the upper layers.  In this case, the
rename can be done while the volume is mounted.</p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appxcsm"></a>Appendix E. The CSM plug-in</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#csmassn">1. Assigning the CSM plug-in</a></span></dt><dt><span class="sect1"><a href="#unassignCSM">2. Unassigning the CSM plug-in</a></span></dt><dt><span class="sect1"><a href="#idm5078">3. Deleting a CSM container</a></span></dt></dl></div><p>The Cluster Segment Manager (CSM) is the EVMS plug-in that identifies and
manages cluster storage.  The CSM protects disk storage objects by writing metadata
at the start and end of the disk, which prevents other plug-ins from attempting to use the disk.
Other plug-ins can look at the disk, but they cannot see their own metadata signatures
and cannot consume the disk.  The protection that CSM provides allows the CSM to
discover cluster storage and present it in an appropriate fashion to the system. </p><p>All cluster storage disk objects must be placed in containers that have the
following attributes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>cluster ID that identifies the cluster management software
</p></li><li class="listitem"><p>node ID that identifies the owner of the disk objects
</p></li><li class="listitem"><p>storage type: private, shared, or deported
</p></li></ul></div><p>
The CSM plug-in reads metadata and constructs containers that consume
the disk object.  Each disk provides a usable area, mapped as an EVMS
data segment, but only if the disk is accessible to the node viewing
the storage.</p><p>The CSM plug-in performs these operations:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
examines disk objects
</p></li><li class="listitem"><p>
creates containers
</p></li><li class="listitem"><p>
uses the containers to consume disk objects
</p></li><li class="listitem"><p>
produces data segment objects if the disk is accessible to the node
</p></li></ul></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="csmassn"></a>1. Assigning the CSM plug-in</h2></div></div></div><p>Assigning a segment manager to a disk means that you want the plug-in to
manage partitions on the disk.  In order to do this, the plug-in needs to create and
maintain appropriate metadata.  The CSM creates the follow three segments on the disk:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>primary metadata segment</p></li><li class="listitem"><p>usable area data segment</p></li><li class="listitem"><p>secondary metadata segment</p></li></ul></div><p>The CSM collects the information it needs to perform the assign operation with the
following options:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">NodeId</span></dt><dd><p>Choose only from a list of configured node IDs that have been
provided to the CSM by clustering software.  The default selection is the
node from which you are running the EVMS user interface.</p></dd><dt><span class="term">Container Name</span></dt><dd><p>The name for the container.  You need to keep this name unique
across the cluster to prevent name-in-conflict errors should the container fail over to
another node that has a container with the same name.  
</p></dd><dt><span class="term">Storage Type</span></dt><dd><p>Can be either: share, private, or deported. </p></dd></dl></div><p>Note that you would typically assign the CSM to a disk when you want to
add a disk to an existing CSM container.  If you are creating a new container, you
have a choice of using either:
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Create</span> &#8594; <span class="guimenuitem">Container</span> or
<span class="guimenu">Actions</span> &#8594; <span class="guimenuitem">Add</span> &#8594; <span class="guimenuitem">Segment Manager</span>.
</p><p>If the container doesn't exist, it will be created for the disk.  If the container already
exists, the disk will be added to it.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unassignCSM"></a>2. Unassigning the CSM plug-in</h2></div></div></div><p>Unassigning a CSM plug-in results in the CSM removing its metadata from
the specified disk storage object.  The result is that the disk has no segments
mapped and appears as a raw disk object.  The disk is removed from the
container that consumed it and the data segment is removed as well.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm5078"></a>3. Deleting a CSM container</h2></div></div></div><p>An existing CSM container cannot be deleted if it is producing any data segments, 
because other EVMS plug-ins might be building higher-level objects on the CSM objects.
To delete a CSM container, first remove disk objects from the container.  When the last
disk is removed, the container is also removed.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="jfsfsim"></a>Appendix F. JFS file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createjfsfsim">1. Creating JFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkjfsfsim">2. Checking JFS file systems</a></span></dt><dt><span class="sect1"><a href="#removejfsfsim">3. Removing JFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandjfsfsim">4. Expanding JFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkjfsfsim">5. Shrinking JFS file systems</a></span></dt></dl></div><p>
The JFS FSIM lets EVMS users create and manage JFS file systems from
within the EVMS interfaces.  In order to use the JFS FSIM, version 1.0.9 or
later of the JFS utilities must be installed on your system.  The latest
version of JFS can be found at 
<a class="ulink" href="http://oss.software.ibm.com/jfs/" target="_top">http://oss.software.ibm.com/jfs/</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createjfsfsim"></a>1. Creating JFS file systems</h2></div></div></div><p>
JFS file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume (at least 16 MB in size) that does not already
have a file system.  The following options are available for creating
JFS file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">badblocks</span></dt><dd><p>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</p></dd><dt><span class="term">caseinsensitive</span></dt><dd><p>Mark the file system as case-insensitive (for OS/2 compatibility).
The default is false.</p></dd><dt><span class="term">vollabel</span></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><span class="term">journalvol</span></dt><dd><p>Specify the volume to use for an external journal.  This option
is only available with version 1.0.20 or later of the JFS utilities.
The default is none.
</p></dd><dt><span class="term">logsize</span></dt><dd><p>
Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 0.4% of the size of
the volume up to 32 MB.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkjfsfsim"></a>2. Checking JFS file systems</h2></div></div></div><p>
The following options are available for checking JFS file systems with
<span class="command"><strong>fsck</strong></span>:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">force</span></dt><dd><p>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</p></dd><dt><span class="term">readonly</span></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</p></dd><dt><span class="term">omitlog</span></dt><dd><p>Omit replaying the transaction log.  This option should only
be specified if the log is corrupt.  The default is false.</p></dd><dt><span class="term">verbose</span></dt><dd><p>Display details and debugging information during the check.
The default is false.</p></dd><dt><span class="term">version</span></dt><dd><p>Display the version of <code class="filename">fsck.jfs</code> and exit without 
checking the file system.  The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removejfsfsim"></a>3. Removing JFS file systems</h2></div></div></div><p>
A JFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandjfsfsim"></a>4. Expanding JFS file systems</h2></div></div></div><p>
A JFS file system is automatically expanded when its volume is expanded.
However, JFS only allows the volume to be expanded if it is mounted,
because JFS performs all of its expansions online.  In addition, JFS only
allows expansions if version 1.0.21 or later of the JFS utilities are
installed.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shrinkjfsfsim"></a>5. Shrinking JFS file systems</h2></div></div></div><p>
At this time, JFS does not support shrinking its file systems.
Hence, volumes with JFS file systems cannot be shrunk.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="xfsfsim"></a>Appendix G. XFS file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createxfsfsim">1. Creating XFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkxfsfsim">2. Checking XFS file systems</a></span></dt><dt><span class="sect1"><a href="#removexfsfsim">3. Removing XFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandxfsfsim">4. Expanding XFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkxfsfsim">5. Shrinking XFS file systems</a></span></dt></dl></div><p>
The XFS FSIM lets EVMS users create and manage XFS file systems from
within the EVMS interfaces.  In order to use the XFS FSIM, version 2.0.0 or
later of the XFS utilities must be installed on your system.  The latest
version of XFS can be found at 
<a class="ulink" href="http://oss.sgi.com/projects/xfs/" target="_top">http://oss.sgi.com/projects/xfs/</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createxfsfsim"></a>1. Creating XFS file systems</h2></div></div></div><p>
XFS file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
XFS file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">vollabel</span></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><span class="term">journalvol</span></dt><dd><p>Specify the volume to use for an external journal. 
The default is none.
</p></dd><dt><span class="term">logsize</span></dt><dd><p>
Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 4 MB; the
allowed range is 2 to 256 MB.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkxfsfsim"></a>2. Checking XFS file systems</h2></div></div></div><p>
The following options are available for checking XFS file systems with
<span class="command"><strong>fsck</strong></span>:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">readonly</span></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  The default is false.</p></dd><dt><span class="term">verbose</span></dt><dd><p>Display details and debugging information during the check.
The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removexfsfsim"></a>3. Removing XFS file systems</h2></div></div></div><p>
An XFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandxfsfsim"></a>4. Expanding XFS file systems</h2></div></div></div><p>
An XFS file system is automatically expanded when its volume is expanded.
However, XFS only allows the volume to be expanded if it is mounted,
because XFS performs all of its expansions online.  
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shrinkxfsfsim"></a>5. Shrinking XFS file systems</h2></div></div></div><p>
At this time, XFS does not support shrinking its file systems.
Hence, volumes with XFS file systems cannot be shrunk.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="reiserfsim"></a>Appendix H. ReiserFS file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createreiserfsim">1. Creating ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkreiserfsim">2. Checking ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#removexreiserfsim">3. Removing ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandreiserFSfsim">4. Expanding ReiserFS file systems</a></span></dt><dt><span class="sect1"><a href="#shrinkreiserfsim">5. Shrinking ReiserFS file systems</a></span></dt></dl></div><p>
The ReiserFS FSIM lets EVMS users create and manage ReiserFS file systems from
within the EVMS interfaces.  In order to use the 
ReiserFS FSIM, version 3.x.0 or
later of the ReiserFS utilities must be installed on your system.  
In order to get full functionality from the ReiserFS FSIM, use version
3.x.1b or later. The latest
version of ReiserFS can be found at 
<a class="ulink" href="http://www.namesys.com/" target="_top">http://www.namesys.com/</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createreiserfsim"></a>1. Creating ReiserFS file systems</h2></div></div></div><p>
ReiserFS file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume that does not already
have a file system.  The following option is available for creating
ReiserFS file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">vollabel</span></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkreiserfsim"></a>2. Checking ReiserFS file systems</h2></div></div></div><p>
The following option is available for checking XFS file systems with
<span class="command"><strong>fsck</strong></span>:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">mode</span></dt><dd><p>There are three possible modes for checking a ReiserFS file system:
Check Read-Only, Fix, and Rebuild Tree."</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removexreiserfsim"></a>3. Removing ReiserFS file systems</h2></div></div></div><p>
A ReiserFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandreiserFSfsim"></a>4. Expanding ReiserFS file systems</h2></div></div></div><p>
A ReiserFS file system is automatically expanded when its volume is expanded.
ReiserFS file systems can be expanded if the volume is mounted or
unmounted.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shrinkreiserfsim"></a>5. Shrinking ReiserFS file systems</h2></div></div></div><p>
A ReiserFS file system is automatically shrunk if the volume is shrunk.
ReiserFS file systems can only be shrunk if the volume is unmounted.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="ext23fsim"></a>Appendix I. Ext-2/3 file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createext23fsim">1. Creating Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#checkext23fsim">2. Checking Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#removeext23fsim">3. Removing Ext-2/3 file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkext23fsim">4. Expanding and shrinking Ext-2/3 
file systems</a></span></dt></dl></div><p>
The Ext-2/3 FSIM lets EVMS users create and manage Ext2 and
Ext3 file systems from
within the EVMS interfaces.  In order to use the Ext-2/3 FSIM, 
the e2fsprogs package 
must be installed on your system.  The e2fsprogs package
can be found at 
<a class="ulink" href="http://e2fsprogs.sourceforge.net/" target="_top">http://e2fsprogs.sourceforge.net/</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createext23fsim"></a>1. Creating Ext-2/3 file systems</h2></div></div></div><p>
Ext-2/3 file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
Ext-2/3 file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">badblocks</span></dt><dd><p>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</p></dd><dt><span class="term">badblocks_rw</span></dt><dd><p>Perform a read/write check for bad blocks on the volume before
creating the file system.  The default is false.
</p></dd><dt><span class="term">vollabel</span></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><span class="term">journal</span></dt><dd><p>Create a journal for use with the Ext2 file system.  The default
is true.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkext23fsim"></a>2. Checking Ext-2/3 file systems</h2></div></div></div><p>
The following options are available for checking Ext-2/3 file systems with
<span class="command"><strong>fsck</strong></span>:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">force</span></dt><dd><p>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</p></dd><dt><span class="term">readonly</span></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</p></dd><dt><span class="term">badblocks</span></dt><dd><p>Check for bad blocks on the volume and mark them as busy.  The
default is false.
</p></dd><dt><span class="term">badblocks_rw</span></dt><dd><p>Perform a read-write check for bad blocks on the volume and mark
them as busy. The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removeext23fsim"></a>3. Removing Ext-2/3 file systems</h2></div></div></div><p>
An Ext-2/3 file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandshrinkext23fsim"></a>4. Expanding and shrinking Ext-2/3 
file systems</h2></div></div></div><p>
An Ext-2/3 file system is automatically expanded or shrunk when its volume 
is expanded or shrunk.
However, Ext-2/3 only allows these operations if the volume is
unmounted, because online expansion and shrinkage is not yet supported.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="gfsfsim"></a>Appendix J. OpenGFS file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createopengfsfsim">1. Creating OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#checkopengfsfsim">2. Checking OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#removeopengfsfsim">3. Removing OpenGFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkopengfsfsim">4. Expanding and shrinking OpenGFS
file systems</a></span></dt></dl></div><p>
The OpenGFS FSIM lets EVMS users create and manage OpenGFS 
file systems from within the EVMS interfaces.  
In order to use the OpenGFS FSIM, the OpenGFS utilities must be
installed on your system.  Go to 
<a class="ulink" href="http://sourceforge.net/projects/opengfs" target="_top">http://sourceforge.net/projects/opengfs</a> for the OpenGFS project.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createopengfsfsim"></a>1. Creating OpenGFS file systems</h2></div></div></div><p>
OpenGFS file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume that does not already
have a file system and that is produced from a shared cluster container.  
The following options are available for creating
OpenGFS file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">blocksize</span></dt><dd><p>Set the file system block size.
The block size is in bytes.
The block size must be a power of 2 between 512 and 65536, inclusive.
The default block size is 4096 bytes.
</p></dd><dt><span class="term">journals</span></dt><dd><p>The names of the journal volumes, one for each node.
</p></dd><dt><span class="term">protocol</span></dt><dd><p>Specify the name of the locking protocol to use.
The choices are "memexp" and "opendlm."
</p></dd><dt><span class="term">lockdev</span></dt><dd><p>Specify the shared volume to be used to contain the locking metadata.
</p></dd></dl></div><p>
The OpenGFS FSIM only takes care of file system operations.
It does not take care of OpenGFS cluster and node configuration.
Before the volumes can be mounted, you must configure the cluster and
node separately after you have made the file system and saved the changes.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkopengfsfsim"></a>2. Checking OpenGFS file systems</h2></div></div></div><p>
The OpenGFS utility for checking the file system has no additional options.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removeopengfsfsim"></a>3. Removing OpenGFS file systems</h2></div></div></div><p>
An OpenGFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume,
erasing the log headers for the journal volumes, and erasing the control
block on the cluster configuration volume associated with the file
system volume so that the file system will not be recognized in the future.
There are no options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandshrinkopengfsfsim"></a>4. Expanding and shrinking OpenGFS
file systems</h2></div></div></div><p>
OpenGFS only allows a volume to be expanded.  
OpenGFS only allows a volume to expanded when the volume is mounted.
An OpenGFS file system is automatically expanded when its volume is
expanded.
</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="ntfsfsim"></a>Appendix K. NTFS file system interface module</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#createntfsfsim">1. Creating NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#fixntfsfsim">2. Fixing NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#clonentfsfsim">3. Cloning NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#removentfsfsim">4. Removing NTFS file systems</a></span></dt><dt><span class="sect1"><a href="#expandshrinkntfsfsim">5. Expanding and shrinking NTFS
file systems</a></span></dt></dl></div><p>
The NTFS FSIM lets EVMS users create and manage Windows® NT®
file systems from within the EVMS interfaces.  
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="createntfsfsim"></a>1. Creating NTFS file systems</h2></div></div></div><p>
NTFS file systems can be created with <span class="command"><strong>mkfs</strong></span> on any EVMS
or compatibility volume that is at least 1 MB in size and that does not already
have a file system.
The following options are available for creating
NTFS file systems:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">label</span></dt><dd><p>
Specify a volume label for the file system.  The default is none.
</p></dd><dt><span class="term">cluster-size</span></dt><dd><p>Specify the size of clusters in bytes.  Valid cluster size values
are powers of two, with at least 256, and at most 65536 bytes per cluster.
If omitted, mkntfs cluster-size is determined by the volume size.  The
value is determined as follows:
</p><pre class="programlisting">
Volume size	Default cluster

0-512 MB	512 bytes
512 MB-1 GB	1024 bytes
1 GB-2 GB	2048 bytes
2 GB+		4096 bytes
</pre></dd><dt><span class="term">mft-zone-mult</span></dt><dd><p>Set the MFT zone multiplier, which determines the size of the
MFT zone to use on the volume.  The MFT zone is the area at the
beginning of the volume reserved for the master file table (MFT),
which stores the on disk inodes (MFT records).  Note that small files
are stored entirely within the node.  Thus, if you expect to use the
volume for storing large numbers of very small files, it is useful
to set the zone multiplier to a higher value.  Note that the MFT zone
is resized on the fly as required during operation of the NTFS driver,
but choosing a good value will reduce fragmentation.  Valid
values are 12.5 (the default), 25, 37.5, and 50.
</p></dd><dt><span class="term">compress</span></dt><dd><p>Enable compression on the volume.
</p></dd><dt><span class="term">quick</span></dt><dd><p>Perform quick format.  This skips both zeroing of the volume
and bad sector checking.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fixntfsfsim"></a>2. Fixing NTFS file systems</h2></div></div></div><p>
The NTFS FSIM can run the <span class="command"><strong>ntfsfix</strong></span> utility on an
NTFS file system.
</p><p>
<span class="command"><strong>ntfsfix</strong></span> fixes NTFS partitions altered in any manner
with the Linux NTFS driver.  <span class="command"><strong>ntfsfix</strong></span> is not a Linux
version of <span class="command"><strong>chkdsk</strong></span>.  <span class="command"><strong>ntfsfix</strong></span>  
only tries to leave the NTFS
partition in a not-so-inconsistent state after the NTFS driver has written
to it.
</p><p>
Running <span class="command"><strong>ntfsfix</strong></span> after mounting an NTFS volume
read-write is recommended for reducing the chance of severe data loss
when Windows NT or Windows 2000 tries to remount the affected volume.
</p><p>
In order to use <span class="command"><strong>ntfsfix</strong></span>, you must unmount the
NTFS volume.  After running <span class="command"><strong>ntfsfix</strong></span>, you can safely
reboot into Windows NT or Windows 2000.  Please note that
<span class="command"><strong>ntfsfix</strong></span> is not an <span class="command"><strong>fsck</strong></span>-like tool. 
<span class="command"><strong>ntfsfix</strong></span> is not guaranteed to fix all the
alterations provoked by the NTFS driver.
</p><p>
The following option is available for running <span class="command"><strong>ntfsfix</strong></span>
on an NTFS file system:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">force</span></dt><dd><p>
Force <span class="command"><strong>ntfsfix</strong></span> to write changes even if it
detects that the file system is dirty.  The default is false.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="clonentfsfsim"></a>3. Cloning NTFS file systems</h2></div></div></div><p>
The NTFS FSIM can run the <span class="command"><strong>ntfsclone</strong></span> utility to
copy an NTFS file system from one volume to another.
<span class="command"><strong>ntfsclone</strong></span> is faster than <span class="command"><strong>dd</strong></span>
because it only copies the files and the file system data instead
of the entire contents of the volume.
</p><p>
The following options are available for running <span class="command"><strong>ntfsclone</strong></span>
on an NTFS file system:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">target</span></dt><dd><p>The volume onto which the file system should be cloned.
</p></dd><dt><span class="term">force</span></dt><dd><p>
Force <span class="command"><strong>ntfsclone</strong></span> to copy the file system
even if it detects that the volume is dirty.  The default is false.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="removentfsfsim"></a>4. Removing NTFS file systems</h2></div></div></div><p>
An NTFS file system can be removed from its volume if the file system
is unmounted.
This operation involves erasing the superblock from the volume so
the file system will not be recognized in the future.
There are no options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="expandshrinkntfsfsim"></a>5. Expanding and shrinking NTFS
file systems</h2></div></div></div><p>
An NTFS file system is automatically expanded or shrunk when its volume
is expanded for shrunk.  However, NTFS only allows these operations if the
volume is unmounted.
</p></div></div></div></body></html>
