<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4. Some Miscellaneous Issues</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Custom Linux: A Porting Guide"><link rel="up" href="ch04.html" title="Chapter 4. Linux Still Isn't Booting"><link rel="prev" href="ch04s03.html" title="3. Ethernet: our first PCI device"><link rel="next" href="ch05.html" title="Chapter 5. Linux Is Booting ... What Now ?"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. Some Miscellaneous Issues</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s03.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Linux Still Isn't Booting</th><td width="20%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm273"></a>4. Some Miscellaneous Issues</h2></div></div></div><p>We had new problems, some would say good problems. We didn't have a bootloader yet, however we needed to pass a command line to the kernel at boot time.  We hard-coded the command line into the kernel inside the <code class="function">parse_options()</code>. After that was finished, we made <code class="function">console_init()</code> and <code class="function">serial_console_setup()</code> work the way they should.  They no longer ignored the command line, but still RTS and DTR stay low.</p><p>Another important issue was memory mapping. The file <code class="filename">arch/ppc/mm/init.c</code> contains a function called <code class="function">MMU_init()</code>. This function is actually a big <span class="command"><strong>switch</strong></span> statment, divided by the machine type. Each machine maps its memory using the <code class="function">setbat()</code> and <code class="function">ioremap()</code> functions. The BAT mechanism is a way of translating virtual addresses into physical ones. Thus, <code class="function">setbat()</code> is used by specifying a virtual address, a physical address and a page size.  Not every size can be used here; you should use one of the finite set of sizes, ranging from 128KB to 256MB.  We mapped our IO memory so that virtual equalled physical.</p><p>As mentioned, there is another way of mapping memory - <code class="function">ioremap()</code>. <code class="function">ioremap()</code> is used to map physical addresses into virtual ones, making them available to the kernel. The function <span class="emphasis"><em>does not allocate any memory</em></span>, simply returns a virtual address by which one can access the memory region. The following is a snippet from <code class="function">MMU_init()</code>:

</p><pre class="programlisting">

case _MACH_mymachine:
	setbat(0, LOW_IO_VIRT_BASE, LOW_IO_PHYS_BASE, LOW_IO_SIZE, IO_PAGE);
	ioremap(UNIVERSE_BASE,UNIVERSE_SIZE);      /* Universe VME */
	ioremap(EEPRO100_BASE,EEPRO100_SIZE);      /* Ethernet EEPRO100 */
	break;

</pre><p>

As you can see,  we don't take the return value of <code class="function">ioremap()</code>. We don't need it,  since at this stage the kernel maps the addresses so that virtual address == physical address.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3. Ethernet: our first PCI device </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 5. Linux Is Booting ... What Now ?</td></tr></table></div></body></html>
