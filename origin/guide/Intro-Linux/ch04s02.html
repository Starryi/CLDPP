<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2. Boot process, Init and shutdown</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Beginners, linux, start, Getting started, guide, Guide, Exercises, exercises"><link rel="home" href="index.html" title="Introduction to Linux"><link rel="up" href="ch04.html" title="Chapter 4. Processes"><link rel="prev" href="ch04s01.html" title="1. Processes inside out"><link rel="next" href="ch04s03.html" title="3. Managing processes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Boot process, Init and shutdown</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s01.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Processes</th><td width="20%" align="right"> <a accesskey="n" href="ch04s03.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_04_02"></a>2. Boot process, Init and shutdown</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_01"></a>2.1. Introduction</h3></div></div></div><p> One of the most powerful aspects of Linux concerns its open method of starting<a class="indexterm" name="idm5151"></a> and stopping<a class="indexterm" name="idm5153"></a> the operating system, where it loads specified programs using their particular configurations, permits you to change those configurations to control the boot process, and shuts down in a graceful and organized way.</p><p> Beyond the question of controlling the boot or shutdown process, the open nature of Linux makes it much easier to determine the exact source of most problems associated with starting up or shutting down your system. A basic understanding of this process is quite beneficial to everybody who uses a Linux system.</p><p>A lot of Linux systems use <span class="command"><strong>lilo<a class="indexterm" name="idm5158"></a></strong></span>, the <span class="application">LInux LOader<a class="indexterm" name="idm5162"></a></span> for booting operating systems.  We will only discuss GRUB<a class="indexterm" name="idm5164"></a>, however, which is easier to use and more flexible.  Should you need information about <span class="command"><strong>lilo</strong></span>, refer to the man pages and HOWTOs.  Both systems support dual boot installations, we refer to the HOWTOs on this subject for practical examples and background information.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_02"></a>2.2. The boot process</h3></div></div></div><p>When an x86 computer is booted, the processor looks at the end of the system memory for the BIOS<a class="indexterm" name="idm5171"></a> (Basic Input/Output System<a class="indexterm" name="idm5174"></a>) and runs it. The BIOS program is written into permanent read-only memory and is always available for use. The BIOS provides the lowest level interface to peripheral devices and controls the first step of the boot process.</p><p> The BIOS tests the system, looks for and checks peripherals, and then looks for a drive to use to boot the system. Usually it checks the floppy drive (or CD-ROM drive on many newer systems) for bootable media, if present, and then it looks to the hard drive. The order of the drives used for booting is usually controlled by a particular BIOS setting on the system.  Once Linux is installed on the hard drive of a system, the BIOS looks for a Master Boot Record<a class="indexterm" name="idm5177"></a> (MBR) starting at the first sector on the first hard drive, loads its contents into memory, then passes control to it.</p><p> This MBR<a class="indexterm" name="idm5180"></a> contains instructions on how to load the GRUB<a class="indexterm" name="idm5183"></a> (or LILO) boot-loader, using a pre-selected operating system.  The MBR then loads the boot-loader<a class="indexterm" name="idm5186"></a>, which takes over the process (if the boot-loader is installed in the MBR). In the default Red Hat Linux configuration, GRUB uses the settings in the MBR to display boot options in a menu.  Once GRUB has received the correct instructions for the operating system to start, either from its command line or configuration file, it finds the necessary boot file and hands off control of the machine to that operating system.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_03"></a>2.3. GRUB features</h3></div></div></div><p>This boot method is called <span class="emphasis"><em>direct loading<a class="indexterm" name="idm5193"></a></em></span> because instructions are used to directly load the operating system, with no intermediary code between the boot-loaders and the operating system's main files (such as the kernel). The boot process used by other operating systems may differ slightly from the above, however. For example, Microsoft's DOS and Windows operating systems completely overwrite anything on the MBR when they are installed without incorporating any of the current MBR's configuration. This destroys any other information stored in the MBR by other operating systems, such as Linux. The Microsoft operating systems, as well as various other proprietary operating systems, are loaded using a chain loading boot method. With this method, the MBR points to the first sector of the partition holding the operating system, where it finds the special files necessary to actually boot that operating system.</p><p>
GRUB<a class="indexterm" name="idm5197"></a> supports both boot methods, allowing you to use it with almost any operating system, most popular file systems, and almost any hard disk your BIOS can recognize.</p><p>GRUB contains a number of other features; the most important include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>GRUB provides a true command-based, pre-OS environment on x86 machines to allow maximum flexibility in loading operating systems with certain options or gathering information about the system.</p></li><li class="listitem"><p>GRUB supports Logical Block Addressing (LBA<a class="indexterm" name="idm5206"></a>) mode, needed to access many IDE and all SCSI hard disks.  Before LBA, hard drives could encounter a 1024-cylinder limit, where the BIOS could not find a file after that point.</p></li><li class="listitem"><p>GRUB's configuration file is read from the disk every time the system boots, preventing you from having to write over the MBR every time you change the boot options.</p></li></ul></div><p>A full description of GRUB may be found by issuing the <span class="command"><strong>info <em class="parameter"><code>grub</code></em></strong></span> command or at <a class="ulink" href="http://www.gnu.org/software/grub/" target="_top">the GRUB site</a>.  The Linux Documentation Project has a <a class="ulink" href="http://www.tldp.org/HOWTO/mini/Multiboot-with-GRUB.html" target="_top">Multiboot with GRUB Mini-HOWTO</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_04"></a>2.4. Init</h3></div></div></div><p>The kernel, once it is loaded, finds <span class="command"><strong>init<a class="indexterm" name="idm5219"></a></strong></span> in <code class="filename">sbin</code> and executes<a class="indexterm" name="idm5223"></a> it.</p><p>When <span class="command"><strong>init</strong></span> starts, it becomes the parent or grandparent of all of the processes that start up automatically on your Linux system. The first thing <span class="command"><strong>init</strong></span> does, is reading its initialization file, <code class="filename">/etc/inittab<a class="indexterm" name="idm5229"></a></code>.  This instructs <span class="command"><strong>init</strong></span> to read an initial configuration script for the environment, which sets the path, starts swapping, checks the file systems, and so on. Basically, this step takes care of everything that your system needs to have done at system initialization: setting the clock, initializing serial ports and so forth.</p><p> Then <span class="command"><strong>init</strong></span> continues to read the <code class="filename">/etc/inittab</code> file, which describes how the system should be set up in each run level and sets the default <span class="emphasis"><em>run level<a class="indexterm" name="idm5236"></a></em></span>.  A run level is a configuration of processes.  All UNIX-like systems can be run in different process configurations, such as the single user mode<a class="indexterm" name="idm5238"></a>, which is referred to as run level 1 or run level S (or s).  In this mode, only the system administrator can connect to the system.  It is used to perform maintenance tasks without risks of damaging the system or user data.  Naturally, in this configuration we don't need to offer user services, so they will all be disabled.  Another run level is the reboot run level, or run level 6, which shuts down all running services according to the appropriate procedures and then restarts the system.</p><p>Use the <span class="command"><strong>who<a class="indexterm" name="idm5242"></a></strong></span> to check what your current<a class="indexterm" name="idm5245"></a> run level is:</p><pre class="screen">
<code class="prompt">willy@ubuntu:~$ </code><span class="command"><strong>who <code class="option">-r</code></strong></span>
	run-level 2 2006-10-17 23:22		last=S
</pre><p>More about run levels in the next section, see <a class="xref" href="ch04s02.html#sect_04_02_05" title="2.5. Init run levels">Section 2.5, &#8220;Init run levels&#8221;</a>.</p><p>After having determined the default run level for your system, <span class="command"><strong>init</strong></span> starts all of the background processes necessary for the system to run by looking in the appropriate <code class="filename">rc</code> directory<a class="indexterm" name="idm5256"></a> for that run level.  <span class="command"><strong>init</strong></span> runs each of the kill<a class="indexterm" name="idm5260"></a> scripts (their file names start with a K) with a stop parameter.  It then runs all of the start<a class="indexterm" name="idm5263"></a> scripts (their file names start with an S) in the appropriate run level directory so that all services and applications are started correctly. In fact, you can execute these same scripts manually after the system is finished booting with a command like <span class="command"><strong>/etc/init.d/httpd <em class="parameter"><code>stop</code></em></strong></span> or <span class="command"><strong>service <em class="parameter"><code>httpd</code></em> <em class="parameter"><code>stop</code></em></strong></span> logged in as <span class="emphasis"><em>root</em></span>, in this case stopping the web server.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Special case</h3><p>Note that on system startup, the scripts in <code class="filename">rc2.d</code> and <code class="filename">rc3.d</code> are usually executed.  In that case, no services are stopped (at least not permanently).  There are only services that are started.</p></div><p> None of the scripts<a class="indexterm" name="idm5278"></a> that actually start and stop the services are located<a class="indexterm" name="idm5281"></a> in <code class="filename">/etc/rc&lt;x&gt;.d</code>. Rather, all of the files in <code class="filename">/etc/rc&lt;x&gt;.d</code> are symbolic links that point to the actual scripts located in <code class="filename">/etc/init.d</code>. A symbolic link is nothing more than a file that points to another file, and is used in this case because it can be created and deleted without affecting the actual scripts that kill or start the services. The symbolic links to the various scripts are numbered in a particular order so that they start in that order. You can change the order in which the services start up or are killed by changing the name of the symbolic link that refers to the script that actually controls the service.  You can use the same number multiple times if you want a particular service started or stopped right before or after another service, as in the example below, listing the content of <code class="filename">/etc/rc5.d</code>, where <span class="command"><strong>crond</strong></span> and <span class="command"><strong>xfs</strong></span> are both started from a linkname starting with <span class="quote">&#8220;<span class="quote">S90</span>&#8221;</span>.  In this case, the scripts are started in alphabetical order.</p><pre class="screen">
<code class="prompt">[jean@blub /etc/rc5.d]</code> <span class="command"><strong>ls</strong></span>
K15httpd@     K45named@    S08ipchains@  S25netfs@      S85gpm@
K16rarpd@     K46radvd@    S08iptables@  S26apmd@       S90crond@
K20nfs@       K61ldap@     S09isdn@      S28autofs@     S90xfs@
K20rstatd@    K65identd@   S10network@   S30nscd@       S95anacron@
K20rusersd@   K74ntpd@     S12syslog@    S55sshd@       S95atd@
K20rwalld@    K74ypserv@   S13portmap@   S56rawdevices@ S97rhnsd@
K20rwhod@     K74ypxfrd@   S14nfslock@   S56xinetd@     S99local@
K25squid@     K89bcm5820@  S17keytable@  S60lpd@
K34yppasswdd@  S05kudzu@    S20random@    S80sendmail@
</pre><p>After <span class="command"><strong>init</strong></span> has progressed through the run levels to get to the default run level, the <code class="filename">/etc/inittab</code> script forks a <span class="command"><strong>getty<a class="indexterm" name="idm5297"></a></strong></span> process for each virtual console (login prompt in text mode).  <span class="command"><strong>getty</strong></span> opens tty lines, sets their modes, prints the login prompt, gets the user's name, and then initiates a login process for that user.  This allows users to authenticate themselves to the system and use it.  By default, most systems offer 6 virtual consoles, but as you can see from the <code class="filename">inittab</code> file, this is configurable.</p><p>
<code class="filename">/etc/inittab</code> can also tell <span class="command"><strong>init</strong></span> how it should handle a user pressing <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>Delete</strong></span> at the console. As the system should be properly shut down and restarted rather than immediately power-cycled, <span class="command"><strong>init</strong></span> is told to execute<a class="indexterm" name="idm5308"></a> the command <span class="command"><strong>/sbin/shutdown <code class="option">-t3 -r</code> <em class="parameter"><code>now</code></em></strong></span>, for instance, when a user hits those keys. In addition, <code class="filename">/etc/inittab</code> states what <span class="command"><strong>init</strong></span> should do in case of power failures, if your system has a UPS unit attached to it.</p><p>
On most RPM-based systems the graphical login screen is started in run level 5, where <code class="filename">/etc/inittab</code> runs a script called <code class="filename">/etc/X11/prefdm<a class="indexterm" name="idm5318"></a></code>. The <code class="filename">prefdm</code> script runs the preferred X display manager, based on the contents of the <code class="filename">/etc/sysconfig/desktop</code> directory.  This is typically <span class="command"><strong>gdm<a class="indexterm" name="idm5323"></a></strong></span> if you run GNOME or <span class="command"><strong>kdm<a class="indexterm" name="idm5326"></a></strong></span> if you run KDE, but they can be mixed, and there's also the <span class="command"><strong>xdm</strong></span> that comes with a standard X installation.</p><p>But there are other possibilities as well.  On Debian, for instance, there is an initscript for each of the display managers, and the content of the <code class="filename">/etc/X11/default-display-manager</code> is used to determine which one to start.  More about the graphical interface can be read in <a class="xref" href="ch07s03.html" title="3. The graphical environment">Section 3, &#8220;The graphical environment&#8221;</a>.  Ultimately, your system documentation will explain the details about the higher level aspects of <span class="command"><strong>init</strong></span>.</p><p>The <code class="filename">/etc/default<a class="indexterm" name="idm5335"></a></code> and/or <code class="filename">/etc/sysconfig<a class="indexterm" name="idm5338"></a></code> directories contain entries for a range of functions and services, these are all read at boot time.  The location of the directory containing system defaults might be somewhat different depending on your Linux distribution.</p><p>Besides the graphical user environment, a lot of other services may be started as well.  But if all goes well, you should be looking at a login prompt or login screen when the boot process has finished.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Other procedures</h3><p>We explained how SysV<a class="indexterm" name="idm5344"></a> <span class="command"><strong>init</strong></span> works on x86 based machines.  Startup procedures may vary on other architectures and distributions.  Other systems may use the BSD-style <span class="command"><strong>init</strong></span>, where startup files are not split up into multiple <code class="filename">/etc/rc&lt;LEVEL&gt;.d</code> directories.  It might also be possible that your system uses <code class="filename">/etc/rc.d/init.d</code> instead of <code class="filename">/etc/init.d</code>.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_05"></a>2.5. Init run levels</h3></div></div></div><p> The idea behind operating different<a class="indexterm" name="idm5355"></a> services at different run levels essentially revolves around the fact that different systems can be used in different ways. Some services cannot be used until the system is in a particular state, or <span class="emphasis"><em>mode</em></span>, such as being ready for more than one user or having networking available.</p><p>
There are times in which you may want to operate the system in a lower mode.  Examples are fixing disk corruption problems in run level 1 so no other users can possibly be on the system, or leaving a server in run level 3 without an X session running. In these cases, running services that depend upon a higher system mode to function does not make sense because they will not work correctly anyway. By already having each service assigned to start when its particular run level is reached, you ensure an orderly start up process, and you can quickly change the mode of the machine without worrying about which services to manually start or stop.</p><p>Available run levels are generally described in <code class="filename">/etc/inittab</code>, which is partially shown below:</p><pre class="screen">

#
# inittab   This file describes how the INIT process should set up
#           the system in a certain run-level.

# Default run level. The run levels are:
#   0 - halt (Do NOT set initdefault to this)
#   1 - Single user mode
#   2 - Multiuser, without NFS 
#	(The same as 3, if you do not have networking)
#   3 - Full multiuser mode
#   4 - unused
#   5 - X11
#   6 - reboot (Do NOT set initdefault to this)
# 
id:5:initdefault:
&lt;--cut--&gt;
</pre><p> Feel free to configure unused run levels (commonly run level 4) as you see fit. Many users configure those run levels in a way that makes the most sense for them while leaving the standard run levels as they are by default. This allows them to quickly move in and out of their custom configuration without disturbing the normal set of features at the standard run levels.</p><p> If your machine gets into a state where it will not boot due to a bad <code class="filename">/etc/inittab</code> or will not let you log in because you have a corrupted <code class="filename">/etc/passwd</code> file (or if you have simply forgotten your password), boot into single-user mode.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">No graphics?</h3><p>When you are working in text mode because you didn't get presented a graphical login screen on the console of your machine, you can normally switch to console 7 or up to have a graphical login.  If this is not the case, check the current run level using the command <span class="command"><strong>who <code class="option">-r</code></strong></span>.  If it is set to something else than the original default from <code class="filename">/etc/inittab</code>, chances are that the system does not start up in graphical mode by default.  Contact your system administrator or read <span class="command"><strong>man init</strong></span> in that case.  Note that switching run levels<a class="indexterm" name="idm5374"></a> is done preferably using the <span class="command"><strong>telinit<a class="indexterm" name="idm5378"></a></strong></span> command; switching from a text to a graphical console or vice versa does not involve a run level switch.</p></div><p>The discussion of run levels, scripts and configurations in this guide tries to be as general as possible.  Lots of variations exist.  For instance, Gentoo Linux stores scripts in <code class="filename">/etc/run levels</code>.  Other systems might first run through (a) lower run level(s) and execute all the scripts in there before arriving at the final run level and executing those scripts.  Refer to your system documentation for more information.  You might also read through the scripts that are refered to in <code class="filename">/etc/inittab</code> to get a better comprehension of what happens on your system.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_02_05_01"></a>2.5.1. Tools</h4></div></div></div><p>The <span class="command"><strong>chkconfig<a class="indexterm" name="idm5387"></a></strong></span> or <span class="command"><strong>update-rc.d<a class="indexterm" name="idm5390"></a></strong></span> utilities, when installed on your system, provide a simple command-line tool for maintaining the <code class="filename">/etc/init.d<a class="indexterm" name="idm5393"></a></code> directory hierarchy. These relieve<a class="indexterm" name="idm5395"></a> system administrators from having to directly manipulate the numerous symbolic links in the directories under <code class="filename">/etc/rc[x].d</code>.</p><p>
In addition, some systems offer the <span class="command"><strong>ntsysv<a class="indexterm" name="idm5401"></a></strong></span> tool, which provides a text-based interface; you may find this easier to use than <span class="command"><strong>chkconfig</strong></span>'s command-line interface.  On SuSE Linux, you will find the <span class="command"><strong>yast<a class="indexterm" name="idm5405"></a></strong></span> and <span class="command"><strong>insserv<a class="indexterm" name="idm5408"></a></strong></span> tools.  For Mandrake easy configuration, you may want to try <span class="application">DrakConf<a class="indexterm" name="idm5411"></a></span>, which allows among other features switching between run levels 3 and 5.  In Mandriva this became the <span class="application">Mandriva Linux Control Center</span>.</p><p>
Most distributions provide a graphical user interface for configuring processes, check with your system documentation.</p><p>
All of these utilities must be run as root.  The system administrator may also manually create the appropriate links in each run level directory in order to start or stop a service in a certain run level.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_02_06"></a>2.6. Shutdown</h3></div></div></div><p>UNIX was not made to be shut down, but if you really must, use the <span class="command"><strong>shutdown<a class="indexterm" name="idm5420"></a></strong></span> command.  After completing the shutdown procedure, the <code class="option">-h</code> option will halt the system, while <code class="option">-r</code> will reboot<a class="indexterm" name="idm5424"></a> it.</p><p>The <span class="command"><strong>reboot</strong></span> and <span class="command"><strong>halt<a class="indexterm" name="idm5429"></a></strong></span> commands are now able to invoke <span class="command"><strong>shutdown</strong></span> if run when the system is in run levels 1-5, and thus ensure proper shutdown of the system,but  it is a bad habit to get into, as not all UNIX/Linux versions have this feature.</p><p>If your computer does not power itself down, you should not turn off the computer until you see a message indicating that the system is halted or finished shutting down, in order to give the system the time to unmount all partitions.  Being impatient may cause data loss.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1. Processes inside out </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Managing processes</td></tr></table></div></body></html>
