<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3. Managing processes</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Beginners, linux, start, Getting started, guide, Guide, Exercises, exercises"><link rel="home" href="index.html" title="Introduction to Linux"><link rel="up" href="ch04.html" title="Chapter 4. Processes"><link rel="prev" href="ch04s02.html" title="2. Boot process, Init and shutdown"><link rel="next" href="ch04s04.html" title="4. Scheduling processes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Managing processes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Processes</th><td width="20%" align="right"> <a accesskey="n" href="ch04s04.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_04_03"></a>3. Managing processes</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_03_01"></a>3.1. Work for the system admin</h3></div></div></div><p>While managing system resources<a class="indexterm" name="idm5438"></a>, including processes, is a task for the local system administrator, it doesn't hurt a common user to know something about it, especially where his or her own processes and their optimal execution are concerned.</p><p>We will explain a little bit on a theoretical level about system performance, though not as far as hardware optimization and other advanced procedures.  Instead, we will study the daily problems a common user is confronted with, and actions such a user can take to optimally use the resources available.  As we learn in the next section, this is mainly a matter of thinking before acting.</p><div class="figure"><a name="idm5442"></a><p class="title"><b>Figure 4.2. Can't you go faster?</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/trappen.png" alt="Man-powered computer: one person works the pedals, one person works with the comp."></div></div></div><br class="figure-break"></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_03_02"></a>3.2. How long does it take?</h3></div></div></div><p>Bash offers a built-in <span class="command"><strong>time<a class="indexterm" name="idm5455"></a></strong></span> command that displays how long a command takes to execute.  The timing<a class="indexterm" name="idm5457"></a> is highly accurate and can be used on any command.  In the example below, it takes about a minute and a half to make this book:</p><pre class="screen">
<code class="prompt">tilly:~/xml/src&gt;</code> <span class="command"><strong>time make</strong></span>
Output written on abook.pdf (222 pages, 1619861 bytes).
Transcript written on abook.log.

real	1m41.056s
user	1m31.190s
sys	0m1.880s
</pre><p>The GNU <span class="command"><strong>time</strong></span> command in <code class="filename">/usr/bin</code> (as opposed to the shell built-in version) displays more information that can be formatted in different ways.  It also shows the exit status of the command, and the total elapsed time.  The same command as the above using the independent <span class="command"><strong>time</strong></span> gives this output:</p><pre class="screen">
<code class="prompt">tilly:~/xml/src&gt;</code> <span class="command"><strong>/usr/bin/time make</strong></span>
Output written on abook.pdf (222 pages, 1595027 bytes).
Transcript written on abook.log.

Command exited with non-zero status 2
88.87user 1.74system 1:36.21elapsed 94%CPU 
				(0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (2192major+30002minor)pagefaults 0swaps
</pre><p>Refer again to the Info pages for all the information.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_03_03"></a>3.3. Performance</h3></div></div></div><p>To a user, performance<a class="indexterm" name="idm5474"></a> means quick execution of commands.  To a system manager, on the other hand, it means much more:  the system admin has to optimize system performance<a class="indexterm" name="idm5477"></a> for the whole system, including users, all programs and daemons.  System performance can depend on a thousand tiny things which are not accounted for with the <span class="command"><strong>time</strong></span> command:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>the program executing is badly written or doesn't use the computer appropriately</p></li><li class="listitem"><p>access to disks, controllers, display, all kinds of interfaces, etc.</p></li><li class="listitem"><p>reachability of remote systems (network performance)</p></li><li class="listitem"><p>amount of users on the system, amount of users actually working simultaneously</p></li><li class="listitem"><p>time of day</p></li><li class="listitem"><p>...</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_03_04"></a>3.4. Load</h3></div></div></div><p>In short:  the load<a class="indexterm" name="idm5496"></a> depends on what is normal<a class="indexterm" name="idm5499"></a> for your system.  My old P133 running a firewall, SSH server, file server, a route daemon, a sendmail server, a proxy server and some other services doesn't complain with 7 users connected; the load is still 0 on average.  Some (multi-CPU) systems I've seen were quite happy with a load of 67.  There is only one way to find out - check the load regularly if you want to know what's normal.  If you don't, you will only be able to measure system load from the response time of the command line, which is a very rough measurement since this speed is influenced by a hundred other factors.</p><p>Keep in mind that different systems will behave different with the same load average.  For example, a system with a graphics card supporting hardware acceleration will have no problem rendering 3D images, while the same system with a cheap VGA card will slow down tremendously while rendering.  My old P133 will become quite uncomfortable when I start the X server, but on a modern system you hardly notice the difference in the system load.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_03_05"></a>3.5. Can I do anything as a user?</h3></div></div></div><p>A big environment can slow you down.  If you have lots of environment variables set (instead of shell variables), long search paths that are not optimized (errors in setting the path environment variable) and more of those settings that are usually made <span class="quote">&#8220;<span class="quote">on the fly</span>&#8221;</span>, the system will need more time to search and read data.</p><p>In X, window managers and desktop environments can be real CPU-eaters.  A really fancy desktop comes with a price, even when you can download it for free, since most desktops provide add-ons ad infinitum.  Modesty is a virtue if you don't buy a new computer every year.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_01"></a>3.5.1. Priority</h4></div></div></div><p>The priority<a class="indexterm" name="idm5510"></a> or importance of a job is defined by it's <span class="emphasis"><em>nice</em></span> number<a class="indexterm" name="idm5514"></a>.  A program with a high nice number is friendly to other programs, other users and the system; it is not an important job.  The lower the nice number, the more important a job is and the more resources it will take without sharing them.</p><p>Making a job nicer by increasing its nice number is only useful for processes that use a lot of CPU time (compilers, math applications and the like).  Processes that always use a lot of I/O time are automatically rewarded by the system and given a higher priority (a lower nice number), for example keyboard input always gets highest priority on a system.</p><p>Defining the priority of a program is done with the <span class="command"><strong>nice<a class="indexterm" name="idm5519"></a></strong></span> command.</p><p>Most systems also provide the BSD <span class="command"><strong>renice<a class="indexterm" name="idm5523"></a></strong></span> command, which allows you to change the <span class="emphasis"><em>niceness</em></span> of a running command.  Again, read the man page for your system-specific information.</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Interactive programs</h3><p>It is NOT a good idea to <span class="command"><strong>nice</strong></span> or <span class="command"><strong>renice</strong></span> an interactive program or a job running in the foreground.</p></div><p>Use of these commands is usually a task for the system administrator.  Read the man page for more info on extra functionality available to the system administrator.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_02"></a>3.5.2. CPU resources</h4></div></div></div><p>On every Linux system, many programs want to use the CPU<a class="indexterm" name="idm5535"></a>(s) at the same time, even if you are the only user on the system.  Every program needs a certain amount of cycles on the CPU to run.  There may be times when there are not enough cycles because the CPU is too busy.  The <span class="command"><strong>uptime<a class="indexterm" name="idm5539"></a></strong></span> command is wildly inaccurate (it only displays averages, you have to know what is normal), but far from being useless.  There are some actions you can undertake if you think your CPU is to blame for the unresponsiveness of your system:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Run heavy programs when the load is low.  This may be the case on your system during the night.  See next section for scheduling.</p></li><li class="listitem"><p>Prevent the system from doing unnecessary work: stop daemons and programs that you don't use, use <span class="command"><strong>locate</strong></span> instead of a heavy <span class="command"><strong>find</strong></span>, ...</p></li><li class="listitem"><p>Run big jobs with a low priority</p></li></ul></div><p>If none of these solutions are an option in your particular situation, you may want to upgrade your CPU.  On a UNIX machine this is a job for the system admin.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_03"></a>3.5.3. Memory resources</h4></div></div></div><p>When the currently running processes<a class="indexterm" name="idm5554"></a> expect more memory than the system has physically available, a Linux system will not crash; it will start paging, or <span class="emphasis"><em>swapping<a class="indexterm" name="idm5558"></a></em></span>, meaning the process uses the memory on disk or in swap space, moving contents of the physical memory (pieces of running programs or entire programs in the case of swapping) to disk, thus reclaiming the physical memory to handle more processes.  This slows the system down enormously since access to disk is much slower than access to memory.  The <span class="command"><strong>top<a class="indexterm" name="idm5561"></a></strong></span> command can be used to display memory and swap use.   Systems using glibc offer the <span class="command"><strong>memusage</strong></span> and <span class="command"><strong>memusagestat</strong></span> commands to visualize memory usage.</p><p>If you find that a lot of memory and swap space are being used, you can try:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Killing, stopping or renicing those programs that use a big chunk of memory</p></li><li class="listitem"><p>Adding more memory (and in some cases more swap space) to the system.</p></li><li class="listitem"><p>Tuning system performance, which is beyond the scope of this document.  See the reading list in <a class="xref" href="apa.html" title="Appendix A. Where to go from here?">Appendix A, <i>Where to go from here?</i></a> for more.</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_04"></a>3.5.4. I/O resources</h4></div></div></div><p>While I/O limitations<a class="indexterm" name="idm5577"></a> are a major cause of stress for system admins, the Linux system offers rather poor utilities to measure I/O performance.  The <span class="command"><strong>ps<a class="indexterm" name="idm5581"></a></strong></span>, <span class="command"><strong>vmstat<a class="indexterm" name="idm5584"></a></strong></span> and <span class="command"><strong>top<a class="indexterm" name="idm5587"></a></strong></span> tools give some indication about how many programs are waiting for I/O; <span class="command"><strong>netstat<a class="indexterm" name="idm5590"></a></strong></span> displays network interface statistics, but there are virtually no tools available to measure the I/O response to system load, and the <span class="command"><strong>iostat<a class="indexterm" name="idm5593"></a></strong></span> command gives a brief overview of general I/O usage.  Various graphical front-ends exist to put the output of these commands in a humanly understandable form.</p><p>Each device has its own problems, but the bandwidth available to network interfaces and the  bandwidth available to disks are the two primary causes of bottlenecks in I/O performance.</p><p>Network I/O problems:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Network overload:</p><p>The amount of data transported over the network is larger than the network's capacity, resulting in slow execution of every network related task for all users.  They can be solved by cleaning up the network (which mainly involves disabling protocols and services that you don't need) or by reconfiguring the network (for example use of subnets, replacing hubs with switches, upgrading interfaces and equipment).</p></li><li class="listitem"><p>Network integrity problems:</p><p>Occurs when data is transferred incorrectly.  Solving this kind of problem can only be done by isolating the faulty element and replacing it.</p></li></ul></div><p>Disk I/O problems:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>per-process transfer rate too low:</p><p>Read or write speed for a single process is not sufficient.</p></li><li class="listitem"><p>aggregate transfer rate too low:</p><p>The maximum total bandwidth that the system can provide to all programs that run is not enough.</p></li></ul></div><p>This kind of problem is more difficult to detect, and usually takes extra hardware in order to re-divide data streams over buses, controllers and disks, if overloaded hardware is cause of the problem.  One solution to solve this is a RAID array configuration optimized for input and output actions.  This way, you get to keep the same hardware.  An upgrade to faster buses, controlers and disks is usually the other option.</p><p>If overload is not the cause, maybe your hardware is gradually failing, or not well connected to the system.  Check contacts, connectors and plugs to start with.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_05"></a>3.5.5. Users</h4></div></div></div><p>Users can be divided in several classes, depending on their behavior with resource<a class="indexterm" name="idm5617"></a> usage:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Users who run a (large) number of small jobs: you, the beginning Linux user, for instance.</p></li><li class="listitem"><p>Users who run relatively few but large jobs: users running simulations, calculations, emulators or other programs that eat a lot of memory, and usually these users have accompanying large data files.</p></li><li class="listitem"><p>Users who run few jobs but use a lot of CPU time (developers and the like).</p></li></ul></div><p>You can see that system requirements may vary for each class of users, and that it can be hard to satisfy everyone.  If you are on a multi-user system, it is useful (and fun) to find out habits of other users and the system, in order to get the most out of it for your specific purposes.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_06"></a>3.5.6. Graphical tools</h4></div></div></div><p>For the graphical environment, there are a whole bunch of monitoring<a class="indexterm" name="idm5631"></a> tools available.  Below is a screen shot of the <span class="application">Gnome System Monitor<a class="indexterm" name="idm5635"></a></span>, which has features for displaying and searching process information, and monitoring<a class="indexterm" name="idm5637"></a> system resources:</p><div class="figure"><a name="idm5639"></a><p class="title"><b>Figure 4.3. Gnome System Monitor</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/system-monitor.png" alt="This GUI shows a graphic of how load and memory usage vary with time."></div></div></div><br class="figure-break"><p>There are also a couple of handy icons you can install in the task bar, such as a disk, memory and load monitor.  <span class="command"><strong>xload<a class="indexterm" name="idm5650"></a></strong></span> is another small X application for monitoring system load.  Find your favorite!</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_03_05_07"></a>3.5.7. Interrupting your processes</h4></div></div></div><p>As a non-privileged user, you can only influence your own processes.  We already saw how you can display processes and filter out processes that belong to a particular user, and what possible restrictions can occur.  When you see that one of your processes is eating too much of the system's resources<a class="indexterm" name="idm5655"></a>, there are two things that you can do:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Make the process use less resources without interrupting it;</p></li><li class="listitem"><p>Stop the process altogether.</p></li></ol></div><p>In the case that you want the process to continue to run, but you also want to give the other processes on the system a chance, you can <span class="command"><strong>renice</strong></span> the process.  Appart from using the <span class="command"><strong>nice</strong></span> or <span class="command"><strong>renice</strong></span> commands, <span class="command"><strong>top<a class="indexterm" name="idm5668"></a></strong></span> is an easy way of spotting the troublesome process(es) and reducing priority<a class="indexterm" name="idm5671"></a>.</p><p>Identify the process in the <span class="quote">&#8220;<span class="quote">NI</span>&#8221;</span> column, it will most likely have a negative priority.  Type <span class="command"><strong>r</strong></span> and enter the process ID of the process that you want to renice.  Then enter the nice value, for instance <span class="quote">&#8220;<span class="quote">20</span>&#8221;</span>.  That means that from now on, this process will take 1/5 of the CPU cycles at the most.</p><p>Examples of processes that you want to keep on running are emulators, virtual machines, compilers and so on.</p><p>If you want to stop a process because it hangs or is going totally berserk in the way of I/O consumption, file creation or use of other system resources, use the <span class="command"><strong>kill</strong></span> command.  If you have the opportunity, first try to kill the process softly, sending it the <span class="emphasis"><em>SIGTERM<a class="indexterm" name="idm5682"></a></em></span> signal.  This is an instruction to terminate whatever it is doing, according to procedures as described in the code of the program<a class="indexterm" name="idm5684"></a>:</p><pre class="screen">
<code class="prompt">joe:~&gt;</code> <span class="command"><strong>ps <code class="option">-ef</code></strong></span> | <span class="command"><strong>grep <em class="parameter"><code>mozilla</code></em></strong></span>
joe    25822	1  0 Mar11 ?	00:34:04 /usr/lib/mozilla-1.4.1/mozilla-

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>kill <code class="option">-15</code> <em class="parameter"><code>25822</code></em></strong></span>
</pre><p>In the example above, user <span class="emphasis"><em>joe</em></span> stopped his Mozilla browser because it hung.</p><p>Some processes are a little bit harder to get rid of.  If you have the time, you might want to send them the SIGINT<a class="indexterm" name="idm5700"></a> signal to interrupt them.  If that does not do the trick either, use the strongest signal, SIGKILL<a class="indexterm" name="idm5702"></a>.  In the example below, <span class="emphasis"><em>joe</em></span> stops<a class="indexterm" name="idm5705"></a> a <span class="application">Mozilla</span> that is frozen:</p><pre class="screen">
<code class="prompt">joe:~&gt;</code> <span class="command"><strong>ps <code class="option">-ef</code></strong></span> | <span class="command"><strong>grep <em class="parameter"><code>mozilla</code></em></strong></span>
joe    25915	1  0 Mar11 ?	00:15:06 /usr/lib/mozilla-1.4.1/mozilla-

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>kill <code class="option">-9</code> <em class="parameter"><code>25915</code></em></strong></span>

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>ps <code class="option">-ef</code></strong></span> | <span class="command"><strong>grep <em class="parameter"><code>25915</code></em></strong></span>
joe	2634 32273 0 18:09 pts/4   00:00:00 grep 25915
</pre><p>In such cases, you might want to check that the process is really dead, using the <span class="command"><strong>grep</strong></span> filter again on the PID.  If this only returns the <span class="command"><strong>grep</strong></span> process, you can be sure that you succeeded in stopping the process.</p><p>Among processes that are hard to kill is your shell.  And that is a good thing: if they would be easy to kill, you woud loose your shell every time you type <span class="keycap"><strong>Ctrl</strong></span>-<span class="keycap"><strong>C</strong></span> on the command line accidentally, since this is equivalent to sending a SIGINT.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">UNIX without pipes is almost unthinkable</h3><p>The usage of pipes (|) for using output of one command as input of another is explained in the next chapter, <a class="xref" href="ch05.html" title="Chapter 5. I/O redirection">Chapter 5, <i>I/O redirection</i></a>.</p></div><p>In a graphical environment, the <span class="command"><strong>xkill<a class="indexterm" name="idm5736"></a></strong></span> program is very easy to use.  Just type the name of the command, followed by an <span class="keycap"><strong>Enter</strong></span> and select the window of the application that you want to stop.  It is rather dangerous because it sends a SIGKILL by default, so only use it when an application hangs.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. Boot process, Init and shutdown </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. Scheduling processes</td></tr></table></div></body></html>
