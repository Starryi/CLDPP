<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>1. Processes inside out</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Beginners, linux, start, Getting started, guide, Guide, Exercises, exercises"><link rel="home" href="index.html" title="Introduction to Linux"><link rel="up" href="ch04.html" title="Chapter 4. Processes"><link rel="prev" href="ch04.html" title="Chapter 4. Processes"><link rel="next" href="ch04s02.html" title="2. Boot process, Init and shutdown"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. Processes inside out</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Processes</th><td width="20%" align="right"> <a accesskey="n" href="ch04s02.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_04_01"></a>1. Processes inside out</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_01"></a>1.1. Multi-user and multi-tasking</h3></div></div></div><p>Now that we are more used to our environment and we are able to communicate a little bit with our system, it is time to study the processes we can start in more detail.  Not every command starts a single process.  Some commands initiate a series of processes, such as <span class="command"><strong>mozilla</strong></span>; others, like <span class="command"><strong>ls</strong></span>, are executed as a single command.</p><p>Furthermore, Linux is based on UNIX, where it has been common policy to have multiple users running multiple commands, at the same time and on the same system.  It is obvious that measures have to be taken to have the CPU manage all these processes, and that functionality has to be provided so users can switch between processes.  In some cases, processes will have to continue to run even when the user who started them logs out.  And users need a means to reactivate interrupted processes.</p><p>We will explain the structure of Linux processes in the next sections.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_02"></a>1.2. Process types</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_02_01"></a>1.2.1. Interactive processes</h4></div></div></div><p>Interactive processes<a class="indexterm" name="idm4650"></a> are initialized and controlled through a terminal session.  In other words, there has to be someone connected to the system to start these processes; they are not started automatically as part of the system functions.  These processes can run in the foreground<a class="indexterm" name="idm4653"></a>, occupying the terminal that started the program, and you can't start other applications as long as this process is running in the foreground.  Alternatively, they can run in the background, so that the terminal in which you started the program can accept new commands while the program is running.  Until now, we mainly focussed on programs running in the foreground - the length of time taken to run them was too short to notice - but viewing a file with the <span class="command"><strong>less</strong></span> command is a good example of a command occupying the terminal session.  In this case, the activated program is waiting for you to do something.  The program is still connected to the terminal from where it was started, and the terminal is only useful for entering commands this program can understand.  Other commands will just result in errors or unresponsiveness of the system.</p><p>While a process runs in the background<a class="indexterm" name="idm4658"></a>, however, the user is not prevented from doing other things in the terminal in which he started the program, while it is running.</p><p>The shell offers a feature called <span class="emphasis"><em>job control<a class="indexterm" name="idm4663"></a></em></span> which allows easy handling of multiple processes.  This mechanism<a class="indexterm" name="idm4665"></a> switches processes between the foreground and the background.  Using this system, programs can also be started in the background immediately.</p><p>Running a process in the background is only useful for programs that don't need user input (via the shell).  Putting a job in the background is typically done when execution of a job is expected to take a long time.  In order to free the issuing terminal after entering the command, a trailing ampersand is added.  In the example, using graphical mode, we open an extra terminal window from the existing one:</p><pre class="screen">
<code class="prompt">billy:~&gt;</code> <span class="command"><strong>xterm &amp;</strong></span>
[1] 26558

<code class="prompt">billy:~&gt;</code> <span class="command"><strong>jobs<a class="indexterm" name="idm4674"></a></strong></span>
[1]+  Running                 xterm &amp;
</pre><p>The full job control features are explained in detail in the <span class="command"><strong>bash</strong></span> <span class="application">Info</span> pages, so only the frequently used job control<a class="indexterm" name="idm4679"></a> applications are listed here<a class="indexterm" name="idm4682"></a>:</p><div class="table"><a name="idm4685"></a><p class="title"><b>Table 4.1. Controlling processes</b></p><div class="table-contents"><table class="table" summary="Controlling processes" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">(part of) command</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="command"><strong>regular_command</strong></span></td><td align="left">Runs this command in the foreground.</td></tr><tr><td align="left"><span class="command"><strong>command &amp;</strong></span></td><td align="left">Run this command in the background (release the terminal)</td></tr><tr><td align="left"><span class="command"><strong>jobs</strong></span></td><td align="left">Show commands running in the background.</td></tr><tr><td align="left"><span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Z</strong></span></td><td align="left">Suspend (stop, but not quit) a process running in the foreground (suspend).</td></tr><tr><td align="left"><span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>C</strong></span></td><td align="left">Interrupt (terminate and quit) a process running in the foreground.</td></tr><tr><td align="left"><em class="parameter"><code>%n</code></em></td><td align="left">Every process running in the background gets a number assigned to it.  By using the % expression a job can be referred to using its number, for instance <span class="command"><strong>fg <em class="parameter"><code>%2</code></em></strong></span>.</td></tr><tr><td align="left"><span class="command"><strong>bg<a class="indexterm" name="idm4724"></a></strong></span></td><td align="left">Reactivate a suspended program in the background.</td></tr><tr><td align="left"><span class="command"><strong>fg<a class="indexterm" name="idm4730"></a></strong></span></td><td align="left">Puts the job back in the foreground.</td></tr><tr><td align="left"><span class="command"><strong>kill<a class="indexterm" name="idm4736"></a></strong></span></td><td align="left">End a process (also see Shell Builtin Commands in the Info pages of <span class="command"><strong>bash</strong></span>)</td></tr></tbody></table></div></div><br class="table-break"><p>More practical examples can be found in the exercises.</p><p>Most UNIX systems are likely to be able to run <span class="command"><strong>screen<a class="indexterm" name="idm4743"></a></strong></span>, which is useful when you actually want another shell to execute commands.  Upon calling <span class="command"><strong>screen</strong></span>, a new session is created with an accompanying shell and/or commands as specified, which you can then put out of the way.  In this new session you may do whatever it is you want to do.  All programs and operations will run independent of the issuing shell.  You can then detach this session, while the programs you started in it continue to run, even when you log out of the originating shell, and pick your <span class="emphasis"><em>screen</em></span> up again any time you like.</p><p>This program originates from a time when virtual consoles were not invented yet, and everything needed to be done using one text terminal.  To addicts, it still has meaning in Linux, even though we've had virtual consoles for almost ten years.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_02_02"></a>1.2.2. Automatic processes</h4></div></div></div><p>Automatic<a class="indexterm" name="idm4751"></a> or batch processes are not connected to a terminal.  Rather, these are tasks that can be queued into a spooler area, where they wait to be executed on a FIFO (first-in, first-out) basis.  Such tasks can be executed using one of two criteria:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>At a certain date and time: done using the <span class="command"><strong>at</strong></span> command, which we will discuss in the second part of this chapter.</p></li><li class="listitem"><p>At times when the total system load is low enough to accept extra jobs: done using the <span class="command"><strong>batch<a class="indexterm" name="idm4761"></a></strong></span> command.  By default, tasks are put in a queue where they wait to be executed until the system load is lower than 0.8.  In large environments, the system administrator may prefer batch processing when large amounts of data have to be processed or when tasks demanding a lot of system resources have to be executed on an already loaded system.  Batch processing is also used for optimizing system performance.</p></li></ul></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_02_03"></a>1.2.3. Daemons</h4></div></div></div><p>Daemons<a class="indexterm" name="idm4766"></a> are server processes<a class="indexterm" name="idm4769"></a> that run continuously.  Most of the time, they are initialized at system startup and then wait in the background until their service is required.  A typical example is the networking daemon, <span class="emphasis"><em>xinetd</em></span>, which is started in almost every boot procedure.  After the system is booted, the network daemon just sits and waits until a client program, such as an FTP client, needs to connect.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_03"></a>1.3. Process attributes</h3></div></div></div><p>A process has a series of characteristics<a class="indexterm" name="idm4776"></a>, which can be viewed with the <span class="command"><strong>ps<a class="indexterm" name="idm4780"></a></strong></span> command:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The process ID or PID<a class="indexterm" name="idm4786"></a>: a unique identification number used to refer to the process.</p></li><li class="listitem"><p>The parent process ID or PPID<a class="indexterm" name="idm4790"></a>: the number of the process (PID) that started this process.</p></li><li class="listitem"><p>Nice number: the degree of friendliness<a class="indexterm" name="idm4794"></a> of this process toward other processes (not to be confused with process priority, which is calculated based on this nice number and recent CPU usage of the process).</p></li><li class="listitem"><p>Terminal or TTY<a class="indexterm" name="idm4799"></a>: terminal to which the process is connected.</p></li><li class="listitem"><p>User name of the real and effective user (RUID<a class="indexterm" name="idm4803"></a> and EUID<a class="indexterm" name="idm4805"></a>): the owner of the process.  The real owner is the user issuing the command, the effective user is the one determining access to system resources.  RUID and EUID are usually the same, and the process has the same access rights the issuing user would have.  An example to clarify this: the browser <span class="command"><strong>mozilla</strong></span> in <code class="filename">/usr/bin</code> is owned by user <span class="emphasis"><em>root</em></span>:</p><pre class="screen">
<code class="prompt">theo:~&gt;</code> <span class="command"><strong>ls -l /usr/bin/mozilla</strong></span>
-rwxr-xr-x  1 root   root      4996 Nov 20 18:28 /usr/bin/mozilla*

<code class="prompt">theo:~&gt;</code> <span class="command"><strong>mozilla &amp;</strong></span>
[1] 26595

<code class="prompt">theo:~&gt;</code> <span class="command"><strong>ps -af</strong></span>
UID     PID  PPID C STIME TTY       TIME CMD
theo  26601 26599 0 15:04 pts/5 00:00:00 /usr/lib/mozilla/mozilla-bin
theo  26613 26569 0 15:04 pts/5 00:00:00 ps -af
</pre><p>When user<a class="indexterm" name="idm4818"></a> <span class="emphasis"><em>theo</em></span> starts this program, the process itself and all processes started by the initial process, will be owned by user <span class="emphasis"><em>theo</em></span> and not by the system administrator.  When <span class="command"><strong>mozilla</strong></span> needs access to certain files, that access will be determined by <span class="emphasis"><em>theo</em></span>'s permissions and not by <span class="emphasis"><em>root</em></span>'s.</p></li><li class="listitem"><p>Real and effective group owner (RGID<a class="indexterm" name="idm4828"></a> and EGID<a class="indexterm" name="idm4830"></a>): The real group owner of a process is the primary group of the user who started the process.  The effective group owner is usually the same, except when SGID access mode has been applied to a file.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_04"></a>1.4. Displaying process information</h3></div></div></div><p>The <span class="command"><strong>ps</strong></span> command is one of the tools for visualizing<a class="indexterm" name="idm4836"></a> processes.  This command has several options which can be combined to display different process attributes.</p><p>With no options specified, <span class="command"><strong>ps</strong></span> only gives information about the current shell and eventual processes<a class="indexterm" name="idm4841"></a>:</p><pre class="screen">
<code class="prompt">theo:~&gt;</code> <span class="command"><strong>ps</strong></span>
  PID TTY          TIME CMD
 4245 pts/7    00:00:00 bash
 5314 pts/7    00:00:00 ps
</pre><p>Since this does not give enough information - generally, at least a hundred processes are running on your system - we will usually select particular processes out of the list of all processes, using the <span class="command"><strong>grep</strong></span> command in a <span class="emphasis"><em>pipe</em></span>, see <a class="xref" href="ch05s01.html#sect_05_01_02_01" title="1.2.1. Output redirection with &gt; and |">Section 1.2.1, &#8220;Output redirection with &gt; and |&#8221;</a>, as in this line, which will select and display all processes owned by a particular<a class="indexterm" name="idm4851"></a> user:</p><div class="cmdsynopsis"><p><code class="command">ps <code class="option">-ef</code> | grep <em class="parameter"><code>username</code></em></code> </p></div><p>This example shows all processes with a process name of <span class="command"><strong>bash</strong></span>, the most common login shell on Linux systems:</p><pre class="screen">
<code class="prompt">theo:&gt;</code> <span class="command"><strong>ps auxw | grep bash</strong></span>
brenda   31970  0.0  0.3  6080 1556 tty2   S  Feb23   0:00 -bash
root     32043  0.0  0.3  6112 1600 tty4   S  Feb23   0:00 -bash
theo     32581  0.0  0.3  6384 1864 pts/1  S  Feb23   0:00 bash
theo     32616  0.0  0.3  6396 1896 pts/2  S  Feb23   0:00 bash
theo     32629  0.0  0.3  6380 1856 pts/3  S  Feb23   0:00 bash
theo      2214  0.0  0.3  6412 1944 pts/5  S  16:18   0:02 bash
theo      4245  0.0  0.3  6392 1888 pts/7  S  17:26   0:00 bash
theo      5427  0.0  0.1  3720  548 pts/7  S  19:22   0:00 grep bash
</pre><p>In these cases, the <span class="command"><strong>grep</strong></span> command finding lines containing the string <span class="emphasis"><em>bash</em></span> is often displayed as well on systems that have a lot of idletime.  If you don't want this to happen, use the <span class="command"><strong>pgrep<a class="indexterm" name="idm4867"></a></strong></span> command.</p><p>Bash shells are a special case: this process list also shows which ones are login shells (where you have to give your username and password, such as when you log in in textmode or do a remote login, as opposed to non-login shells, started up for instance by clicking a terminal window icon).  Such login shells are preceded with a dash (-).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">|?</h3><p>We will explain about the | operator in the next chapter, see <a class="xref" href="ch05.html" title="Chapter 5. I/O redirection">Chapter 5, <i>I/O redirection</i></a>.</p></div><p>More info can be found the usual way: <span class="command"><strong>ps <code class="option">--help</code></strong></span> or <span class="command"><strong>man <em class="parameter"><code>ps</code></em></strong></span>.  GNU <span class="command"><strong>ps</strong></span> supports different styles of option formats; the above examples don't contain errors.</p><p>Note that <span class="command"><strong>ps</strong></span> only gives a momentary state of the active processes, it is a one-time recording.  The <span class="command"><strong>top<a class="indexterm" name="idm4883"></a></strong></span> program displays a more precise view by updating the results given by <span class="command"><strong>ps</strong></span> (with a bunch of options) once every five seconds, generating a new list of the processes causing the heaviest<a class="indexterm" name="idm4886"></a> load periodically, meanwhile integrating more information about the swap space in use and the state of the CPU, from the <code class="filename">proc</code> file system<a class="indexterm" name="idm4890"></a>:</p><pre class="screen">
 12:40pm up 9 days, 6:00, 4 users, load average: 0.21, 0.11, 0.03
89 processes: 86 sleeping, 3 running, 0 zombie, 0 stopped
CPU states:  2.5% user,  1.7% system,  0.0% nice, 95.6% idle
Mem:   255120K av, 239412K used, 15708K free, 756K shrd, 22620K buff
Swap: 1050176K av, 76428K used, 973748K free, 82756K cached

  PID USER  PRI NI SIZE  RSS SHARE STAT %CPU %MEM TIME COMMAND
 5005 root  14  0 91572  15M 11580 R    1.9  6.0  7:53 X
19599 jeff  14  0  1024 1024   796 R    1.1  0.4  0:01 top
19100 jeff   9  0  5288 4948  3888 R    0.5  1.9  0:24 gnome-terminal
19328 jeff   9  0 37884  36M 14724 S    0.5 14.8  1:30 mozilla-bin
    1 root   8  0   516  472   464 S    0.0  0.1  0:06 init
    2 root   9  0     0    0     0 SW   0.0  0.0  0:02 keventd
    3 root   9  0     0    0     0 SW   0.0  0.0  0:00 kapm-idled
    4 root  19 19     0    0     0 SWN  0.0  0.0  0:00 ksoftirqd_CPU0
    5 root   9  0     0    0     0 SW   0.0  0.0  0:33 kswapd
    6 root   9  0     0    0     0 SW   0.0  0.0  0:00 kreclaimd
    7 root   9  0     0    0     0 SW   0.0  0.0  0:00 bdflush
    8 root   9  0     0    0     0 SW   0.0  0.0  0:05 kupdated
    9 root  -1-20     0    0     0 SW&lt;  0.0  0.0  0:00 mdrecoveryd
   13 root   9  0     0    0     0 SW   0.0  0.0  0:01 kjournald
   89 root   9  0     0    0     0 SW   0.0  0.0  0:00 khubd
  219 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
  220 root   9  0     0    0     0 SW   0.0  0.0  0:00 kjournald
</pre><p>The first line of <span class="command"><strong>top</strong></span> contains the same information displayed by the <span class="command"><strong>uptime<a class="indexterm" name="idm4897"></a></strong></span> command:</p><pre class="screen">
<code class="prompt">jeff:~&gt;</code> <span class="command"><strong>uptime</strong></span>
  3:30pm, up 12 days, 23:29, 6 users, load average: 0.01, 0.02, 0.00
</pre><p>The data for these programs is stored among others in <code class="filename">/var/run/utmp</code> (information about currently connected users) and in the virtual file system <code class="filename">/proc<a class="indexterm" name="idm4905"></a></code>, for example <code class="filename">/proc/loadavg</code> (average load information).  There are all sorts of graphical applications to view this data, such as the <span class="application">Gnome System Monitor<a class="indexterm" name="idm4909"></a></span> and <span class="emphasis"><em>lavaps</em></span>.  Over at <a class="ulink" href="http://www.freshmeat.net" target="_top">FreshMeat</a> and <a class="ulink" href="http://www.sourceforge.org" target="_top">SourceForge</a> you will find tens of applications that centralize this information along with other server data and logs from multiple servers on one (web) server, allowing monitoring of the entire IT infrastructure from one workstation.</p><p>The relations<a class="indexterm" name="idm4915"></a> between processes can be visualized using the <span class="command"><strong>pstree<a class="indexterm" name="idm4919"></a></strong></span> command:</p><pre class="screen">
<code class="prompt">sophie:~&gt;</code> <span class="command"><strong>pstree</strong></span>
init-+-amd
     |-apmd
     |-2*[artsd]
     |-atd
     |-crond
     |-deskguide_apple
     |-eth0
     |-gdm---gdm-+-X
     |           `-gnome-session-+-Gnome
     |                           |-ssh-agent
     |                           `-true
     |-geyes_applet
     |-gkb_applet
     |-gnome-name-serv
     |-gnome-smproxy
     |-gnome-terminal-+-bash---vim
     |                |-bash
     |                |-bash---pstree
     |                |-bash---ssh
     |                |-bash---mozilla-bin---mozilla-bin---3*[mozilla-bin]
     |                `-gnome-pty-helper
     |-gpm
     |-gweather
     |-kapm-idled
     |-3*[kdeinit]
     |-keventd
     |-khubd
     |-5*[kjournald]
     |-klogd
     |-lockd---rpciod
     |-lpd
     |-mdrecoveryd
     |-6*[mingetty]
     |-8*[nfsd]
     |-nscd---nscd---5*[nscd]
     |-ntpd
     |-3*[oafd]
     |-panel
     |-portmap
     |-rhnsd
     |-rpc.mountd
     |-rpc.rquotad
     |-rpc.statd
     |-sawfish
     |-screenshooter_a
     |-sendmail
     |-sshd---sshd---bash---su---bash
     |-syslogd
     |-tasklist_applet
     |-vmnet-bridge
     |-xfs
     `-xinetd-ipv6
</pre><p>The <code class="option">-u</code> and <code class="option">-a</code> options give additional information.  For more options and what they do, refer to the <span class="application">Info</span> pages.</p><p>In the next section, we will see how one process can create another.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_05"></a>1.5. Life and death of a process</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_05_01"></a>1.5.1. Process creation</h4></div></div></div><p>A new process<a class="indexterm" name="idm4934"></a> is created because an existing process makes an exact copy of itself.  This child process has the same environment as its parent, only the process ID number is different.  This procedure is called <span class="emphasis"><em>forking<a class="indexterm" name="idm4938"></a></em></span>.</p><p>After the forking process, the address space of the child process is overwritten with the new process data.  This is done through an <span class="emphasis"><em>exec<a class="indexterm" name="idm4943"></a></em></span> call to the system.</p><p>The <span class="emphasis"><em>fork-and-exec<a class="indexterm" name="idm4948"></a></em></span> mechanism thus switches an old command with a new, while the environment in which the new program is executed remains the same, including configuration of input and output devices, environment variables and priority.  This mechanism is used to create all UNIX processes, so it also applies to the Linux operating system.  Even the first process, <span class="command"><strong>init<a class="indexterm" name="idm4951"></a></strong></span>, with process ID 1, is forked during the boot procedure in the so-called <span class="emphasis"><em>bootstrapping<a class="indexterm" name="idm4954"></a></em></span> procedure.</p><p>This scheme illustrates the fork-and-exec mechanism.  The process ID changes after the fork procedure:</p><div class="figure"><a name="idm4957"></a><p class="title"><b>Figure 4.1. Fork-and-exec mechanism</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/fork-and-exec.png" alt="Fork creates a new process with the same content as the parent in memory but a different PID, exec replaces the content with the actual data to be processed, PID stays the same."></div></div></div><br class="figure-break"><p>There are a couple of cases in which <span class="command"><strong>init</strong></span> becomes the parent of a process, while the process was not started by <span class="command"><strong>init</strong></span>, as we already saw in the <span class="command"><strong>pstree</strong></span> example.   Many programs, for instance, <span class="emphasis"><em>daemonize<a class="indexterm" name="idm4971"></a></em></span> their child processes, so they can keep on running when the parent stops or is being stopped.  A window manager is a typical example; it starts an <span class="command"><strong>xterm</strong></span> process that generates a shell that accepts commands.  The window manager then denies any further responsibility and passes the child process to <span class="command"><strong>init</strong></span>.  Using this mechanism, it is possible to change window managers without interrupting running applications.</p><p>Every now and then things go wrong, even in good families.  In an exceptional case, a process might finish while the parent does not wait for the completion of this process.  Such an unburied process is called a <span class="emphasis"><em>zombie</em></span> process<a class="indexterm" name="idm4978"></a>.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_05_02"></a>1.5.2. Ending processes</h4></div></div></div><p>When a process<a class="indexterm" name="idm4984"></a> ends normally (it is not killed or otherwise unexpectedly interrupted), the program returns its <span class="emphasis"><em>exit status<a class="indexterm" name="idm4988"></a></em></span> to the parent.  This exit status is a number returned by the program providing the results of the program's execution.  The system of returning information upon executing a job has its origin in the C programming language in which UNIX has been written.</p><p>The return codes<a class="indexterm" name="idm4991"></a> can then be interpreted by the parent, or in scripts.  The values of the return codes are program-specific.  This information can usually be found in the man pages of the specified program, for example the <span class="command"><strong>grep</strong></span> command returns <code class="computeroutput">-1</code> if no matches are found, upon which a message on the lines of <span class="quote">&#8220;<span class="quote">No files found</span>&#8221;</span> can be printed.  Another example is the <span class="application">Bash</span> builtin command <span class="command"><strong>true</strong></span>, which does nothing except return an exit status of 0, meaning success.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_04_01_05_03"></a>1.5.3. Signals</h4></div></div></div><p>Processes end<a class="indexterm" name="idm5002"></a> because they receive a signal<a class="indexterm" name="idm5005"></a>.  There are multiple signals that you can send to a process.  Use the <span class="command"><strong>kill<a class="indexterm" name="idm5009"></a></strong></span> command to send a signal to a process.  The command <span class="command"><strong>kill <code class="option">-l</code></strong></span> shows a list of signals.  Most signals are for internal use by the system, or for programmers when they write code.  As a user, you will need the following signals<a class="indexterm" name="idm5013"></a>:</p><div class="table"><a name="idm5016"></a><p class="title"><b>Table 4.2. Common signals</b></p><div class="table-contents"><table class="table" summary="Common signals" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">Signal name</th><th align="left">Signal number</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">SIGTERM<a class="indexterm" name="idm5027"></a></td><td align="left">15</td><td align="left">Terminate the process in an orderly way.</td></tr><tr><td align="left">SIGINT<a class="indexterm" name="idm5033"></a></td><td align="left">2</td><td align="left">Interrupt the process.  A process can ignore this signal.</td></tr><tr><td align="left">SIGKILL<a class="indexterm" name="idm5039"></a></td><td align="left">9</td><td align="left">Interrupt the process.  A process can not ignore this signal.</td></tr><tr><td align="left">SIGHUP<a class="indexterm" name="idm5045"></a></td><td align="left">1</td><td align="left">For daemons: reread the configuration file.</td></tr></tbody></table></div></div><br class="table-break"><p>You can read more about default actions that are taken when sending a signal to a process in <span class="command"><strong>man <code class="option">7</code> <em class="parameter"><code>signal</code></em></strong></span>.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_04_01_06"></a>1.6. SUID and SGID</h3></div></div></div><p>As promised in the previous chapter, we will now discuss the special modes SUID<a class="indexterm" name="idm5056"></a> and SGID<a class="indexterm" name="idm5058"></a> in more detail.  These modes exist to provide normal users the ability to execute tasks they would normally not be able to do because of the tight file permission scheme used on UNIX based systems.  In the ideal situation special modes are used as sparsely as possible, since they include security risks.  Linux developers have generally tried to avoid them as much as possible.  The Linux <span class="command"><strong>ps</strong></span> version, for example, uses the information stored in the <code class="filename">/proc</code> file system, which is accessible to everyone, thus avoiding exposition of sensitive system data and resources to the general public.  Before that, and still on older UNIX systems, the <span class="command"><strong>ps</strong></span> program needed access to files such as <code class="filename">/dev/mem<a class="indexterm" name="idm5064"></a></code> and <code class="filename">/dev/kmem<a class="indexterm" name="idm5067"></a></code>, which had disadvantages because of the permissions and ownerships on these files:</p><pre class="screen">
<code class="prompt">rita:~&gt;</code> <span class="command"><strong>ls -l /dev/*mem</strong></span>
crw-r-----    1 root     kmem       1,   2 Aug 30 22:30 /dev/kmem
crw-r-----    1 root     kmem       1,   1 Aug 30 22:30 /dev/mem
</pre><p>With older versions of <span class="command"><strong>ps</strong></span>, it was not possible to start the program as a common user, unless special modes were applied to it.</p><p>While we generally try to avoid applying any special modes, it is sometimes necessary to use an SUID.  An example is the mechanism for changing passwords.  Of course users will want to do this themselves instead of having their password set by the system administrator.  As we know, user names and passwords are listed in the <code class="filename">/etc/passwd<a class="indexterm" name="idm5076"></a></code> file, which has these access permissions and owners:</p><pre class="screen">
<code class="prompt">bea:~&gt;</code> <span class="command"><strong>ls -l /etc/passwd</strong></span>
-rw-r--r--    1 root     root     1267 Jan 16 14:43 /etc/passwd
</pre><p>Still, users need to be able to change their own information in this file.  This is achieved by giving the <span class="command"><strong>passwd</strong></span> program special permissions:</p><pre class="screen">
<code class="prompt">mia:~&gt;</code> <span class="command"><strong>which passwd</strong></span>
passwd is /usr/bin/passwd

<code class="prompt">mia:~&gt;</code> <span class="command"><strong>ls -l /usr/bin/passwd</strong></span>
-r-s--x--x    1 root     root    13476 Aug  7 06:03 /usr/bin/passwd*
</pre><p>When called, the <span class="command"><strong>passwd</strong></span> command will run using the access permissions<a class="indexterm" name="idm5090"></a> of <span class="emphasis"><em>root</em></span>, thus enabling a common user to edit the password file which is owned by the system admin.</p><p>SGID modes on a file don't occur nearly as frequently as SUID, because SGID often involves the creation of extra groups.  In some cases, however, we have to go through this trouble in order to build an elegant solution (don't worry about this too much -  the necessary groups are usually created upon installation).  This is the case for the <span class="command"><strong>write<a class="indexterm" name="idm5096"></a></strong></span> and <span class="command"><strong>wall<a class="indexterm" name="idm5100"></a></strong></span> programs, which are used to send messages to other users' terminals<a class="indexterm" name="idm5102"></a> (ttys).  The <span class="command"><strong>write</strong></span> command writes a message to a single user, while <span class="command"><strong>wall</strong></span> writes to all connected users.</p><p>Sending text to another user's terminal or graphical display is normally not allowed.  In order to bypass this problem, a group has been created, which owns all terminal devices.  When the <span class="command"><strong>write</strong></span> and <span class="command"><strong>wall</strong></span> commands are granted SGID permissions, the commands will run using the access rights as applicable to this group, <span class="emphasis"><em>tty</em></span> in the example.  Since this group has write access to the destination terminal, also a user having no permissions to use that terminal in any way can send messages to it.</p><p>In the example below, user <span class="emphasis"><em>joe</em></span> first finds out on which terminal his correspondent is connected, using the <span class="command"><strong>who</strong></span> command.  Then he sends her a message using the <span class="command"><strong>write</strong></span> command.  Also illustrated are the access rights on the <span class="command"><strong>write</strong></span> program and on the terminals occupied by the receiving user: it is clear that others than the user owner have no permissions<a class="indexterm" name="idm5116"></a> on the device, except for the group owner, which can write to it.</p><pre class="screen">
<code class="prompt">joe:~&gt;</code> <span class="command"><strong>which write</strong></span>
write is /usr/bin/write

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>ls -l /usr/bin/write</strong></span>
-rwxr-sr-x    1 root     tty      8744 Dec  5 00:55 /usr/bin/write*

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>who<a class="indexterm" name="idm5126"></a></strong></span>
jenny     tty1     Jan 23 11:41
jenny     pts/1    Jan 23 12:21 (:0)
jenny     pts/2    Jan 23 12:22 (:0)
jenny     pts/3    Jan 23 12:22 (:0)
joe       pts/0    Jan 20 10:13 (lo.callhost.org)

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>ls -l /dev/tty1</strong></span>
crw--w----    1 jenny   tty  4,     1 Jan 23 11:41 /dev/tty1

<code class="prompt">joe:~&gt;</code> <span class="command"><strong>write jenny tty1</strong></span>
hey Jenny, shall we have lunch together?
^C
</pre><p>User <span class="emphasis"><em>jenny</em></span> gets this on her screen:</p><pre class="screen">
Message from joe@lo.callhost.org on ptys/1 at 12:36 ...
hey Jenny, shall we have lunch together?
EOF
</pre><p>After receiving a message, the terminal can be cleared using the <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>L</strong></span> key combination.  In order to receive no messages at all (except from the system administrator), use the <span class="command"><strong>mesg</strong></span> command.  To see which connected users accept messages from others use <span class="command"><strong>who <code class="option">-w</code></strong></span>.  All features are fully explained in the <span class="application">Info</span> pages of each command.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Group names may vary</h3><p>The group scheme is specific to the distribution.  Other distributions may use other names or other solutions.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. Processes </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2. Boot process, Init and shutdown</td></tr></table></div></body></html>
