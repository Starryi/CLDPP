<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>1. General overview of the Linux file system</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Beginners, linux, start, Getting started, guide, Guide, Exercises, exercises"><link rel="home" href="index.html" title="Introduction to Linux"><link rel="up" href="ch03.html" title="Chapter 3. About files and the file system"><link rel="prev" href="ch03.html" title="Chapter 3. About files and the file system"><link rel="next" href="ch03s02.html" title="2. Orientation in the file system"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. General overview of the Linux file system</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><th width="60%" align="center">Chapter 3. About files and the file system</th><td width="20%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_03_01"></a>1. General overview of the Linux file system</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_01_01"></a>1.1. Files</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_01_01"></a>1.1.1. General</h4></div></div></div><p>A simple description<a class="indexterm" name="idm1680"></a> of the UNIX system, also applicable to Linux, is this:</p><p><span class="quote">&#8220;<span class="quote">On a UNIX system, everything is a file; if something is not a file, it is a process.</span>&#8221;</span></p><p>This statement is true because there are special<a class="indexterm" name="idm1686"></a> files that are more than just files (named pipes and sockets, for instance), but to keep things simple, saying that everything is a file is an acceptable generalization.  A Linux system, just like UNIX, makes no difference between a file and a directory, since a directory is just a file containing names of other files.  Programs, services, texts, images, and so forth, are all files.  Input and output devices, and generally all devices, are considered to be files, according to the system.</p><p>In order to manage all those files in an orderly fashion, man likes to think of them in an ordered tree-like structure<a class="indexterm" name="idm1690"></a> on the hard disk, as we know from <span class="application">MS-DOS</span> (Disk Operating System) for instance.  The large branches contain more branches, and the branches at the end contain the tree's leaves or normal files.  For now we will use this image of the tree, but we will find out later why this is not a fully accurate image.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_01_02"></a>1.1.2. Sorts of files</h4></div></div></div><p>Most files<a class="indexterm" name="idm1697"></a> are just files, called <span class="emphasis"><em>regular<a class="indexterm" name="idm1701"></a></em></span> files; they contain normal data, for example text files, executable files or programs, input for or output from a program and so on.</p><p>While it is reasonably safe to suppose that everything you encounter on a Linux system is a file, there are some exceptions.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Directories</em></span>: files<a class="indexterm" name="idm1709"></a> that are lists of other files.</p></li><li class="listitem"><p><span class="emphasis"><em>Special files</em></span>: the mechanism<a class="indexterm" name="idm1715"></a> used for input and output.  Most special files are in <code class="filename">/dev</code>, we will discuss them later.</p></li><li class="listitem"><p><span class="emphasis"><em>Links</em></span>: a system<a class="indexterm" name="idm1722"></a> to make a file or directory visible in multiple parts of the system's file tree.  We will talk about links in detail.</p></li><li class="listitem"><p><span class="emphasis"><em>(Domain) sockets</em></span>: a special<a class="indexterm" name="idm1728"></a> file type, similar to TCP/IP sockets, providing inter-process networking protected by the file system's access control.</p></li><li class="listitem"><p><span class="emphasis"><em>Named pipes</em></span>: act<a class="indexterm" name="idm1734"></a> more or less like sockets and form a way for processes to communicate with each other, without using network socket semantics.</p></li></ul></div><p>The <code class="option">-l</code> option to <span class="command"><strong>ls<a class="indexterm" name="idm1740"></a></strong></span> displays the file type, using the first character of each input line:</p><pre class="screen">
<code class="prompt">jaime:~/Documents&gt;</code> <span class="command"><strong>ls -l</strong></span>
total 80
-rw-rw-r--   1 jaime   jaime   31744 Feb 21 17:56 intro Linux.doc
-rw-rw-r--   1 jaime   jaime   41472 Feb 21 17:56 Linux.doc
drwxrwxr-x   2 jaime   jaime    4096 Feb 25 11:50 course
</pre><p>This table gives an overview of the characters determining the file type<a class="indexterm" name="idm1746"></a>:</p><div class="table"><a name="idm1749"></a><p class="title"><b>Table 3.1. File types in a long list</b></p><div class="table-contents"><table class="table" summary="File types in a long list" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Symbol</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">-</td><td align="left">Regular<a class="indexterm" name="idm1760"></a> file</td></tr><tr><td align="left">d</td><td align="left">Directory</td></tr><tr><td align="left">l</td><td align="left">Link</td></tr><tr><td align="left">c</td><td align="left">Special file</td></tr><tr><td align="left">s</td><td align="left">Socket</td></tr><tr><td align="left">p</td><td align="left">Named pipe</td></tr><tr><td align="left">b</td><td align="left">Block device</td></tr></tbody></table></div></div><br class="table-break"><p>In order not to always have to perform a long listing for seeing the file type, a lot of systems by default don't issue just <span class="command"><strong>ls<a class="indexterm" name="idm1782"></a></strong></span>, but <span class="command"><strong>ls <code class="option">-F</code></strong></span>, which suffixes file names with one of the characters <span class="quote">&#8220;<span class="quote">/=*|@</span>&#8221;</span> to indicate the file type.  To make it extra easy on the beginning user, both the <code class="option">-F</code> and <code class="option">--color<a class="indexterm" name="idm1789"></a></code> options are usually combined, see <a class="xref" href="ch03s03.html#sect_03_03_01_01" title="3.1.1. More about ls">Section 3.1.1, &#8220;More about ls&#8221;</a>.  We will use <span class="command"><strong>ls <code class="option">-F</code></strong></span> throughout this document for better readability.</p><p>As a user, you only need to deal directly with plain files, executable files, directories and links.  The special file types are there for making your system do what you demand from it and are dealt with by system administrators and programmers.</p><p>
Now, before we look at the important files and directories, we need to know more about partitions.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_01_02"></a>1.2. About partitioning</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_02_01"></a>1.2.1. Why partition?</h4></div></div></div><p>Most people have a vague knowledge of what partitions are, since every operating system has the ability to create or remove them.  It may seem strange that Linux uses more than one partition on the same disk, even when using the standard installation procedure, so some explanation is called for.</p><p>One of the goals of having different partitions<a class="indexterm" name="idm1802"></a> is to achieve higher data security in case of disaster.  By dividing the hard disk in partitions, data can be grouped and separated.  When an accident occurs, only the data in the partition that got the hit will be damaged, while the data on the other partitions will most likely survive. </p><p>This principle dates from the days when Linux didn't have journaled<a class="indexterm" name="idm1806"></a> file systems and power failures might have lead to disaster.  The use of partitions remains for security and robustness reasons, so a breach on one part of the system doesn't automatically mean that the whole computer is in danger.  This is currently the most important reason for partitioning.  A simple example: a user creates a script, a program or a web application that starts filling up the disk.  If the disk contains only one big partition, the entire system will stop functioning if the disk is full.  If the user stores the data on a separate partition, then only that (data) partition will be affected, while the system partitions and possible other data partitions keep functioning.</p><p>Mind that having a journaled file system only provides data security in case of power failure and sudden disconnection of storage devices.  This does not protect your data against bad blocks and logical errors in the file system.  In those cases, you should use a RAID (Redundant Array of Inexpensive Disks) solution.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_02_02"></a>1.2.2. Partition layout and types</h4></div></div></div><p>There are two kinds of major partitions<a class="indexterm" name="idm1812"></a> on a Linux system:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>data partition<a class="indexterm" name="idm1819"></a></em></span>: normal Linux system data, including the <span class="emphasis"><em>root partition</em></span> containing all the data to start up and run the system; and </p></li><li class="listitem"><p><span class="emphasis"><em>swap partition<a class="indexterm" name="idm1825"></a></em></span>: expansion of the computer's physical memory, extra memory on hard disk.</p></li></ul></div><p>Most systems contain a root partition, one or more data partitions and one or more swap partitions.  Systems in mixed environments may contain partitions for other system data, such as a partition with a FAT or VFAT file system for MS Windows data.</p><p>Most Linux systems use <span class="command"><strong>fdisk<a class="indexterm" name="idm1830"></a></strong></span> at installation time to set<a class="indexterm" name="idm1832"></a> the partition type.  As you may have noticed during the exercise from Chapter 1, this usually happens automatically.  On some occasions, however, you may not be so lucky.  In such cases, you will need to select the partition type manually and even manually do the actual partitioning.  The standard Linux partitions have number 82 for swap and 83 for data, which can be journaled (ext3) or normal (ext2, on older systems).  The <span class="command"><strong>fdisk</strong></span> utility has built-in help, should you forget these values.</p><p>Apart from these two, Linux supports a variety of other file system types, such as the relatively new Reiser file system, JFS, NFS, FATxx and many other file systems natively available on other (proprietary) operating systems.</p><p>The standard root partition<a class="indexterm" name="idm1838"></a> (indicated with a single forward slash<a class="indexterm" name="idm1841"></a>, <span class="emphasis"><em>/</em></span>) is about 100-500 MB, and contains<a class="indexterm" name="idm1845"></a> the system configuration files, most basic commands and server programs, system libraries, some temporary space and the home directory of the administrative user.  A standard installation requires about 250 MB for the root partition.</p><p>Swap<a class="indexterm" name="idm1848"></a> space (indicated with <span class="emphasis"><em>swap<a class="indexterm" name="idm1851"></a></em></span>) is only accessible for the system itself, and is hidden from view during normal operation.  Swap is the system that ensures, like on normal UNIX systems, that you can keep on working, whatever happens.  On Linux, you will virtually never see irritating messages like <span class="emphasis"><em>Out of memory, please close some applications first and try again</em></span>, because of this extra memory.  The swap or virtual memory procedure has long been adopted by operating systems outside the UNIX world by now.</p><p>Using memory on a hard disk is naturally slower than using the real memory chips of a computer, but having this little extra is a great comfort.  We will learn more about swap when we discuss processes in <a class="xref" href="ch04.html" title="Chapter 4. Processes">Chapter 4, <i>Processes</i></a>.</p><p>Linux generally counts on having twice the amount of physical memory in the form of swap space on the hard disk.  When installing a system, you have to know how you are going to do this.  An example<a class="indexterm" name="idm1858"></a> on a system with 512 MB of RAM:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>1st possibility: one swap partition of 1 GB</p></li><li class="listitem"><p>2nd possibility: two swap partitions of 512 MB</p></li><li class="listitem"><p>3rd possibility: with two hard disks: 1 partition of 512 MB on each disk.</p></li></ul></div><p>The last option will give the best results when a lot of I/O is to be expected.</p><p>Read the software documentation for specific guidelines.  Some applications, such as databases, might require more swap space.  Others, such as some handheld systems, might not have any swap at all by lack of a hard disk.  Swap space may also depend on your kernel version.</p><p>The kernel is on a separate partition as well in many distributions, because it is the most important file of your system.  If this is the case, you will find that you also have a <span class="emphasis"><em>/boot<a class="indexterm" name="idm1872"></a></em></span> partition, holding your kernel(s) and accompanying data files.</p><p>The rest of the hard disk(s) is generally divided in data partitions<a class="indexterm" name="idm1875"></a>, although it may be that all of the non-system critical data resides on one partition, for example when you perform a standard workstation installation.  When non-critical data is separated on different partitions, it usually happens following<a class="indexterm" name="idm1877"></a> a set pattern:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>a partition for user programs (<span class="emphasis"><em>/usr</em></span>)</p></li><li class="listitem"><p>a partition containing the users' personal data (<span class="emphasis"><em>/home</em></span>)</p></li><li class="listitem"><p>a partition to store temporary data like print- and mail-queues (<span class="emphasis"><em>/var</em></span>)</p></li><li class="listitem"><p>a partition for third party and extra software (<span class="emphasis"><em>/opt</em></span>)</p></li></ul></div><p>Once the partitions are made, you can only add more.  Changing sizes or properties of existing partitions is possible but not advisable.</p><p>The division of hard disks into partitions is determined by the system administrator.  On larger<a class="indexterm" name="idm1895"></a> systems, he or she may even spread one partition over several hard disks, using the appropriate software.  Most distributions allow for standard setups optimized for workstations (average users) and for general server purposes, but also accept customized partitions.  During the installation process you can define your own partition layout using either your distribution specific tool, which is usually a straight forward graphical interface, or <span class="command"><strong>fdisk<a class="indexterm" name="idm1899"></a></strong></span>, a text-based tool for creating partitions and setting their properties.</p><p>A workstation<a class="indexterm" name="idm1902"></a> or client installation is for use by mainly one and the same person.  The selected software for installation reflects this and the stress is on common user packages, such as nice desktop themes, development tools, client programs for E-mail, multimedia software, web and other services.  Everything is put together on one large partition, swap space twice the amount of RAM is added and your generic workstation is complete, providing the largest amount of disk space possible for personal use, but with the disadvantage of possible data integrity loss during problem situations.</p><p>On a server, system data<a class="indexterm" name="idm1906"></a> tends to be separate from user data.  Programs that offer services are kept in a different place than the data handled by this service.  Different partitions will be created on such systems:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>a partition with all data necessary to boot the machine</p></li><li class="listitem"><p>a partition with configuration data and server programs</p></li><li class="listitem"><p>one or more partitions containing the server data such as database tables, user mails, an ftp archive etc.</p></li><li class="listitem"><p>a partition with user programs and applications</p></li><li class="listitem"><p>one or more partitions for the user specific files (home directories)</p></li><li class="listitem"><p>one or more swap partitions (virtual memory)</p></li></ul></div><p>Servers usually have more memory and thus more swap space.  Certain server processes, such as databases, may require more swap space than usual; see the specific documentation for detailed information.  For better performance, swap is often divided into different swap partitions.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_02_03"></a>1.2.3. Mount points</h4></div></div></div><p>All partitions<a class="indexterm" name="idm1926"></a> are attached to the system via a mount point<a class="indexterm" name="idm1929"></a>.  The mount point defines the place of a particular data set in the file system.  Usually, all partitions are connected through the <span class="emphasis"><em>root</em></span> partition<a class="indexterm" name="idm1932"></a>.  On this partition, which is indicated with the slash (/), directories are created.  These empty directories will be the starting point of the partitions that are attached to them.  An example: given a partition that holds the following directories:</p><pre class="screen">
videos/		cd-images/	pictures/
</pre><p>We want to attach<a class="indexterm" name="idm1937"></a> this partition in the filesystem in a directory called <code class="filename">/opt/media</code>.  In order to do this, the system administrator has to make sure that the directory <code class="filename">/opt/media</code> exists on the system.  Preferably, it should be an empty directory.  How this is done is explained later in this chapter.  Then, using the <span class="command"><strong>mount</strong></span> command, the administrator can attach the partition to the system.  When you look at the content of the formerly empty directory <code class="filename">/opt/media</code>, it will contain the files and directories that are on the mounted medium (hard disk or partition of a hard disk, CD, DVD, flash card, USB or other storage device).</p><p>During system startup, all the partitions are thus mounted, as described in the file <code class="filename">/etc/fstab<a class="indexterm" name="idm1946"></a></code>.  Some partitions are not mounted by default, for instance if they are not constantly connected to the system, such like the storage used by your digital camera.  If well configured, the device will be mounted as soon as the system notices that it is connected, or it can be user-mountable, i.e. you don't need to be system administrator to attach and detach the device to and from the system.  There is an example in <a class="xref" href="ch09s03.html" title="3. Using rsync">Section 3, &#8220;Using rsync&#8221;</a>.</p><p>On a running system, information about the partitions and their mount points can be displayed using the <span class="command"><strong>df<a class="indexterm" name="idm1951"></a></strong></span> command (which stands for <span class="emphasis"><em>disk full</em></span> or <span class="emphasis"><em>disk free</em></span>).  In Linux, <span class="command"><strong>df</strong></span> is the GNU version, and supports the <code class="option">-h</code> or <span class="emphasis"><em>human readable</em></span> option which greatly improves readability.  Note that commercial UNIX machines commonly have their own versions of <span class="command"><strong>df</strong></span> and many other commands.  Their behavior is usually the same, though GNU versions of common tools often have more and better features.</p><p>The <span class="command"><strong>df</strong></span> command only displays information about active non-swap partitions.  These can include partitions from other networked systems, like in the example below where the home directories are mounted from a file server on the network, a situation often encountered in corporate<a class="indexterm" name="idm1961"></a> environments.</p><pre class="screen">
<code class="prompt">freddy:~&gt;</code> <span class="command"><strong>df -h</strong></span>
Filesystem          Size  Used Avail Use% Mounted on
/dev/hda8           496M  183M  288M  39% /
/dev/hda1           124M  8.4M  109M   8% /boot
/dev/hda5            19G   15G  2.7G  85% /opt
/dev/hda6           7.0G  5.4G  1.2G  81% /usr
/dev/hda7           3.7G  2.7G  867M  77% /var
fs1:/home           8.9G  3.7G  4.7G  44% /.automount/fs1/root/home
</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_01_03"></a>1.3. More file system layout</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_03_01"></a>1.3.1. Visual</h4></div></div></div><p>For convenience, the Linux file system is usually thought of in a tree<a class="indexterm" name="idm1972"></a> structure.  On a standard Linux system you will find the layout generally follows the scheme presented<a class="indexterm" name="idm1975"></a> below.</p><div class="figure"><a name="idm1977"></a><p class="title"><b>Figure 3.1. Linux file system layout</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/FS-layout.png" alt="Graphical overview of Linux top level directories and most important subdirectories."></div></div></div><br class="figure-break"><p>This is a layout from a RedHat system.  Depending on the system admin, the operating system and the mission of the UNIX machine, the structure may vary, and directories may be left out or added at will.  The names are not even required; they are only a convention.</p><p>The tree of the file system starts at the trunk or <span class="emphasis"><em>slash<a class="indexterm" name="idm1989"></a></em></span>, indicated by a forward slash (/).  This directory, containing all underlying directories and files, is also called the <span class="emphasis"><em>root directory<a class="indexterm" name="idm1992"></a></em></span> or <span class="quote">&#8220;<span class="quote">the root</span>&#8221;</span> of the file system.</p><p>Directories that are only one level below the root directory are often preceded by a slash, to indicate their position and prevent confusion with other directories that could have the same name.  When starting with a new system, it is always a good idea to take a look in the root directory<a class="indexterm" name="idm1996"></a>.  Let's see what you could run into:</p><pre class="screen">
<code class="prompt">emmy:~&gt;</code> <span class="command"><strong>cd /</strong></span>
<code class="prompt">emmy:/&gt;</code> <span class="command"><strong>ls</strong></span>
bin/   dev/  home/    lib/         misc/  opt/     root/  tmp/  var/
boot/  etc/  initrd/  lost+found/  mnt/   proc/    sbin/  usr/
</pre><div class="table"><a name="idm2004"></a><p class="title"><b>Table 3.2. Subdirectories of the root directory</b></p><div class="table-contents"><table class="table" summary="Subdirectories of the root directory" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Directory</th><th align="left">Content</th></tr></thead><tbody><tr><td align="left">/bin</td><td align="left">Common<a class="indexterm" name="idm2015"></a> programs, shared by the system, the system administrator and the users.</td></tr><tr><td align="left">/boot</td><td align="left">The startup<a class="indexterm" name="idm2020"></a> files and the kernel, <code class="filename">vmlinuz</code>.  In some recent distributions also <code class="filename">grub</code> data.  Grub is the <span class="application">GRand Unified Boot</span> loader and is an attempt to get rid of the many different boot-loaders we know today.</td></tr><tr><td align="left">/dev</td><td align="left">Contains references<a class="indexterm" name="idm2028"></a> to all the CPU peripheral hardware, which are represented as files with special properties.</td></tr><tr><td align="left">/etc</td><td align="left">Most important<a class="indexterm" name="idm2033"></a> system configuration files are in <code class="filename">/etc</code>, this directory contains data similar to those in the Control Panel in Windows</td></tr><tr><td align="left">/home</td><td align="left">Home directories<a class="indexterm" name="idm2039"></a> of the common users.</td></tr><tr><td align="left">/initrd</td><td align="left">(on some distributions) Information<a class="indexterm" name="idm2044"></a> for booting.  Do not remove!</td></tr><tr><td align="left">/lib</td><td align="left">Library<a class="indexterm" name="idm2049"></a> files, includes files for all kinds of programs needed by the system and the users.</td></tr><tr><td align="left">/lost+found</td><td align="left">Every partition<a class="indexterm" name="idm2054"></a> has a <code class="filename">lost+found</code> in its upper directory.  Files that were saved during failures are here.</td></tr><tr><td align="left">/misc</td><td align="left">For miscellaneous<a class="indexterm" name="idm2060"></a> purposes.</td></tr><tr><td align="left">/mnt</td><td align="left">Standard mount<a class="indexterm" name="idm2065"></a> point for external file systems, e.g. a CD-ROM or a digital camera.</td></tr><tr><td align="left">/net</td><td align="left">Standard mount point<a class="indexterm" name="idm2070"></a> for entire remote file systems</td></tr><tr><td align="left">/opt</td><td align="left">Typically contains<a class="indexterm" name="idm2075"></a> extra and third party software.</td></tr><tr><td align="left">/proc</td><td align="left">A virtual<a class="indexterm" name="idm2080"></a> file system containing information about system resources.  More information about the meaning of the files in <code class="filename">proc</code> is obtained by entering the command <span class="command"><strong>man <em class="parameter"><code>proc</code></em></strong></span> in a terminal window.  The file <code class="filename">proc.txt</code> discusses the virtual file system in detail.</td></tr><tr><td align="left">/root</td><td align="left">The administrative<a class="indexterm" name="idm2089"></a> user's home directory.  Mind the difference between /, the root directory and /root, the home directory of the <span class="emphasis"><em>root</em></span> user.</td></tr><tr><td align="left">/sbin</td><td align="left">Programs<a class="indexterm" name="idm2095"></a> for use by the system and the system administrator.</td></tr><tr><td align="left">/tmp</td><td align="left">Temporary<a class="indexterm" name="idm2100"></a> space for use by the system, cleaned upon reboot, so don't use this for saving any work!</td></tr><tr><td align="left">/usr</td><td align="left">Programs<a class="indexterm" name="idm2105"></a>, libraries, documentation etc. for all user-related programs.</td></tr><tr><td align="left">/var</td><td align="left">Storage for all variable<a class="indexterm" name="idm2110"></a> files and temporary files created by users, such as log files, the mail queue, the print spooler area, space for temporary storage of files downloaded from the Internet, or to keep an image of a CD before burning it.</td></tr></tbody></table></div></div><br class="table-break"><p>How can you find out which partition a directory is on?  Using the <span class="command"><strong>df</strong></span> command with a dot (.) as an option shows the partition the current directory belongs to, and informs about the amount of space used<a class="indexterm" name="idm2114"></a> on this partition:</p><pre class="screen">
<code class="prompt">sandra:/lib&gt;</code> <span class="command"><strong>df -h .</strong></span>
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda7             980M  163M  767M  18% /
</pre><p>As a general rule, every directory under the root directory is on the root partition, unless it has a separate entry in the full listing from <span class="command"><strong>df</strong></span> (or <span class="command"><strong>df <code class="option">-h</code></strong></span> with no other options).</p><p>Read more in <span class="command"><strong>man <em class="parameter"><code>hier<a class="indexterm" name="idm2127"></a></code></em></strong></span>.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_01_03_02"></a>1.3.2. The file system in reality</h4></div></div></div><p>For most users and for most common system administration tasks, it is enough to accept that files and directories are ordered in a tree-like structure.  The computer, however, doesn't understand a thing about trees or tree-structures.</p><p>Every partition<a class="indexterm" name="idm2134"></a> has its own file system.  By imagining all those file systems together, we can form an idea of the tree-structure of the entire system, but it is not as simple as that.  In a file system, a file is represented by an <span class="emphasis"><em>inode<a class="indexterm" name="idm2138"></a></em></span>, a kind of serial number containing information about the actual data that makes up the file: to whom this file belongs, and where is it located on the hard disk.</p><p>Every partition has its own set of inodes; throughout a system with multiple partitions, files with the same inode number can exist.</p><p>Each inode describes a data structure on the hard disk, storing the properties of a file, including the physical location of the file data.  When a hard disk is initialized to accept data storage, usually during the initial system installation process or when adding extra disks to an existing system, a fixed number of inodes per partition is created.  This number will be the maximum amount of files, of all types (including directories, special files, links etc.) that can exist at the same time on the partition.  We typically count on having 1 inode per 2 to 8 kilobytes of storage.</p><p>At the time a new file is created, it gets a free inode.  In that inode is the following<a class="indexterm" name="idm2144"></a> information:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Owner and group owner of the file.</p></li><li class="listitem"><p>File type (regular, directory, ...)</p></li><li class="listitem"><p>Permissions on the file <a class="xref" href="ch03s04.html#sect_03_04_01" title="4.1. Access rights: Linux's first line of defense">Section 4.1, &#8220;Access rights: Linux's first line of defense&#8221;</a></p></li><li class="listitem"><p>Date and time of creation, last read and change.</p></li><li class="listitem"><p>Date and time this information has been changed in the inode.</p></li><li class="listitem"><p>Number of links to this file (see later in this chapter).</p></li><li class="listitem"><p>File size</p></li><li class="listitem"><p>An address defining the actual location of the file data.</p></li></ul></div><p>The only information not included in an inode, is the file name and directory.  These are stored in the special directory files.  By comparing file names and inode numbers, the system can make up a tree-structure that the user understands.  Users can display inode numbers using the <code class="option">-i</code> option to ls.  The inodes have their own separate space on the disk.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. About files and the file system </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2. Orientation in the file system</td></tr></table></div></body></html>
