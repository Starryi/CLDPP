<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Pocket Linux Guide</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="description" content="The Pocket Linux Guide is for anyone interested in learning the techniques of building a GNU/Linux system from source code. The guide is structured as a project that builds a small diskette-based GNU/Linux system called Pocket Linux. Each chapter explores a small piece of the overall system explaining how it works, why it is needed and how to build it. After completing the Pocket Linux project, readers should possess an enhanced knowledge of what makes GNU/Linux systems work as well as the confidence to explore larger, more complex source-code-only projects."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="Pocket-Linux-Guide"></a>Pocket Linux Guide</h1></div><div><div class="author"><h3 class="author"><span class="firstname">David</span> <span class="surname">Horton</span></h3><div class="affiliation"><div class="address"><p><br>
<code class="email">&lt;<a class="email" href="mailto:dhorton&lt;AT&gt;NOSPAM.member.fsf.org">dhorton&lt;AT&gt;NOSPAM.member.fsf.org</a>&gt;</code><br>
</p></div></div></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 3.1</td><td align="left">2005-04-09</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Minor clarifications and spelling corrections.</td></tr><tr><td align="left">Revision 3.0</td><td align="left">2004-11-02</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Changed bootloader to GRUB rather than LILO. Updated
        versions on all source code packages. Made minor clarifications to
        some shell commands and scripts.</td></tr><tr><td align="left">Revision 2.1</td><td align="left">2004-02-18</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Corrected typos. Changed resource site hosting to
        SourceForge. Added appendix B to include the GNU Free Documentation
        License as part of this document.</td></tr><tr><td align="left">Revision 2.0</td><td align="left">2003-11-08</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Updated to use GNU coreutils in place of fileutils,
        sh-utils and textutils. Updated version numbers on many source code
        packages. Introduced Freshmeat as a resource for finding source code.
        Changed /etc/mtab to a real file rather than using a symlink to
        /proc/mounts. Corrected local_fs script errors. Updated email
        address.</td></tr><tr><td align="left">Revision 1.2</td><td align="left">2003-05-31</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Corrected errors in "strip -o library"
        commands.</td></tr><tr><td align="left">Revision 1.1</td><td align="left">2003-05-21</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Bug fixes, typo corrections and improved XML
        markup.</td></tr><tr><td align="left">Revision 1.0</td><td align="left">2003-02-17</td><td align="left">DH</td></tr><tr><td align="left" colspan="3">Initial Release, reviewed by LDP.</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>The Pocket Linux Guide is for anyone interested in learning the
      techniques of building a GNU/Linux system from source code. The guide is
      structured as a project that builds a small diskette-based GNU/Linux
      system called Pocket Linux. Each chapter explores a small piece of the
      overall system explaining how it works, why it is needed and how to
      build it. After completing the Pocket Linux project, readers should
      possess an enhanced knowledge of what makes GNU/Linux systems work as
      well as the confidence to explore larger, more complex source-code-only
      projects.</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#legal">Legal Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#copyright">1. Copyright and License</a></span></dt><dt><span class="sect1"><a href="#disclaimer">2. Disclaimer</a></span></dt></dl></dd><dt><span class="preface"><a href="#idm60">Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm62">1. About Pocket Linux</a></span></dt><dt><span class="sect1"><a href="#idm65">2. Prerequisite Skills</a></span></dt><dt><span class="sect1"><a href="#idm77">3. Project Format</a></span></dt><dt><span class="sect1"><a href="#idm91">4. Help &amp; Support</a></span></dt><dt><span class="sect1"><a href="#idm104">5. Feedback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#initiation">1. Project Initiation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm110">1. A Brief History of GNU/Linux</a></span></dt><dt><span class="sect1"><a href="#idm118">2. The Goal of Pocket Linux</a></span></dt><dt><span class="sect1"><a href="#idm132">3. Working Within The Constraints</a></span></dt></dl></dd><dt><span class="chapter"><a href="#phase1">2. A Simple Prototype</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm140">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm150">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm152">2.1. Simplification</a></span></dt><dt><span class="sect2"><a href="#idm169">2.2. Boot Disk</a></span></dt><dt><span class="sect2"><a href="#idm173">2.3. Root Disk</a></span></dt><dt><span class="sect2"><a href="#idm181">2.4. CPU Compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm185">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm190">3.1. Prepare the boot disk media</a></span></dt><dt><span class="sect2"><a href="#idm200">3.2. Build the GRUB bootloader</a></span></dt><dt><span class="sect2"><a href="#idm207">3.3. Copy the bootloader files to diskette</a></span></dt><dt><span class="sect2"><a href="#idm219">3.4. Finish bootloader installation</a></span></dt><dt><span class="sect2"><a href="#idm227">3.5. Build the Linux kernel</a></span></dt><dt><span class="sect2"><a href="#idm261">3.6. Copy the kernel to diskette</a></span></dt><dt><span class="sect2"><a href="#idm266">3.7. Unmount the boot disk</a></span></dt><dt><span class="sect2"><a href="#idm272">3.8. Prepare the root disk media</a></span></dt><dt><span class="sect2"><a href="#idm279">3.9. Build BASH</a></span></dt><dt><span class="sect2"><a href="#idm292">3.10. Copy BASH to the root disk</a></span></dt><dt><span class="sect2"><a href="#idm299">3.11. Create device files that BASH needs</a></span></dt><dt><span class="sect2"><a href="#idm305">3.12. Unmount the root disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm311">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm313">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm333">4.2. Testing what works</a></span></dt><dt><span class="sect2"><a href="#idm342">4.3. Noting what does not work</a></span></dt><dt><span class="sect2"><a href="#idm352">4.4. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase2">3. Saving Space</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm360">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm367">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm370">2.1. Shared Libraries</a></span></dt><dt><span class="sect2"><a href="#idm376">2.2. Stripped Binaries</a></span></dt><dt><span class="sect2"><a href="#idm383">2.3. Compressed Root Filesystem</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm388">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm392">3.1. Create a ramdisk</a></span></dt><dt><span class="sect2"><a href="#idm399">3.2. Rebuild the BASH shell</a></span></dt><dt><span class="sect2"><a href="#idm409">3.3. Determine which libraries are required</a></span></dt><dt><span class="sect2"><a href="#idm423">3.4. Copy BASH and its libraries to the ramdisk</a></span></dt><dt><span class="sect2"><a href="#idm439">3.5. Create a console device</a></span></dt><dt><span class="sect2"><a href="#idm445">3.6. Compress the ramdisk image</a></span></dt><dt><span class="sect2"><a href="#idm453">3.7. Copy the compressed image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm459">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm463">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm484">4.2. Verify results</a></span></dt><dt><span class="sect2"><a href="#idm487">4.3. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase3">4. Some Basic Utilities</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm495">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm510">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm512">2.1. Determining Required Commands</a></span></dt><dt><span class="sect2"><a href="#idm518">2.2. Locating Source Code</a></span></dt><dt><span class="sect2"><a href="#idm524">2.3. Leveraging FHS</a></span></dt><dt><span class="sect2"><a href="#idm576">2.4. Downloading Source Code</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm581">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm602">3.1. Create a staging area</a></span></dt><dt><span class="sect2"><a href="#idm610">3.2. Copy contents of phase 2 rootdisk</a></span></dt><dt><span class="sect2"><a href="#idm619">3.3. Install binaries from GNU coreutils</a></span></dt><dt><span class="sect2"><a href="#idm633">3.4. Copy additional libraries</a></span></dt><dt><span class="sect2"><a href="#idm651">3.5. Strip binaries and libraries</a></span></dt><dt><span class="sect2"><a href="#idm657">3.6. Create a compressed root disk image</a></span></dt><dt><span class="sect2"><a href="#idm671">3.7. Write the root disk image to floppy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm677">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm682">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm704">4.2. Testing new commands</a></span></dt><dt><span class="sect2"><a href="#idm721">4.3. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase4">5. Checking and Mounting Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm729">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm755">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm757">2.1. Determining necessary utilities.</a></span></dt><dt><span class="sect2"><a href="#idm771">2.2. Finding source code</a></span></dt><dt><span class="sect2"><a href="#idm806">2.3. Automating fsck and mount</a></span></dt><dt><span class="sect2"><a href="#idm817">2.4. File dependencies</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm867">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm869">3.1. Install utilities from e2fsprogs</a></span></dt><dt><span class="sect2"><a href="#idm885">3.2. Install utilities from util-linux</a></span></dt><dt><span class="sect2"><a href="#idm913">3.3. Check library requirements</a></span></dt><dt><span class="sect2"><a href="#idm922">3.4. Strip binaries to save space</a></span></dt><dt><span class="sect2"><a href="#idm928">3.5. Create additional device files</a></span></dt><dt><span class="sect2"><a href="#idm935">3.6. Create the fstab and mtab files</a></span></dt><dt><span class="sect2"><a href="#idm947">3.7. Write a script to check and mount local filesystems</a></span></dt><dt><span class="sect2"><a href="#idm956">3.8. Create a compressed root disk image</a></span></dt><dt><span class="sect2"><a href="#idm968">3.9. Write the root disk image to floppy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm974">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm976">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm994">4.2. Test the local_fs script</a></span></dt><dt><span class="sect2"><a href="#idm1012">4.3. Create and mount additional filesystems</a></span></dt><dt><span class="sect2"><a href="#idm1024">4.4. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase5">6. Automating Startup &amp; Shutdown</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1036">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1058">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1060">2.1. Determining necessary utilities</a></span></dt><dt><span class="sect2"><a href="#idm1073">2.2. Obtaining source code</a></span></dt><dt><span class="sect2"><a href="#idm1080">2.3. Checking dependencies</a></span></dt><dt><span class="sect2"><a href="#idm1087">2.4. Designing a simple GRUB configuration file.</a></span></dt><dt><span class="sect2"><a href="#idm1091">2.5. Outlining start-up scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1127">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1130">3.1. Create a GRUB configuration file</a></span></dt><dt><span class="sect2"><a href="#idm1138">3.2. Install sysvinit utilities</a></span></dt><dt><span class="sect2"><a href="#idm1152">3.3. Create /etc/inittab file</a></span></dt><dt><span class="sect2"><a href="#idm1158">3.4. Create /etc/init.d/rc script</a></span></dt><dt><span class="sect2"><a href="#idm1168">3.5. Modify /etc/init.d/local_fs script</a></span></dt><dt><span class="sect2"><a href="#idm1173">3.6. Create a hostname script</a></span></dt><dt><span class="sect2"><a href="#idm1179">3.7. Create halt &amp; reboot scripts</a></span></dt><dt><span class="sect2"><a href="#idm1193">3.8. Create rcN.d directories and links</a></span></dt><dt><span class="sect2"><a href="#idm1208">3.9. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1220">3.10. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1226">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1228">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm1233">4.2. Verify success of startup scripts</a></span></dt><dt><span class="sect2"><a href="#idm1244">4.3. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase6">7. Enabling Multiple Users</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1257">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1265">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1267">2.1. The login process</a></span></dt><dt><span class="sect2"><a href="#idm1290">2.2. Obtaining source code</a></span></dt><dt><span class="sect2"><a href="#idm1295">2.3. Creating support files</a></span></dt><dt><span class="sect2"><a href="#idm1339">2.4. Dependencies</a></span></dt><dt><span class="sect2"><a href="#idm1356">2.5. Assigning ownership and permissions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1378">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1380">3.1. Verify presence of getty and login</a></span></dt><dt><span class="sect2"><a href="#idm1386">3.2. Modify inittab for multi-user mode</a></span></dt><dt><span class="sect2"><a href="#idm1393">3.3. Create tty devices</a></span></dt><dt><span class="sect2"><a href="#idm1406">3.4. Create support files in /etc</a></span></dt><dt><span class="sect2"><a href="#idm1433">3.5. Copy required libraries</a></span></dt><dt><span class="sect2"><a href="#idm1438">3.6. Set directory and file permissions</a></span></dt><dt><span class="sect2"><a href="#idm1499">3.7. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1511">3.8. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1517">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1519">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm1524">4.2. Add a new user to the system</a></span></dt><dt><span class="sect2"><a href="#idm1537">4.3. Test the new user's ability to use the system</a></span></dt><dt><span class="sect2"><a href="#idm1555">4.4. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#phase7">8. Filling in the Gaps</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1563">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1601">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1603">2.1. more</a></span></dt><dt><span class="sect2"><a href="#idm1624">2.2. More device files</a></span></dt><dt><span class="sect2"><a href="#idm1642">2.3. ps, sed &amp; ed</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1654">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1656">3.1. Write a "more" script</a></span></dt><dt><span class="sect2"><a href="#idm1667">3.2. Create additional device files</a></span></dt><dt><span class="sect2"><a href="#idm1675">3.3. Install ps</a></span></dt><dt><span class="sect2"><a href="#idm1685">3.4. Install sed</a></span></dt><dt><span class="sect2"><a href="#idm1697">3.5. Install ed</a></span></dt><dt><span class="sect2"><a href="#idm1707">3.6. Strip binaries to save space</a></span></dt><dt><span class="sect2"><a href="#idm1712">3.7. Ensure proper permissions</a></span></dt><dt><span class="sect2"><a href="#idm1719">3.8. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1731">3.9. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1737">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1739">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm1742">4.2. Test the "more" script</a></span></dt><dt><span class="sect2"><a href="#idm1756">4.3. Use ps to show running processes</a></span></dt><dt><span class="sect2"><a href="#idm1766">4.4. Run a simple sed script</a></span></dt><dt><span class="sect2"><a href="#idm1778">4.5. Test the "ed" editor</a></span></dt><dt><span class="sect2"><a href="#idm1795">4.6. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#wrap-up">9. Project Wrap Up</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1801">1. Celebrating Accomplishments</a></span></dt><dt><span class="sect1"><a href="#idm1815">2. Planning Next Steps</a></span></dt></dl></dd><dt><span class="appendix"><a href="#a">A. Hosting Applications</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm1829">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1841">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1843">2.1. Support for audio hardware</a></span></dt><dt><span class="sect2"><a href="#idm1857">2.2. Creating space for the program</a></span></dt><dt><span class="sect2"><a href="#idm1909">2.3. Accessing audio files</a></span></dt><dt><span class="sect2"><a href="#idm1920">2.4. Other required files</a></span></dt><dt><span class="sect2"><a href="#idm1933">2.5. Summary of tasks</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1950">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1952">3.1. Create an enhanced boot disk</a></span></dt><dt><span class="sect2"><a href="#idm1987">3.2. Create an enhanced root disk</a></span></dt><dt><span class="sect2"><a href="#idm2025">3.3. Create a compressed /usr disk for mp3blaster</a></span></dt><dt><span class="sect2"><a href="#idm2053">3.4. Create a data diskette for testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2058">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2060">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm2072">4.2. Verify that the /usr diskette loaded properly</a></span></dt><dt><span class="sect2"><a href="#idm2076">4.3. Check the audio device initialization</a></span></dt><dt><span class="sect2"><a href="#idm2083">4.4. Test audio output</a></span></dt><dt><span class="sect2"><a href="#idm2088">4.5. Play a sample file</a></span></dt><dt><span class="sect2"><a href="#idm2095">4.6. System shutdown</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#gfdl">B. GNU Free Documentation License</a></span></dt><dd><dl><dt><span class="section"><a href="#gfdl-0">1. PREAMBLE</a></span></dt><dt><span class="section"><a href="#gfdl-1">2. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="section"><a href="#gfdl-2">3. VERBATIM COPYING</a></span></dt><dt><span class="section"><a href="#gfdl-3">4. COPYING IN QUANTITY</a></span></dt><dt><span class="section"><a href="#gfdl-4">5. MODIFICATIONS</a></span></dt><dt><span class="section"><a href="#gfdl-5">6. COMBINING DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-6">7. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-7">8. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="section"><a href="#gfdl-8">9. TRANSLATION</a></span></dt><dt><span class="section"><a href="#gfdl-9">10. TERMINATION</a></span></dt><dt><span class="section"><a href="#gfdl-10">11. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="section"><a href="#gfdl-addendum">12. ADDENDUM: How to use this License for your documents</a></span></dt></dl></dd></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="legal"></a>Legal Information</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#copyright">1. Copyright and License</a></span></dt><dt><span class="sect1"><a href="#disclaimer">2. Disclaimer</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="copyright"></a>1. Copyright and License</h2></div></div></div><p> This document, <span class="emphasis"><em>Pocket Linux Guide</em></span>, is
    copyright (c) 2003 - 2005 by <span class="emphasis"><em>David Horton</em></span>. Permission
    is granted to copy, distribute and/or modify this document under the terms
    of the GNU Free Documentation License, Version 1.2 or any later version
    published by the Free Software Foundation; with no Invariant Sections,
    with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the
    license is available at the end of this document. </p><p>Linux is a registered trademark of Linus Torvalds. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="disclaimer"></a>2. Disclaimer</h2></div></div></div><p>This documentation is provided as-is with no warranty of any kind,
    either expressed or implied, including, but not limited to, the implied
    warranties of merchantability and fitness for a particular purpose. Use
    the concepts, examples and information at your own risk. The author(s) do
    not take any responsibility for damages that may arise from the use of
    this document. </p><p>All copyrights are held by their respective owners, unless
    specifically noted otherwise. Use of a term in this document should not be
    regarded as affecting the validity of any trademark or service mark.
    Naming of particular products or brands should not be seen as
    endorsements. </p></div></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="idm60"></a>Introduction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm62">1. About Pocket Linux</a></span></dt><dt><span class="sect1"><a href="#idm65">2. Prerequisite Skills</a></span></dt><dt><span class="sect1"><a href="#idm77">3. Project Format</a></span></dt><dt><span class="sect1"><a href="#idm91">4. Help &amp; Support</a></span></dt><dt><span class="sect1"><a href="#idm104">5. Feedback</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm62"></a>1. About Pocket Linux</h2></div></div></div><p>The Pocket Linux Guide demonstrates how to build a small
    console-based GNU/Linux system using only source code and a couple of
    diskettes. It is intended for Linux users who would like to gain a deeper
    understanding about how their system works beneath the shroud of
    distribution specific features and tools. </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm65"></a>2. Prerequisite Skills</h2></div></div></div><p>This guide is intended for intermediate to advanced Linux users. It
    is not intentionally obscure, but certain assumptions about the readers
    skill level are made. Success with this guide depends in part on being
    able to perform the following tasks: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Use basic shell commands</p></li><li class="listitem"><p>Reference man and info pages</p></li><li class="listitem"><p>Build a custom Linux kernel</p></li><li class="listitem"><p>Compile source code using make and related tools</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm77"></a>3. Project Format</h2></div></div></div><p> The Pocket Linux Guide takes a hands-on approach to learning. The
    guide is written with each chapter building a piece of an overall project.
    Chapters are further broken into sections of Analysis, Design,
    Construction and Implementation. This format is derived from Rapid
    Application Development (RAD) methodology. Without going into detail about
    design methodologies, the sections may be summed up as follows. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The Analysis section gives a high-level overview of what is to
        be accomplished in each chapter. It will introduce the tasks that need
        to be completed and why they are important to the overall
        system.</p></li><li class="listitem"><p>The Design section defines the source code packages, files and
        configuration necessary to address the requirements set forth in the
        Analysis section. Much of the theory of why certain system files exist
        and what their purpose is can be found here.</p></li><li class="listitem"><p>The Construction section is where all the hands-on action takes
        place. This section goes into detail about building source code and
        configuring the system files.</p></li><li class="listitem"><p>The Implementation section will test the proper operation of the
        project at the end of each chapter. Often there are a few shell
        commands to perform and samples of expected screen outputs are
        given.</p></li></ul></div><p> Readers interested in learning more about RAD may want to consult a
    textbook covering systems analysis and design or visit the following
    University of California, Davis website on the subject: <a class="ulink" href="http://sysdev.ucdavis.edu/WEBADM/document/rad-stages.htm" target="_top">http://sysdev.ucdavis.edu/WEBADM/document/rad-stages.htm</a>.
    </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm91"></a>4. Help &amp; Support</h2></div></div></div><p> Readers are encouraged to visit the Pocket Linux Resource Site at
    <a class="ulink" href="http://pocket-linux.sourceforge.net" target="_top">http://pocket-linux.sourceforge.net/</a>.
    The resource site is home to: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Information about the Pocket Linux mailing list.</p></li><li class="listitem"><p>A web-based troubleshooting forum where readers can ask
        questions and give tips to others.</p></li><li class="listitem"><p>A collection of diskette images for various chapters.</p></li><li class="listitem"><p>Additional projects that may be of interest to Pocket Linux
        Guide readers.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm104"></a>5. Feedback</h2></div></div></div><p> For technical questions about Pocket Linux please use the mailing
    list or the troubleshooting forum on the <a class="ulink" href="http://pocket-linux.sourceforge.net" target="_top">resource site</a>. General
    comments and suggestions may be sent to the mailing list or emailed to the
    author directly.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="initiation"></a>Chapter 1. Project Initiation</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm110">1. A Brief History of GNU/Linux</a></span></dt><dt><span class="sect1"><a href="#idm118">2. The Goal of Pocket Linux</a></span></dt><dt><span class="sect1"><a href="#idm132">3. Working Within The Constraints</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm110"></a>1. A Brief History of GNU/Linux</h2></div></div></div><p>In the early 90's GNU/Linux systems consisted of little more than a
    beta-quality Linux kernel and a small collection of software ported from
    the GNU project. It was a true hacker's operating system. There were no
    CD-ROM's or GUI installation tools; everything had to be compiled and
    configured by the end user. Being a Linux Expert meant knowing your system
    inside and out.</p><p>Toward the middle of the decade several GNU/Linux distributions
    began appearing. One of the first was <a class="ulink" href="http://www.slackware.org" target="_top">Slackware</a> in 1993 and since then
    there have been many others. Even though there are many "flavors" of Linux
    today, the main purpose of the distribution remains the same. The
    distribution automates many of the tasks involved in GNU/Linux
    installation and configuration taking the burden off of the system
    administrator. Being a Linux Expert now means knowing which button to
    click in the GUI administration tool.</p><p>Recently there has been a yearn for a return to the "good old days"
    of Linux when men were men, sysadmins were hardcore geeks and everything
    was compiled from source code. A notable indication of this movement was
    the publication of the Linux-From-Scratch-HOWTO version 1.0 by Gerard
    Beekmans in 1999. Being a Linux Expert once again means knowing how to do
    it yourself.</p><p>For more historical information, see Ragib Hasan's "History of
    Linux" at <a class="ulink" href="http://netfiles.uiuc.edu/rhasan/linux" target="_top">http://netfiles.uiuc.edu/rhasan/linux</a></p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm118"></a>2. The Goal of Pocket Linux</h2></div></div></div><p>The purpose of Pocket Linux is to support and encourage people who
    wish to explore Linux by building a GNU/Linux system from nothing but
    source code. Pocket Linux is not intended to be a full featured system,
    but rather to give the reader a taste of what is involved in building an
    operating system from source code. After completing the Pocket Linux
    system the reader should have enough knowledge to confidently build almost
    any project using only source code. Given this direction we can put a few
    constraints on the project.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The main focus should be learning. The project should not just
        describe how to do something, it should also describe why it should be
        done.</p></li><li class="listitem"><p>The required time commitment should be minimal and
        manageable.</p></li><li class="listitem"><p>The project should not require any investment in additional
        hardware or reconfiguration of existing hardware to set up a lab
        environment.</p></li><li class="listitem"><p>Readers should not need to know any programming languages in
        order to complete the project.</p></li><li class="listitem"><p>To remain true to the spirit of GNU/Linux, all software used in
        the project should be covered under the GNU/GPL or another, similarly
        liberal, open-source license.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm132"></a>3. Working Within The Constraints</h2></div></div></div><p>The Pocket Linux project gets its name from the fact that the bulk
    of the project fits onto two diskettes making it possible to carry the
    entire, working system around in one's pocket. This has the advantage of
    not requiring any additional hardware since any PC can be booted from the
    diskettes without disrupting any OS that exists on the hard drive. Using
    diskettes also partially addresses the aspect of time commitment, because
    the project size and complexity is necessarily limited by the 1.44
    Megabyte size of the installation media.</p><p>To further reduce the time commitment, the Pocket Linux project is
    divided into several phases, each one chapter in length. Each phase builds
    only a small piece of the overall project, but at the same time the
    conclusion of each chapter results in a self-contained, working system.
    This step-by-step approach should allow readers to pace themselves and not
    feel the need to rush to see results.</p><p>Chapters are further subdivided into four sections. The first two
    sections, analysis and design, focus on the theory of what is to be
    accomplished in each phase and why. The last two sections, construction
    and implementation, detail the steps needed to do the actual building.
    Advanced readers, who may be familiar with the theories laid out in a
    particular chapter are encouraged to gloss over the analysis and design
    sections in the interest of time. The separation of theory from hands-on
    exercises should allow readers of all skill levels to complete the project
    without feeling either completely lost or mired in too much detail.</p><p>Finally, the Pocket Linux project will strive to use GNU/GPL
    software when possible and other open-source licensed software when there
    is no GNU/GPL alternative. Also, Pocket Linux will never require any
    programming more complex than a BASH shell script.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase1"></a>Chapter 2. A Simple Prototype</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm140">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm150">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm152">2.1. Simplification</a></span></dt><dt><span class="sect2"><a href="#idm169">2.2. Boot Disk</a></span></dt><dt><span class="sect2"><a href="#idm173">2.3. Root Disk</a></span></dt><dt><span class="sect2"><a href="#idm181">2.4. CPU Compatibility</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm185">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm190">3.1. Prepare the boot disk media</a></span></dt><dt><span class="sect2"><a href="#idm200">3.2. Build the GRUB bootloader</a></span></dt><dt><span class="sect2"><a href="#idm207">3.3. Copy the bootloader files to diskette</a></span></dt><dt><span class="sect2"><a href="#idm219">3.4. Finish bootloader installation</a></span></dt><dt><span class="sect2"><a href="#idm227">3.5. Build the Linux kernel</a></span></dt><dt><span class="sect2"><a href="#idm261">3.6. Copy the kernel to diskette</a></span></dt><dt><span class="sect2"><a href="#idm266">3.7. Unmount the boot disk</a></span></dt><dt><span class="sect2"><a href="#idm272">3.8. Prepare the root disk media</a></span></dt><dt><span class="sect2"><a href="#idm279">3.9. Build BASH</a></span></dt><dt><span class="sect2"><a href="#idm292">3.10. Copy BASH to the root disk</a></span></dt><dt><span class="sect2"><a href="#idm299">3.11. Create device files that BASH needs</a></span></dt><dt><span class="sect2"><a href="#idm305">3.12. Unmount the root disk</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm311">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm313">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm333">4.2. Testing what works</a></span></dt><dt><span class="sect2"><a href="#idm342">4.3. Noting what does not work</a></span></dt><dt><span class="sect2"><a href="#idm352">4.4. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm140"></a>1. Analysis</h2></div></div></div><p>Since this is the first phase of the project it will be kept very
    simple. The goal here is not to create the ultimate GNU/Linux system on
    the first try. Instead, we will be building a very minimal, working system
    to be used as a building block in subsequent phases of the project.
    Keeping this in mind, we can list a few goals for phase one.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Keep it simple to avoid stressing out.</p></li><li class="listitem"><p>Build something that works for instant gratification.</p></li><li class="listitem"><p>Make something that it is useful in later phases of the
        project.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm150"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm152"></a>2.1. Simplification</h3></div></div></div><p>Take a moment to skim through the Bootdisk-HOWTO or the
      From-PowerUp-to-BASH-Prompt-HOWTO. These HOWTO documents can be found
      online at <a class="ulink" href="http://www.tldp.org/docs.html#howto" target="_top">http://www.tldp.org/docs.html#howto</a>.
      Both documents offer an excellent view of what it takes to get a
      GNU/Linux system up and running. There is also a lot of information to
      digest. Remember that one of our goals is, "keep it simple to avoid
      stressing out," so we want to ignore everything but the absolutely
      critical pieces of a boot / root diskset.</p><p>Basically it boils down to the following required items:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A boot loader</p></li><li class="listitem"><p>The Linux kernel</p></li><li class="listitem"><p>A shell</p></li><li class="listitem"><p>Some <code class="filename">/dev</code> files</p></li></ul></div><p>We don't even need an init daemon. The kernel can be told to run
      the shell directly by passing it an option through the boot
      loader.</p><p>For easy construction we will build a two-disk boot / root set
      rather than trying to get everything onto a single diskette. The boot
      loader and kernel will go on the boot disk and the shell will reside on
      the root disk.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm169"></a>2.2. Boot Disk</h3></div></div></div><p>For the boot disk we simply need to install the GRUB bootloader
      and a Linux kernel. We will need to use a kernel that does not require
      modules for the hardware we need to access. Mainly, it should have
      compiled-in support for the floppy drive, ram disk, second extended
      filesystem, proc filesystem, ELF binaries, and a text-based console. If
      such a kernel is not available, it will need to be built from source
      code. Kwan Lowe's <a class="ulink" href="http://www.digitalhermit.com/linux/Kernel-Build-HOWTO.html" target="_top">Kernel
      Rebuild Guide</a> is a good reference for this task, however we can
      ignore the sections that deal with modules and the initial
      ramdisk.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm173"></a>2.3. Root Disk</h3></div></div></div><p>For the root disk we will need a floppy that has been prepared
      with a filesystem. We will also need a BASH shell that is
      statically-linked so we can avoid the additional complexities of shared
      libraries. The <span class="command"><strong>configure</strong></span> program in the BASH source
      code recognizes the <code class="option">--enable-static-link</code> option for
      this feature. We will also be using the
      <code class="option">--enable-minimal-config</code> option to keep the BASH binary
      down to a manageable size. Additional requirements for the root disk are
      a <code class="filename">/dev</code> directory and a device file for the console.
      The <code class="filename">console</code> device is required for BASH to be able
      to communicate with the keyboard and video display.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm181"></a>2.4. CPU Compatibility</h3></div></div></div><p>There is one other, less obvious requirement to keep in mind and
      that is CPU compatibility. Each generation of CPU features a more
      complex architecture than its predecessor. Late generation chips have
      additional registers and instructions when compared to an older 486 or
      386. So a kernel optimized for a new, fast 6x86 machine will not run on
      an older box. (See the <code class="filename">README</code> file in the Linux
      kernel source code for details.) A BASH shell built for a 6x86 will
      probably not run on an older processor either. To avoid this problem, we
      can choose the 386 as a lowest common denominator CPU and build all the
      code for that architecture.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm185"></a>3. Construction</h2></div></div></div><p>In this section, we will be building the actual boot disk and root
    disk floppies. Lines preceded by <code class="prompt">bash#</code> indicate a shell
    command and lines starting with <code class="prompt">grub&gt;</code> indicate a
    command typed within the grub shell.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm190"></a>3.1. Prepare the boot disk media</h3></div></div></div><p>Insert a blank diskette labeled "boot disk".</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It may be necessary to erase the "blank" diskette if it comes
        factory pre-formatted for another, non-Linux operating system. This
        can be done using the command <span class="command"><strong>dd if=/dev/zero of=/dev/fd0
        bs=1k count=1440</strong></span></p></div><pre class="programlisting"><code class="prompt">bash#</code> mke2fs -m0 /dev/fd0
<code class="prompt">bash#</code> mount /dev/fd0 /mnt</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm200"></a>3.2. Build the GRUB bootloader</h3></div></div></div><p>Get the GRUB source code from <a class="ulink" href="ftp://alpha.gnu.org/gnu/grub/" target="_top">ftp://alpha.gnu.org/gnu/grub/</a>
      and unpack it into the <code class="filename">/usr/src</code> directory.</p><p>Configure and build the GRUB source code for an i386 processor by
      using the following commands:</p><pre class="programlisting">bash# cd /usr/src/grub-0.95
bash# export CC="gcc -mcpu=i386"
bash# ./configure --host=i386-pc-linux-gnu --without-curses
bash# make</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm207"></a>3.3. Copy the bootloader files to diskette</h3></div></div></div><p>Normally, after compiling source code, one would use the command
      <span class="command"><strong>make install</strong></span> to copy the finished files to their
      proper destinations in the filesystem. However, using <span class="command"><strong>make
      install</strong></span> does not work well with small media like the floppy
      disks we are using. The problem is that there are many files in a
      package besides the actual binaries that get the job done. For example,
      there are often man or info pages that provide documentation. These
      extra files can take up more space than we can spare on the diskette. We
      can work around this limitation by copying essential files manually
      rather than using <span class="command"><strong>make install</strong></span>.</p><p>For GRUB to boot we will need to copy the stage1 and stage2
      bootloader files to the <code class="filename">/boot/grub</code> directory on the
      boot floppy.</p><pre class="programlisting"><code class="prompt">bash#</code> mkdir -p /mnt/boot/grub
<code class="prompt">bash#</code> cp /usr/src/grub-0.95/stage1/stage1 /mnt/boot/grub
<code class="prompt">bash#</code> cp /usr/src/grub-0.95/stage2/stage2 /mnt/boot/grub</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm219"></a>3.4. Finish bootloader installation</h3></div></div></div><p>Once the bootloader's files are copied to the boot disk we can
      enter the grub shell to finish the installation.</p><pre class="programlisting"><code class="prompt">bash#</code> /usr/src/grub-0.95/grub/grub
<code class="prompt">grub&gt;</code> root (fd0)
<code class="prompt">grub&gt;</code> setup (fd0)
<code class="prompt">grub&gt;</code> quit</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm227"></a>3.5. Build the Linux kernel</h3></div></div></div><p>The steps for building the kernel were tested using Linux kernel
      version 2.4.26 and should work any 2.4.x or 2.6.x kernel. The latest
      version of the kernel source code may be downloaded from <a class="ulink" href="http://www.kernel.org/" target="_top">http://www.kernel.org/</a> or one of
      its mirrors.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The instructions below are very brief and are intended for
        someone who has previous experience building custom kernels. A more
        detailed explanation of the kernel building process can be found in
        the <a class="ulink" href="http://www.digitalhermit.com/linux/Kernel-Build-HOWTO.html" target="_top">Kernel
        Rebuild Guide</a> by Kwan Lowe.</p></div><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/linux
<code class="prompt">bash#</code> make menuconfig</pre><p>Be sure to configure support for the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>386 processor</p></li><li class="listitem"><p>Console on virtual terminal (2.4.x kernels only)</p></li><li class="listitem"><p>ELF binaries</p></li><li class="listitem"><p>Floppy disk</p></li><li class="listitem"><p>proc filesystem</p></li><li class="listitem"><p>RAM disk with a default size of 4096K</p></li><li class="listitem"><p>Second extended (ext2) filesystem</p></li><li class="listitem"><p>VGA console</p></li></ul></div><pre class="programlisting"><code class="prompt">bash#</code> make dep
<code class="prompt">bash#</code> make clean
<code class="prompt">bash#</code> make bzImage</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm261"></a>3.6. Copy the kernel to diskette</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cp /usr/src/linux/arch/i386/boot/bzImage /mnt/boot/vmlinuz</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm266"></a>3.7. Unmount the boot disk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> umount /mnt</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm272"></a>3.8. Prepare the root disk media</h3></div></div></div><p>Insert a blank diskette labeled "root disk".</p><pre class="programlisting"><code class="prompt">bash#</code> mke2fs -m0 /dev/fd0
<code class="prompt">bash#</code> mount /dev/fd0 /mnt</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm279"></a>3.9. Build BASH</h3></div></div></div><p>Get the bash-3.0 source code package from <a class="ulink" href="ftp://ftp.gnu.org/gnu/bash/" target="_top">ftp://ftp.gnu.org/gnu/bash/</a>
      and untar it into the <code class="filename">/usr/src</code> directory.</p><p>Build BASH for an i386 CPU with the following commands:</p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/bash-3.0
<code class="prompt">bash#</code> export CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> ./configure --enable-static-link \
  --enable-minimal-config --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> strip bash</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm292"></a>3.10. Copy BASH to the root disk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mkdir /mnt/bin
<code class="prompt">bash#</code> cp bash /mnt/bin/bash
<code class="prompt">bash#</code> ln -s bash /mnt/bin/sh</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm299"></a>3.11. Create device files that BASH needs</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mkdir /mnt/dev
<code class="prompt">bash#</code> mknod /mnt/dev/console c 5 1</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm305"></a>3.12. Unmount the root disk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> umount /mnt
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm311"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm313"></a>4.1. System startup</h3></div></div></div><p>Follow these steps to boot the system:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Restart the PC with the boot disk in the floppy drive.</p></li><li class="listitem"><p>When the <code class="prompt">grub&gt;</code> prompt appears, type
          <strong class="userinput"><code>kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</code></strong> and press
          <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>After the kernel loads, type <strong class="userinput"><code>boot</code></strong> and
          press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Insert the root disk when prompted.</p></li></ul></div><p>If all goes well the screen should look something like the example
      shown below.</p><pre class="screen">GNU GRUB version 0.95

grub&gt; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&gt; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: ext2 filesystem found at block 0
RAMDISK: Loading 1440 blocks [1 disk] into ram disk... done.
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm333"></a>4.2. Testing what works</h3></div></div></div><p>Try out a few of BASH's built-in commands to see if things are
      working properly.</p><pre class="programlisting"><code class="prompt">bash#</code> echo "Hello World"
<code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> pwd
<code class="prompt">bash#</code> echo *</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm342"></a>4.3. Noting what does not work</h3></div></div></div><p>Try out a few other familiar commands.</p><pre class="programlisting"><code class="prompt">bash#</code> ls /var
<code class="prompt">bash#</code> mkdir /var/tmp</pre><p>Notice that only commands internal to BASH actually work and that
      external commands like <span class="command"><strong>ls</strong></span> and
      <span class="command"><strong>mkdir</strong></span> do not work at all. This shortcoming is
      something that can be addressed in a future phase of the project. For
      now we should just enjoy the fact that our prototype boot / root diskset
      works and that it was not all that hard to build.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm352"></a>4.4. System shutdown</h3></div></div></div><p>Remove the diskette from fd0 and restart the system using
      <span class="keycap"><strong>CTRL</strong></span>-<span class="keycap"><strong>ALT</strong></span>-<span class="keycap"><strong>DELETE</strong></span>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase2"></a>Chapter 3. Saving Space</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm360">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm367">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm370">2.1. Shared Libraries</a></span></dt><dt><span class="sect2"><a href="#idm376">2.2. Stripped Binaries</a></span></dt><dt><span class="sect2"><a href="#idm383">2.3. Compressed Root Filesystem</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm388">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm392">3.1. Create a ramdisk</a></span></dt><dt><span class="sect2"><a href="#idm399">3.2. Rebuild the BASH shell</a></span></dt><dt><span class="sect2"><a href="#idm409">3.3. Determine which libraries are required</a></span></dt><dt><span class="sect2"><a href="#idm423">3.4. Copy BASH and its libraries to the ramdisk</a></span></dt><dt><span class="sect2"><a href="#idm439">3.5. Create a console device</a></span></dt><dt><span class="sect2"><a href="#idm445">3.6. Compress the ramdisk image</a></span></dt><dt><span class="sect2"><a href="#idm453">3.7. Copy the compressed image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm459">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm463">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm484">4.2. Verify results</a></span></dt><dt><span class="sect2"><a href="#idm487">4.3. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm360"></a>1. Analysis</h2></div></div></div><p>One of the drawbacks in the prototype phase of the project was that
    the diskset was not all that useful. The only commands that worked were
    the ones built into the BASH shell. We could improve our root disk by
    installing commands like <span class="command"><strong>cat</strong></span>, <span class="command"><strong>ls</strong></span>,
    <span class="command"><strong>mv</strong></span>, <span class="command"><strong>rm</strong></span> and so on. Unfortunately, we
    are short on space. The current root disk has no shared libraries so each
    utility would have to be statically-linked just like the BASH shell. A lot
    of big binaries together with a static shell will rapidly exceed the tiny
    1.44M of available disk space. So our main goal in this phase should be to
    maximize space savings on the root disk and pave the way for expanded
    functionality in the next phase.</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm367"></a>2. Design</h2></div></div></div><p>Take another look at the Bootdisk-HOWTO and notice how many
    utilities can be squeezed onto a 1.44M floppy. There are three things that
    make this possible. One is the use of shared libraries. The second is
    stripped binaries. And the third is the use of a compressed filesystem. We
    can use all of these techniques to save space on our root disk.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm370"></a>2.1. Shared Libraries</h3></div></div></div><p>First, in order to use shared libraries we will need to rebuild
      the BASH shell. This time we will configure it without using the
      <code class="option">--enable-static-link</code> option. Once BASH is rebuilt we
      need to figure out which libraries it is linked with and be sure to
      include them on the root disk. The <span class="command"><strong>ldd</strong></span> command makes
      this job easy. By typing <span class="command"><strong>ldd bash</strong></span> on the command-line
      we can see a list of all the shared libraries that BASH uses. As long as
      all these libraries are copied to the root disk, the new BASH build
      should work fine.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm376"></a>2.2. Stripped Binaries</h3></div></div></div><p>Next, we should strip any binaries that get copied to the root
      disk. The manpage for <span class="command"><strong>strip</strong></span> does not give much
      description of what it does other than to say, "strip discards all
      symbols from the object files." It seems like removing pieces of a
      binary would render it useless, but this is not the case. The reason it
      works is because a large number of these discarded symbols are used for
      debugging. While debugging symbols are very helpful to programmers
      working to improve the code, they do not do much for the average
      end-user other than take up more disk space. And since space is at a
      premium, we should definitely remove as many symbols as possible from
      BASH and any other binaries before we copy over them to the
      ramdisk.</p><p>The process of stripping files to save space also works with
      shared library files. But when stripping libraries it is important to
      use the <code class="option">--strip-unneeded</code> option so as not to break
      them. Using <code class="option">--strip-unneeded</code> shrinks the file size, but
      leaves the symbols needed for relocation intact which is something that
      shared libraries need to function properly.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm383"></a>2.3. Compressed Root Filesystem</h3></div></div></div><p>Finally, we can tackle the problem of how to build a compressed
      root filesystem. The Bootdisk-HOWTO suggests three ways of constructing
      a compressed root filesystem using either a ramdisk, a spare hard drive
      partition or a loopback device. This project will concentrate on using
      the ramdisk approach. It seems logical that if the root filesystem is
      going to be run from a ramdisk, it may as well be built on a ramdisk.
      All we have to do is create a second extended filesystem on a ramdisk
      device, mount it and copy files to it. Once the filesystem is populated
      with all the files that the root disk needs, we simply unmount it,
      compress it and write it out to floppy.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For this to work, we need to make sure the system used for
        building has ramdisk support. If ramdisk is not available it is also
        possible to use a loopback device. See the Bootdisk-HOWTO for more
        information on using loopback devices.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm388"></a>3. Construction</h2></div></div></div><p>This section is written using ramdisk seven
    (<code class="filename">/dev/ram7</code>) to build the root image. There is nothing
    particularly special about ramdisk seven and it is possible to use any of
    the other available ramdisks provided they are not already in use.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm392"></a>3.1. Create a ramdisk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm399"></a>3.2. Rebuild the BASH shell</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/bash-3.0
<code class="prompt">bash#</code> make distclean
<code class="prompt">bash#</code> export CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> ./configure --enable-minimal-config --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> strip bash</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm409"></a>3.3. Determine which libraries are required</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> ldd bash</pre><p>View the output from the <span class="command"><strong>ldd</strong></span> command. It should
      look similar to the example below.</p><pre class="screen">bash# ldd bash
  libdl.so.2 =&gt; /lib/libdl.so.2 (0x4001d000)
  libc.so.6 =&gt; /lib/libc.so.6 (0x40020000)
  /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Some systems may have a slightly different library set up. For
        example, you may see <code class="computeroutput">libc.so.6 =&gt;
        /lib/tls/libc.so.6</code> rather than
        <code class="computeroutput">libc.so.6 =&gt; /lib/libc.so.6</code> as
        shown in the example. If your <span class="command"><strong>ldd</strong></span> output does not
        match the example then use the path given by your
        <span class="command"><strong>ldd</strong></span> command when completing the next step.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm423"></a>3.4. Copy BASH and its libraries to the ramdisk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mkdir /mnt/bin
<code class="prompt">bash#</code> cp bash /mnt/bin
<code class="prompt">bash#</code> ln -s bash /mnt/bin/sh
<code class="prompt">bash#</code> mkdir /mnt/lib
<code class="prompt">bash#</code> strip --strip-unneeded -o /mnt/lib/libdl.so.2 /lib/libdl.so.2
<code class="prompt">bash#</code> strip --strip-unneeded -o /mnt/lib/libc.so.6 /lib/libc.so.6
<code class="prompt">bash#</code> strip --strip-unneeded -o /mnt/lib/ld-linux.so.2 /lib/ld-linux.so.2
<code class="prompt">bash#</code> chmod +x /mnt/lib/ld-linux.so.2</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Using <span class="command"><strong>strip -o</strong></span> might seem an odd way to
          copy library files from the development system to the ramdisk. What
          it does is strip the symbols while the file is in transit from the
          source location to the destination. This has the effect of stripping
          symbols from the library on the ramdisk without altering the
          libraries on the development system. Unfortunately file permissions
          are lost when copying libraries this way which is why the
          <span class="command"><strong>chmod +x</strong></span> command is then used to set the execute
          flag for the rootdisk's dynamic loader.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm439"></a>3.5. Create a console device</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mkdir /mnt/dev
<code class="prompt">bash#</code> mknod /mnt/dev/console c 5 1</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm445"></a>3.6. Compress the ramdisk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase2-image bs=1k count=4096
<code class="prompt">bash#</code> gzip -9 ~/phase2-image</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm453"></a>3.7. Copy the compressed image to diskette</h3></div></div></div><p>Insert the floppy labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase2-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm459"></a>4. Implementation</h2></div></div></div><p>Successful implementation of this phase is probably the most
    difficult part of the Pocket Linux Guide. If you need help getting things
    to work please visit the <a class="ulink" href="http://pocket-linux.sourceforge.net" target="_top">Pocket Linux Guide Resource
    Site</a> to browse the troubleshooting forum and subscribe to the
    mailing list.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm463"></a>4.1. System startup</h3></div></div></div><p>Follow these steps to boot:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Restart the PC using the boot disk from the previous
          chapter.</p></li><li class="listitem"><p>At the <code class="prompt">grub&gt;</code> prompt, type
          <strong class="userinput"><code>kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</code></strong> and press
          <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Type <strong class="userinput"><code>boot</code></strong> at the
          <code class="prompt">grub&gt;</code> prompt and press
          <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Insert the new, compressed root disk when prompted.</p></li></ul></div><p>The screen output should be similar to the following
      example:</p><pre class="screen">GNU GRUB version 0.95

grub&gt; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&gt; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm484"></a>4.2. Verify results</h3></div></div></div><p>If the implementation was successful, this new root disk should
      behave exactly like the root disk from the previous chapter. The key
      difference is that this compressed root disk has much more room to grow
      and we will put this extra space to good use in the next phase of the
      project.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm487"></a>4.3. System shutdown</h3></div></div></div><p>Remove the diskette from fd0 and restart the system using
      <span class="keycap"><strong>CTRL</strong></span>-<span class="keycap"><strong>ALT</strong></span>-<span class="keycap"><strong>DELETE</strong></span>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase3"></a>Chapter 4. Some Basic Utilities</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm495">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm510">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm512">2.1. Determining Required Commands</a></span></dt><dt><span class="sect2"><a href="#idm518">2.2. Locating Source Code</a></span></dt><dt><span class="sect2"><a href="#idm524">2.3. Leveraging FHS</a></span></dt><dt><span class="sect2"><a href="#idm576">2.4. Downloading Source Code</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm581">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm602">3.1. Create a staging area</a></span></dt><dt><span class="sect2"><a href="#idm610">3.2. Copy contents of phase 2 rootdisk</a></span></dt><dt><span class="sect2"><a href="#idm619">3.3. Install binaries from GNU coreutils</a></span></dt><dt><span class="sect2"><a href="#idm633">3.4. Copy additional libraries</a></span></dt><dt><span class="sect2"><a href="#idm651">3.5. Strip binaries and libraries</a></span></dt><dt><span class="sect2"><a href="#idm657">3.6. Create a compressed root disk image</a></span></dt><dt><span class="sect2"><a href="#idm671">3.7. Write the root disk image to floppy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm677">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm682">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm704">4.2. Testing new commands</a></span></dt><dt><span class="sect2"><a href="#idm721">4.3. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm495"></a>1. Analysis</h2></div></div></div><p>In the previous chapter it might seem like we did not accomplish
    very much. A lot of energy was expended redesigning the root disk, but the
    functionality is basically the same as in the initial prototype phase. The
    root disk still does not do very much. But we did make significant
    improvements when it comes to space savings. In this chapter we will put
    that extra space to good use and start cramming the root disk with as many
    utilities as it can hold.</p><p>The first two root disks we built only had shell built-in commands
    like <span class="command"><strong>echo</strong></span> and <span class="command"><strong>pwd</strong></span>. This time it
    would be nice to have some of the commonly used external commands like
    <span class="command"><strong>cat</strong></span>, <span class="command"><strong>ls</strong></span>, <span class="command"><strong>mkdir</strong></span>,
    <span class="command"><strong>rm</strong></span> and such on the root disk. Keeping this in mind we
    can define the goals for this phase as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Retain all of the functionality from the previous root
        disk.</p></li><li class="listitem"><p>Add some of the commonly used external commands.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm510"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm512"></a>2.1. Determining Required Commands</h3></div></div></div><p>The first question that might come to mind is, "How do we know
      which commands are needed?" It is possible to just start with
      <span class="command"><strong>cat</strong></span> and <span class="command"><strong>ls</strong></span> then install other
      commands as we discover a need for them. But this is terribly
      inefficient. We need a plan or a blueprint to work from. For this we can
      turn to the Filesystem Hierarchy Standard (FHS) available from <a class="ulink" href="http://www.pathname.com/fhs/" target="_top">http://www.pathname.com/fhs/</a>.
      The FHS dictates which commands should be present on a Linux system and
      where they should be placed in the directory structure.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm518"></a>2.2. Locating Source Code</h3></div></div></div><p>The next logical question is, "Now that we know what we need,
      where do we get the source code?" One way to find the answer to this
      question is to check the manpages. We can either search the manpages
      included with one of the popular GNU/Linux distributions or use one of
      the manpage search engines listed at <a class="ulink" href="http://www.tldp.org/docs.html#man" target="_top">http://www.tldp.org/docs.html#man</a>.
      One thing that should tip us off as to where to find the source code for
      a particular command is the email address listed for reporting bugs. For
      example the cat manpage lists bug-textutils@gnu.org. From this email
      address we can deduce that <span class="command"><strong>cat</strong></span> is part of the
      textutils package from <a class="ulink" href="http://gnu.org" target="_top">GNU</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm524"></a>2.3. Leveraging FHS</h3></div></div></div><p>So let's look at the FHS requirements for the
      <code class="filename">/bin</code> directory. The first few commands in the list
      are <span class="command"><strong>cat</strong></span>, <span class="command"><strong>chgrp</strong></span>,
      <span class="command"><strong>chmod</strong></span>, <span class="command"><strong>chown</strong></span> and
      <span class="command"><strong>cp</strong></span>. We already know that <span class="command"><strong>cat</strong></span> is
      part of GNU's textutils. Using the next few commands as keywords in a
      manpage search we discover that we need GNU's fileutils package for
      <span class="command"><strong>chmod</strong></span>, <span class="command"><strong>chgrp</strong></span>,
      <span class="command"><strong>chown</strong></span> and <span class="command"><strong>cp</strong></span>. In fact quite a few
      of the commands in <code class="filename">/bin</code> come from GNU's fileutils.
      The <span class="command"><strong>date</strong></span> command also comes from a GNU package called
      sh-utils. So a good way to tackle the problem of finding source code
      might be to group the commands together by package as shown
      below.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The BASH shell -- <span class="command"><strong>echo</strong></span>,
          <span class="command"><strong>false</strong></span>, <span class="command"><strong>pwd</strong></span>,
          <span class="command"><strong>sh</strong></span>, <span class="command"><strong>true</strong></span></p></li><li class="listitem"><p>GNU textutils -- <span class="command"><strong>cat</strong></span></p></li><li class="listitem"><p>GNU fileutils -- <span class="command"><strong>chgrp</strong></span>,
          <span class="command"><strong>chmod</strong></span>, <span class="command"><strong>chown</strong></span>,
          <span class="command"><strong>cp</strong></span>, <span class="command"><strong>dd</strong></span>, <span class="command"><strong>df</strong></span>,
          <span class="command"><strong>ln</strong></span>, <span class="command"><strong>ls</strong></span>,
          <span class="command"><strong>mkdir</strong></span>, <span class="command"><strong>mknod</strong></span>,
          <span class="command"><strong>mv</strong></span>, <span class="command"><strong>rm</strong></span>,
          <span class="command"><strong>rmdir</strong></span>, <span class="command"><strong>sync</strong></span></p></li><li class="listitem"><p>GNU sh-utils -- <span class="command"><strong>date</strong></span>,
          <span class="command"><strong>hostname</strong></span>, <span class="command"><strong>stty</strong></span>,
          <span class="command"><strong>su</strong></span>, <span class="command"><strong>uname</strong></span></p></li></ul></div><p>These four packages do not contain all of the commands in the
      <code class="filename">/bin</code> directory, but they do represent of over 70%
      of them. That should be enough to accomplish our goal of adding some of
      the commonly used external commands. We can worry about the other
      commands in later phases of the project.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm576"></a>2.4. Downloading Source Code</h3></div></div></div><p>To fetch the source code we simply need to connect to <a class="ulink" href="ftp://ftp.gnu.org/gnu" target="_top">GNU's FTP site</a> and navigate to the
      appropriate package directory.</p><p>When we get to the directory for textutils there are several
      versions available. There is also a note informing us that the package
      has been renamed to coreutils. The same message about coreutils appears
      in the fileutils and sh-utils directories as well. So instead of
      downloading three separate packages we can get everything in one
      convenient bundle in the coreutils directory.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm581"></a>3. Construction</h2></div></div></div><p>Rather than copying files directly to the ramdisk, we can make
    things easier by setting up a staging area. The staging area will give us
    room to work without worrying about the space constraints of the ramdisk.
    It will also provide a way to save our work and make it easier to enhance
    the rootdisk in later phases of the project.</p><p>The staging procedure will work like this:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create a directory structure as defined in the FHS.</p></li><li class="listitem"><p>Copy in the files from phase 2's root disk.</p></li><li class="listitem"><p>Build the new package from source code.</p></li><li class="listitem"><p>Install files into the correct FHS directories.</p></li><li class="listitem"><p>Strip the binaries to save space.</p></li><li class="listitem"><p>Check library dependencies.</p></li><li class="listitem"><p>Copy to the whole directory structure to the ramdisk.</p></li><li class="listitem"><p>Compress the ramdisk and write it out to floppy.</p></li></ol></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm602"></a>3.1. Create a staging area</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mkdir ~/staging
<code class="prompt">bash#</code> cd ~/staging
<code class="prompt">bash#</code> mkdir bin boot dev etc home lib mnt opt proc root sbin tmp usr var
<code class="prompt">bash#</code> mkdir var/log var/run</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm610"></a>3.2. Copy contents of phase 2 rootdisk</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase2-image.gz | gunzip -c &gt; /dev/ram7
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR /mnt/* ~/staging
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> rmdir ~/staging/lost+found</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm619"></a>3.3. Install binaries from GNU coreutils</h3></div></div></div><p>Download a recent version of coreutils from <a class="ulink" href="ftp://ftp.gnu.org/gnu/coreutils/" target="_top">ftp://ftp.gnu.org/gnu/coreutils/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/coreutils-5.2.1
<code class="prompt">bash#</code> export CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> ./configure --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> cd src
<code class="prompt">bash#</code> cp cat chgrp chmod chown cp date dd df ~/staging/bin
<code class="prompt">bash#</code> cp hostname ln ls mkdir mkfifo mknod ~/staging/bin
<code class="prompt">bash#</code> cp mv rm rmdir stty su sync uname ~/staging/bin</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm633"></a>3.4. Copy additional libraries</h3></div></div></div><p>Check library requirements by using <span class="command"><strong>ldd</strong></span> on some
      of the new binaries.</p><pre class="programlisting"><code class="prompt">bash#</code> ldd ~/staging/bin/cat
<code class="prompt">bash#</code> ldd ~/staging/bin/ls
<code class="prompt">bash#</code> ldd ~/staging/bin/su
<code class="prompt">bash#</code> ls ~/staging/lib
</pre><p>Note the differences in the required libraries, as shown by the
      <span class="command"><strong>ldd</strong></span> command, and the libraries present in the staging
      area, as shown by the <span class="command"><strong>ls</strong></span> command, then copy any
      missing libraries to the staging area.</p><pre class="programlisting"><code class="prompt">bash#</code> cp /lib/librt.so.1 ~/staging/lib
<code class="prompt">bash#</code> cp /lib/libpthread.so.0 ~/staging/lib
<code class="prompt">bash#</code> cp /lib/libcrypt.so.1 ~/staging/lib</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm651"></a>3.5. Strip binaries and libraries</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> strip ~/staging/bin/*
<code class="prompt">bash#</code> strip --strip-unneeded ~/staging/lib/*</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm657"></a>3.6. Create a compressed root disk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR ~/staging/* /mnt
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase3-image bs=1k count=4096
<code class="prompt">bash#</code> gzip -9 ~/phase3-image</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The process for creating the compressed root disk image will
          change very little throughout the remaining chapters. Writing a
          small script to handle this function can be a great time
          saver.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm671"></a>3.7. Write the root disk image to floppy</h3></div></div></div><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase3-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm677"></a>4. Implementation</h2></div></div></div><p>We will need to have a read-write filesystem in order for some of
    the commands to work. The kernel's normal behavior is to mount root as
    read-only, but we can change this using a kernel option. By passing the
    kernel the <em class="parameter"><code>rw</code></em> option before
    <em class="parameter"><code>init=/bin/sh</code></em> we will get a read-write root
    filesystem.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm682"></a>4.1. System startup</h3></div></div></div><p>Follow these steps to get the system running.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Boot the PC from using the GRUB boot disk.</p></li><li class="listitem"><p>At the <code class="prompt">grub&gt;</code> prompt, type
          <strong class="userinput"><code>kernel (fd0)/boot/vmlinuz rw init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</code></strong>.</p></li><li class="listitem"><p>Verify that you remembered to add the
          <em class="parameter"><code>rw</code></em> parameter and press
          <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Type boot and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Insert the recently created root disk when prompted.</p></li></ul></div><p>The terminal display should look similar to the example
      below.</p><pre class="screen">GNU GRUB version 0.95

grub&gt; kernel (fd0)/boot/vmlinuz rw init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&gt; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) read-write.
Freeing unused kernel memory: 178k freed
# _</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm704"></a>4.2. Testing new commands</h3></div></div></div><p>Now that the system is up and running, try using some of the new
      commands.</p><pre class="programlisting"><code class="prompt">bash#</code> uname -a
<code class="prompt">bash#</code> ls /etc
<code class="prompt">bash#</code> echo "PocketLinux" &gt; /etc/hostname
<code class="prompt">bash#</code> hostname $(cat /etc/hostname)
<code class="prompt">bash#</code> uname -n
<code class="prompt">bash#</code> mkdir /home/stuff
<code class="prompt">bash#</code> cd /home/stuff</pre><p>If everything goes well the commands like <span class="command"><strong>cat</strong></span>,
      <span class="command"><strong>ls</strong></span> and <span class="command"><strong>hostname</strong></span> should work now.
      Even <span class="command"><strong>mkdir</strong></span> should work since the root filesystem is
      mounted read-write. Of course since we are using a ramdisk, any changes
      will be lost once the PC is reset.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm721"></a>4.3. System shutdown</h3></div></div></div><p>Remove the diskette from fd0 and restart the system using
      <span class="keycap"><strong>CTRL</strong></span>-<span class="keycap"><strong>ALT</strong></span>-<span class="keycap"><strong>DELETE</strong></span>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase4"></a>Chapter 5. Checking and Mounting Disks</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm729">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm755">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm757">2.1. Determining necessary utilities.</a></span></dt><dt><span class="sect2"><a href="#idm771">2.2. Finding source code</a></span></dt><dt><span class="sect2"><a href="#idm806">2.3. Automating fsck and mount</a></span></dt><dt><span class="sect2"><a href="#idm817">2.4. File dependencies</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm867">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm869">3.1. Install utilities from e2fsprogs</a></span></dt><dt><span class="sect2"><a href="#idm885">3.2. Install utilities from util-linux</a></span></dt><dt><span class="sect2"><a href="#idm913">3.3. Check library requirements</a></span></dt><dt><span class="sect2"><a href="#idm922">3.4. Strip binaries to save space</a></span></dt><dt><span class="sect2"><a href="#idm928">3.5. Create additional device files</a></span></dt><dt><span class="sect2"><a href="#idm935">3.6. Create the fstab and mtab files</a></span></dt><dt><span class="sect2"><a href="#idm947">3.7. Write a script to check and mount local filesystems</a></span></dt><dt><span class="sect2"><a href="#idm956">3.8. Create a compressed root disk image</a></span></dt><dt><span class="sect2"><a href="#idm968">3.9. Write the root disk image to floppy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm974">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm976">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm994">4.2. Test the local_fs script</a></span></dt><dt><span class="sect2"><a href="#idm1012">4.3. Create and mount additional filesystems</a></span></dt><dt><span class="sect2"><a href="#idm1024">4.4. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm729"></a>1. Analysis</h2></div></div></div><p>In the previous chapter we added many new commands by installing
    coreutils and as a result the root disk has a lot more functionality. But
    there are still a few things lacking. One thing that really stands out is
    that there was no way to mount disks. In order to get a read-write root
    filesystem we had to resort to passing the <em class="parameter"><code>rw</code></em>
    kernel parameter at the <code class="prompt">grub&gt;</code> prompt. This is fine for
    an emergency situation, but a normal system boot process should do things
    differently.</p><p>Most GNU/Linux distributions take several steps to mount
    filesystems. Watching the boot process or digging into the startup scripts
    on one of the popular Linux distributions reveals the following sequence
    of events:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The kernel automatically mounts the root filesystem as
        read-only.</p></li><li class="listitem"><p>All local filesystems are checked for errors.</p></li><li class="listitem"><p>If filesystems are clean, root is remounted as
        read-write.</p></li><li class="listitem"><p>The rest of the local filesystems are mounted.</p></li><li class="listitem"><p>Network filesystems are mounted.</p></li></ol></div><p>So far our Pocket Linux system can do step one and that is it. If we
    want to have a professional looking boot / root diskset we will have to do
    better than one out of five. In this phase of the project we will work on
    steps two and three. Steps four and five can wait. Since this is a
    diskette-based system, there really are no other filesystems to mount
    besides root.</p><p>Taking into account all of the above information, the goals for this
    phase are defined as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>A way to check filesystem integrity.</p></li><li class="listitem"><p>The ability to mount filesystems.</p></li><li class="listitem"><p>A script to automate checking and mounting of local
        filesystems.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm755"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm757"></a>2.1. Determining necessary utilities.</h3></div></div></div><p>We can use the Filesystem Hierarchy Standard (FHS) document to
      help find the names of utilities we need and where they reside in the
      directory structure. The FHS <code class="filename">/sbin</code> directory lists
      <span class="command"><strong>fsck</strong></span> and something called <span class="command"><strong>fsck.*</strong></span>
      for checking filesystems. Since we are using a Second Extended (ext2)
      filesystem the <span class="command"><strong>fsck.*</strong></span> becomes
      <span class="command"><strong>fsck.ext2</strong></span> for our purposes. Mounting filesystems is
      done using the commands <span class="command"><strong>mount</strong></span> and
      <span class="command"><strong>umount</strong></span> in the <code class="filename">/bin</code> directory.
      However, the name of a script to automatically mount local filesystems
      cannot be found. On most systems this type of script is in the
      <code class="filename">/etc</code> directory, but while FHS does list
      requirements for <code class="filename">/etc</code>, it does not currently make
      recommendations for startup scripts. Several GNU/Linux distributions use
      <code class="filename">/etc/init.d</code> as the place to hold startup scripts so
      we will put our filesystem mounting script there.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm771"></a>2.2. Finding source code</h3></div></div></div><p>In the previous chapter we used manpages to help us find source
      code. In this chapter we will use a tool called the Linux Software Map
      (LSM). LSM is a database of GNU/Linux software that tracks such things
      as package name, author, names of binaries that make up the package and
      download sites. Using an LSM search engine we can locate packages using
      command names as keywords.</p><p>If we search Ibiblio's Linux Software Map (LSM) at <a class="ulink" href="http://www.ibiblio.org/pub/Linux/" target="_top">http://www.ibiblio.org/pub/Linux/</a>
      for the keyword "fsck" we get a large number of matches. Since we are
      using a Second Extended filesystem, called ext2 for short, we can refine
      the search using "ext2" as a keyword. Supplying both keywords to the LSM
      search engine comes up with a package called e2fsprogs. Looking at the
      LSM entry for e2fsprogs we find out that this package contains the
      utilities <span class="command"><strong>e2fsck</strong></span>, <span class="command"><strong>mke2fs</strong></span>,
      <span class="command"><strong>dumpe2fs</strong></span>, <span class="command"><strong>fsck</strong></span> and more. We also
      find out that the LSM entry for e2fsprogs has not been updated for a
      while. There is almost certainly a newer version out there somewhere.
      Another good Internet resource for source code is SourceForge at <a class="ulink" href="http://sourceforge.net/" target="_top">http://sourceforge.net/</a>. Using the
      keyword "e2fsprogs" in the SourceForge search engine results in a much
      newer version of e2fsprogs.</p><p>Finding <span class="command"><strong>fsck</strong></span> was quite an adventure, but now we
      can move on to finding <span class="command"><strong>mount</strong></span> and
      <span class="command"><strong>umount</strong></span>. A search on LSM comes up with a number of
      matches, but most of them point to various versions of a package called
      util-linux. All we have to do is scroll through and pick the most recent
      release. The LSM entry for util-linux lists a lot of utilities besides
      just mount and umount. We should definitely scan through the list to see
      if any of the other util-linux commands show up in the FHS requirements
      for <code class="filename">/bin</code> and <code class="filename">/sbin</code>.</p><p>Below is a list of packages we have gathered so far and the
      utilities that match up with FHS.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>e2fsprogs -- <span class="command"><strong>fsck</strong></span>,
          <span class="command"><strong>fsck.ext2</strong></span> (<span class="command"><strong>e2fsck</strong></span>),
          <span class="command"><strong>mkfs.ext2</strong></span> (<span class="command"><strong>mke2fs</strong></span>)</p></li><li class="listitem"><p>util-linux -- <span class="command"><strong>dmesg</strong></span>,
          <span class="command"><strong>getty</strong></span> (<span class="command"><strong>agetty</strong></span>),
          <span class="command"><strong>kill</strong></span>, <span class="command"><strong>login</strong></span>,
          <span class="command"><strong>mount</strong></span>, <span class="command"><strong>swapon</strong></span>,
          <span class="command"><strong>umount</strong></span></p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm806"></a>2.3. Automating fsck and mount</h3></div></div></div><p>Now that we have <span class="command"><strong>fsck</strong></span> and
      <span class="command"><strong>mount</strong></span> commands we need to come up with a shell script
      to automate checking and mounting the local filesystems. An easy way to
      do this would be to write a short, two line script that calls
      <span class="command"><strong>fsck</strong></span> and then <span class="command"><strong>mount</strong></span>. But, what if
      the filesystems are not clean? The system should definitely not try to
      mount a corrupted filesystem. Therefore we need to devise a way of
      determining the status of the filesystems before mounting them. The
      manpage for <span class="command"><strong>fsck</strong></span> gives some insight into how this can
      be accomplished using return codes. Basically, if
      <span class="command"><strong>fsck</strong></span> returns a code of zero or one it means the
      filesystem is okay and a return code of two or greater means some kind
      of manual intervention is needed. A simple if-then statement could
      evaluate the <span class="command"><strong>fsck</strong></span> return code to determine whether or
      not the filesystem should be mounted. For help on writing shell scripts
      we can turn to the BASH(1) manpage and the
      Advanced-BASH-Scripting-Guide. Both references are freely available from
      the Linux Documentation Project web site at <a class="ulink" href="http://www.tldp.org/" target="_top">http://www.tldp.org/</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm817"></a>2.4. File dependencies</h3></div></div></div><p>The last thing to do is to figure out if any other files besides
      the binaries are needed. We learned about using <span class="command"><strong>ldd</strong></span>
      to check for library dependencies in the last phase of the project and
      we will use it to check the utilities in this phase too. There are also
      some other files that <span class="command"><strong>fsck</strong></span> and
      <span class="command"><strong>mount</strong></span> will need and the fsck(8) and mount(8) manpages
      give some insight into what those files are. There is
      <code class="filename">/etc/fstab</code> that lists devices and their mount
      points, <code class="filename">/etc/mtab</code> that keeps track of what is
      mounted, and a number of <code class="filename">/dev</code> files that represent
      the various disks. We will need to include all of these to have
      everything work right.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm826"></a>2.4.1. /etc/fstab</h4></div></div></div><p>The <code class="filename">/etc/fstab</code> file is just a simple text
        file that can be created with any editor. We will need an entry for
        the root filesystem and for the proc filesystem. Information about the
        format of this file can be found in the fstab(5) manpage or by looking
        at the <code class="filename">/etc/fstab</code> file on any of the popular
        GNU/Linux distributions.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm831"></a>2.4.2. /etc/mtab</h4></div></div></div><p>The <code class="filename">/etc/mtab</code> file presents a unique
        challenge, because it does not contain static information like
        <code class="filename">fstab</code>. The <code class="filename">mtab</code> file tracks
        mounted filesystems and therefore its contents change from time to
        time. We are particularly interested in the state of
        <code class="filename">mtab</code> when the system first starts up, before any
        filesystems are mounted. At this point <code class="filename">/etc/mtab</code>
        should be empty so we will need to configure a startup script to
        create an empty <code class="filename">/etc/mtab</code> before any filesystems
        are mounted. But it is not possible to create any files in the
        <code class="filename">/etc</code> directory because <code class="filename">/</code> is
        read-only at startup. This creates a paradox. We cannot create an
        empty <code class="filename">mtab</code>, because the <code class="filename">/</code>
        filesystem is not mounted as writable and we should not mount any
        filesystems until we have created an empty <code class="filename">mtab</code>.
        In order to sidestep this problem we need to do the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Remount <code class="filename">/</code> as read-write, but use the
            <code class="option">-n</code> option so that <span class="command"><strong>mount</strong></span> does
            not attempt to write an entry to <code class="filename">/etc/mtab</code>
            which is read-only at this point.</p></li><li class="listitem"><p>Create an empty <code class="filename">/etc/mtab</code> file now that
            the filesystem is writable.</p></li><li class="listitem"><p>Remount <code class="filename">/</code> as read-write again, this
            time using the <code class="option">-f</code> option so that an entry is
            written into <code class="filename">/etc/mtab</code>, but
            <code class="filename">/</code> is not actually mounted a second
            time.</p></li></ol></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm861"></a>2.4.3. Device files</h4></div></div></div><p>The only thing left to do is to create device files. We will
        need <code class="filename">/dev/ram0</code>, because that is where the root
        filesystem is located. We also need <code class="filename">/dev/fd0</code> to
        mount other floppy disks and <code class="filename">/dev/null</code> for use by
        some of the system commands.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm867"></a>3. Construction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm869"></a>3.1. Install utilities from e2fsprogs</h3></div></div></div><p>Download the e2fsprogs source code package from <a class="ulink" href="http://sourceforge.net/projects/e2fsprogs/" target="_top">http://sourceforge.net/projects/e2fsprogs/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/e2fsprogs-1.35
<code class="prompt">bash#</code> export CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> ./configure --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> cd e2fsck
<code class="prompt">bash#</code> cp e2fsck.shared ~/staging/sbin/e2fsck
<code class="prompt">bash#</code> ln -s e2fsck ~/staging/sbin/fsck.ext2
<code class="prompt">bash#</code> cd ../misc
<code class="prompt">bash#</code> cp fsck mke2fs ~/staging/sbin
<code class="prompt">bash#</code> ln -s mke2fs ~/staging/sbin/mkfs.ext2</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm885"></a>3.2. Install utilities from util-linux</h3></div></div></div><p>Get the latest util-linux source from <a class="ulink" href="ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/" target="_top">ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/util-linux-2.12h</pre><p>Use a text editor to make the following changes to
      <code class="filename">MCONFIG</code>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Change "CPU=$(shell uname -m)" to "CPU=i386"</p></li><li class="listitem"><p>Change "HAVE_SHADOW=yes" to "HAVE_SHADOW=no"</p></li></ul></div><pre class="programlisting"><code class="prompt">bash#</code> ./configure
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> cp disk-utils/mkfs ~/staging/sbin
<code class="prompt">bash#</code> cp fdisk/fdisk ~/staging/sbin
<code class="prompt">bash#</code> cp login-utils/agetty ~/staging/sbin
<code class="prompt">bash#</code> ln -s agetty ~/staging/sbin/getty
<code class="prompt">bash#</code> cp login-utils/login ~/staging/bin
<code class="prompt">bash#</code> cp misc-utils/kill ~/staging/bin
<code class="prompt">bash#</code> cp mount/mount ~/staging/bin
<code class="prompt">bash#</code> cp mount/umount ~/staging/bin
<code class="prompt">bash#</code> cp mount/swapon ~/staging/sbin
<code class="prompt">bash#</code> cp sys-utils/dmesg ~/staging/bin</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm913"></a>3.3. Check library requirements</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> ldd ~/staging/bin/* | more
<code class="prompt">bash#</code> ldd ~/staging/sbin/* | more
<code class="prompt">bash#</code> ls ~/staging/lib</pre><p>All of the dependencies revealed by the <span class="command"><strong>ldd</strong></span>
      command are for libraries already present in the staging area so there
      is no need to copy anything new.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm922"></a>3.4. Strip binaries to save space</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> strip ~/staging/bin/*
<code class="prompt">bash#</code> strip ~/staging/sbin/*</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm928"></a>3.5. Create additional device files</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> mknod ~/staging/dev/ram0 b 1 0
<code class="prompt">bash#</code> mknod ~/staging/dev/fd0 b 2 0
<code class="prompt">bash#</code> mknod ~/staging/dev/null c 1 3</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm935"></a>3.6. Create the fstab and mtab files</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd ~/staging/etc
</pre><p>Use an editor like vi, emacs or pico to create the following file
      and save it as <code class="filename">~/staging/etc/fstab</code>.</p><pre class="programlisting">proc        /proc   proc   defaults   0   0
/dev/ram0   /       ext2   defaults   1   1</pre><p>Create an empty mtab file.</p><pre class="programlisting"><code class="prompt">bash#</code> echo -n &gt;mtab</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm947"></a>3.7. Write a script to check and mount local filesystems</h3></div></div></div><p>Use an editor to create the following shell script and save it as
      <code class="filename">~/staging/etc/init.d/local_fs</code>:</p><pre class="programlisting">#!/bin/sh
#
# local_fs - check and mount local filesystems
#
PATH=/sbin:/bin ; export PATH

fsck -ATCp
if [ $? -gt 1 ]; then
  echo "Filesystem errors still exist!  Manual intervention required."
  /bin/sh
else
  echo "Remounting / as read-write."
  mount -n -o remount,rw /
  echo -n &gt;/etc/mtab
  mount -f -o remount,rw /
  echo "Mounting local filesystems."
  mount -a -t nonfs,nosmbfs
fi
#
# end of local_fs</pre><p>Set execute permissions on the script.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod +x local_fs</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm956"></a>3.8. Create a compressed root disk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR ~/staging/* /mnt
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase4-image bs=1k count=4096
<code class="prompt">bash#</code> gzip -9 ~/phase4-image</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm968"></a>3.9. Write the root disk image to floppy</h3></div></div></div><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase4-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm974"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm976"></a>4.1. System startup</h3></div></div></div><p>Start the system using the following procedure:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Boot the PC using the floppy labeled "boot disk".</p></li><li class="listitem"><p>At the <code class="prompt">grub&gt;</code> prompt, type the usual kernel
          and boot commands, but without the <em class="parameter"><code>rw</code></em>
          parameter this time. In other words, type <strong class="userinput"><code>kernel
          (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1
          prompt_ramdisk=1</code></strong>, press <span class="keycap"><strong>Enter</strong></span> then type
          <strong class="userinput"><code>boot</code></strong> and press <span class="keycap"><strong>Enter</strong></span>.</p></li><li class="listitem"><p>Put in the recently created root disk when prompted.</p></li></ul></div><p>The output should resemble the example below:</p><pre class="screen">GNU GRUB version 0.95

grub&gt; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&gt; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm994"></a>4.2. Test the local_fs script</h3></div></div></div><p>Run the script by typing the following commands at the shell
      prompt:</p><pre class="programlisting"><code class="prompt">bash#</code> PATH=/sbin:/bin:/etc/init.d ; export PATH
<code class="prompt">bash#</code> cat /etc/mtab
<code class="prompt">bash#</code> local_fs
<code class="prompt">bash#</code> cat /etc/mtab
<code class="prompt">bash#</code> df</pre><p>If everything is working properly, then the screen output should
      look something like the example below.</p><pre class="screen"><code class="prompt">bash#</code> PATH=/sbin:/bin:/etc/init.d ; export PATH
<code class="prompt">bash#</code> cat /etc/mtab
<code class="prompt">bash#</code> local_fs
/dev/ram0: clean 74/1024 files 3178/4096 blocks
Remounting / as read-write.
Mounting local filesystems.
<code class="prompt">bash#</code> cat /etc/mtab
/dev/ram0 / ext2 rw 0 0
proc /proc proc rw 0 0
<code class="prompt">bash#</code> df
Filesystem      1k-blocks       Used Available Use% Mounted on
/dev/ram0       3963            3045 918        77% /
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1012"></a>4.3. Create and mount additional filesystems</h3></div></div></div><p>Procure a blank floppy disk and label it as "home". Remove the
      root disk floppy and insert the "home" diskette. Type the following
      commands:</p><pre class="programlisting"><code class="prompt">bash#</code> mkfs -t ext2 /dev/fd0
<code class="prompt">bash#</code> fsck /dev/fd0
<code class="prompt">bash#</code> mount /dev/fd0 /home
<code class="prompt">bash#</code> mkdir /home/floyd
<code class="prompt">bash#</code> cd /home/floyd
<code class="prompt">bash#</code> echo "Goodbye cruel world." &gt; goodbye.txt
<code class="prompt">bash#</code> cat goodbye.txt</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1024"></a>4.4. System shutdown</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> umount /home</pre><p>Remove the diskette from fd0 and restart the system using
      <span class="keycap"><strong>CTRL</strong></span>-<span class="keycap"><strong>ALT</strong></span>-<span class="keycap"><strong>DELETE</strong></span>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase5"></a>Chapter 6. Automating Startup &amp; Shutdown</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1036">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1058">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1060">2.1. Determining necessary utilities</a></span></dt><dt><span class="sect2"><a href="#idm1073">2.2. Obtaining source code</a></span></dt><dt><span class="sect2"><a href="#idm1080">2.3. Checking dependencies</a></span></dt><dt><span class="sect2"><a href="#idm1087">2.4. Designing a simple GRUB configuration file.</a></span></dt><dt><span class="sect2"><a href="#idm1091">2.5. Outlining start-up scripts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1127">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1130">3.1. Create a GRUB configuration file</a></span></dt><dt><span class="sect2"><a href="#idm1138">3.2. Install sysvinit utilities</a></span></dt><dt><span class="sect2"><a href="#idm1152">3.3. Create /etc/inittab file</a></span></dt><dt><span class="sect2"><a href="#idm1158">3.4. Create /etc/init.d/rc script</a></span></dt><dt><span class="sect2"><a href="#idm1168">3.5. Modify /etc/init.d/local_fs script</a></span></dt><dt><span class="sect2"><a href="#idm1173">3.6. Create a hostname script</a></span></dt><dt><span class="sect2"><a href="#idm1179">3.7. Create halt &amp; reboot scripts</a></span></dt><dt><span class="sect2"><a href="#idm1193">3.8. Create rcN.d directories and links</a></span></dt><dt><span class="sect2"><a href="#idm1208">3.9. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1220">3.10. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1226">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1228">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm1233">4.2. Verify success of startup scripts</a></span></dt><dt><span class="sect2"><a href="#idm1244">4.3. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1036"></a>1. Analysis</h2></div></div></div><p>The root disk from the last chapter is looking pretty good. It has
    about seventy percent of the commands that the Filesystem Hierarchy
    Standard (FHS) document requires for the root filesystem. Plus it has
    commands for checking and mounting filesystems. But even with all of this
    the root disk is far from perfect. The list below outlines three things
    that could use some improvement if the Pocket Linux system is to stand up
    next to the more professional looking distributions.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The system currently requires the kernel parameters to be typed
        at the <code class="prompt">grub&gt;</code> prompt in order to start properly. On
        any other GNU/Linux system this is only done in an emergency situation
        when the system is corrupted.</p></li><li class="listitem"><p>Checking and mounting the root filesystem has to be done
        manually by running a script at a shell prompt. On most modern
        operating systems this function is handled automatically as part of
        the system start-up process.</p></li><li class="listitem"><p>Using
        <span class="keycap"><strong>CTRL</strong></span>-<span class="keycap"><strong>ALT</strong></span>-<span class="keycap"><strong>DELETE</strong></span> for
        system shutdown is not very graceful. Filesystems should be unmounted
        and cached information should be flushed prior to shutdown. Again,
        this is something that most operating systems handle
        automatically.</p></li></ol></div><p>Taking the above list into consideration, the goals for this phase
    are defined as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Kernel loads without manual intervention.</p></li><li class="listitem"><p>Automated system start-up sequence.</p></li><li class="listitem"><p>Graceful shutdown capability.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1058"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1060"></a>2.1. Determining necessary utilities</h3></div></div></div><p>Loading the kernel without manually typing parameters is easy to
      do if we read the grub info page. According to the section entitled
      "configuration" all of the commands used for booting can be put in a
      file called <code class="filename">menu.lst</code> and placed in the
      <code class="filename">/boot/grub</code> directory.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Be sure to type the <code class="filename">menu.lst</code> filename
        correctly with a lowercase L after the dot and not a number
        one.</p></div><p>To automate system start-up we will need an init daemon. We know
      this because the Bootdisk-HOWTO and From-Powerup-To-BASH-Prompt-HOWTO
      both make mention of <span class="command"><strong>init</strong></span> as the first program to
      start after the kernel loads. The latter HOWTO also goes into some
      detail about the <code class="filename">/etc/inittab</code> file and the
      organization of startup scripts. This could be helpful since FHS, the
      blueprint we have used so far, makes no recommendation for init
      scripts.</p><p>We will also need to find the <span class="command"><strong>shutdown</strong></span> command
      to fulfill the second goal of graceful shutdown capability.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1073"></a>2.2. Obtaining source code</h3></div></div></div><p>Searching the Linux Software Map on Ibiblio for the keyword "init"
      gives a large number of results. From reading the
      From-Powerup-To-BASH-Prompt-HOWTO however, we know that most Linux
      systems use a System V style init daemon. Narrowing the search with the
      additional key phrase of "System V" gives much better results. The
      sysvinit package contains <span class="command"><strong>init</strong></span>,
      <span class="command"><strong>shutdown</strong></span>, <span class="command"><strong>halt</strong></span> and
      <span class="command"><strong>reboot</strong></span> which is everything we need. The version
      listed in the LSM entry looks to be pretty old, but there is a
      primary-site URL that will probably lead to the latest version.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1080"></a>2.3. Checking dependencies</h3></div></div></div><p>The manpage for <span class="command"><strong>init</strong></span> mentions a FIFO called
      <code class="filename">/dev/initctl</code> that is required for
      <span class="command"><strong>init</strong></span> to communicate with other programs in the
      sysvinit package. We will have to create this file for
      <span class="command"><strong>init</strong></span> to function properly.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1087"></a>2.4. Designing a simple GRUB configuration file.</h3></div></div></div><p>Using a GRUB configuration file is slightly more complex than
      specifying the bootloader commands manually. There are directives for
      features like menus, default selections and timeouts that need to be
      specified in the configuration file as well as the familiar kernel
      loading command. The info page for GRUB gives much of the necessary
      information. We may also be able to use the GRUB configuration file on
      the development system as a template. However, there is some
      inconsistency between vendors as to the name and location of the file.
      Regardless of what the path is on the development system it should be
      <code class="filename">/boot/grub/menu.lst</code> on the Pocket Linux
      System.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1091"></a>2.5. Outlining start-up scripts</h3></div></div></div><p>Many of the popular GNU/Linux distributions use System V style
      init scripts. Since we are using a "sysvinit" daemon it makes sense to
      use System V style scripts as well. The following documents all touch
      upon the System V style init scripts in some way and will serve as
      references when building the scripts for this project:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The Debian Policy Manual -- available online at <a class="ulink" href="http://www.debian.org/doc/debian-policy" target="_top">http://www.debian.org/doc/debian-policy</a>.</p></li><li class="listitem"><p>The Linux Standard Base specification -- downloadable in many
          formats from <a class="ulink" href="http://www.linuxbase.org/spec/index.shtml" target="_top">http://www.linuxbase.org/spec/index.shtml</a>.</p></li><li class="listitem"><p>Essential System Administration, 3rd Edition by Aeleen Frisch
          -- available at libraries, bookstores or directly from O'Reilly
          Publishing at <a class="ulink" href="http://www.oreilly.com/" target="_top">http://www.oreilly.com/</a>.</p></li></ul></div><p>After glancing at one or two of the above references we should
      have a pretty good idea of how the System V style system initialization
      process works. We should also know what it takes to create System V
      style init scripts for the Pocket Linux project. Below is a brief list
      of what needs to be done:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Create an <code class="filename">inittab</code> file to call an
          <code class="filename">rc</code> script with a numerical argument giving the
          runlevel.</p></li><li class="listitem"><p>Write an <code class="filename">rc</code> script that uses the runlevel
          argument to execute the appropriate "K" and "S" scripts.</p></li><li class="listitem"><p>Modify the previously built <code class="filename">local_fs</code>
          script to take <em class="parameter"><code>start</code></em> and
          <em class="parameter"><code>stop</code></em> arguments.</p></li><li class="listitem"><p>Create new scripts for <code class="filename">shutdown</code> and
          <code class="filename">reboot</code>.</p></li><li class="listitem"><p>Set up <code class="filename">/etc/rcN.d</code> directories and links
          to scripts in <code class="filename">/etc/init.d</code>.</p></li></ul></div><p>As always, the BASH(1) manpage and the Advanced BASH Scripting
      Guide are very helpful for writing and understanding shell
      scripts.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1127"></a>3. Construction</h2></div></div></div><p>There is a lot of typing to do in this section because of all of the
    start-up scripts that need to be created. Using a mouse to copy the text
    from this guide and paste it into a text editor can be a great time saving
    tool.</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1130"></a>3.1. Create a GRUB configuration file</h3></div></div></div><p>Insert and mount the floppy labeled "boot disk".</p><pre class="programlisting"><code class="prompt">bash#</code> mount /dev/fd0 /mnt
<code class="prompt">bash#</code> cd /mnt/boot/grub</pre><p>Use your favorite text editor to create the following file and
      save it as /mnt/boot/grub/menu.lst:</p><pre class="programlisting">default 0
timeout 3
title Pocket Linux Boot Disk
kernel (fd0)/boot/vmlinuz root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1138"></a>3.2. Install sysvinit utilities</h3></div></div></div><p>Download the latest sysvinit source from <a class="ulink" href="ftp://ftp.cistron.nl/pub/people/miquels/software/" target="_top">ftp://ftp.cistron.nl/pub/people/miquels/software/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/sysvinit-2.85/src
<code class="prompt">bash#</code> make CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> cp halt init shutdown ~/staging/sbin
<code class="prompt">bash#</code> ln -s halt ~/staging/sbin/reboot
<code class="prompt">bash#</code> ln -s init ~/staging/sbin/telinit
<code class="prompt">bash#</code> mknod ~/staging/dev/initctl p</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the interest of speed we are skipping the steps for checking
        libraries and stripping binaries. The library requirements for
        sysvinit are very basic and the Makefile is configured to
        automatically strip the binaries.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1152"></a>3.3. Create /etc/inittab file</h3></div></div></div><p>Use a text editor to create the following file and save it as
      <code class="filename">~/staging/etc/inittab</code></p><pre class="programlisting"># /etc/inittab - init daemon configuration file
#
# Default runlevel
id:1:initdefault:
#
# System initialization
si:S:sysinit:/etc/init.d/rc S
#
# Runlevel scripts
r0:0:wait:/etc/init.d/rc 0
r1:1:respawn:/bin/sh
r2:2:wait:/etc/init.d/rc 2
r3:3:wait:/etc/init.d/rc 3
r4:4:wait:/etc/init.d/rc 4
r5:5:wait:/etc/init.d/rc 5
r6:6:wait:/etc/init.d/rc 6
#
# end of /etc/inittab</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1158"></a>3.4. Create /etc/init.d/rc script</h3></div></div></div><p>Use a text editor to create the following file and save it as
      <code class="filename">~/staging/etc/init.d/rc</code></p><pre class="programlisting">#!/bin/sh
#
# /etc/init.d/rc - runlevel change script
#
PATH=/sbin:/bin
SCRIPT_DIR="/etc/rc$1.d"
#
# Check that the rcN.d directory really exists.
if [ -d $SCRIPT_DIR ]; then
#
# Execute the kill scripts first.
  for SCRIPT in $SCRIPT_DIR/K*; do
    if [ -x $SCRIPT ]; then
      $SCRIPT stop;
    fi;
  done;
#
# Do the Start scripts last.
  for SCRIPT in $SCRIPT_DIR/S*; do
    if [ -x $SCRIPT ]; then
      $SCRIPT start;
    fi;
  done;
fi
#
# end of /etc/init.d/rc</pre><p>Make the file executable.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod +x ~/staging/etc/init.d/rc</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1168"></a>3.5. Modify /etc/init.d/local_fs script</h3></div></div></div><p>A case statement is added to allow the script to either mount or
      unmount local filesystems depending on the command-line argument given.
      The original script is contained inside the "start" portion of the case
      statement. The "stop" portion is new.</p><pre class="programlisting">#!/bin/sh
#
# local_fs - check and mount local filesystems
#
PATH=/sbin:/bin ; export PATH

case $1 in

start)
  echo "Checking local filesystem integrity."
  fsck -ATCp
  if [ $? -gt 1 ]; then
    echo "Filesystem errors still exist!  Manual intervention required."
    /bin/sh
  else
    echo "Remounting / as read-write."
    mount -n -o remount,rw /
    echo -n &gt; /etc/mtab
    mount -f -o remount,rw /
    echo "Mounting local filesystems."
    mount -a -t nonfs,smbfs
  fi
;;

stop)
  echo "Unmounting local filesystems."
  umount -a -r
;;

*)
  echo "usage: $0 start|stop";
;;

esac
#
# end of local_fs</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1173"></a>3.6. Create a hostname script</h3></div></div></div><p>Use a text editor to create the following script and save it as
      <code class="filename">~/staging/etc/init.d/hostname</code></p><pre class="programlisting">#!/bin/sh
#
# hostname - set the system name to the name stored in /etc/hostname
#
PATH=/sbin:/bin ; export PATH

echo "Setting hostname."
if [ -f /etc/hostname ]; then
  hostname $(cat /etc/hostname)
else
  hostname gnu-linux
fi
#
# end of hostname</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1179"></a>3.7. Create halt &amp; reboot scripts</h3></div></div></div><p>Use a text editor to create
      <code class="filename">~/staging/etc/init.d/halt</code> as shown below.</p><pre class="programlisting">#!/bin/sh
#
# halt - halt the system
#
PATH=/sbin:/bin ; export PATH

echo "Initiating system halt."
halt
#
# end of /etc/init.d/halt</pre><p>Create the following script and save it as
      <code class="filename">~/staging/etc/init.d/reboot</code></p><pre class="programlisting">#!/bin/sh
#
# reboot - reboot the system
#
PATH=/sbin:/bin ; export PATH

echo "Initiating system reboot."
reboot
#
# end of /etc/init.d/reboot</pre><p>Flag all script files as executable.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod +x ~/staging/etc/init.d/*</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1193"></a>3.8. Create rcN.d directories and links</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd ~/staging/etc
<code class="prompt">bash#</code> mkdir rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d
<code class="prompt">bash#</code> cd ~/staging/etc/rcS.d
<code class="prompt">bash#</code> ln -s ../init.d/local_fs S20local_fs
<code class="prompt">bash#</code> ln -s ../init.d/hostname S30hostname
<code class="prompt">bash#</code> cd ~/staging/etc/rc0.d
<code class="prompt">bash#</code> ln -s ../init.d/local_fs K10local_fs
<code class="prompt">bash#</code> ln -s ../init.d/halt K90halt
<code class="prompt">bash#</code> cd ~/staging/etc/rc6.d
<code class="prompt">bash#</code> ln -s ../init.d/local_fs K10local_fs
<code class="prompt">bash#</code> ln -s ../init.d/reboot K90reboot</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1208"></a>3.9. Create the root disk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR ~/staging/* /mnt
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase5-image bs=1k
<code class="prompt">bash#</code> gzip -9 ~/phase5-image</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1220"></a>3.10. Copy the image to diskette</h3></div></div></div><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase5-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1226"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1228"></a>4.1. System Startup</h3></div></div></div><p>Boot the PC using the floppy labeled "boot disk". Place the
      recently created root disk in fd0 when prompted. The output should
      resemble the example below:</p><pre class="screen">GNU GRUB version 0.95

Uncompressing Linux... Ok, booting kernel.
..
.. [various kernel messages]
..
VFS: Insert root floppy to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
Checking local filesystem integrity.
/dev/ram0: clean 105/1024 files 2842/4096 blocks
Remounting / as read-write.
Mounting local filesystems.
Setting the hostname.
INIT: Entering runlevel: 1
# _</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1233"></a>4.2. Verify success of startup scripts</h3></div></div></div><p>Use the <span class="command"><strong>mount</strong></span> command to check that local
      filesystems are mounted as read-write. The output should look like the
      example below.</p><pre class="screen"><code class="prompt">bash#</code> mount
/dev/root on / type ext2 (rw)
proc on /proc type proc (rw)</pre><p>Check the hostname.</p><pre class="screen"><code class="prompt">bash#</code> uname -n
gnu-linux</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1244"></a>4.3. System shutdown</h3></div></div></div><p>Bring the system down gracefully with the
      <span class="command"><strong>shutdown</strong></span> command.</p><pre class="programlisting"><code class="prompt">bash#</code> shutdown -h now</pre><p>We should see the following output from <span class="command"><strong>init</strong></span>
      and the shutdown scripts:</p><pre class="screen">INIT: Switching to runlevel: 0
INIT: Sending processes the TERM signal
Terminated
INIT: Sending processes the KILL signal
Unmounting local filesystems.
Initiating system halt.
System halted.</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase6"></a>Chapter 7. Enabling Multiple Users</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1257">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1265">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1267">2.1. The login process</a></span></dt><dt><span class="sect2"><a href="#idm1290">2.2. Obtaining source code</a></span></dt><dt><span class="sect2"><a href="#idm1295">2.3. Creating support files</a></span></dt><dt><span class="sect2"><a href="#idm1339">2.4. Dependencies</a></span></dt><dt><span class="sect2"><a href="#idm1356">2.5. Assigning ownership and permissions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1378">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1380">3.1. Verify presence of getty and login</a></span></dt><dt><span class="sect2"><a href="#idm1386">3.2. Modify inittab for multi-user mode</a></span></dt><dt><span class="sect2"><a href="#idm1393">3.3. Create tty devices</a></span></dt><dt><span class="sect2"><a href="#idm1406">3.4. Create support files in /etc</a></span></dt><dt><span class="sect2"><a href="#idm1433">3.5. Copy required libraries</a></span></dt><dt><span class="sect2"><a href="#idm1438">3.6. Set directory and file permissions</a></span></dt><dt><span class="sect2"><a href="#idm1499">3.7. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1511">3.8. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1517">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1519">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm1524">4.2. Add a new user to the system</a></span></dt><dt><span class="sect2"><a href="#idm1537">4.3. Test the new user's ability to use the system</a></span></dt><dt><span class="sect2"><a href="#idm1555">4.4. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1257"></a>1. Analysis</h2></div></div></div><p>Up to now the system has been operating in single-user mode. There
    is no login process and anyone who boots the system goes straight into a
    shell with root privileges. Obviously, this is not the normal operating
    mode for most GNU/Linux distributions. Most systems feature multi-user
    capability where many users can access the system simultaneously with
    different privilege levels. These multi-user systems also support virtual
    consoles so that the keyboard and video display can be multiplexed between
    several terminal sessions. So in this phase we would like to add the
    following enhancements to the system:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Enable multi-user capability.</p></li><li class="listitem"><p>Create multiple, virtual consoles.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1265"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1267"></a>2.1. The login process</h3></div></div></div><p>The From-Powerup-To-BASH-Prompt-HOWTO does a good job of outlining
      the steps in the login process. Basically it works like this.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The <span class="command"><strong>init</strong></span> daemon starts a
          <span class="command"><strong>getty</strong></span> process on the terminal.</p></li><li class="listitem"><p>The <span class="command"><strong>getty</strong></span> program displays the contents of
          <code class="filename">/etc/issue</code> and prompts for a user name.</p></li><li class="listitem"><p>When the user name is entered, control is handed off to the
          <span class="command"><strong>login</strong></span> program.</p></li><li class="listitem"><p>The <span class="command"><strong>login</strong></span> program asks for a password and
          verifies the credentials using <code class="filename">/etc/passwd</code>,
          <code class="filename">/etc/group</code> and possibly
          <code class="filename">/etc/shadow</code>.</p></li><li class="listitem"><p>If everything is okay the user's shell is started.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1290"></a>2.2. Obtaining source code</h3></div></div></div><p>The <span class="command"><strong>getty</strong></span> and <span class="command"><strong>login</strong></span> programs
      were already installed as part of the util-linux package so there is no
      need to download any new source code.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1295"></a>2.3. Creating support files</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1297"></a>2.3.1. Device nodes</h4></div></div></div><p>Details about virtual console device files can be found in the
        Linux kernel source code file called <code class="filename">devices.txt</code>
        in the <code class="filename">Documentation</code> directory. We will need to
        create <code class="filename">tty1</code> through <code class="filename">tty6</code> for
        each of the virtual consoles as well as <code class="filename">tty0</code> and
        <code class="filename">tty</code> to represent the current virtual
        console.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1306"></a>2.3.2. /etc/issue</h4></div></div></div><p>The <code class="filename">/etc/issue</code> file is pretty easy to
        construct. It can contain any text we want displayed on the screen
        prior to the login prompt. It could be something friendly like
        "Welcome to Pocket Linux", something menacing like "Authorized users
        only!" or something informational like "Connected to tty1 at 9600bps".
        The agetty(8) manpage explains how to display information like tty
        line and baud rate using escape codes.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1310"></a>2.3.3. /etc/passwd</h4></div></div></div><p>The format of <code class="filename">/etc/passwd</code> can be obtained
        by reading the passwd(5) manpage. We can easily create a user account
        by adding a line like "root::0:0:superuser:/root:/bin/sh" to the
        file.</p><p>Maintaining passwords will be somewhat challenging because of
        the system being loaded into ramdisk. Any changes to
        <code class="filename">/etc/passwd</code> will be lost when the system is
        shutdown. So to make things easy, we will create all users with null
        passwords.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1316"></a>2.3.4. /etc/group</h4></div></div></div><p>The structure of <code class="filename">/etc/group</code> is available
        from the group(5) manpage. A line of "root::0:root" would define a
        group called "root" with no password, a group id of zero and the user
        root assigned to it as the only member.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1320"></a>2.3.5. Conventions</h4></div></div></div><p>User and group names and id's are generally not chosen at
        random. Most Linux systems have very similar looking
        <code class="filename">/etc/passwd</code> and <code class="filename">/etc/group</code>
        files. Definitions for commonly used user id and group id assignments
        may be found in one of several places:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The <code class="filename">/etc/passwd</code> and
            <code class="filename">/etc/group</code> files on any popular GNU/Linux
            distribution.</p></li><li class="listitem"><p>The Debian Policy Manual -- available online at <a class="ulink" href="http://www.debian.org/doc/debian-policy" target="_top">http://www.debian.org/doc/debian-policy</a>.</p></li><li class="listitem"><p>The Linux Standard Base specification -- downloadable in
            many formats from <a class="ulink" href="http://www.linuxbase.org/spec/index.shtml" target="_top">http://www.linuxbase.org/spec/index.shtml</a>.</p></li><li class="listitem"><p>Essential System Administration, 3rd Edition by Aeleen
            Frisch -- available at libraries, bookstores or directly from
            O'Reilly Publishing at <a class="ulink" href="http://www.oreilly.com/" target="_top">http://www.oreilly.com/</a>.</p></li></ul></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1339"></a>2.4. Dependencies</h3></div></div></div><p>Running <span class="command"><strong>ldd</strong></span> on the <code class="filename">login</code>
      program from util-linux will reveal that it is linked to the libraries
      <code class="filename">libcrypt.so.1</code>, <code class="filename">libc.so.6</code> and
      <code class="filename">ld-linux.so.2</code>. In addition to these libraries there
      is another, unseen dependency on <code class="filename">libnss_files.so.2</code>
      and the configuration file
      <code class="filename">/etc/nsswitch.conf</code>.</p><p>The name service switch library
      <code class="filename">libnss_files.so.2</code> and
      <code class="filename">nsswitch.conf</code> are required for
      <code class="filename">libc.so.6</code>, and consequently the
      <code class="filename">login</code> program, to access the
      <code class="filename">/etc/passwd</code> file. Without libnss and its
      configuration file, all logins will mysteriously fail. More information
      about glibc's use of the name service switch libraries can be found at
      <a class="ulink" href="http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html" target="_top">http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1356"></a>2.5. Assigning ownership and permissions</h3></div></div></div><p>Previously, with the single user system, there was no need to
      worry about permissions when installing directories, files and device
      nodes. The shell was effectively operating as root, so everything was
      accessible. Things become more complex with the addition of multiple
      user capability. Now we need to make sure that every user has access to
      what they need and at the same time gets blocked from what they do not
      need.</p><p>A good guideline for assigning ownership and permissions would be
      to give the minimum level of access required. Take the
      <code class="filename">/bin</code> directory as an example. The Filesystem
      Hierarchy (FHS) document says, "<code class="filename">/bin</code> contains
      commands that may be used by both the system administrator and by
      users". From that statement we can infer that <code class="filename">/bin</code>
      should have read and execute permission for everyone. On the other hand,
      the <code class="filename">/boot</code> directory contains files for the boot
      loader. Chances are good that regular users will not need to access
      anything in the <code class="filename">/boot</code> directory. So the minimum
      level of access would be read permission for the root user and other
      administrators who are members of the root group. Normal users would
      have no permissions assigned on the <code class="filename">/boot</code>
      directory.</p><p>Most of the time we can assign similar permissions to all the
      commands in a directory, but there are some programs that prove to be
      exceptions to the rule. The <span class="command"><strong>su</strong></span> command is a good
      example. Other commands in the /bin directory have a minimum requirement
      of read and execute, but the <span class="command"><strong>su</strong></span> command needs to be
      setuid root in order to run correctly. Since it is a setuid binary, it
      might not be a good idea to allow just anyone to run it. Ownership of
      0:0 (root user, root group) and permissions of rwsr-x--- (octal 4750)
      would be a good fit for <span class="command"><strong>su</strong></span>.</p><p>The same logic can be applied to other directories and files in
      the root filesystem using the following steps:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Assign ownership to the root user and root group.</p></li><li class="listitem"><p>Set the most restrictive permissions possible.</p></li><li class="listitem"><p>Adjust ownership and permissions on an "as needed"
          basis.</p></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1378"></a>3. Construction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1380"></a>3.1. Verify presence of getty and login</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> ls ~/staging/sbin/getty
<code class="prompt">bash#</code> ls ~/staging/bin/login</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1386"></a>3.2. Modify inittab for multi-user mode</h3></div></div></div><p>Modify <code class="filename">~/staging/etc/inittab</code> by changing the
      default runlevel and adding <span class="command"><strong>getty</strong></span> entries as shown
      below.</p><pre class="programlisting"># /etc/inittab - init daemon configuration file
#
# Default runlevel
id:2:initdefault:
#
# System initialization
si:S:sysinit:/etc/init.d/rc S
#
# Runlevel scripts
r0:0:wait:/etc/init.d/rc 0
r1:1:respawn:/bin/sh
r2:2:wait:/etc/init.d/rc 2
r3:3:wait:/etc/init.d/rc 3
r4:4:wait:/etc/init.d/rc 4
r5:5:wait:/etc/init.d/rc 5
r6:6:wait:/etc/init.d/rc 6
#
# Spawn virtual terminals
1:235:respawn:/sbin/getty 38400 tty1 linux
2:235:respawn:/sbin/getty 38400 tty2 linux
3:235:respawn:/sbin/getty 38400 tty3 linux
4:235:respawn:/sbin/getty 38400 tty4 linux
5:235:respawn:/sbin/getty 38400 tty5 linux
6:2345:respawn:/sbin/getty 38400 tty6 linux
#
# end of /etc/inittab</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1393"></a>3.3. Create tty devices</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd ~/staging/dev
<code class="prompt">bash#</code> mknod ~/staging/dev/tty0 c 4 0
<code class="prompt">bash#</code> mknod ~/staging/dev/tty1 c 4 1
<code class="prompt">bash#</code> mknod ~/staging/dev/tty2 c 4 2
<code class="prompt">bash#</code> mknod ~/staging/dev/tty3 c 4 3
<code class="prompt">bash#</code> mknod ~/staging/dev/tty4 c 4 4
<code class="prompt">bash#</code> mknod ~/staging/dev/tty5 c 4 5
<code class="prompt">bash#</code> mknod ~/staging/dev/tty6 c 4 6
<code class="prompt">bash#</code> mknod ~/staging/dev/tty c 5 0</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1406"></a>3.4. Create support files in /etc</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1408"></a>3.4.1. /etc/issue</h4></div></div></div><p>Create the file <code class="filename">~/staging/etc/issue</code> using
        the example below or design a customized message.</p><pre class="programlisting">Connected to \l at \b bps.</pre><p>Be sure that "\l" is a lowercase letter L and not the number
        one.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1415"></a>3.4.2. /etc/passwd</h4></div></div></div><p>Use a text editor to create a minimal passwd file conforming to
        the Linux Standards Base (LSB) document. Save the file as
        <code class="filename">~/staging/etc/passwd</code></p><pre class="programlisting">root::0:0:Super User:/root:/bin/sh
bin:x:1:1:Legacy UID:/bin:/bin/false
daemon:x:2:2:Legacy UID:/sbin:/bin/false</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1421"></a>3.4.3. /etc/group</h4></div></div></div><p>Use a text editor to create an LSB conforming group file and
        save it as <code class="filename">~/staging/etc/group</code></p><pre class="programlisting">root::0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1427"></a>3.4.4. /etc/nsswitch.conf</h4></div></div></div><p>Create the following file and save it as
        <code class="filename">~/staging/etc/nsswitch.conf</code></p><pre class="programlisting">passwd: files
group:  files</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1433"></a>3.5. Copy required libraries</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cp /lib/libnss_files.so.2 ~/staging/lib
bash# strip --strip-unneeded ~/staging/lib/*</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1438"></a>3.6. Set directory and file permissions</h3></div></div></div><p>Set minimal privileges on all files and directories under
      <code class="filename">~/staging</code>. Everything is owned by the root user and
      the root group. Permissions are read-write for the owner and read-only
      for the group. Exceptions to the blanket permissions are handled case by
      case.</p><pre class="programlisting"><code class="prompt">bash#</code> cd ~/staging
<code class="prompt">bash#</code> chown -R 0:0 ~/staging/*
<code class="prompt">bash#</code> chmod -R 640 ~/staging/*</pre><p>Set execute permission on all directories. (Note the capital
      "X")</p><pre class="programlisting"><code class="prompt">bash#</code> chmod -R +X ~/staging/*</pre><p>Files in <code class="filename">/bin</code> are read and execute for all,
      but <code class="filename">su</code> is an exception.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 755 ~/staging/bin/*
<code class="prompt">bash#</code> chmod 4750 ~/staging/bin/su</pre><p>Files in <code class="filename">/dev</code> have various permissions. Disk
      devices should be accessible to administrators only. Other files like
      <code class="filename">/dev/null</code> should have full privileges granted to
      everyone.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 660 ~/staging/dev/fd0 dev/ram0
<code class="prompt">bash#</code> chmod 666 ~/staging/dev/null
<code class="prompt">bash#</code> chmod 622 ~/staging/dev/console
<code class="prompt">bash#</code> chmod 600 ~/staging/dev/initctl
<code class="prompt">bash#</code> chmod 622 ~/staging/dev/tty
<code class="prompt">bash#</code> chmod 622 ~/staging/dev/tty?</pre><p>The <code class="filename">passwd</code> and <code class="filename">group</code>
      files must be world readable.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 644 ~/staging/etc/passwd
<code class="prompt">bash#</code> chmod 644 ~/staging/etc/group</pre><p>The scripts in <code class="filename">/etc/init.d</code> are read and
      execute for administrators.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 750 ~/staging/etc/init.d/*</pre><p>Libraries need read and execute permissions for everyone.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 755 ~/staging/lib/*</pre><p>Only root should have access to the <code class="filename">/root</code>
      directory.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 700 ~/staging/root</pre><p>Make files in <code class="filename">/sbin</code> read and execute for
      administrators.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 750 ~/staging/sbin/*</pre><p>Temp should be read-write for all with the sticky bit set.</p><pre class="programlisting"><code class="prompt">bash#</code> chmod 1777 ~/staging/tmp</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1499"></a>3.7. Create the root disk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR ~/staging/* /mnt
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase6-image bs=1k count=4096
<code class="prompt">bash#</code> gzip -9 ~/phase6-image</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1511"></a>3.8. Copy the image to diskette</h3></div></div></div><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase6-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1517"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1519"></a>4.1. System Startup</h3></div></div></div><p>If everything goes well, the virtual console display should look
      similar to the following example:</p><pre class="screen">Connected to tty1 at 38400 bps.
gnu-linux login:</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1524"></a>4.2. Add a new user to the system</h3></div></div></div><p>Log in as root.</p><p>Create a new, unprivileged user and new group by appending a line
      to the <code class="filename">/etc/passwd</code> and
      <code class="filename">/etc/group</code> files, respectively. Be sure to use a
      double greater-than (&gt;&gt;) to avoid accidentally overwriting the
      files.</p><pre class="programlisting"><code class="prompt">bash#</code> echo "floyd::501:500:User:/home/floyd:/bin/sh" &gt;&gt;/etc/passwd
<code class="prompt">bash#</code> echo "users::500:" &gt;&gt;/etc/group
<code class="prompt">bash#</code> mkdir /home/floyd
<code class="prompt">bash#</code> chown floyd.users /home/floyd
<code class="prompt">bash#</code> chmod 700 /home/floyd</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1537"></a>4.3. Test the new user's ability to use the system</h3></div></div></div><p>Switch to virtual terminal tty2 by pressing
      <span class="keycap"><strong>ALT</strong></span>+<span class="keycap"><strong>F2</strong></span>.</p><p>Log in as floyd.</p><p>Try the following commands and verify that they work.</p><pre class="programlisting"><code class="prompt">bash$</code> pwd
<code class="prompt">bash$</code> ls -l /
<code class="prompt">bash$</code> cat /etc/passwd</pre><p>Try the following commands and verify that they do not
      work.</p><pre class="programlisting"><code class="prompt">bash$</code> ls /root
<code class="prompt">bash$</code> /sbin/shutdown -h now
<code class="prompt">bash$</code> su -</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1555"></a>4.4. System shutdown</h3></div></div></div><p>Switch back to tty1 where root is logged in.</p><pre class="programlisting"><code class="prompt">bash#</code> shutdown -h now</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="phase7"></a>Chapter 8. Filling in the Gaps</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1563">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1601">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1603">2.1. more</a></span></dt><dt><span class="sect2"><a href="#idm1624">2.2. More device files</a></span></dt><dt><span class="sect2"><a href="#idm1642">2.3. ps, sed &amp; ed</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1654">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1656">3.1. Write a "more" script</a></span></dt><dt><span class="sect2"><a href="#idm1667">3.2. Create additional device files</a></span></dt><dt><span class="sect2"><a href="#idm1675">3.3. Install ps</a></span></dt><dt><span class="sect2"><a href="#idm1685">3.4. Install sed</a></span></dt><dt><span class="sect2"><a href="#idm1697">3.5. Install ed</a></span></dt><dt><span class="sect2"><a href="#idm1707">3.6. Strip binaries to save space</a></span></dt><dt><span class="sect2"><a href="#idm1712">3.7. Ensure proper permissions</a></span></dt><dt><span class="sect2"><a href="#idm1719">3.8. Create the root disk image</a></span></dt><dt><span class="sect2"><a href="#idm1731">3.9. Copy the image to diskette</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1737">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1739">4.1. System startup</a></span></dt><dt><span class="sect2"><a href="#idm1742">4.2. Test the "more" script</a></span></dt><dt><span class="sect2"><a href="#idm1756">4.3. Use ps to show running processes</a></span></dt><dt><span class="sect2"><a href="#idm1766">4.4. Run a simple sed script</a></span></dt><dt><span class="sect2"><a href="#idm1778">4.5. Test the "ed" editor</a></span></dt><dt><span class="sect2"><a href="#idm1795">4.6. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1563"></a>1. Analysis</h2></div></div></div><p>The root disk has come a long way since its humble beginnings as a
    statically-linked shell. It now shares many features with the popular,
    ready-made distributions. For example it has:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Several common utilities like <span class="command"><strong>cat</strong></span>,
        <span class="command"><strong>ls</strong></span> and so on.</p></li><li class="listitem"><p>Startup scripts that automatically check and mount
        filesystems.</p></li><li class="listitem"><p>Graceful shutdown capability.</p></li><li class="listitem"><p>Support for multiple users and virtual terminals.</p></li></ul></div><p>As a final test, we can put the root disk up against the Filesystem
    Hierarchy Standard (FHS) requirements for the root filesystem. (We will
    ignore anything in the <code class="filename">/usr</code> hierarchy because of
    space constraints.) Compared to FHS requirement, the only files missing
    are a few commands in the <code class="filename">/bin</code> directory.
    Specifically, the root disk lacks the following commands:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>more</strong></span></p></li><li class="listitem"><p><span class="command"><strong>ps</strong></span></p></li><li class="listitem"><p><span class="command"><strong>sed</strong></span></p></li></ul></div><p>In addition to the required commands, it might be nice to include
    the "ed" editor listed as an option by the FHS. It is not as robust as vi
    or emacs, but it works and it should fit onto the tiny root
    filesystem.</p><p>So in order to finish up this phase of the project, we need to
    accomplish the following goals:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Add the <span class="command"><strong>more</strong></span>, <span class="command"><strong>ps</strong></span> and
        <span class="command"><strong>sed</strong></span> commands.</p></li><li class="listitem"><p>Install the optional <span class="command"><strong>ed</strong></span> editor.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1601"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1603"></a>2.1. more</h3></div></div></div><p>There is a <span class="command"><strong>more</strong></span> command that comes with
      util-linux, but it will not work for this project. The reason is because
      of library dependencies and space constraints. The util-linux supplied
      <span class="command"><strong>more</strong></span> needs either the libncurses or libtermcap to
      work and there just is not enough space on the root disk floppy to fit
      everything in. So, in order to have a <span class="command"><strong>more</strong></span> command we
      will have to get creative.</p><p>The <span class="command"><strong>more</strong></span> command is used to display a file page
      by page. It's a little like having a <span class="command"><strong>cat</strong></span> command that
      pauses every twenty-five lines. The basic logic is outlined
      below.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Read one line of the file.</p></li><li class="listitem"><p>Display the line on the screen.</p></li><li class="listitem"><p>If 25 lines have been displayed, pause.</p></li><li class="listitem"><p>Loop and do it again.</p></li></ul></div><p>Of course there are some details left out like what to do if the
      screen dimensions are not what we anticipated, but overall it is a fair
      representation of what <span class="command"><strong>more</strong></span> does. Given this simple
      program logic, it should not be hard to put together a short shell
      script that emulates the basic functionality of <span class="command"><strong>more</strong></span>.
      The BASH(1) manpage and Adv-BASH-Scripting-Guide will serve as
      references.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1624"></a>2.2. More device files</h3></div></div></div><p>The <span class="command"><strong>more</strong></span> script will need access to device
      files that are not on the root disk yet. Specifically
      <span class="command"><strong>more</strong></span> needs to have <code class="filename">stdin</code>,
      <code class="filename">stdout</code> and <code class="filename">stderr</code>, but while
      we are at it we should check for any other missing
      <code class="filename">/dev</code> files. The Linux Standard Base requires
      <code class="filename">null</code>, <code class="filename">zero</code> and
      <code class="filename">tty</code> to be present in the <code class="filename">/dev</code>
      directory. Files for <code class="filename">null</code> and
      <code class="filename">tty</code> already exist from previous phases of the
      project, but we still need <code class="filename">/dev/zero</code>. We can refer
      to <code class="filename">devices.txt</code> in the Linux source code
      <code class="filename">Documentation</code> directory for major and minor
      numbers.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1642"></a>2.3. ps, sed &amp; ed</h3></div></div></div><p>These three packages can be found by using the Internet resources
      we have used before plus one new site. The "sed" and "ed" packages can
      be found at the same place we found BASH, on the <a class="ulink" href="ftp://ftp.gnu.org" target="_top">GNU FTP server</a>. The procps package shows
      up in an Ibiblio LSM search, but it is an old version. In order to find
      the latest version we can go to the Freshmeat website at <a class="ulink" href="http://freshmeat.net" target="_top">http://freshmeat.net</a> and search for
      "procps" in projects.</p><p>Both "sed" and "ed" packages feature GNU's familiar
      <span class="command"><strong>configure</strong></span> script and are therefore very easy to
      build. There is no <span class="command"><strong>configure</strong></span> script for "procps" but
      this does not make things too difficult. We can just read the package's
      <code class="filename">README</code> file to find out about how to set various
      configuration options. We can use one of these options to avoid the
      complexity of using and installing libproc. Setting
      <em class="parameter"><code>SHARED=0</code></em> makes <code class="filename">libproc</code> an
      integrated part of <span class="command"><strong>ps</strong></span> rather than a separate, shared
      library.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1654"></a>3. Construction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1656"></a>3.1. Write a "more" script</h3></div></div></div><p>Create the following script with a text editor and save it as
      <code class="filename">~/staging/bin/more.sh</code></p><pre class="programlisting">#!/bin/sh
#
# more.sh - emulates the basic functions of the "more" binary without
#           requiring ncurses or termcap libraries.
#
# Assume input is coming from STDIN unless a valid file is given as
# a command-line argument. 
if [ -f $1 ]; then
  INPUT="$1"
else
  INPUT="/dev/stdin"
fi
#
# Set IFS to newline only. See BASH(1) manpage for details on IFS.
IFS=$'\n'
#
# If terminal dimensions are not already set as shell variables, take
# a guess of 80x25.
if [ "$COLUMNS" = "" ]; then
  let COLUMNS=80;
fi
if [ "$LINES" = "" ]; then
  let LINES=25;
fi
#
# Initialize line counter variable
let LINE_COUNTER=$LINES
#
# Read the input file one line at a time and display on STDOUT until
# the page fills up. Display "Press &lt;Enter&gt;" message on STDERR and wait
# for keypress from STDERR.  Continue until the end of the input file.
# Any input line greater than $COLUMNS characters in length is wrapped
# and counts as multiple lines.
#
while read -n $COLUMNS LINE_BUFFER; do
  echo "$LINE_BUFFER"
  let LINE_COUNTER=$LINE_COUNTER-1
  if [ $LINE_COUNTER -le 1 ]; then
    echo "Press &lt;ENTER&gt; for next page or &lt;CTRL&gt;+C to quit."&gt;/dev/stderr
    read&lt;/dev/stderr
    let LINE_COUNTER=$LINES
  fi
done&lt;$INPUT
#
# end of more.sh</pre><p>Create a symbolic link for <code class="filename">more</code></p><pre class="programlisting"><code class="prompt">bash#</code> ln -s more.sh ~/staging/bin/more</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1667"></a>3.2. Create additional device files</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> ln -s /proc/self/fd ~/staging/dev/fd
<code class="prompt">bash#</code> ln -s fd/0 ~/staging/dev/stdin
<code class="prompt">bash#</code> ln -s fd/1 ~/staging/dev/stdout
<code class="prompt">bash#</code> ln -s fd/2 ~/staging/dev/stderr
bash# mknod -m644 ~/staging/dev/zero c 1 5</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1675"></a>3.3. Install ps</h3></div></div></div><p>Get the latest procps source package from <a class="ulink" href="http://procps.sourceforge.net/" target="_top">http://procps.sourceforge.net/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/procps-3.2.3
<code class="prompt">bash#</code> make SHARED=0 CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> cd ps
<code class="prompt">bash#</code> cp ps ~/staging/bin</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1685"></a>3.4. Install sed</h3></div></div></div><p>Download GNU's sed from <a class="ulink" href="ftp://ftp.gnu.org/gnu/sed/" target="_top">ftp://ftp.gnu.org/gnu/sed/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/sed-4.1.2
<code class="prompt">bash#</code> export CC="gcc -mcpu=i386"
<code class="prompt">bash#</code> ./configure --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> cd sed
<code class="prompt">bash#</code> cp sed ~/staging/bin</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1697"></a>3.5. Install ed</h3></div></div></div><p>The ed package also comes from GNU at <a class="ulink" href="ftp://ftp.gnu.org/gnu/ed/" target="_top">ftp://ftp.gnu.org/gnu/ed/</a></p><pre class="programlisting"><code class="prompt">bash#</code> cd /usr/src/ed-0.2
<code class="prompt">bash#</code> ./configure --host=i386-pc-linux-gnu
<code class="prompt">bash#</code> make
<code class="prompt">bash#</code> cp ed ~/staging/bin</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1707"></a>3.6. Strip binaries to save space</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> strip ~/staging/bin/*</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1712"></a>3.7. Ensure proper permissions</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> chown 0:0 ~/staging/bin/*
<code class="prompt">bash#</code> chmod -R 755 ~/staging/bin
<code class="prompt">bash#</code> chmod 4750 ~/staging/bin/su</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1719"></a>3.8. Create the root disk image</h3></div></div></div><pre class="programlisting"><code class="prompt">bash#</code> cd /
<code class="prompt">bash#</code> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<code class="prompt">bash#</code> mke2fs -m0 /dev/ram7 4096
<code class="prompt">bash#</code> mount /dev/ram7 /mnt
<code class="prompt">bash#</code> cp -dpR ~/staging/* /mnt
<code class="prompt">bash#</code> umount /dev/ram7
<code class="prompt">bash#</code> dd if=/dev/ram7 of=~/phase7-image bs=1k
<code class="prompt">bash#</code> gzip -9 ~/phase7-image</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1731"></a>3.9. Copy the image to diskette</h3></div></div></div><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting"><code class="prompt">bash#</code> dd if=~/phase7-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1737"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1739"></a>4.1. System startup</h3></div></div></div><p>Boot from the diskset in the usual way and log in as root.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1742"></a>4.2. Test the "more" script</h3></div></div></div><p>Display kernel messages by piping the output of
      <span class="command"><strong>dmesg</strong></span> to <span class="command"><strong>more</strong></span>.</p><pre class="programlisting"><code class="prompt">bash#</code> dmesg | more</pre><p>Examine the <code class="filename">local_fs</code> script by using
      <span class="command"><strong>more</strong></span> with a command-line argument.</p><pre class="programlisting"><code class="prompt">bash#</code> more /etc/init.d/local_fs</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1756"></a>4.3. Use ps to show running processes</h3></div></div></div><p>Display processes for the user currently logged in.</p><pre class="programlisting"><code class="prompt">bash#</code> ps</pre><p>Display all available information about all running
      processes.</p><pre class="programlisting"><code class="prompt">bash#</code> ps -ef</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1766"></a>4.4. Run a simple sed script</h3></div></div></div><p>Use <span class="command"><strong>sed</strong></span> to display an alternate version of
      <code class="filename">/etc/passwd</code>.</p><pre class="programlisting"><code class="prompt">bash#</code> sed -e "s/Legacy/Old School/" /etc/passwd</pre><p>Verify that sed did not make the changes permanent.</p><pre class="programlisting"><code class="prompt">bash#</code> cat /etc/passwd</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1778"></a>4.5. Test the "ed" editor</h3></div></div></div><p>Use <span class="command"><strong>ed</strong></span> to change properties on the "daemon"
      user.</p><pre class="programlisting"><code class="prompt">bash#</code> ed -p*
<code class="prompt">ed*</code> r /etc/passwd
<code class="prompt">ed*</code> %p
<code class="prompt">ed*</code> /daemon/s/Legacy/Old School/
<code class="prompt">ed*</code> %p
<code class="prompt">ed*</code> w
<code class="prompt">ed*</code> q</pre><p>Verify that the changes are permanent (at least until the system
      is restarted.)</p><pre class="programlisting"><code class="prompt">bash#</code> cat /etc/passwd</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1795"></a>4.6. System shutdown</h3></div></div></div><p>Bring the system down gracefully with the
      <span class="command"><strong>shutdown</strong></span> command.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="wrap-up"></a>Chapter 9. Project Wrap Up</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1801">1. Celebrating Accomplishments</a></span></dt><dt><span class="sect1"><a href="#idm1815">2. Planning Next Steps</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1801"></a>1. Celebrating Accomplishments</h2></div></div></div><p>As the Pocket Linux Project draws to a close we should take a moment
    to celebrate all of our accomplishments. Some of the highlights are listed
    below:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>We have built a system, from source code only, that fully
        implements all of the commands described in the Filesystem Hierarchy
        Standard requirements for a root filesystem.</p></li><li class="listitem"><p>We have learned how to use Internet resources to locate and
        download the source code needed to build a GNU/Linux system.</p></li><li class="listitem"><p>We have written basic system startup and shutdown scripts and
        configured them to execute in the proper runlevels.</p></li><li class="listitem"><p>We have included support for multiple users on virtual consoles
        and implemented permissions on system files.</p></li><li class="listitem"><p>But most importantly, we have learned some good design
        techniques and project management skills that will enable us to tackle
        any future projects with ease and confidence.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1815"></a>2. Planning Next Steps</h2></div></div></div><p>The Pocket Linux system is nearly overflowing, so there really is no
    more room to expand the current root diskette to support any additional
    commands and features. This leaves us with a few choices of where to go
    next. We can:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Find a way to expand the current system just enough to host a
        small application. (For more information about hosting applications
        with Pocket Linux, see Appendix A)</p></li><li class="listitem"><p>Remove multi-user capability and some of the less often used
        commands from the root disk, replacing them with utilities like tar
        and gzip that would be useful for a rescue/restore diskset.</p></li><li class="listitem"><p>Use the techniques we have learned to design and build an entire
        GNU/Linux system and install it on a more spacious hard disk
        partition. (For more infomation about building a larger system, check
        out the GNU/Linux System Architect Toolkit at: <a class="ulink" href="http://architect.sourceforge.net/" target="_top">http://architect.sourceforge.net/</a>.)</p></li></ul></div><p>Which ever path is chosen, we can move forward confidently, armed
    with the knowledge we need to be successful in our endeavors.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="a"></a>Appendix A. Hosting Applications</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm1829">1. Analysis</a></span></dt><dt><span class="sect1"><a href="#idm1841">2. Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1843">2.1. Support for audio hardware</a></span></dt><dt><span class="sect2"><a href="#idm1857">2.2. Creating space for the program</a></span></dt><dt><span class="sect2"><a href="#idm1909">2.3. Accessing audio files</a></span></dt><dt><span class="sect2"><a href="#idm1920">2.4. Other required files</a></span></dt><dt><span class="sect2"><a href="#idm1933">2.5. Summary of tasks</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm1950">3. Construction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm1952">3.1. Create an enhanced boot disk</a></span></dt><dt><span class="sect2"><a href="#idm1987">3.2. Create an enhanced root disk</a></span></dt><dt><span class="sect2"><a href="#idm2025">3.3. Create a compressed /usr disk for mp3blaster</a></span></dt><dt><span class="sect2"><a href="#idm2053">3.4. Create a data diskette for testing</a></span></dt></dl></dd><dt><span class="sect1"><a href="#idm2058">4. Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm2060">4.1. System Startup</a></span></dt><dt><span class="sect2"><a href="#idm2072">4.2. Verify that the /usr diskette loaded properly</a></span></dt><dt><span class="sect2"><a href="#idm2076">4.3. Check the audio device initialization</a></span></dt><dt><span class="sect2"><a href="#idm2083">4.4. Test audio output</a></span></dt><dt><span class="sect2"><a href="#idm2088">4.5. Play a sample file</a></span></dt><dt><span class="sect2"><a href="#idm2095">4.6. System shutdown</a></span></dt></dl></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1829"></a>1. Analysis</h2></div></div></div><p>An operating system by itself is not much fun. What makes an OS
    great is the applications that can be run on top of it. Unfortunately,
    Pocket Linux currently does not have much room for anything other than
    system programs. Still, it would be nice to expand the system just enough
    to host some cool applications. Obviously a full-blown X-Windows GUI is
    out of the question, but running a small console based program should be
    within our reach.</p><p>Rather than doing a typical "hello world" program as an example,
    application hosting will be demonstrated using a console based audio
    player called mp3blaster. Building mp3blaster offers more technical
    challenge than "hello world" and the finished product should be a lot more
    fun. However, it should not be construed that a console-based jukebox is
    the only application for Pocket Linux. On the contrary, after completing
    this phase the reader should have the knowledge and tools to build almost
    any console-based program he or she desires.</p><p>So what will it take to turn a pocket-sized GNU/Linux system into a
    pocket-sized mp3 player? A few things are listed below.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Add support for audio hardware.</p></li><li class="listitem"><p>Create space for the mp3blaster program.</p></li><li class="listitem"><p>Provide a convenient way to access audio files.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1841"></a>2. Design</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1843"></a>2.1. Support for audio hardware</h3></div></div></div><p>There is a vast proliferation of audio hardware on the market and
      each sound card has its own particular configuration. For details on how
      to set up a particular sound card we can turn to the Sound-HOWTO
      available from <a class="ulink" href="http://www.tldp.org" target="_top">The Linux Documentation
      Project</a>. In a broader sense, however, we can treat a sound card
      like any other piece of new hardware. To add new hardware to a GNU/Linux
      system we will need configure the kernel to recognize it and configure
      <code class="filename">/dev</code> files on the root disk to access it.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1848"></a>2.1.1. Kernel support for audio</h4></div></div></div><p>In order to support sound cards, a new kernel will have to be
        built. It is very important that audio hardware support be configured
        as built-in, because Pocket Linux is not set up to handle kernel
        modules.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1851"></a>2.1.2. Root disk support for audio</h4></div></div></div><p>Searching <code class="filename">devices.txt</code> for the keyword
        "sound" will list quite a few possible audio devices, but usually only
        <code class="filename">/dev/dsp</code> and <code class="filename">/dev/mixer</code> are
        required to get sound from a PC. These two files control the digital
        audio output and mixer controls, respectively.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1857"></a>2.2. Creating space for the program</h3></div></div></div><p>Probably the easiest way to create more space for the mp3blaster
      program is to mount an additional storage device. There are several
      choices for mount points. So far <code class="filename">/usr</code>,
      <code class="filename">/home</code> and <code class="filename">/opt</code> are all empty
      directories and any one of them could be used to mount a floppy, CD-ROM
      or additional compressed ramdisk image. The <code class="filename">/usr</code>
      directory is a logical choice for a place to put an application, but
      what about the choice of media? Mp3blaster and its required libraries
      are too big to fit on a 1.44M floppy and burning a CD-ROM seems like a
      lot of work for one little program. So given these constraints, the best
      choice would be to put the program on a compressed floppy.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1864"></a>2.2.1. Mounting additional compressed floppies</h4></div></div></div><p>Mounting CDs and uncompressed diskettes is easy, but what about
        loading compressed images from floppy into ramdisk? It will have to be
        done manually, because automatic mounting of compressed floppies only
        works for the root diskette. And using <span class="command"><strong>mount
        /dev/fd0</strong></span> will not work because there is no filesystem on the
        diskette, there are only the contents of a gzip file. The actual
        filesystem is contained inside the gzip file. So how can we mount the
        filesystem buried beneath the gzip file? This puzzle can be solved by
        examining at the steps used to create the familiar compressed root
        disk floppy.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A ramdisk is created, mounted and filled with files.</p></li><li class="listitem"><p>The ramdisk device is unmounted.</p></li><li class="listitem"><p>The contents of the ramdisk are dumped to an image file
            using <span class="command"><strong>dd</strong></span>.</p></li><li class="listitem"><p>The image file is compressed with
            <span class="command"><strong>gzip</strong></span>.</p></li><li class="listitem"><p>The compressed image file is written to floppy with
            <span class="command"><strong>dd</strong></span>.</p></li></ol></div><p>If that is how the compressed image makes its way from ramdisk
        to compressed floppy, then going from compressed floppy to ramdisk
        should be as simple as running through the steps in reverse.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The compressed image file is read from floppy with
            <span class="command"><strong>dd</strong></span>.</p></li><li class="listitem"><p>The image file is uncompressed with
            <span class="command"><strong>gunzip</strong></span>.</p></li><li class="listitem"><p>The contents of the image file are dumped into ramdisk using
            <span class="command"><strong>dd</strong></span>.</p></li><li class="listitem"><p>The ramdisk device is mounted.</p></li><li class="listitem"><p>The files are available.</p></li></ol></div><p>We can cut out the intermediate image file by using a pipe to
        combine <span class="command"><strong>dd</strong></span> and <span class="command"><strong>gunzip</strong></span> like this:
        <span class="command"><strong>dd if=/dev/fd0 | gunzip -cq &gt; /dev/ram1</strong></span>. Now the
        compressed floppy goes straight into ramdisk, decompressing on the
        fly.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1901"></a>2.2.2. Root disk support for additional ramdisks</h4></div></div></div><p>We already have kernel support for ramdisks, because we are
        using a compressed root disk, but we will need to create more ramdisks
        in <code class="filename">/dev</code>. Typically the kernel supports eight
        ramdisks on <code class="filename">/dev/ram0</code> through
        <code class="filename">/dev/ram7</code> with <code class="filename">ram0</code> being
        used for the rootdisk. The <code class="filename">devices.txt</code> file
        included in the Linux source code documentation will be helpful for
        matching devices to their major and minor numbers.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1909"></a>2.3. Accessing audio files</h3></div></div></div><p>The sample mp3 file that we will be using in our example is small
      enough to fit on an uncompressed floppy disk so that there is no need to
      burn a CD. However, serious music lovers may want to have the capability
      to mount a custom CD-ROM full of tunes and that option will require
      support for additional hardware.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1912"></a>2.3.1. CD-ROM hardware support</h4></div></div></div><p>Most modern CD-ROM drives will use IDE devices like
        <code class="filename">/dev/hdc</code> or <code class="filename">/dev/hdd</code>. To
        support these CD-ROM drives we will have to configure IDE support in
        the kernel and create the appropriate device files on the root
        disk.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1917"></a>2.3.2. CD-ROM filesystem support</h4></div></div></div><p>CD-ROMs have different filesystems than hard disks and floppies.
        Most CD burning applications use a filesystem called ISO-9660 and have
        the capability to support Joliet or Rockridge extensions. We will have
        to include support for these filesystems in the kernel in order to
        mount CD-ROMs.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1920"></a>2.4. Other required files</h3></div></div></div><p>We will want to have all of mp3blaster's required libraries and
      other supporting files available as part of the compressed
      <code class="filename">/usr</code> image so that mp3blaster can run correctly.
      The familiar <span class="command"><strong>ldd</strong></span> command can be used to determine
      which libraries mp3blaster requires. Any additional libraries can be
      placed in <code class="filename">/usr/lib</code>. Even though some of the
      libraries may appear in <code class="filename">/lib</code> on the development
      system, they can still go in <code class="filename">/usr/lib</code> on the Pocket
      Linux system. The dynamic linker, <code class="filename">ld-linux.so</code>, is
      smart enough to look in both places when loading libraries.</p><p>Because mp3blaster uses the curses (or ncurses) screen control
      library there is one additional file we need. The curses library needs
      to know the characteristics of the terminal it is controlling and it
      gets that information from the terminfo database. The terminfo database
      consists of all the files under the
      <code class="filename">/usr/share/terminfo</code> directory and is very large
      compared to our available disk space. But, since Pocket Linux only
      supports the PC console, we only have one terminal type to worry about
      and therefore need only one file. The piece of the terminfo database we
      need is the file <code class="filename">/usr/share/terminfo/l/linux</code>,
      because we are using a "Linux" terminal. For more information about the
      subject of curses, see John Strang's book entitled "Programming with
      Curses" available from <a class="ulink" href="http://www.oreilly.com" target="_top">O'Reilly
      publishing</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1933"></a>2.5. Summary of tasks</h3></div></div></div><p>Between sound cards, ramdisks, CD-ROMs and terminfo there is quite
      a bit to keep track of. So let's take a moment to organize and summarize
      the tasks necessary to make the pocket jukebox a reality.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Create a new kernel disk that includes built-in support for
          audio hardware, IDE devices and CD-ROM filesystems.</p></li><li class="listitem"><p>Create the appropriate <code class="filename">/dev</code> files on the
          root disk to support audio hardware, additional ramdisks and IDE
          CD-ROMs.</p></li><li class="listitem"><p>Install the <span class="command"><strong>gunzip</strong></span> utility to enable
          decompression of the usr image.</p></li><li class="listitem"><p>Create a startup script to load a compressed image from floppy
          into a ramdisk and mount the ramdisk on
          <code class="filename">/usr</code>.</p></li><li class="listitem"><p>Create a compressed floppy that holds the mp3blaster program,
          its required libraries and terminfo files.</p></li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm1950"></a>3. Construction</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1952"></a>3.1. Create an enhanced boot disk</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1954"></a>3.1.1. Build a new kernel</h4></div></div></div><pre class="programlisting">bash# cd /usr/src/linux
bash# make menuconfig</pre><p>Be sure to configure support for the following:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>386 processor</p></li><li class="listitem"><p>Floppy disk</p></li><li class="listitem"><p>RAM disk</p></li><li class="listitem"><p>Second extended (ext2) filesystem</p></li><li class="listitem"><p>Virtual console</p></li><li class="listitem"><p>Audio hardware</p></li><li class="listitem"><p>CD-ROM hardware</p></li><li class="listitem"><p>ISO-9660 and Joliet filesystems</p></li></ul></div><pre class="programlisting">bash# make dep
bash# make clean
bash# make bzImage</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1978"></a>3.1.2. Copy the kernel to diskette</h4></div></div></div><p>Place the boot disk in drive fd0</p><pre class="programlisting">bash# mount /dev/fd0 /mnt
bash# cp /usr/src/linux/arch/i386/boot/bzImage /mnt/boot/vmlinuz</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1983"></a>3.1.3. Unmount the boot disk</h4></div></div></div><pre class="programlisting">bash# cd /
bash# umount /mnt</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm1987"></a>3.2. Create an enhanced root disk</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm1989"></a>3.2.1. Create additional device files</h4></div></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="idm1991"></a>3.2.1.1. IDE CD-ROM</h5></div></div></div><pre class="programlisting">bash# mknod -m640 ~/staging/dev/hdc b 22 0
bash# mknod -m640 ~/staging/dev/hdd b 22 64</pre><p>Optionally create additional IDE devices.</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="idm1996"></a>3.2.1.2. Ramdisk</h5></div></div></div><pre class="programlisting">bash# mknod -m 640 ~/staging/dev/ram1 b 1 1
bash# mknod -m 640 ~/staging/dev/ram2 b 1 2 
bash# mknod -m 640 ~/staging/dev/ram3 b 1 3
bash# mknod -m 640 ~/staging/dev/ram4 b 1 4
bash# mknod -m 640 ~/staging/dev/ram5 b 1 5
bash# mknod -m 640 ~/staging/dev/ram6 b 1 6
bash# mknod -m 640 ~/staging/dev/ram7 b 1 7</pre></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="idm2000"></a>3.2.1.3. Audio</h5></div></div></div><pre class="programlisting">bash# mknod -m664 ~/staging/dev/dsp c 14 3
bash# mknod -m664 ~/staging/dev/mixer c 14 0</pre></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2004"></a>3.2.2. Install the gunzip binary</h4></div></div></div><pre class="programlisting">bash# cd /usr/src/gzip-1.2.4a
bash# export CC="gcc -mcpu=i386"
bash# ./configure --host=i386-pc-linux-gnu
bash# make
bash# strip gzip
bash# cp gzip ~/staging/bin
bash# ln -s gzip ~/staging/bin/gunzip</pre><p>Don't forget to verify library requirements, check the ownership
        and check permissions on the gzip binary.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2009"></a>3.2.3. Write a startup script to mount a compressed floppy</h4></div></div></div><p>Use a text editor to create the following script and save it as
        <code class="filename">~/staging/etc/init.d/usr_image</code></p><pre class="programlisting">#!/bin/sh
#
# usr_image - load compressed images from floppy into ramdisk and
#             mount on /usr.
#
echo -n "Is there a compressed diskette to load for /usr [y/N]? "
read REPLY
if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ]; then
  echo -n "Please insert the /usr floppy into fd0 and press &lt;ENTER&gt;."
  read REPLY
  echo "Clearing /dev/ram1."
  dd if=/dev/zero of=/dev/ram1 bs=1k count=4096
  echo "Loading compressed image from /dev/fd0 into /dev/ram1..."
  (dd if=/dev/fd0 bs=1k | gunzip -cq) &gt;/dev/ram1 2&gt;/dev/null
  fsck -fp /dev/ram1
  if [ $? -gt 1 ]; then
    echo "Filesystem errors on /dev/ram1!  Manual intervention required."
  else
    echo "Mounting /usr."
    mount /dev/ram1 /usr
  fi
fi
#
# end of usr_image</pre><p>Configure the script to run right after root is mounted.</p><pre class="programlisting">bash# ln -s ../init.d/usr_image ~/staging/etc/rcS.d/S21usr_image</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2018"></a>3.2.4. Create a compressed root disk</h4></div></div></div><pre class="programlisting">bash# cd /
bash# dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
bash# mke2fs -m0 /dev/ram7
bash# mount /dev/ram7 /mnt
bash# cp -dpR ~/staging/* /mnt
bash# umount /dev/ram7
bash# dd if=/dev/ram7 of=~/phase8-image bs=1k
bash# gzip -9 ~/phase8-image</pre><p>Insert the diskette labeled "root disk" into drive fd0.</p><pre class="programlisting">bash# dd if=~/phase8-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2025"></a>3.3. Create a compressed /usr disk for mp3blaster</h3></div></div></div><p>The compressed /usr diskette will be created in using the same
      process that is used to create the compressed root disk. We will copy
      files to a staging area, copy the staging area to ramdisk, compress the
      ramdisk and write it to diskette.</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2028"></a>3.3.1. Create a staging area</h4></div></div></div><pre class="programlisting">bash# mkdir ~/usr-staging
bash# cd ~/usr-staging
bash# mkdir bin lib
bash# mkdir -p share/terminfo/l</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2032"></a>3.3.2. Install the mp3blaster program</h4></div></div></div><p>Download the latest version of mp3blaster source code from its
        home at <a class="ulink" href="http://www.stack.nl/~brama/mp3blaster/" target="_top">http://www.stack.nl/~brama/mp3blaster/</a>.</p><pre class="programlisting">bash# cd ~/usr/src/mp3blaster-3.2.0
bash# ./configure
bash# make
bash# cp src/mp3blaster ~/usr-staging/bin</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2038"></a>3.3.3. Copy additional libraries and terminfo</h4></div></div></div><p>Use <span class="command"><strong>ldd</strong></span> to find out which libraries are
        needed for mp3blaster.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The following is an example from the author's development
          system. It is possible that different systems may yield slightly
          different results in terms of library requirements.</p></div><pre class="programlisting">bash# cd ~/usr-staging/lib
bash# ldd ~/usr-staging/bin/mp3blaster
bash# cp /usr/lib/ncurses.so.5.0  .
bash# cp /usr/lib/stdc++.so.3 .
bash# cp /lib/libm.so.6 .
bash# cp /usr/lib/libgcc_s.so.1 .
bash# cd ~/usr-staging/share/terminfo/l
bash# cp /usr/share/terminfo/l/linux .</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="idm2046"></a>3.3.4. Make a compressed image and copy it to diskette</h4></div></div></div><pre class="programlisting">bash# cd /
bash# dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
bash# mke2fs -m0 /dev/ram7
bash# mount /dev/ram7 /mnt
bash# cp -dpR ~/usr-staging/* /mnt
bash# umount /dev/ram7
bash# dd if=/dev/ram7 of=~/mp3blaster-image bs=1k
bash# gzip -9 ~/mp3blaster-image</pre><p>Insert the diskette labeled "mp3blaster" into drive fd0.</p><pre class="programlisting">bash# dd if=~/mp3blaster-image.gz of=/dev/fd0 bs=1k</pre></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2053"></a>3.4. Create a data diskette for testing</h3></div></div></div><p>Go to the Internet site <a class="ulink" href="http://www.paul.sladen.org" target="_top">http://www.paul.sladen.org</a> and
      download the mp3 file of Linus Torvalds pronouncing "Linux." The direct
      link is: <a class="ulink" href="http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3" target="_top">http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3</a>.
      Create a Second Extended (ext2) filesystem on a floppy and copy the mp3
      file onto the diskette.</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm2058"></a>4. Implementation</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2060"></a>4.1. System Startup</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Boot from the kernel diskette.</p></li><li class="listitem"><p>Insert the root floppy when prompted.</p></li><li class="listitem"><p>When prompted for a /usr diskette, say 'Y'.</p></li><li class="listitem"><p>Insert the mp3blaster diskette and press
          <span class="keycap"><strong>Enter</strong></span>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2072"></a>4.2. Verify that the /usr diskette loaded properly</h3></div></div></div><pre class="programlisting">bash# mount
bash# ls -lR /usr</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2076"></a>4.3. Check the audio device initialization</h3></div></div></div><pre class="programlisting">bash# dmesg | more</pre><p>If everything worked there should be a line or two indicating that
      the kernel found the audio hardware. The example below shows how the
      kernel might report a Yamaha integrated sound system.</p><pre class="screen">ymfpci: YMF740C at 0xf4000000 IRQ 10
ac97_codec: AC97 Audio codec, id: 0x4144:0x5303 (Analog Devices AD1819)
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2083"></a>4.4. Test audio output</h3></div></div></div><pre class="programlisting">bash# echo "Garbage" &gt; /dev/dsp</pre><p>A short burst of static coming from the PC speakers indicates that
      sound is working.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2088"></a>4.5. Play a sample file</h3></div></div></div><p>Insert the diskette containing the sample audio file.</p><pre class="programlisting">mount /dev/fd0 /home
bash# /usr/bin/mp3blaster</pre><p>Use mp3blaster to select and play the file
      <code class="filename">/home/torvalds-says-linux.mp3</code>. Use mp3blaster's
      mixer controls to adjust the volume as needed.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="idm2095"></a>4.6. System shutdown</h3></div></div></div><p>Bring the system down gracefully with the
      <span class="command"><strong>shutdown</strong></span> command.</p></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="gfdl"></a>Appendix B. GNU Free Documentation License</h1></div><div><h3 class="subtitle"><i>Version 1.2, November 2002</i></h3></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#gfdl-0">1. PREAMBLE</a></span></dt><dt><span class="section"><a href="#gfdl-1">2. APPLICABILITY AND DEFINITIONS</a></span></dt><dt><span class="section"><a href="#gfdl-2">3. VERBATIM COPYING</a></span></dt><dt><span class="section"><a href="#gfdl-3">4. COPYING IN QUANTITY</a></span></dt><dt><span class="section"><a href="#gfdl-4">5. MODIFICATIONS</a></span></dt><dt><span class="section"><a href="#gfdl-5">6. COMBINING DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-6">7. COLLECTIONS OF DOCUMENTS</a></span></dt><dt><span class="section"><a href="#gfdl-7">8. AGGREGATION WITH INDEPENDENT WORKS</a></span></dt><dt><span class="section"><a href="#gfdl-8">9. TRANSLATION</a></span></dt><dt><span class="section"><a href="#gfdl-9">10. TERMINATION</a></span></dt><dt><span class="section"><a href="#gfdl-10">11. FUTURE REVISIONS OF THIS LICENSE</a></span></dt><dt><span class="section"><a href="#gfdl-addendum">12. ADDENDUM: How to use this License for your documents</a></span></dt></dl></div><div class="blockquote"><a name="fsf-copyright"></a><blockquote class="blockquote"><p>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 59
    Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is permitted
    to copy and distribute verbatim copies of this license document, but
    changing it is not allowed.</p></blockquote></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-0"></a>1. PREAMBLE</h2></div></div></div><p>The purpose of this License is to make a manual, textbook, or other
    functional and useful document "free" in the sense of freedom: to assure
    everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially. Secondarily,
    this License preserves for the author and publisher a way to get credit
    for their work, while not being considered responsible for modifications
    made by others.</p><p>This License is a kind of "copyleft", which means that derivative
    works of the document must themselves be free in the same sense. It
    complements the GNU General Public License, which is a copyleft license
    designed for free software.</p><p>We have designed this License in order to use it for manuals for
    free software, because free software needs free documentation: a free
    program should come with manuals providing the same freedoms that the
    software does. But this License is not limited to software manuals; it can
    be used for any textual work, regardless of subject matter or whether it
    is published as a printed book. We recommend this License principally for
    works whose purpose is instruction or reference.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-1"></a>2. APPLICABILITY AND DEFINITIONS</h2></div></div></div><p><a name="gfdl-doc"></a>This License applies to any manual or other work, in
    any medium, that contains a notice placed by the copyright holder saying
    it can be distributed under the terms of this License. Such a notice
    grants a world-wide, royalty-free license, unlimited in duration, to use
    that work under the conditions stated herein. The "Document", below,
    refers to any such manual or work. Any member of the public is a licensee,
    and is addressed as "you". You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright
    law.</p><p><a name="gfdl-mod-ver"></a>A "Modified Version" of the Document means any
    work containing the Document or a portion of it, either copied verbatim,
    or with modifications and/or translated into another language.</p><p><a name="gfdl-secnd-sect"></a>A "Secondary Section" is a named appendix or a
    front-matter section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains nothing
    that could fall directly within that overall subject. (Thus, if the
    Document is in part a textbook of mathematics, a Secondary Section may not
    explain any mathematics.) The relationship could be a matter of historical
    connection with the subject or with related matters, or of legal,
    commercial, philosophical, ethical or political position regarding
    them.</p><p><a name="gfdl-inv-sect"></a>The "Invariant Sections" are certain Secondary
    Sections whose titles are designated, as being those of Invariant
    Sections, in the notice that says that the Document is released under this
    License. If a section does not fit the above definition of Secondary then
    it is not allowed to be designated as Invariant. The Document may contain
    zero Invariant Sections. If the Document does not identify any Invariant
    Sections then there are none.</p><p><a name="gfdl-cov-text"></a>The "Cover Texts" are certain short passages of
    text that are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this License. A
    Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at
    most 25 words.</p><p><a name="gfdl-transparent"></a>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification is
    available to the general public, that is suitable for revising the
    document straightforwardly with generic text editors or (for images
    composed of pixels) generic paint programs or (for drawings) some widely
    available drawing editor, and that is suitable for input to text
    formatters or for automatic translation to a variety of formats suitable
    for input to text formatters. A copy made in an otherwise Transparent file
    format whose markup, or absence of markup, has been arranged to thwart or
    discourage subsequent modification by readers is not Transparent. An image
    format is not Transparent if used for any substantial amount of text. A
    copy that is not "Transparent" is called "Opaque".</p><p>Examples of suitable formats for Transparent copies include plain
    ASCII without markup, Texinfo input format, LaTeX input format, SGML or
    XML using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification. Examples of transparent
    image formats include PNG, XCF and JPG. Opaque formats include proprietary
    formats that can be read and edited only by proprietary word processors,
    SGML or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML, PostScript or PDF produced by
    some word processors for output purposes only.</p><p><a name="gfdl-title-page"></a>The "Title Page" means, for a printed book, the
    title page itself, plus such following pages as are needed to hold,
    legibly, the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such, "Title
    Page" means the text near the most prominent appearance of the work's
    title, preceding the beginning of the body of the text.</p><p><a name="gfdl-entitled"></a>A section "Entitled XYZ" means a named subunit of
    the Document whose title either is precisely XYZ or contains XYZ in
    parentheses following text that translates XYZ in another language. (Here
    XYZ stands for a specific section name mentioned below, such as
    "Acknowledgements", "Dedications", "Endorsements", or "History".) To
    "Preserve the Title" of such a section when you modify the Document means
    that it remains a section "Entitled XYZ" according to this
    definition.</p><p>The Document may include Warranty Disclaimers next to the notice
    which states that this License applies to the Document. These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-2"></a>3. VERBATIM COPYING</h2></div></div></div><p>You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the copyright
    notices, and the license notice saying this License applies to the
    Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License. You may not use technical
    measures to obstruct or control the reading or further copying of the
    copies you make or distribute. However, you may accept compensation in
    exchange for copies. If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</p><p>You may also lend copies, under the same conditions stated above,
    and you may publicly display copies.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-3"></a>4. COPYING IN QUANTITY</h2></div></div></div><p>If you publish printed copies (or copies in media that commonly have
    printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover. Both covers must also clearly and legibly identify you as the
    publisher of these copies. The front cover must present the full title
    with all words of the title equally prominent and visible. You may add
    other material on the covers in addition. Copying with changes limited to
    the covers, as long as they preserve the title of the Document and satisfy
    these conditions, can be treated as verbatim copying in other
    respects.</p><p>If the required texts for either cover are too voluminous to fit
    legibly, you should put the first ones listed (as many as fit reasonably)
    on the actual cover, and continue the rest onto adjacent pages.</p><p>If you publish or distribute Opaque copies of the Document numbering
    more than 100, you must either include a machine-readable Transparent copy
    along with each Opaque copy, or state in or with each Opaque copy a
    computer-network location from which the general network-using public has
    access to download using public-standard network protocols a complete
    Transparent copy of the Document, free of added material. If you use the
    latter option, you must take reasonably prudent steps, when you begin
    distribution of Opaque copies in quantity, to ensure that this Transparent
    copy will remain thus accessible at the stated location until at least one
    year after the last time you distribute an Opaque copy (directly or
    through your agents or retailers) of that edition to the public.</p><p>It is requested, but not required, that you contact the authors of
    the Document well before redistributing any large number of copies, to
    give them a chance to provide you with an updated version of the
    Document.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-4"></a>5. MODIFICATIONS</h2></div></div></div><p>You may copy and distribute a Modified Version of the Document under
    the conditions of sections 2 and 3 above, provided that you release the
    Modified Version under precisely this License, with the Modified Version
    filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it. In
    addition, you must do these things in the Modified Version:</p><div class="orderedlist"><a name="gfdl-modif-cond"></a><ol class="orderedlist" type="A"><li class="listitem">Use in the Title Page (and on the covers, if any) a title
        distinct from that of the Document, and from those of previous
        versions (which should, if there were any, be listed in the History
        section of the Document). You may use the same title as a previous
        version if the original publisher of that version gives
        permission.</li><li class="listitem">List on the Title Page, as authors, one or more persons or
        entities responsible for authorship of the modifications in the
        Modified Version, together with at least five of the principal authors
        of the Document (all of its principal authors, if it has fewer than
        five), unless they release you from this requirement.</li><li class="listitem">State on the Title page the name of the publisher of the
        Modified Version, as the publisher.</li><li class="listitem">Preserve all the copyright notices of the Document.</li><li class="listitem">Add an appropriate copyright notice for your modifications
        adjacent to the other copyright notices.</li><li class="listitem">Include, immediately after the copyright notices, a license
        notice giving the public permission to use the Modified Version under
        the terms of this License, in the form shown in the <a class="link" href="#gfdl-addendum" title="12. ADDENDUM: How to use this License for your documents">Addendum</a> below.</li><li class="listitem">Preserve in that license notice the full lists of Invariant
        Sections and required Cover Texts given in the Document's license
        notice.</li><li class="listitem">Include an unaltered copy of this License.</li><li class="listitem">Preserve the section Entitled "History", Preserve its Title,
        and add to it an item stating at least the title, year, new authors,
        and publisher of the Modified Version as given on the Title Page. If
        there is no section Entitled "History" in the Document, create one
        stating the title, year, authors, and publisher of the Document as
        given on its Title Page, then add an item describing the Modified
        Version as stated in the previous sentence.</li><li class="listitem">Preserve the network location, if any, given in the Document
        for public access to a Transparent copy of the Document, and likewise
        the network locations given in the Document for previous versions it
        was based on. These may be placed in the "History" section. You may
        omit a network location for a work that was published at least four
        years before the Document itself, or if the original publisher of the
        version it refers to gives permission.</li><li class="listitem">For any section Entitled "Acknowledgements" or "Dedications",
        Preserve the Title of the section, and preserve in the section all the
        substance and tone of each of the contributor acknowledgements and/or
        dedications given therein.</li><li class="listitem">Preserve all the Invariant Sections of the Document,
        unaltered in their text and in their titles. Section numbers or the
        equivalent are not considered part of the section titles.</li><li class="listitem">Delete any section Entitled "Endorsements". Such a section
        may not be included in the Modified Version.</li><li class="listitem">Do not retitle any existing section to be Entitled
        "Endorsements" or to conflict in title with any Invariant
        Section.</li><li class="listitem">Preserve any Warranty Disclaimers.</li></ol></div><p>If the Modified Version includes new front-matter sections or
    appendices that qualify as Secondary Sections and contain no material
    copied from the Document, you may at your option designate some or all of
    these sections as invariant. To do this, add their titles to the list of
    Invariant Sections in the Modified Version's license notice. These titles
    must be distinct from any other section titles.</p><p>You may add a section Entitled "Endorsements", provided it contains
    nothing but endorsements of your Modified Version by various parties--for
    example, statements of peer review or that the text has been approved by
    an organization as the authoritative definition of a standard.</p><p>You may add a passage of up to five words as a Front-Cover Text, and
    a passage of up to 25 words as a Back-Cover Text, to the end of the list
    of Cover Texts in the Modified Version. Only one passage of Front-Cover
    Text and one of Back-Cover Text may be added by (or through arrangements
    made by) any one entity. If the Document already includes a cover text for
    the same cover, previously added by you or by arrangement made by the same
    entity you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous publisher
    that added the old one.</p><p>The author(s) and publisher(s) of the Document do not by this
    License give permission to use their names for publicity for or to assert
    or imply endorsement of any Modified Version.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-5"></a>6. COMBINING DOCUMENTS</h2></div></div></div><p>You may combine the Document with other documents released under
    this License, under the terms defined in <a class="link" href="#gfdl-4" title="5. MODIFICATIONS">section
    4</a> above for modified versions, provided that you include in the
    combination all of the Invariant Sections of all of the original
    documents, unmodified, and list them all as Invariant Sections of your
    combined work in its license notice, and that you preserve all their
    Warranty Disclaimers.</p><p>The combined work need only contain one copy of this License, and
    multiple identical Invariant Sections may be replaced with a single copy.
    If there are multiple Invariant Sections with the same name but different
    contents, make the title of each such section unique by adding at the end
    of it, in parentheses, the name of the original author or publisher of
    that section if known, or else a unique number. Make the same adjustment
    to the section titles in the list of Invariant Sections in the license
    notice of the combined work.</p><p>In the combination, you must combine any sections Entitled "History"
    in the various original documents, forming one section Entitled "History";
    likewise combine any sections Entitled "Acknowledgements", and any
    sections Entitled "Dedications". You must delete all sections Entitled
    "Endorsements".</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-6"></a>7. COLLECTIONS OF DOCUMENTS</h2></div></div></div><p>You may make a collection consisting of the Document and other
    documents released under this License, and replace the individual copies
    of this License in the various documents with a single copy that is
    included in the collection, provided that you follow the rules of this
    License for verbatim copying of each of the documents in all other
    respects.</p><p>You may extract a single document from such a collection, and
    distribute it individually under this License, provided you insert a copy
    of this License into the extracted document, and follow this License in
    all other respects regarding verbatim copying of that document.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-7"></a>8. AGGREGATION WITH INDEPENDENT WORKS</h2></div></div></div><p>A compilation of the Document or its derivatives with other separate
    and independent documents or works, in or on a volume of a storage or
    distribution medium, is called an "aggregate" if the copyright resulting
    from the compilation is not used to limit the legal rights of the
    compilation's users beyond what the individual works permit. When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.</p><p>If the Cover Text requirement of section 3 is applicable to these
    copies of the Document, then if the Document is less than one half of the
    entire aggregate, the Document's Cover Texts may be placed on covers that
    bracket the Document within the aggregate, or the electronic equivalent of
    covers if the Document is in electronic form. Otherwise they must appear
    on printed covers that bracket the whole aggregate.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-8"></a>9. TRANSLATION</h2></div></div></div><p>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section 4.
    Replacing Invariant Sections with translations requires special permission
    from their copyright holders, but you may include translations of some or
    all Invariant Sections in addition to the original versions of these
    Invariant Sections. You may include a translation of this License, and all
    the license notices in the Document, and any Warranty Disclaimers,
    provided that you also include the original English version of this
    License and the original versions of those notices and disclaimers. In
    case of a disagreement between the translation and the original version of
    this License or a notice or disclaimer, the original version will
    prevail.</p><p>If a section in the Document is Entitled "Acknowledgements",
    "Dedications", or "History", the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual title.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-9"></a>10. TERMINATION</h2></div></div></div><p>You may not copy, modify, sublicense, or distribute the Document
    except as expressly provided for under this License. Any other attempt to
    copy, modify, sublicense or distribute the Document is void, and will
    automatically terminate your rights under this License. However, parties
    who have received copies, or rights, from you under this License will not
    have their licenses terminated so long as such parties remain in full
    compliance.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-10"></a>11. FUTURE REVISIONS OF THIS LICENSE</h2></div></div></div><p>The Free Software Foundation may publish new, revised versions of
    the GNU Free Documentation License from time to time. Such new versions
    will be similar in spirit to the present version, but may differ in detail
    to address new problems or concerns. See
    http://www.gnu.org/copyleft/.</p><p>Each version of the License is given a distinguishing version
    number. If the Document specifies that a particular numbered version of
    this License "or any later version" applies to it, you have the option of
    following the terms and conditions either of that specified version or of
    any later version that has been published (not as a draft) by the Free
    Software Foundation. If the Document does not specify a version number of
    this License, you may choose any version ever published (not as a draft)
    by the Free Software Foundation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="gfdl-addendum"></a>12. ADDENDUM: How to use this License for your documents</h2></div></div></div><p>To use this License in a document you have written, include a copy
    of the License in the document and put the following copyright and license
    notices just after the title page:</p><div class="blockquote"><a name="copyright-sample"></a><blockquote class="blockquote"><p>Copyright (c) YEAR YOUR NAME. Permission is granted to copy,
      distribute and/or modify this document under the terms of the GNU Free
      Documentation License, Version 1.2 or any later version published by the
      Free Software Foundation; with no Invariant Sections, no Front-Cover
      Texts, and no Back-Cover Texts. A copy of the license is included in the
      section entitled "GNU Free Documentation License".</p></blockquote></div><p>If you have Invariant Sections, Front-Cover Texts and Back-Cover
    Texts, replace the "with...Texts." line with this:</p><div class="blockquote"><a name="inv-cover-sample"></a><blockquote class="blockquote"><p>with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being
      LIST.</p></blockquote></div><p>If you have Invariant Sections without Cover Texts, or some other
    combination of the three, merge those two alternatives to suit the
    situation.</p><p>If your document contains nontrivial examples of program code, we
    recommend releasing these examples in parallel under your choice of free
    software license, such as the GNU General Public License, to permit their
    use in free software.</p></div></div></div></body></html>
