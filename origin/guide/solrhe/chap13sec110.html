<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2. Why choose tarballs?</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="RedHat, redhat, maddy, linus, linux, Linux, Securing, Optimising, security, secure, openna, gerhard"><link rel="home" href="index.html" title="Securing and Optimizing Linux"><link rel="up" href="lin-compiler.html" title="Chapter 13. Linux -The Compiler functionality"><link rel="prev" href="chap13sec109.html" title="1. The necessary packages"><link rel="next" href="chap13sec111.html" title="3. Build, Install software on your system"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Why choose <code class="literal">tarballs</code>?</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="chap13sec109.html">Prev</a> </td><th width="60%" align="center">Chapter 13. Linux -The Compiler functionality</th><td width="20%" align="right"> <a accesskey="n" href="chap13sec111.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm7103"></a>2. Why choose <code class="literal">tarballs</code>?</h2></div></div></div><p>
         All the programs in Red Hat distributions of Linux are provided as <acronym class="acronym">RPM</acronym> files. An <acronym class="acronym">RPM</acronym> file, also known, as a package, is a way of distributing software so that it can be easily installed, upgraded, queried, and deleted. 
         However, in Unix world, the defacto-standard for package distribution continues to be by way of so-called <code class="literal">tarballs</code>. Tarballs are simply compressed files that can be readable and uncompressed with the tar utility. Installing 
         from tar is usually significantly more tedious than using <acronym class="acronym">RPM</acronym>. So why would we choose to do so?
         </p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>
         Unfortunately, it takes a few weeks for developers and coders to get the latest version of a package converted to <acronym class="acronym">RPM</acronym>s because many developers first release them as <code class="literal">tarballs</code>.
         </p></li><li class="listitem"><p>
         When developers and vendors release a new <acronym class="acronym">RPM</acronym>, they include a lot of options that often are not necessary. Those organization and companies don't know what options you will need and what you will not, so they include the most used to fit the needs of everyone.
         </p></li><li class="listitem"><p>
         Often <acronym class="acronym">RPM</acronym>s are not optimized for your specific processors; companies like Red Hat Linux build <acronym class="acronym">RPM</acronym>s based on a standard PC. This permit their <acronym class="acronym">RPM</acronym> packages to be installed on all sorts of computers since compiling programs for an i386 machine can fit on all systems.
         </p></li><li class="listitem"><p>
         Sometimes you download and install <acronym class="acronym">RPM</acronym>, which other people around the world are building and make available for your purposes. This can pose conflicts in certain cases depending how this individual built the package, such as errors, security and all the other problems described above.
         </p></li></ol></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idm7127"></a>2.1. Compiling software on your system</h3></div></div></div><p>
         A program is something a computer can execute. Originally, somebody wrote the source code in a programming language he/she could understand <abbr class="abbrev">e.g.</abbr>, C, C++. The program source code also makes sense to a compiler that converts the instructions into a binary file suited to whatever processor is 
         wanted <abbr class="abbrev">e.g.</abbr> a 386 or similar. A modern file format for these executable programs is Elf. The programmer compiles his source using the compiler and gets a result of some sort. It's not at all uncommon that early attempts fail to compile, or having compiled, fail to act as expected. Half of programming 
         is tracking down and fixing these problems debugging.
         </p><p>
         For the beginners there are more aspect and new words relating to compilation of a source code that you must know, these includes but are not limited to:
         </p><div class="glosslist"><dl><dt><span class="glossterm">
         The Multiple Files
         </span></dt><dd class="glossdef"><p>
         One-file programs are quite rare. Usually there are a number of files say <code class="literal">*.c</code>, <code class="literal">*.cpp</code>, <abbr class="abbrev">etc.</abbr> that are each compiled into object files <code class="literal">*.o</code> and then linked into an executable. The compiler is usually used to perform the linking and calls the ld program behind the scenes.
         </p></dd><dt><span class="glossterm">
         The Makefiles
         </span></dt><dd class="glossdef"><p>
         The Makefiles are intended to aid you in building your program the same way each time. They also often help with speed. The make program uses dependencies in the Makefile to decide what parts of the program need to be recompiled. If you change one source file out of fifty 
         you hope to get away with one compile and one link step, instead of starting from scratch.
         </p></dd><dt><span class="glossterm">
         The Libraries
         </span></dt><dd class="glossdef"><p>
         Programs can be linked not only to object files <code class="literal">*.o</code> but also to libraries that are collections of object files. There are two forms of linking to libraries: 
         static, where the code goes in the executable file, and dynamic, where the code is collected when the program starts to run.
         </p></dd><dt><span class="glossterm">
         The Patches
         </span></dt><dd class="glossdef"><p>
         It was common before for executable files to be given corrections without recompiling them. Now this practice has died out; in modern days, people changes a small proportion of the whole source code, putting a change into a file called a patch. Where different versions of a 
         program are required, small changes to code can be released this way, saving the trouble of having two large distributions.
         </p></dd><dt><span class="glossterm">
         The Errors in Compilation and Linking
         </span></dt><dd class="glossdef"><p>
         Errors in compilation and linking are often typos, omissions, and misuse of the language. Check that the right includes files are used for the functions you are calling. Unreferenced symbols are the sign of an incomplete link step. Also checks if the necessary development 
         libraries GLIBC or tools GCC, DEV86, AUTOMAKE, <abbr class="abbrev">etc.</abbr> are installed on your system.
         </p></dd><dt><span class="glossterm">
         The Debugging
         </span></dt><dd class="glossdef"><p>
         Debugging is a large topic. It usually helps to have statements in the code that inform you of what is happening. To avoid drowning in output you might sometimes get them to print out only the first 3 passes in a loop. Checking that variables have passed correctly between 
         modules often helps. Get familiar with your debugging tools.
         </p></dd></dl></div><p>
         </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chap13sec109.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="lin-compiler.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="chap13sec111.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1. The necessary packages </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Build, Install software on your system</td></tr></table></div></body></html>
