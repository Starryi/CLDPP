<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4. Shell expansion</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Scripts, linux, Bash, guide, Guide, Exercises, exercises, bash, scripting, Scripting, awk, sed, variables, functions, loops, conditionals"><link rel="home" href="index.html" title="Bash Guide for Beginners"><link rel="up" href="ch03.html" title="Chapter 3. The Bash environment"><link rel="prev" href="ch03s03.html" title="3. Quoting characters"><link rel="next" href="ch03s05.html" title="5. Aliases"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. Shell expansion</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s03.html">Prev</a> </td><th width="60%" align="center">Chapter 3. The Bash environment</th><td width="20%" align="right"> <a accesskey="n" href="ch03s05.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_03_04"></a>4. Shell expansion</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_0"></a>4.1. General</h3></div></div></div><p>After the command has been split into <span class="emphasis"><em>tokens</em></span> (see <a class="xref" href="ch01s04.html#sect_01_04_01_01" title="4.1.1. Shell syntax">Section 4.1.1, &#8220;Shell syntax&#8221;</a>), these tokens or words are expanded or resolved.  There are eight kinds of expansion performed, which we will discuss in the next sections, in the order that they are expanded.</p><p>After all expansions, quote removal is performed.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_01"></a>4.2. Brace expansion</h3></div></div></div><p>Brace expansion<a class="indexterm" name="idm2603"></a> is a mechanism by which arbitrary strings may be generated.  Patterns to be brace-expanded take the form of an optional <span class="emphasis"><em>PREAMBLE</em></span>, followed by a series of comma-separated strings between a pair of braces, followed by an optional <span class="emphasis"><em>POSTSCRIPT</em></span>.  The preamble is prefixed to each string contained within the braces, and the postscript is then appended to each resulting string, expanding left to right.</p><p>Brace expansions<a class="indexterm" name="idm2609"></a> may be nested.  The results of each expanded string are not sorted; left to right order is preserved:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <em class="parameter"><code>sp{el,il,al}l</code></em></strong></span>
spell spill spall
</pre><p>Brace expansion is performed before any other expansions, and any characters special to other expansions are preserved in the result.  It is strictly textual.  Bash does not apply any syntactic interpretation to the context of the expansion or the text between the braces.  To avoid conflicts with parameter expansion, the string <span class="quote">&#8220;<span class="quote">${</span>&#8221;</span> is not considered eligible for brace expansion.</p><p>A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one unquoted comma.  Any incorrectly formed brace expansion is left unchanged.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_02"></a>4.3. Tilde expansion</h3></div></div></div><p>If a word begins with an unquoted tilde character<a class="indexterm" name="idm2622"></a> (<span class="quote">&#8220;<span class="quote">~</span>&#8221;</span>), all of the characters up to the first unquoted slash (or all characters, if there is no unquoted slash) are considered a <span class="emphasis"><em>tilde-prefix</em></span>.  If none of the characters in the tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login name.  If this login name is the null string, the tilde is replaced with the value of the <code class="varname">HOME</code> shell variable.  If <code class="varname">HOME</code> is unset, the home directory of the user executing the shell is substituted instead.  Otherwise, the tilde-prefix is replaced with the home directory associated with the specified login name.</p><p>If the tilde-prefix<a class="indexterm" name="idm2630"></a> is <span class="quote">&#8220;<span class="quote">~+</span>&#8221;</span>, the value of the shell variable <code class="varname">PWD</code> replaces the tilde-prefix.  If the tilde-prefix is <span class="quote">&#8220;<span class="quote">~-</span>&#8221;</span>, the value of the shell variable <code class="varname">OLDPWD</code>, if it is set, is substituted.</p><p>If the characters following the tilde in the tilde-prefix consist of a number N, optionally prefixed by a <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> or a <span class="quote">&#8220;<span class="quote">-</span>&#8221;</span>, the tilde-prefix is replaced with the corresponding element from the directory stack, as it would be displayed by the <span class="command"><strong>dirs</strong></span> built-in invoked with the characters following tilde in the tilde-prefix as an argument.  If the tilde-prefix, without the tilde, consists of a number without a leading <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">-</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">+</span>&#8221;</span> is assumed.</p><p>If the login name is invalid, or the tilde expansion fails, the word
is left unchanged.</p><p>Each variable assignment is checked for unquoted tilde-prefixes immediately following a <span class="quote">&#8220;<span class="quote">:</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">=</span>&#8221;</span>.  In these cases, tilde expansion is also performed.  Consequently, one may use file names with tildes in assignments to <code class="varname">PATH</code>, <code class="varname">MAILPATH</code>, and <code class="varname">CDPATH</code>, and the shell assigns the expanded value.</p><p>Example:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>export <code class="varname">PATH</code>=<em class="parameter"><code>"$PATH:~/testdir"</code></em></strong></span>
</pre><p><code class="filename">~/testdir</code> will be expanded to <code class="varname">$HOME</code><code class="filename">/testdir</code>, so if <code class="varname">$HOME</code> is <code class="filename">/var/home/franky</code>, the directory <code class="filename">/var/home/franky/testdir</code> will be added to the content of the <code class="varname">PATH</code> variable.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_03"></a>4.4. Shell parameter and variable expansion</h3></div></div></div><p>The <span class="quote">&#8220;<span class="quote">$</span>&#8221;</span> character<a class="indexterm" name="idm2669"></a> introduces parameter expansion, command substitution, or arithmetic expansion.  The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name.</p><p>When braces are used, the matching ending brace is the first <span class="quote">&#8220;<span class="quote">}</span>&#8221;</span> not escaped by a backslash or within a quoted string, and not within an embedded arithmetic expansion, command substitution, or parameter expansion.</p><p>The basic form of parameter expansion is <span class="quote">&#8220;<span class="quote">${PARAMETER}</span>&#8221;</span>.  The value of <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> is substituted.  The braces are required when <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> is a positional parameter with more than one digit, or when <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> is followed by a character that is not to be interpreted as part of its name.</p><p>If the first character of <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> is an exclamation point,  Bash uses the value of the variable formed from the rest of <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> as the name of the variable; this variable is then expanded and that value is used in the rest of the substitution, rather than the value of <span class="quote">&#8220;<span class="quote">PARAMETER</span>&#8221;</span> itself.  This is known as <span class="emphasis"><em>indirect expansion</em></span>.</p><p>You are certainly familiar with straight parameter expansion, since it happens all the time, even in the simplest of cases, such as the one above or the following<a class="indexterm" name="idm2685"></a>:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$SHELL</code></strong></span>
/bin/bash
</pre><p>The following is an example of indirect expansion<a class="indexterm" name="idm2693"></a>:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">${!N*}</code></strong></span>
NNTPPORT NNTPSERVER NPX_PLUGIN_PATH
</pre><p>Note that this is not the same as <span class="command"><strong>echo <code class="varname">$N*</code></strong></span>.</p><p>The following construct allows for creation of the named variable if it does not yet exist:</p><div class="cmdsynopsis"><p><code class="command">${<code class="varname">VAR</code>:=<em class="parameter"><code>value</code></em>}</code> </p></div><p>Example:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$FRANKY</code></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <em class="parameter"><code>${FRANKY:=Franky}</code></em></strong></span>
Franky
</pre><p>Special parameters, among others the positional parameters, may not be assigned this way, however.</p><p>We will further discuss the use of the curly braces for treatment of variables in <a class="xref" href="ch10.html" title="Chapter 10. More on variables">Chapter 10, <i>More on variables</i></a>.  More information can also be found in the Bash info pages.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_04"></a>4.5. Command substitution</h3></div></div></div><p>Command substitution<a class="indexterm" name="idm2722"></a> allows the output of a command to replace the
command itself.  Command substitution<a class="indexterm" name="idm2725"></a> occurs when a command is enclosed like this:</p><div class="cmdsynopsis"><p><code class="command">$(command)</code> </p></div><p>or like this using backticks:</p><div class="cmdsynopsis"><p><code class="command">`command`</code> </p></div><p>Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted.  Embedded newlines are not deleted, but they may be removed during word splitting.</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <em class="parameter"><code>`date`</code></em></strong></span>
Thu Feb 6 10:06:20 CET 2003
</pre><p>When the old-style backquoted form of substitution is used, backslash retains its literal meaning except when followed by <span class="quote">&#8220;<span class="quote">$</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">`</span>&#8221;</span>, or <span class="quote">&#8220;<span class="quote">\</span>&#8221;</span>.  The first backticks not preceded by a backslash terminates the command substitution.  When using the <span class="quote">&#8220;<span class="quote">$(COMMAND)</span>&#8221;</span> form, all characters between the parentheses make up the command; none are treated specially.</p><p>Command substitutions may be nested.  To nest when using the backquoted form, escape the inner backticks with backslashes.</p><p>If the substitution appears within double quotes, word splitting and file name expansion are not performed on the results.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_05"></a>4.6. Arithmetic expansion</h3></div></div></div><p>Arithmetic expansion<a class="indexterm" name="idm2748"></a> allows the evaluation of an arithmetic expression<a class="indexterm" name="idm2751"></a> and the substitution of the result.  The format for arithmetic expansion is:</p><div class="cmdsynopsis"><p><code class="command">$(( EXPRESSION ))</code> </p></div><p>The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially.  All tokens in the expression undergo parameter expansion, command substitution, and quote removal.  Arithmetic substitutions may be nested.</p><p>Evaluation of arithmetic expressions is done in fixed-width integers with no check for overflow - although division by zero is trapped and recognized as an error.  The operators are roughly the same as in the C programming language.  In order of decreasing precedence<a class="indexterm" name="idm2758"></a>, the list looks like this:</p><div class="table"><a name="table_03_04"></a><p class="title"><b>Table 3.4. Arithmetic operators</b></p><div class="table-contents"><table class="table" summary="Arithmetic operators" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Operator</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">VAR++ and VAR--</td><td align="left">variable post-increment and post-decrement</td></tr><tr><td align="left">++VAR and --VAR</td><td align="left">variable pre-increment and pre-decrement</td></tr><tr><td align="left">- and +</td><td align="left">unary minus and plus</td></tr><tr><td align="left">! and ~</td><td align="left">logical and bitwise negation</td></tr><tr><td align="left">**</td><td align="left">exponentiation</td></tr><tr><td align="left">*, / and %</td><td align="left">multiplication, division, remainder</td></tr><tr><td align="left">+ and -</td><td align="left">addition, subtraction</td></tr><tr><td align="left">&lt;&lt; and &gt;&gt;</td><td align="left">left and right bitwise shifts</td></tr><tr><td align="left">&lt;=, &gt;=, &lt; and &gt;</td><td align="left">comparison operators</td></tr><tr><td align="left">== and !=</td><td align="left">equality and inequality</td></tr><tr><td align="left">&amp;</td><td align="left">bitwise AND</td></tr><tr><td align="left">^</td><td align="left">bitwise exclusive OR</td></tr><tr><td align="left">|</td><td align="left">bitwise OR</td></tr><tr><td align="left">&amp;&amp;</td><td align="left">logical AND</td></tr><tr><td align="left">||</td><td align="left">logical OR</td></tr><tr><td align="left">expr ? expr : expr</td><td align="left">conditional evaluation</td></tr><tr><td align="left">=, *=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^= and |=</td><td align="left">assignments</td></tr><tr><td align="left">,</td><td align="left">separator between expressions</td></tr></tbody></table></div></div><br class="table-break"><p>Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated.  Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax.  The value of a variable is evaluated as an arithmetic expression when it is referenced.  A shell variable need not have its integer attribute turned on to be used in an expression.</p><p>Constants with a leading 0 (zero) are interpreted as octal numbers.  A
leading <span class="quote">&#8220;<span class="quote">0x</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">0X</span>&#8221;</span> denotes hexadecimal.  Otherwise, numbers take the form <span class="quote">&#8220;<span class="quote">[BASE'#']N</span>&#8221;</span>, where <span class="quote">&#8220;<span class="quote">BASE</span>&#8221;</span> is a decimal number between 2 and 64 representing the arithmetic base, and N is a number in that base.  If <span class="quote">&#8220;<span class="quote">BASE'#'</span>&#8221;</span> is omitted, then base 10 is used.  The digits greater than 9 are represented by the lowercase letters, the uppercase letters, <span class="quote">&#8220;<span class="quote">@</span>&#8221;</span>, and <span class="quote">&#8220;<span class="quote">_</span>&#8221;</span>, in that order.  If <span class="quote">&#8220;<span class="quote">BASE</span>&#8221;</span> is less than or equal to 36, lowercase and uppercase letters may be used interchangably to represent numbers between 10 and 35.</p><p>Operators are evaluated in order of precedence.  Sub-expressions in parentheses are evaluated first and may override the precedence rules above.</p><p>Wherever possible, Bash users should try to use the syntax with square brackets:</p><div class="cmdsynopsis"><p><code class="command">$[ EXPRESSION ]</code> </p></div><p>However, this will only calculate the result of <span class="emphasis"><em>EXPRESSION</em></span>, and do no tests:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <em class="parameter"><code>$[365*24]</code></em></strong></span>
8760
</pre><p>See <a class="xref" href="ch07s01.html#sect_07_01_02_02" title="1.2.2. Numeric comparisons">Section 1.2.2, &#8220;Numeric comparisons&#8221;</a>, among others, for practical examples in scripts.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_06"></a>4.7. Process substitution</h3></div></div></div><p>Process substitution<a class="indexterm" name="idm2848"></a> is supported on systems that support named pipes (FIFOs) or the <code class="filename">/dev/fd</code> method of naming open files.  It takes the form<a class="indexterm" name="idm2852"></a> of</p><div class="cmdsynopsis"><p><code class="command">&lt;(LIST)</code> </p></div><p>or</p><div class="cmdsynopsis"><p><code class="command">&gt;(LIST)</code> </p></div><p>The process <code class="varname">LIST</code> is run with its input or output connected to a FIFO or some file in <code class="filename">/dev/fd</code>.  The name of this file is passed as an argument to the current command as the result of the expansion.  If the <span class="quote">&#8220;<span class="quote">&gt;(LIST)</span>&#8221;</span> form is used, writing to the file will provide input for <code class="varname">LIST</code>.  If the <span class="quote">&#8220;<span class="quote">&lt;(LIST)</span>&#8221;</span> form is used, the file passed as an argument should be read to obtain the output of <code class="varname">LIST</code>.  Note that no space may appear between the &lt; or &gt; signs and the left parenthesis, otherwise the construct would be interpreted as a redirection.</p><p>When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion.</p><p>More information in <a class="xref" href="ch08s02.html#sect_08_02_03" title="2.3. Redirection and file descriptors">Section 2.3, &#8220;Redirection and file descriptors&#8221;</a>.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_07"></a>4.8. Word splitting</h3></div></div></div><p>The shell<a class="indexterm" name="idm2873"></a> scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting.</p><p>The shell<a class="indexterm" name="idm2877"></a> treats each character of <code class="varname">$IFS<a class="indexterm" name="idm2881"></a></code> as a delimiter, and splits the results of the other expansions into words on these characters.  If <code class="varname">IFS<a class="indexterm" name="idm2885"></a></code> is unset, or its value is exactly <span class="quote">&#8220;<span class="quote">'&lt;space&gt;&lt;tab&gt;&lt;newline&gt;'</span>&#8221;</span>, the default, then any sequence of <code class="varname">IFS</code> characters serves to delimit words.  If <code class="varname">IFS</code> has a value other than the default, then sequences of the whitespace characters <span class="quote">&#8220;<span class="quote">space</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">Tab</span>&#8221;</span> are ignored at the beginning and end of the word, as long as the whitespace character is in the value of <code class="varname">IFS</code> (an <code class="varname">IFS</code> whitespace character).  Any character in <code class="varname">IFS</code> that is not <code class="varname">IFS</code> whitespace, along with any adjacent <code class="varname">IF</code> whitespace characters, delimits a field.  A sequence of <code class="varname">IFS</code> whitespace characters is also treated as a delimiter.  If the value of <code class="varname">IFS</code> is null, no word splitting occurs.</p><p>Explicit null arguments<a class="indexterm" name="idm2901"></a> (<span class="quote">&#8220;<span class="quote">""</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">''</span>&#8221;</span>) are retained.  Unquoted implicit null arguments, resulting from the expansion of parameters that have no values, are removed.  If a parameter with no value is expanded within double quotes, a null argument results and is retained.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Expansion and word splitting</h3><p>If no expansion occurs, no splitting is performed.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_04_08"></a>4.9. File name expansion</h3></div></div></div><p>After word splitting<a class="indexterm" name="idm2912"></a>, unless the <code class="option">-f</code> option has been set (see <a class="xref" href="ch02s03.html#sect_02_03_02" title="3.2. Debugging on part(s) of the script">Section 3.2, &#8220;Debugging on part(s) of the script&#8221;</a>), Bash scans each word for the characters<a class="indexterm" name="idm2917"></a> <span class="quote">&#8220;<span class="quote">*</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">?</span>&#8221;</span>, and <span class="quote">&#8220;<span class="quote">[</span>&#8221;</span>.  If one of these characters appears, then the word is regarded as a <span class="emphasis"><em>PATTERN</em></span>, and replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are found, and the shell option <code class="option">nullglob<a class="indexterm" name="idm2925"></a></code> is disabled, the word is left unchanged.  If the <code class="option">nullglob</code> option is set, and no matches are found, the word is removed.  If the shell option<a class="indexterm" name="idm2929"></a> <code class="option">nocaseglob</code> is enabled, the match is performed without regard to the case of alphabetic characters.</p><p>When a pattern is used for file name generation, the character <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> at the start of a file name or immediately following a slash must be matched explicitly, unless the shell option <code class="option">dotglob</code> is set.  When matching a file name, the slash character must always be matched explicitly.  In other cases, the <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> character is not treated specially.</p><p>The <code class="varname">GLOBIGNORE<a class="indexterm" name="idm2939"></a></code> shell variable may be used to restrict the set of file names matching a pattern.  If <code class="varname">GLOBIGNORE</code> is set, each matching file name that also matches one of the patterns in <code class="varname">GLOBIGNORE</code> is removed from the list of matches.  The file names <code class="filename">.</code> and <code class="filename">..</code> are always ignored, even when <code class="varname">GLOBIGNORE</code> is set.  However, setting <code class="varname">GLOBIGNORE</code> has the effect of enabling the <code class="option">dotglob</code> shell option, so all other file names beginning with a <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> will match.  To get the old behavior of ignoring file names beginning with a <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span>, make <span class="quote">&#8220;<span class="quote">.*</span>&#8221;</span> one of the patterns in <code class="varname">GLOBIGNORE</code>.  The <code class="option">dotglob</code> option is disabled when <code class="varname">GLOBIGNORE</code> is unset.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3. Quoting characters </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5. Aliases</td></tr></table></div></body></html>
