<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>2. Variables</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Scripts, linux, Bash, guide, Guide, Exercises, exercises, bash, scripting, Scripting, awk, sed, variables, functions, loops, conditionals"><link rel="home" href="index.html" title="Bash Guide for Beginners"><link rel="up" href="ch03.html" title="Chapter 3. The Bash environment"><link rel="prev" href="ch03s01.html" title="1. Shell initialization files"><link rel="next" href="ch03s03.html" title="3. Quoting characters"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Variables</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s01.html">Prev</a> </td><th width="60%" align="center">Chapter 3. The Bash environment</th><td width="20%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_03_02"></a>2. Variables</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_01"></a>2.1. Types of variables</h3></div></div></div><p>As seen in the examples above, shell variables<a class="indexterm" name="idm1904"></a> are in uppercase
characters by convention.  Bash keeps a list of two types of variables:</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_02_01_01"></a>2.1.1. Global variables</h4></div></div></div><p>Global variables<a class="indexterm" name="idm1910"></a> or environment<a class="indexterm" name="idm1913"></a> variables are available in all shells.  The <span class="command"><strong>env<a class="indexterm" name="idm1917"></a></strong></span> or <span class="command"><strong>printenv<a class="indexterm" name="idm1921"></a></strong></span> commands can be used to display environment variables.  These programs come with the <span class="emphasis"><em>sh-utils</em></span> package<a class="indexterm" name="idm1925"></a>.</p><p>Below is a typical output<a class="indexterm" name="idm1929"></a>:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>printenv</strong></span>
CC=gcc
CDPATH=.:~:/usr/local:/usr:/
CFLAGS=-O2 -fomit-frame-pointer
COLORTERM=gnome-terminal
CXXFLAGS=-O2 -fomit-frame-pointer
DISPLAY=:0
DOMAIN=hq.garrels.be
e=
TOR=vi
FCEDIT=vi
FIGNORE=.o:~
G_BROKEN_FILENAMES=1
GDK_USE_XFT=1
GDMSESSION=Default
GNOME_DESKTOP_SESSION_ID=Default
GTK_RC_FILES=/etc/gtk/gtkrc:/nethome/franky/.gtkrc-1.2-gnome2
GWMCOLOR=darkgreen
GWMTERM=xterm
HISTFILESIZE=5000
history_control=ignoredups
HISTSIZE=2000
HOME=/nethome/franky
HOSTNAME=octarine.hq.garrels.be
INPUTRC=/etc/inputrc
IRCNAME=franky
JAVA_HOME=/usr/java/j2sdk1.4.0
LANG=en_US
LDFLAGS=-s
LD_LIBRARY_PATH=/usr/lib/mozilla:/usr/lib/mozilla/plugins
LESSCHARSET=latin1
LESS=-edfMQ
LESSOPEN=|/usr/bin/lesspipe.sh %s
LEX=flex
LOCAL_MACHINE=octarine
LOGNAME=franky
LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:
MACHINES=octarine
MAILCHECK=60
MAIL=/var/mail/franky
MANPATH=/usr/man:/usr/share/man/:/usr/local/man:/usr/X11R6/man
MEAN_MACHINES=octarine
MOZ_DIST_BIN=/usr/lib/mozilla
MOZILLA_FIVE_HOME=/usr/lib/mozilla
MOZ_PROGRAM=/usr/lib/mozilla/mozilla-bin
MTOOLS_FAT_COMPATIBILITY=1
MYMALLOC=0
NNTPPORT=119
NNTPSERVER=news
NPX_PLUGIN_PATH=/plugin/ns4plugin/:/usr/lib/netscape/plugins
OLDPWD=/nethome/franky
OS=Linux
PAGER=less
PATH=/nethome/franky/bin.Linux:/nethome/franky/bin:/usr/local/bin:/usr/local/sbin:/usr/X11R6/bin:/usr/bin:/usr/sbin:/bin:/sbin:.
PS1=\[\033[1;44m\]franky is in \w\[\033[0m\]
PS2=More input&gt;
PWD=/nethome/franky
SESSION_MANAGER=local/octarine.hq.garrels.be:/tmp/.ICE-unix/22106
SHELL=/bin/bash
SHELL_LOGIN=--login
SHLVL=2
SSH_AGENT_PID=22161
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
SSH_AUTH_SOCK=/tmp/ssh-XXmhQ4fC/agent.22106
START_WM=twm
TERM=xterm
TYPE=type
USERNAME=franky
USER=franky
_=/usr/bin/printenv
VISUAL=vi
WINDOWID=20971661
XAPPLRESDIR=/nethome/franky/app-defaults
XAUTHORITY=/nethome/franky/.Xauthority
XENVIRONMENT=/nethome/franky/.Xdefaults
XFILESEARCHPATH=/usr/X11R6/lib/X11/%L/%T/%N%C%S:/usr/X11R6/lib/X11/%l/%T/%N%C%S:/usr/X11R6/lib/X11/%T/%N%C%S:/usr/X11R6/lib/X11/%L/%T/%N%S:/usr/X11R6/lib/X11/%l/%T/%N%S:/usr/X11R6/lib/X11/%T/%N%S
XKEYSYMDB=/usr/X11R6/lib/X11/XKeysymDB
XMODIFIERS=@im=none
XTERMID=
XWINHOME=/usr/X11R6
X=X11R6
YACC=bison -y
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_02_01_02"></a>2.1.2. Local variables</h4></div></div></div><p>Local variables<a class="indexterm" name="idm1938"></a> are only available in the current shell.  Using the <span class="command"><strong>set</strong></span> built-in command without any options will display a list of all variables (including environment variables) and functions.  The output will be sorted according to the current locale and displayed in a reusable format.</p><p>Below is a diff file made by comparing <span class="command"><strong>printenv</strong></span> and <span class="command"><strong>set</strong></span> output, after leaving out the functions which are also displayed by the <span class="command"><strong>set</strong></span> command:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>diff <code class="filename">set.sorted</code> <code class="filename">printenv.sorted</code></strong></span> | <span class="command"><strong>grep <em class="parameter"><code>"&lt;"</code></em></strong></span> | <span class="command"><strong>awk <em class="parameter"><code>'{ print $2 }'</code></em></strong></span>
BASE=/nethome/franky/.Shell/hq.garrels.be/octarine.aliases
BASH=/bin/bash
BASH_VERSINFO=([0]="2"
BASH_VERSION='2.05b.0(1)-release'
COLUMNS=80
DIRSTACK=()
DO_FORTUNE=
EUID=504
GROUPS=()
HERE=/home/franky
HISTFILE=/nethome/franky/.bash_history
HOSTTYPE=i686
IFS=$'
LINES=24
MACHTYPE=i686-pc-linux-gnu
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PIPESTATUS=([0]="0")
PPID=10099
PS4='+
PWD_REAL='pwd
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
THERE=/home/franky
UID=504
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Awk</h3><p>the GNU Awk programming language is explained in <a class="xref" href="ch06.html" title="Chapter 6. The GNU awk programming language">Chapter 6, <i>The GNU awk programming language</i></a>.</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_02_01_03"></a>2.1.3. Variables by content</h4></div></div></div><p>Apart from dividing variables in local and global variables, we can also divide them in categories according to the sort of content the variable contains.  In this respect, variables come in 4 types<a class="indexterm" name="idm1962"></a>:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>String variables</p></li><li class="listitem"><p>Integer variables</p></li><li class="listitem"><p>Constant variables</p></li><li class="listitem"><p>Array variables</p></li></ul></div><p>We'll discuss these types in <a class="xref" href="ch10.html" title="Chapter 10. More on variables">Chapter 10, <i>More on variables</i></a>.  For now, we will work with integer and string values for our variables.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_02"></a>2.2. Creating variables</h3></div></div></div><p>Variables<a class="indexterm" name="idm1979"></a> are case sensitive and capitalized by default.  Giving local variables a lowercase name is a convention which is sometimes applied.  However, you are free to use the names you want or to mix cases.  Variables can also contain digits, but a name starting with a digit is not allowed:</p><pre class="screen">
<code class="prompt">prompt&gt;</code> <span class="command"><strong>export <code class="varname">1number</code>=<em class="parameter"><code>1</code></em></strong></span>
bash: export: `1number=1': not a valid identifier
</pre><p>To set a variable in the shell, use</p><div class="cmdsynopsis"><p><code class="command"><code class="varname">VARNAME</code>="value"</code> </p></div><p>Putting spaces around the equal sign will cause errors.  It is a good habit to quote content strings when assigning values to variables: this will reduce the chance that you make errors.</p><p>Some examples using upper and lower cases, numbers and spaces:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">MYVAR1</code>=<em class="parameter"><code>"2"</code></em></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$MYVAR1</code></strong></span>
2

<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">first_name</code>=<em class="parameter"><code>"Franky"</code></em></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$first_name</code></strong></span>
Franky

<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">full_name</code>=<em class="parameter"><code>"Franky M. Singh"</code></em></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$full_name</code></strong></span>
Franky M. Singh

<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">MYVAR-2</code>=<em class="parameter"><code>"2"</code></em></strong></span>
bash: MYVAR-2=2: command not found

<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">MYVAR1</code> =<em class="parameter"><code>"2"</code></em></strong></span>
bash: MYVAR1: command not found

<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">MYVAR1</code>= <em class="parameter"><code>"2"</code></em></strong></span>
bash: 2: command not found

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>unset <code class="varname">MYVAR1</code> <code class="varname">first_name</code> <code class="varname">full_name</code></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$MYVAR1</code> <code class="varname">$first_name</code> <code class="varname">$full_name</code></strong></span>
&lt;--no output--&gt;

<code class="prompt">franky ~&gt;</code>
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_03"></a>2.3. Exporting variables</h3></div></div></div><p>A variable<a class="indexterm" name="idm2041"></a> created like the ones in the example above is only available to the current shell.  It is a local variable: child processes of the current shell will not be aware of this variable.  In order to pass variables to a subshell, we need to <span class="emphasis"><em>export</em></span> them using the <span class="command"><strong>export<a class="indexterm" name="idm2046"></a></strong></span> built-in command.  Variables that are exported are referred to as environment variables.  Setting and exporting is usually done in one step:</p><div class="cmdsynopsis"><p><code class="command">export <code class="varname">VARNAME</code>="<em class="parameter"><code>value</code></em>"</code> </p></div><p>A subshell<a class="indexterm" name="idm2054"></a> can change variables it inherited from the parent, but the changes made by the child don't affect the parent.  This is demonstrated in the example:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong><code class="varname">full_name</code>=<em class="parameter"><code>"Franky M. Singh"</code></em></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>bash</strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$full_name</code></strong></span>


<code class="prompt">franky ~&gt;</code> <span class="command"><strong>exit</strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>export <code class="varname">full_name</code></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>bash</strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$full_name</code></strong></span>
Franky M. Singh

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>export <code class="varname">full_name</code>=<em class="parameter"><code>"Charles the Great"</code></em></strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$full_name</code></strong></span>
Charles the Great

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>exit</strong></span>

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$full_name</code></strong></span>
Franky M. Singh

<code class="prompt">franky ~&gt;</code>
</pre><p>When first trying to read the value of <code class="varname">full_name</code> in a subshell, it is not there (<span class="command"><strong>echo</strong></span> shows a null string).  The subshell quits, and <code class="varname">full_name</code> is exported in the parent - a variable can be exported after it has been assigned a value.  Then a new subshell is started, in which the variable exported from the parent is visible.  The variable is changed to hold another name, but the value for this variable in the parent stays the same.</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_04"></a>2.4. Reserved variables</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_02_04_01"></a>2.4.1. Bourne shell reserved variables</h4></div></div></div><p>Bash uses certain shell variables<a class="indexterm" name="idm2099"></a> in the same way as the Bourne shell.  In some cases, Bash assigns a default value to the variable.  The table below gives an overview of these plain shell variables:</p><div class="table"><a name="table_03_01"></a><p class="title"><b>Table 3.1. Reserved Bourne shell variables</b></p><div class="table-contents"><table class="table" summary="Reserved Bourne shell variables" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Variable name</th><th align="left">Definition</th></tr></thead><tbody><tr><td align="left">CDPATH</td><td align="left">A colon-separated list of directories used as a search path for the <span class="command"><strong>cd</strong></span> built-in command.</td></tr><tr><td align="left">HOME</td><td align="left">The current user's home directory; the default for the <span class="command"><strong>cd</strong></span> built-in.  The value of this variable is also used by tilde expansion.</td></tr><tr><td align="left">IFS</td><td align="left">A list of characters that separate fields; used when the shell splits words as part of expansion.</td></tr><tr><td align="left">MAIL</td><td align="left">If this parameter is set to a file name and the <code class="varname">MAILPATH</code> variable is not set, Bash informs the user of the arrival of mail in the specified file.</td></tr><tr><td align="left">MAILPATH</td><td align="left">A colon-separated list of file names which the shell periodically checks for new mail.</td></tr><tr><td align="left">OPTARG</td><td align="left">The value of the last option argument processed by the <span class="command"><strong>getopts</strong></span> built-in.</td></tr><tr><td align="left">OPTIND</td><td align="left">The index of the last option argument processed by the <span class="command"><strong>getopts</strong></span> built-in.</td></tr><tr><td align="left">PATH</td><td align="left">A colon-separated list of directories in which the shell looks for commands.</td></tr><tr><td align="left">PS1</td><td align="left">The primary prompt string.  The default value is <span class="quote">&#8220;<span class="quote">'\s-\v\$ '</span>&#8221;</span>.  </td></tr><tr><td align="left">PS2</td><td align="left">The secondary prompt string.  The default value is <span class="quote">&#8220;<span class="quote">'&gt; '</span>&#8221;</span>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_03_02_04_02"></a>2.4.2. Bash reserved variables</h4></div></div></div><p>These variables are set or used by Bash<a class="indexterm" name="idm2150"></a>, but other shells do not normally treat them specially.</p><div class="table"><a name="table_03_02"></a><p class="title"><b>Table 3.2. Reserved Bash variables</b></p><div class="table-contents"><table class="table" summary="Reserved Bash variables" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Variable name</th><th align="left">Definition</th></tr></thead><tbody><tr><td align="left">auto_resume</td><td align="left">This variable controls how the shell interacts with the user and job control.</td></tr><tr><td align="left">BASH</td><td align="left">The full pathname used to execute the current instance of Bash.</td></tr><tr><td align="left">BASH_ENV</td><td align="left">If this variable is set when Bash is invoked to execute a shell script, its value is expanded and used as the name of a startup file to read before executing the script.</td></tr><tr><td align="left">BASH_VERSION</td><td align="left">The version number of the current instance of Bash.</td></tr><tr><td align="left">BASH_VERSINFO</td><td align="left">A read-only array variable whose members hold version information for this instance of Bash.</td></tr><tr><td align="left">COLUMNS</td><td align="left">Used by the <span class="command"><strong>select</strong></span> built-in to determine the terminal width when printing selection lists.  Automatically set upon receipt of a <span class="emphasis"><em>SIGWINCH</em></span> signal.</td></tr><tr><td align="left">COMP_CWORD</td><td align="left">An index into <code class="varname">${COMP_WORDS}</code> of the word containing the current cursor position.</td></tr><tr><td align="left">COMP_LINE</td><td align="left">The current command line.</td></tr><tr><td align="left">COMP_POINT</td><td align="left">The index of the current cursor position relative to the beginning of the current command.</td></tr><tr><td align="left">COMP_WORDS</td><td align="left">An array variable consisting of the individual words in the current command line.</td></tr><tr><td align="left">COMPREPLY</td><td align="left">An array variable from which Bash reads the possible completions generated by a shell function invoked by the programmable completion facility.</td></tr><tr><td align="left">DIRSTACK</td><td align="left">An array variable containing the current contents of the directory stack.</td></tr><tr><td align="left">EUID</td><td align="left">The numeric effective user ID of the current user.</td></tr><tr><td align="left">FCEDIT</td><td align="left">The editor used as a default by the <code class="option">-e</code> option to the <span class="command"><strong>fc</strong></span> built-in command.</td></tr><tr><td align="left">FIGNORE</td><td align="left">A colon-separated list of suffixes to ignore when performing file name completion.</td></tr><tr><td align="left">FUNCNAME</td><td align="left">The name of any currently-executing shell function.</td></tr><tr><td align="left">GLOBIGNORE</td><td align="left">A colon-separated list of patterns defining the set of file names to be ignored by file name expansion.</td></tr><tr><td align="left">GROUPS</td><td align="left">An array variable containing the list of groups of which the current user is a member.</td></tr><tr><td align="left">histchars</td><td align="left">Up to three characters which control history expansion, quick substitution, and <span class="emphasis"><em>tokenization</em></span>.</td></tr><tr><td align="left">HISTCMD</td><td align="left">The history number, or index in the history list, of the current command.</td></tr><tr><td align="left">HISTCONTROL</td><td align="left">Defines whether a command is added to the history file.</td></tr><tr><td align="left">HISTFILE</td><td align="left">The name of the file to which the command history is saved.  The default value is <code class="filename">~/.bash_history</code>.</td></tr><tr><td align="left">HISTFILESIZE</td><td align="left">The maximum number of lines contained in the history file, defaults to 500.</td></tr><tr><td align="left">HISTIGNORE</td><td align="left">A colon-separated list of patterns used to decide which command lines should be saved in the history list.</td></tr><tr><td align="left">HISTSIZE</td><td align="left">The maximum number of commands to remember on the history list, default is 500.</td></tr><tr><td align="left">HOSTFILE</td><td align="left">Contains the name of a file in the same format as <code class="filename">/etc/hosts</code> that should be read when the shell needs to complete a hostname.</td></tr><tr><td align="left">HOSTNAME</td><td align="left">The name of the current host.</td></tr><tr><td align="left">HOSTTYPE</td><td align="left">A string describing the machine Bash is running on.</td></tr><tr><td align="left">IGNOREEOF</td><td align="left">Controls the action of the shell on receipt of an <span class="emphasis"><em>EOF</em></span> character as the sole input.</td></tr><tr><td align="left">INPUTRC</td><td align="left">The name of the Readline initialization file, overriding the default <code class="filename">/etc/inputrc</code>.</td></tr><tr><td align="left">LANG</td><td align="left">Used to determine the locale category for any category not specifically selected with a variable starting with <code class="varname">LC_</code>.</td></tr><tr><td align="left">LC_ALL</td><td align="left">This variable overrides the value of <code class="varname">LANG</code> and any other <code class="varname">LC_</code> variable specifying a locale category.</td></tr><tr><td align="left">LC_COLLATE</td><td align="left">This variable determines the collation order used when sorting the results of file name expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within file name expansion and pattern matching.</td></tr><tr><td align="left">LC_CTYPE</td><td align="left">This variable determines the interpretation of characters and the behavior of character classes within file name expansion and pattern matching.</td></tr><tr><td align="left">LC_MESSAGES</td><td align="left">This variable determines the locale used to translate double-quoted strings preceded by a <span class="quote">&#8220;<span class="quote">$</span>&#8221;</span> sign.</td></tr><tr><td align="left">LC_NUMERIC</td><td align="left">This variable determines the locale category used for number formatting.</td></tr><tr><td align="left">LINENO</td><td align="left">The line number in the script or shell function currently executing.</td></tr><tr><td align="left">LINES</td><td align="left">Used by the <span class="command"><strong>select</strong></span> built-in to determine the column length for printing selection lists.</td></tr><tr><td align="left">MACHTYPE</td><td align="left">A string that fully describes the system type on which Bash is executing, in the standard GNU CPU-COMPANY-SYSTEM format.</td></tr><tr><td align="left">MAILCHECK</td><td align="left">How often (in seconds) that the shell should check for mail in the files specified in the <code class="varname">MAILPATH</code> or <code class="varname">MAIL</code> variables.</td></tr><tr><td align="left">OLDPWD</td><td align="left">The previous working directory as set by the <span class="command"><strong>cd</strong></span> built-in.</td></tr><tr><td align="left">OPTERR</td><td align="left">If set to the value 1, Bash displays error messages generated by the <span class="command"><strong>getopts</strong></span> built-in.</td></tr><tr><td align="left">OSTYPE</td><td align="left">A string describing the operating system Bash is running on.</td></tr><tr><td align="left">PIPESTATUS</td><td align="left">An array variable containing a list of exit status values from the processes in the most recently executed foreground pipeline (which may contain only a single command).</td></tr><tr><td align="left">POSIXLY_CORRECT</td><td align="left">If this variable is in the environment when <span class="command"><strong>bash</strong></span> starts, the shell enters POSIX mode.</td></tr><tr><td align="left">PPID</td><td align="left">The process ID of the shell's parent process.</td></tr><tr><td align="left">PROMPT_COMMAND</td><td align="left">If set, the value is interpreted as a command to execute before the printing of each primary prompt (<code class="varname">PS1</code>).</td></tr><tr><td align="left">PS3</td><td align="left">The value of this variable is used as the prompt for the <span class="command"><strong>select</strong></span> command.  Defaults to <span class="quote">&#8220;<span class="quote">'#? '</span>&#8221;</span></td></tr><tr><td align="left">PS4</td><td align="left">The value is the prompt printed before the command line is echoed when the <code class="option">-x</code> option is set; defaults to <span class="quote">&#8220;<span class="quote">'+ '</span>&#8221;</span>.</td></tr><tr><td align="left">PWD</td><td align="left">The current working directory as set by the <span class="command"><strong>cd</strong></span> built-in command.</td></tr><tr><td align="left">RANDOM</td><td align="left">Each time this parameter is referenced, a random integer between 0 and 32767 is generated.  Assigning a value to this variable seeds the random number generator.</td></tr><tr><td align="left">REPLY</td><td align="left">The default variable for the <span class="command"><strong>read</strong></span> built-in.</td></tr><tr><td align="left">SECONDS</td><td align="left">This variable expands to the number of seconds since the shell was started.</td></tr><tr><td align="left">SHELLOPTS</td><td align="left">A colon-separated list of enabled shell options.</td></tr><tr><td align="left">SHLVL</td><td align="left">Incremented by one each time a new instance of Bash is started.</td></tr><tr><td align="left">TIMEFORMAT</td><td align="left">The value of this parameter is used as a format string specifying
     how the timing information for pipelines prefixed with the <span class="command"><strong>time</strong></span> reserved word should be displayed.</td></tr><tr><td align="left">TMOUT</td><td align="left">If set to a value greater than zero, <code class="varname">TMOUT</code> is treated as the default timeout for the <span class="command"><strong>read</strong></span> built-in.  In an interative shell, the value is interpreted as the number of seconds to wait for input after issuing the primary prompt when the shell is interactive.  Bash terminates after that number of seconds if input does not arrive.</td></tr><tr><td align="left">UID</td><td align="left">The numeric, real user ID of the current user.</td></tr></tbody></table></div></div><br class="table-break"><p>Check the Bash man, info or doc pages for extended information.  Some variables are read-only, some are set automatically and some lose their meaning when set to a different value than the default.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_05"></a>2.5. Special parameters</h3></div></div></div><p>The shell treats several parameters<a class="indexterm" name="idm2369"></a> specially.  These parameters may only be referenced; assignment to them is not allowed.</p><div class="table"><a name="table_03_03"></a><p class="title"><b>Table 3.3. Special bash variables</b></p><div class="table-contents"><table class="table" summary="Special bash variables" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Character</th><th align="left">Definition</th></tr></thead><tbody><tr><td align="left"><code class="varname">$*</code></td><td align="left">Expands to the positional parameters, starting from one.  When the expansion occurs within double quotes, it expands to a single word with the value of each parameter separated by the first character of the <code class="varname">IFS</code> special variable.</td></tr><tr><td align="left"><code class="varname">$@</code></td><td align="left">Expands to the positional parameters, starting from one.  When the expansion occurs within double quotes, each parameter expands to a separate word.</td></tr><tr><td align="left"><code class="varname">$#</code></td><td align="left">Expands to the number of positional parameters in decimal.</td></tr><tr><td align="left"><code class="varname">$?</code></td><td align="left">Expands to the exit status of the most recently executed foreground pipeline.</td></tr><tr><td align="left"><code class="varname">$-</code></td><td align="left">A hyphen expands to the current option flags as specified upon invocation, by the <span class="command"><strong>set</strong></span> built-in command, or those set by the shell itself (such as the <code class="option">-i</code>).</td></tr><tr><td align="left"><code class="varname">$$</code></td><td align="left">Expands to the process ID of the shell.</td></tr><tr><td align="left"><code class="varname">$!</code></td><td align="left">Expands to the process ID of the most recently executed background (asynchronous) command.</td></tr><tr><td align="left"><code class="varname">$0</code></td><td align="left">Expands to the name of the shell or shell script.</td></tr><tr><td align="left"><code class="varname">$_</code></td><td align="left">The underscore variable is set at shell startup and contains the absolute file name of the shell or script being executed as passed in the argument list.  Subsequently, it expands to the last argument to the previous command, after expansion.  It is also set to the full pathname of each command executed and placed in the environment exported to that command.  When checking mail, this parameter holds the name of the mail file.
</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">$* vs. $@</h3><p>The implementation of <span class="quote">&#8220;<span class="quote">$*</span>&#8221;</span> has always been a problem and realistically should have been replaced with the behavior of <span class="quote">&#8220;<span class="quote">$@</span>&#8221;</span>.  In almost every case where coders use <span class="quote">&#8220;<span class="quote">$*</span>&#8221;</span>, they mean <span class="quote">&#8220;<span class="quote">$@</span>&#8221;</span>.  <span class="quote">&#8220;<span class="quote">$*</span>&#8221;</span> Can cause bugs and even security holes in your software.</p></div><p>The positional parameters<a class="indexterm" name="idm2428"></a> are the words following the name of a shell script.  They are put into the variables <code class="varname">$1</code>, <code class="varname">$2</code>, <code class="varname">$3</code> and so on.  As long as needed, variables are added to an internal array.  <code class="varname">$#</code> holds the total number of parameters, as is demonstrated with this simple<a class="indexterm" name="idm2435"></a> script:</p><pre class="screen">
#!/bin/bash

# positional.sh
# This script reads 3 positional parameters and prints them out.

POSPAR1="$1"
POSPAR2="$2"
POSPAR3="$3"

echo "$1 is the first positional parameter, \$1."
echo "$2 is the second positional parameter, \$2."
echo "$3 is the third positional parameter, \$3."
echo
echo "The total number of positional parameters is $#."
</pre><p>Upon execution one could give any numbers of arguments<a class="indexterm" name="idm2440"></a>:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>positional.sh <em class="parameter"><code>one two three four five</code></em></strong></span>
one is the first positional parameter, $1.
two is the second positional parameter, $2.
three is the third positional parameter, $3.

The total number of positional parameters is 5.

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>positional.sh <em class="parameter"><code>one two</code></em></strong></span>
one is the first positional parameter, $1.
two is the second positional parameter, $2.
 is the third positional parameter, $3.

The total number of positional parameters is 2.
</pre><p>More on evaluating these parameters is in <a class="xref" href="ch07.html" title="Chapter 7. Conditional statements">Chapter 7, <i>Conditional statements</i></a> and <a class="xref" href="ch09s07.html" title="7. The shift built-in">Section 7, &#8220;The shift built-in&#8221;</a>.</p><p>Some examples on the other special parameters<a class="indexterm" name="idm2454"></a>:</p><pre class="screen">
<code class="prompt">franky ~&gt;</code> <span class="command"><strong>grep <em class="parameter"><code>dictionary</code></em> <code class="filename">/usr/share/dict/words</code></strong></span>
dictionary

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$_</code></strong></span>
/usr/share/dict/words

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$$</code></strong></span>
10662

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>mozilla &amp;</strong></span>
[1] 11064

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$!</code></strong></span>
11064

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$0</code></strong></span>
bash

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$?</code></strong></span>
0

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>ls <code class="filename">doesnotexist</code></strong></span>
ls: doesnotexist: No such file or directory

<code class="prompt">franky ~&gt;</code> <span class="command"><strong>echo <code class="varname">$?</code></strong></span>
1

<code class="prompt">franky ~&gt;</code>
</pre><p>User <span class="emphasis"><em>franky</em></span> starts entering the <span class="command"><strong>grep</strong></span> command, which results in the assignment of the <code class="varname">_</code> variable.  The process ID of his shell is 10662.  After putting a job in the background, the <code class="varname">!</code> holds the process ID of the backgrounded job.  The shell running is <span class="command"><strong>bash</strong></span>.  When a mistake is made, <code class="varname">?</code> holds an exit code different from 0 (zero).</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_03_02_06"></a>2.6. Script recycling with variables</h3></div></div></div><p>Apart<a class="indexterm" name="idm2496"></a> from making the script more readable, variables will also enable you to faster apply a script in another environment or for another purpose.  Consider the following example, a very simple script that makes a backup of <span class="emphasis"><em>franky</em></span>'s home directory to a remote server:</p><pre class="screen">
#!/bin/bash

# This script makes a backup of my home directory.

cd /home

# This creates the archive
tar cf /var/tmp/home_franky.tar franky &gt; /dev/null 2&gt;&amp;1

# First remove the old bzip2 file.  Redirect errors because this generates some if the archive
# does not exist.  Then create a new compressed file.
rm /var/tmp/home_franky.tar.bz2 2&gt; /dev/null
bzip2 /var/tmp/home_franky.tar

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp /var/tmp/home_franky.tar.bz2 bordeaux:/opt/backup/franky &gt; /dev/null 2&gt;&amp;1

# Create a timestamp in a logfile.
date &gt;&gt; /home/franky/log/home_backup.log
echo backup succeeded &gt;&gt; /home/franky/log/home_backup.log
</pre><p>First of all, you are more likely to make errors if you name files and directories manually each time you need them.  Secondly, suppose <span class="emphasis"><em>franky</em></span> wants to give this script to <span class="emphasis"><em>carol</em></span>, then carol will have to do quite some editing before she can use the script to back up her home directory.  The same is true if <span class="emphasis"><em>franky</em></span> wants to use this script for backing up other directories.  For easy recycling, make all files, directories, usernames, servernames etcetera variable.  Thus, you only need to edit a value once, without having to go through the entire script to check where a parameter occurs.  This is an example:</p><pre class="screen">
#!/bin/bash
                                                                                                 
# This script makes a backup of my home directory.

# Change the values of the variables to make the script work for you:
BACKUPDIR=/home
BACKUPFILES=franky
TARFILE=/var/tmp/home_franky.tar
BZIPFILE=/var/tmp/home_franky.tar.bz2
SERVER=bordeaux
REMOTEDIR=/opt/backup/franky
LOGFILE=/home/franky/log/home_backup.log

cd $BACKUPDIR

# This creates the archive
tar cf $TARFILE $BACKUPFILES &gt; /dev/null 2&gt;&amp;1
                                                                                                 
# First remove the old bzip2 file.  Redirect errors because this generates some if the archive 
# does not exist.  Then create a new compressed file.
rm $BZIPFILE 2&gt; /dev/null
bzip2 $TARFILE

# Copy the file to another host - we have ssh keys for making this work without intervention.
scp $BZIPFILE $SERVER:$REMOTEDIR &gt; /dev/null 2&gt;&amp;1

# Create a timestamp in a logfile.
date &gt;&gt; $LOGFILE
echo backup succeeded &gt;&gt; $LOGFILE
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Large directories and low bandwidth</h3><p>The above is purely an example that everybody can understand, using a small directory and a host on the same subnet.  Depending on your bandwidth, the size of the directory and the location of the remote server, it can take an awful lot of time to make backups using this mechanism.  For larger directories and lower bandwidth, use <span class="command"><strong>rsync</strong></span> to keep the directories at both ends synchronized.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1. Shell initialization files </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 3. Quoting characters</td></tr></table></div></body></html>
