<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>1. Signals</title><link rel="stylesheet" type="text/css" href="style.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="Linux, Scripts, linux, Bash, guide, Guide, Exercises, exercises, bash, scripting, Scripting, awk, sed, variables, functions, loops, conditionals"><link rel="home" href="index.html" title="Bash Guide for Beginners"><link rel="up" href="ch12.html" title="Chapter 12. Catching signals"><link rel="prev" href="ch12.html" title="Chapter 12. Catching signals"><link rel="next" href="ch12s02.html" title="2. Traps"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. Signals</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch12.html">Prev</a> </td><th width="60%" align="center">Chapter 12. Catching signals</th><td width="20%" align="right"> <a accesskey="n" href="ch12s02.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect_12_01"></a>1. Signals</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_12_01_01"></a>1.1. Introduction</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_12_01_01_01"></a>1.1.1. Finding the signal man page</h4></div></div></div><p>Your system contains a man page listing all the available signals, but depending on your operating system, it might be opened in a different way.  On most Linux systems, this will be <span class="command"><strong>man <code class="option">7</code> signal</strong></span>.  When in doubt, locate the exact man page and section using commands like</p><div class="cmdsynopsis"><p><code class="command">man <code class="option">-k</code> signal | grep <code class="option">list</code></code> </p></div><p>or</p><div class="cmdsynopsis"><p><code class="command">apropos signal | grep <code class="option">list</code></code> </p></div><p>Signal names can be found using <span class="command"><strong>kill -l</strong></span>.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_12_01_01_02"></a>1.1.2. Signals to your Bash shell</h4></div></div></div><p>In the absence of any traps, an interactive Bash shell ignores <span class="emphasis"><em>SIGTERM</em></span> and <span class="emphasis"><em>SIGQUIT</em></span>.  <span class="emphasis"><em>SIGINT</em></span> is caught and handled, and if job control is active, <span class="emphasis"><em>SIGTTIN</em></span>, <span class="emphasis"><em>SIGTTOU</em></span> and <span class="emphasis"><em>SIGTSTP</em></span> are also ignored.  Commands that are run as the result of a command substitution also ignore these signals, when keyboard generated.</p><p><span class="emphasis"><em>SIGHUP</em></span> by default exits a shell.  An interactive shell will send a <span class="emphasis"><em>SIGHUP</em></span> to all jobs, running or stopped; see the documentation on the <span class="command"><strong>disown</strong></span> built-in if you want to disable this default behavior for a particular process.  Use the <code class="option">huponexit</code> option for killing all jobs upon receiving a <span class="emphasis"><em>SIGHUP</em></span> signal, using the <span class="command"><strong>shopt</strong></span> built-in.</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sect_12_01_01_03"></a>1.1.3. Sending signals using the shell</h4></div></div></div><p>The following signals can be sent using the Bash shell:</p><div class="table"><a name="tab_12_01"></a><p class="title"><b>Table 12.1. Control signals in Bash</b></p><div class="table-contents"><table class="table" summary="Control signals in Bash" border="1"><colgroup><col><col></colgroup><thead><tr><th align="left">Standard key combination</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>C</strong></span></td><td align="left">The interrupt signal, sends SIGINT to the job running in the foreground.</td></tr><tr><td align="left"><span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Y</strong></span></td><td align="left">The <span class="emphasis"><em>delayed suspend</em></span> character.  Causes a running process to be stopped when it attempts to read input from the terminal.  Control is returned to the shell, the user can foreground, background or kill the process.  Delayed suspend is only available on operating systems supporting this feature.</td></tr><tr><td align="left"><span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Z</strong></span></td><td align="left">The <span class="emphasis"><em>suspend</em></span> signal, sends a <span class="emphasis"><em>SIGTSTP</em></span> to a running program, thus stopping it and returning control to the shell.</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Terminal settings</h3><p>Check your <span class="command"><strong>stty</strong></span> settings.  Suspend and resume of output is usually disabled if you are using <span class="quote">&#8220;<span class="quote">modern</span>&#8221;</span> terminal emulations.  The standard <span class="command"><strong>xterm</strong></span> supports <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>S</strong></span> and <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Q</strong></span> by default.</p></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sect_12_01_02"></a>1.2. Usage of signals with kill</h3></div></div></div><p>Most modern shells, Bash included, have a built-in <span class="command"><strong>kill</strong></span> function.  In Bash, both signal names and numbers are accepted as options, and arguments may be job or process IDs.  An exit status can be reported using the <code class="option">-l</code> option: zero when at least one signal was successfully sent, non-zero if an error occurred.</p><p>Using the <span class="command"><strong>kill</strong></span> command from <code class="filename">/usr/bin</code>, your system might enable extra options, such as the ability to kill processes from other than your own user ID and specifying processes by name, like with <span class="command"><strong>pgrep</strong></span> and <span class="command"><strong>pkill</strong></span>.</p><p>Both <span class="command"><strong>kill</strong></span> commands send the <span class="emphasis"><em>TERM</em></span> signal if none is given.</p><p>This is a list of the most common signals:</p><div class="table"><a name="tab_12_02"></a><p class="title"><b>Table 12.2. Common kill signals</b></p><div class="table-contents"><table class="table" summary="Common kill signals" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="left">Signal name</th><th align="left">Signal value</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left">SIGHUP</td><td align="left">1</td><td align="left">Hangup</td></tr><tr><td align="left">SIGINT</td><td align="left">2</td><td align="left">Interrupt from keyboard</td></tr><tr><td align="left">SIGKILL</td><td align="left">9</td><td align="left">Kill signal</td></tr><tr><td align="left">SIGTERM</td><td align="left">15</td><td align="left">Termination signal</td></tr><tr><td align="left">SIGSTOP</td><td align="left">17,19,23</td><td align="left">Stop the process</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">SIGKILL and SIGSTOP</h3><p><span class="emphasis"><em>SIGKILL</em></span> and <span class="emphasis"><em>SIGSTOP</em></span> can not be caught, blocked or ignored.</p></div><p>When killing a process or series of processes, it is common sense to start trying with the least dangerous signal, <span class="emphasis"><em>SIGTERM</em></span>.  That way, programs that care about an orderly shutdown get the chance to follow the procedures that they have been designed to execute when getting the <span class="emphasis"><em>SIGTERM</em></span> signal, such as cleaning up and closing open files.  If you send a <span class="emphasis"><em>SIGKILL</em></span> to a process, you remove any chance for the process to do a tidy cleanup and shutdown, which might have unfortunate consequences.</p><p>But if a clean termination does not work, the <span class="emphasis"><em>INT</em></span> or<span class="emphasis"><em>KILL</em></span> signals might be the only way.  For instance, when a process does not die using <span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>C</strong></span>, it is best to use the <span class="command"><strong>kill <code class="option">-9</code></strong></span> on that process ID:</p><pre class="screen">
<code class="prompt">maud: ~&gt;</code> <span class="command"><strong>ps <code class="option">-ef</code> | grep <em class="parameter"><code>stuck_process</code></em></strong></span>
maud    5607   2214  0 20:05 pts/5    00:00:02 stuck_process

<code class="prompt">maud: ~&gt;</code> <span class="command"><strong>kill <code class="option">-9</code> <em class="parameter"><code>5607</code></em></strong></span>

<code class="prompt">maud: ~&gt;</code> <span class="command"><strong>ps <code class="option">-ef</code> | grep <em class="parameter"><code>stuck_process</code></em></strong></span>
maud    5614    2214 0 20:15 pts/5    00:00:00 grep stuck_process
[1]+ Killed		stuck_process
</pre><p>When a process starts up several instances, <span class="command"><strong>killall</strong></span> might be easier.  It takes the same option as the <span class="command"><strong>kill</strong></span> command, but applies on all instances of a given process.  Test this command before using it in a production environment, since it might not work as expected on some of the commercial Unices.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch12.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch12.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch12s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 12. Catching signals </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2. Traps</td></tr></table></div></body></html>
